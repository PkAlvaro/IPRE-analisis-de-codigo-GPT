Human_Code;IA_Code
"class Solution:
    def findSecretWord(self, words: List[str], master: 'Master') -> None:        
        k = 1 # for tracing the number of loops
        matches = 0
        blacklists = [[] for i in range(6)]
        
        while matches != 6:
            n = len(words)
            r = random.randint(0, n - 1)
            matches = master.guess(words[r])
            key = words[r]
            # print(k, n, r, matches, key)
            
            words.pop(r)
            
            if matches == 0:
                for i in range(6):
                    blacklists[i].append(key[i])
                # print(blacklists)
            
            elif matches > 0 and matches < 6:
                candidates = []
                for i in range(n - 1):
                    count = 0
                    for j in range(6):
                        if words[i][j] not in blacklists[j] and words[i][j] == key[j]:
                            count += 1
                    if count >= matches:
                        candidates.append(words[i])
                            
                words = candidates.copy()
                # print(words)
            
            k += 1";"# Master.adivinar(palabra)
# """"""
# @param {string[]} lista_palabras
# @param {Master} maestro
# @return {None}
# """"""
class Solucion(object):
    def encontrarPalabraSecreta(self, lista_palabras, maestro):
        
        intentos = 0
        while intentos < 10:
            
            palabra_a_probar = lista_palabras[0]
            coincidencias = maestro.adivinar(palabra_a_probar)
            
            if coincidencias == 6:
                return

            nueva_lista_palabras = []
            
            for palabra in lista_palabras:
                
                coincidencias_entre_palabras = 0
                i = 0
                while i < 6:
                    if palabra_a_probar[i] == palabra[i]:
                        coincidencias_entre_palabras = coincidencias_entre_palabras + 1
                    i = i + 1
                
                if coincidencias_entre_palabras == coincidencias:
                    nueva_lista_palabras.append(palabra)
            
            lista_palabras = nueva_lista_palabras
            intentos = intentos + 1"
"class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        # Dealing special case: 1.
        if n == 1:
            return True
        # If n is an odd, it is not a number that is power of three.
        # Also, eliminating those number did not have any factor of 3.
        elif n % 2 == 0 or n % 3 != 0:
            return False
        else:
            return power_of_three(n)

def power_of_three(n):
    # Base Case
    if n == 3:
        return True
    # If n is not devided by 3, it's not a power of three number.
    elif n % 3:
        return False
    elif n < 3:
        return False
    # Recursive
    else:
        return power_of_three(n / 3)";"def es_potencia_de_tres(numero):
    if numero < 1:
        return False

    while numero % 3 == 0:
        numero = numero / 3

    if numero == 1:
        return True
    else:
        return False"
"class Solution:
    def pushDominoes(self, dominoes: str) -> str:
        condensed = []
        
        index = 0
        currDir = dominoes[0]
        
        while index < len(dominoes) and dominoes[index] == currDir:
            index += 1
        
        count = index
                
        if index == len(dominoes):
            return dominoes
        elif currDir == '.' and dominoes[index] == 'L':
            currDir = dominoes[index]
            
            while index < len(dominoes) and dominoes[index] == currDir:
                index += 1
        
        condensed.append(currDir * index)
        count = 1
        
        if index == len(dominoes):
            return ''.join(condensed)
        
        currDir = dominoes[index]
        index += 1
        
        while index < len(dominoes):
            if dominoes[index] == currDir:
                count += 1
            else:
                if currDir == '.':
                    condensed.append([currDir, count])
                elif type(condensed[-1]) is not list:
                    condensed.append(currDir * count)
                else:
                    dotCount = condensed.pop()[1]
                    prevDir = condensed[-1][0]

                    if prevDir == currDir:
                        condensed.append(condensed.pop() + currDir * (dotCount + count))
                    elif prevDir == 'L':
                        condensed.append('.' * dotCount)
                        condensed.append(currDir * count)
                    else:
                        halfCount = dotCount // 2
                        hasExtraDot = halfCount*2 != dotCount
                        condensed.append(prevDir * halfCount)
                        if hasExtraDot:
                            condensed.append('.')
                        condensed.append(currDir * (halfCount + count))
                        
                currDir = dominoes[index]
                count = 1
                
            index += 1
        
        if condensed:
            if currDir == '.':            
                dotCount = count
                prevDir = condensed[-1][0]

                if prevDir == 'L':
                    condensed.append(currDir * dotCount)
                else:                
                    condensed.append(prevDir * dotCount)
            elif type(condensed[-1]) is list:
                dotCount = condensed.pop()[1]            
                
                if not condensed:
                    if currDir == 'L':
                        condensed.append(currDir * (dotCount + count))
                    else:
                        condensed.append('.' * dotCount)
                        condensed.append(currDir * count)
                else:
                    prevDir = condensed[-1][0]
                    
                    if prevDir == currDir:
                        condensed.append(condensed.pop() + currDir * (dotCount + count))
                    elif prevDir == 'L':
                        condensed.append('.' * dotCount)
                        condensed.append(currDir * count)
                    else:
                        halfCount = dotCount // 2
                        hasExtraDot = halfCount*2 != dotCount
                        condensed.append(prevDir * halfCount)
                        if hasExtraDot:
                            condensed.append('.')
                        condensed.append(currDir * (halfCount + count))
            else:
                condensed.append(currDir * count)
        else:
            condensed.append(currDir * count)
        
        return ''.join(condensed)";"class Solucion:
    def empujar_dominoes(self, dominoes):
        dominoes_con_bordes = 'L' + dominoes + 'R'
        
        lista_dominoes = []
        for caracter in dominoes_con_bordes:
            lista_dominoes.append(caracter)

        i = 0
        j = 1
        
        longitud = len(lista_dominoes)
        
        while j < longitud:
            if lista_dominoes[j] == '.':
                j = j + 1
                continue
            
            simbolo_i = lista_dominoes[i]
            simbolo_j = lista_dominoes[j]
            
            if simbolo_i == 'L' and simbolo_j == 'L':
                puntero = i + 1
                while puntero < j:
                    lista_dominoes[puntero] = 'L'
                    puntero = puntero + 1
            elif simbolo_i == 'R' and simbolo_j == 'R':
                puntero = i + 1
                while puntero < j:
                    lista_dominoes[puntero] = 'R'
                    puntero = puntero + 1
            elif simbolo_i == 'R' and simbolo_j == 'L':
                izquierda = i + 1
                derecha = j - 1
                while izquierda < derecha:
                    lista_dominoes[izquierda] = 'R'
                    lista_dominoes[derecha] = 'L'
                    izquierda = izquierda + 1
                    derecha = derecha - 1

            i = j
            j = j + 1
            
        lista_resultado = lista_dominoes[1:longitud-1]
        
        cadena_final = """"
        for caracter in lista_resultado:
            cadena_final = cadena_final + caracter
            
        return cadena_final"
"class Solution:
    #Time-Complexity: O(n^2)
    #Space-Complexity: O(n)
    def integerBreak(self, n: int) -> int:
        #we know we can reduce n as 
        # n
    #   /  \
    #  1   n-1
    #     /  \
    #    1   n-2
    #     ...
    
        #Basically, we can keep reducing n like this in this tree structure above!
        #This is the pattern I recognized! I recognized for given n, there are 
        #potential sums of (1, n-1), (2, n-2), (3, n-3), ..., (n//2, n//2)!
        #For each pair, I can compare the direct number with the max product decomposition
        #and take the max of two!
        
        
        #Reason for comparison: for each of the sum factor of given n, either leave it
        #undecomposed or decompose it into further sum factors if the product of sum
        #factors produce ultimately a number that exceeds the orignal sum factor! This way
        #I am maximing product contribution for each and every sum factor!
        
        #For example, for 5, we decompose it into 2 and 3, since 2*3 > 5, so it will
        #maximize our product further!
        
        #However, for 3, we don't decompose since we can maximally decompose to
        #1 and 2 but 1*2 < 3!
        
        #Do that for both numbers of each pair and take the product!
        #Whatever is largest across the pairs will be answer for given input n!
    
        dp = [-1] * (n+1)
        #add dp-base!
        dp[1] = 1
    
        #this problem has only one state parameter: the given number to start decomposing           #from!
        #iterate through each subproblem or state!
        #Bottom-Up
        for i in range(2, n+1, 1):
            upper_bound = (i // 2) + 1
            #iterate through all possible pairs!
            for j in range(1, upper_bound, 1):
                #current pair (j, i-j), which we probably already solved its subproblems!
                first = max(j, dp[j])
                second = max(i-j, dp[i-j])
                #get product for current pair!
                sub_ans = first * second
                #compare current pair's product against built up answer maximum!
                dp[i] = max(dp[i], sub_ans)
    
        #then, once we are done, we can return dp[n]!
        return dp[n]";"def romper_entero(numero):
    if numero == 2:
        return 1
    if numero == 3:
        return 2

    producto = 1
    while numero > 4:
        producto = producto * 3
        numero = numero - 3
    
    producto_final = producto * numero
    
    return producto_final"
"class Solution:
    def catMouseGame(self, graph: List[List[int]]) -> int:
        n = len(graph)
        
        @cache
        def fn(i, m, c): 
            """"""Return """"""
            if i == 2*n: return 0 # tie 
            if m == 0: return 1 # mouse wins
            if m == c: return 2 # cat wins 
            if i&amp,1: # cat's turn 
                tie = 0 
                for cc in graph[c]: 
                    if cc != 0: 
                        x = fn(i+1, m, cc)
                        if x == 2: return 2 
                        if x == 0: tie = 1
                if tie: return 0 
                return 1
            else: # mouse's turn 
                tie = 0 
                for mm in graph[m]: 
                    x = fn(i+1, mm, c)
                    if x == 1: return 1 
                    if x == 0: tie = 1
                if tie: return 0
                return 2 
        
        return fn(0, 1, 2)";"class Solucion:
    def juegoGatoRaton(self, grafo):
        num_nodos = len(grafo)

        # Estados: color[pos_raton][pos_gato][turno]
        # turno 0: turno del raton
        # turno 1: turno del gato
        # resultado 0: Empate (inicial), 1: Gana Raton, 2: Gana Gato
        color = []
        for i in range(num_nodos):
            fila_raton = []
            for j in range(num_nodos):
                fila_gato = [0, 0]
                fila_raton.append(fila_gato)
            color.append(fila_raton)

        grados = []
        for i in range(num_nodos):
            fila_raton = []
            for j in range(num_nodos):
                fila_gato = [0, 0]
                fila_raton.append(fila_gato)
            grados.append(fila_raton)
        
        cola = []

        # Inicializar grados y estados terminales
        for pos_raton in range(num_nodos):
            for pos_gato in range(1, num_nodos):
                # Grados para el turno del raton
                grados[pos_raton][pos_gato][0] = len(grafo[pos_raton])
                # Grados para el turno del gato
                grados[pos_raton][pos_gato][1] = len(grafo[pos_gato])
                
                # El gato no puede ir a la madriguera (nodo 0)
                tiene_cero = False
                for vecino_gato in grafo[pos_gato]:
                    if vecino_gato == 0:
                        tiene_cero = True
                        break
                if tiene_cero:
                    grados[pos_raton][pos_gato][1] = grados[pos_raton][pos_gato][1] - 1

                # El raton llega a la madriguera (Gana Raton)
                if pos_raton == 0:
                    color[pos_raton][pos_gato][0] = 1
                    color[pos_raton][pos_gato][1] = 1
                    cola.append((pos_raton, pos_gato, 0, 1))
                    cola.append((pos_raton, pos_gato, 1, 1))
                
                # El gato atrapa al raton (Gana Gato)
                if pos_gato == pos_raton:
                    color[pos_raton][pos_gato][0] = 2
                    color[pos_raton][pos_gato][1] = 2
                    cola.append((pos_raton, pos_gato, 0, 2))
                    cola.append((pos_raton, pos_gato, 1, 2))

        # Propagacion de los resultados usando una cola (BFS)
        indice_cola = 0
        while indice_cola < len(cola):
            raton, gato, turno, resultado = cola[indice_cola]
            indice_cola = indice_cola + 1
            
            # Si el turno actual es del raton, el turno anterior fue del gato
            if turno == 0:
                for prev_gato in grafo[gato]:
                    if prev_gato == 0:
                        continue
                    
                    if color[raton][prev_gato][1] == 0: # Si el estado anterior aun no tiene resultado
                        if resultado == 2: # El gato encontro una jugada ganadora
                            color[raton][prev_gato][1] = 2
                            cola.append((raton, prev_gato, 1, 2))
                        else: # El gato debe evitar que gane el raton
                            grados[raton][prev_gato][1] = grados[raton][prev_gato][1] - 1
                            if grados[raton][prev_gato][1] == 0:
                                color[raton][prev_gato][1] = 1
                                cola.append((raton, prev_gato, 1, 1))
            
            # Si el turno actual es del gato, el turno anterior fue del raton
            else:
                for prev_raton in grafo[raton]:
                    if color[prev_raton][gato][0] == 0: # Si el estado anterior aun no tiene resultado
                        if resultado == 1: # El raton encontro una jugada ganadora
                            color[prev_raton][gato][0] = 1
                            cola.append((prev_raton, gato, 0, 1))
                        else: # El raton debe evitar que gane el gato
                            grados[prev_raton][gato][0] = grados[prev_raton][gato][0] - 1
                            if grados[prev_raton][gato][0] == 0:
                                color[prev_raton][gato][0] = 2
                                cola.append((prev_raton, gato, 0, 2))
                                
        return color[1][2][0]"
"class Solution:
    def isPathCrossing(self, path: str) -> bool:
        #Store the directions(key) with their corresponding actions(values)
        directions = {'N': [0,1], 'E':[1,0], 'W':[-1,0], 'S':[0,-1]}
        
        #Keep the track of visited points
        visited = set()
        
        #Add the initial point from where you're starting
        visited.add((0,0))
        
        #Current trackers of x and y coordinates
        curr_x,curr_y = 0,0
        
        #Loop through all the path
        for i in path:
            curr_x += directions[i][0]
            curr_y += directions[i][1]
            
            #If visited for first time, add them to visited
            if (curr_x,curr_y) not in visited:
                visited.add((curr_x,curr_y))
            else:
                return True #Else return True
            
        return False #Return True if there is no re-visiting";"class Solucion:
    def la_ruta_se_cruza(self, ruta: str) -> bool:
        posicion_x = 0
        posicion_y = 0
        
        puntos_visitados = [(0, 0)]
        
        for movimiento in ruta:
            if movimiento == 'N':
                posicion_y = posicion_y + 1
            elif movimiento == 'S':
                posicion_y = posicion_y - 1
            elif movimiento == 'E':
                posicion_x = posicion_x + 1
            elif movimiento == 'W':
                posicion_x = posicion_x - 1
            
            punto_actual = (posicion_x, posicion_y)
            
            if punto_actual in puntos_visitados:
                return True
            else:
                puntos_visitados.append(punto_actual)
                
        return False"
"class Solution:
    def winnerSquareGame(self, n: int) -> bool:
        @cache
        def doIWin(n, isAlice):
            if n == 0: return False # I lost, i cannot pick anything more :(
            sqr = 1
            while sqr*sqr <= n:
                if False == doIWin(n-sqr*sqr, 1 ^ isAlice):
                    # i forced my opponent to lose :)
                    return True
                
                sqr += 1
            
            
            # I did not find any way to make opponent lose..
            return False
        
        return doIWin(n, True)
        """"""
        No need of 'isAlice' :)
        Just makes the code cleaner?
        """"""

		@cache
        def doIWin(n):
            if n == 0: return False # I lost, i cannot pick anything more :(
            sqr = 1
            while sqr*sqr <= n:
                if False == doIWin(n-sqr*sqr):
                    # i forced my opponent to lose :)
                    return True
                
                sqr += 1
            
            
            # I did not find any way to make opponent lose..
            return False
        
        return doIWin(n)

		# final optimization.. travel backwards from sqrt to 1 :)
        @cache
        def doIWin(n):
            if n == 0: return False # I lost, i cannot pick anything more :(
            sqr = floor(sqrt(n))
            while sqr:
                if not doIWin(n-sqr*sqr):
                    # i forced my opponent to lose :)
                    return True
                
                sqr -= 1
            
            # I did not find any way to make opponent lose..
            return False
        
        return doIWin(n)";"def ganador_piedra(n):
    puede_ganar = [False] * (n + 1)
    
    contador_i = 1
    while contador_i <= n:
        
        contador_k = 1
        while True:
            cuadrado = contador_k * contador_k
            
            if cuadrado > contador_i:
                break
            
            if puede_ganar[contador_i - cuadrado] == False:
                puede_ganar[contador_i] = True
                break
                
            contador_k = contador_k + 1
            
        contador_i = contador_i + 1
        
    return puede_ganar[n]"
"class Solution:
    def knightDialer1(self, n: int) -> int:
        # observe pattern of knight moves and store in lookup table

        # 0 -> 4, 6
        # 1 -> 6, 8
        # 2 -> 7, 9
        # 3 -> 4, 8
        # 4 -> 3, 9, 0
        # 5 -> -
        # 6 -> 1, 7, 0
        # 7 -> 2, 6
        # 8 -> 1, 3
        # 9 -> 2, 4

        # approach #1: recursive with memo
        # helper function takes (curr, left),
        # returns number of possible moves based on (curr)ent value and moves (left)
        # if left is 1, return 1
        # otherwise, recursive call into next value based on lookup dict

        lut = { 0 : [4,6],
                1 : [6,8],
                2 : [7,9],
                3 : [4,8],
                4 : [0,3,9],
                5 : [],
                6 : [0,1,7],
                7 : [2,6],
                8 : [1,3],
                9 : [2,4] }

        def hlpr(curr: int, left: int) -> int:
            if left == 1: return 1
            if (curr, left) in memo: return memo[(curr, left)]

            res = 0
            for next in lut[curr]:
                res += hlpr(next, left-1)

            memo[(curr, left)] = res
            return res

        # setup and recursive call
        memo = {}
        res = 0
        for i in [0,1,2,3,4,5,6,7,8,9]:
            res += hlpr(i, n)
        return res % (10**9 + 7)

    def knightDialer2(self, n: int) -> int:
        # tabulate the solution above
        # two dimensional table
        # dp[i][j] is total moves starting from j, with i moves left
        # curr, which can be from 0-9 (cols)
        # left, which is strictly decreasing (rows)
        # O(N) time and space

        lut = { 0 : [4,6],
                1 : [6,8],
                2 : [7,9],
                3 : [4,8],
                4 : [0,3,9],
                5 : [],
                6 : [0,1,7],
                7 : [2,6],
                8 : [1,3],
                9 : [2,4] }

        dp = [[0 for _ in range(10)] for __ in range(n)]

        for i in range(10):
            dp[0][i] = 1

        for i in range(1,n):
            for j in range(10):
                tmp = 0
                for next in lut[j]:
                    tmp += dp[i-1][next]
                dp[i][j] += tmp

        return sum(dp[-1]) % (10**9 + 7)

    def knightDialer(self, n: int) -> int:
        # last trick, only need a single row of array rather than N rows
        # dp[i] represents total moves starting from i
        # make a copy of current dp row, and refer to that
        # using the actual dp row to store subproblem result
        # O(N) time, O(1) space

        lut = { 0 : [4,6],
                1 : [6,8],
                2 : [7,9],
                3 : [4,8],
                4 : [0,3,9],
                5 : [],
                6 : [0,1,7],
                7 : [2,6],
                8 : [1,3],
                9 : [2,4] }

        dp = [1 for _ in range(10)]

        for _ in range(1,n):
            last = dp[:]

            for j in range(10):
                tmp = 0
                for next in lut[j]:
                    tmp += last[next]
                dp[j] = tmp

        return sum(dp) % (10**9 + 7)";"def marcador_caballo(n):
    MODULO = 1000000007

    if n == 1:
        return 10

    movimientos = [
        [4, 6],       # Desde 0
        [6, 8],       # Desde 1
        [7, 9],       # Desde 2
        [4, 8],       # Desde 3
        [0, 3, 9],    # Desde 4
        [],           # Desde 5
        [0, 1, 7],    # Desde 6
        [2, 6],       # Desde 7
        [1, 3],       # Desde 8
        [2, 4]        # Desde 9
    ]

    # Para una longitud de 1, hay una forma de terminar en cada número.
    caminos = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

    # Se necesitan n-1 saltos para un número de longitud n.
    contador_saltos = 1
    while contador_saltos < n:
        caminos_siguiente_salto = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        
        numero_actual = 0
        while numero_actual < 10:
            
            # Ver los movimientos posibles desde el número actual
            posibles_destinos = movimientos[numero_actual]
            
            # Para cada destino, sumar las formas de llegar al número actual
            for destino in posibles_destinos:
                formas_de_llegar_al_numero_actual = caminos[numero_actual]
                caminos_siguiente_salto[destino] = (caminos_siguiente_salto[destino] + formas_de_llegar_al_numero_actual) % MODULO

            numero_actual = numero_actual + 1
        
        # Actualizamos los caminos para el siguiente paso
        caminos = caminos_siguiente_salto
        contador_saltos = contador_saltos + 1

    # Sumar todas las formas de obtener un número de longitud n
    total_numeros = 0
    for cantidad in caminos:
        total_numeros = (total_numeros + cantidad) % MODULO
    
    return total_numeros"
"class Solution:
    def stoneGameII(self, piles: List[int]) -> int:
        n = len(piles)
        dp = {} 
        def recursion(index,M):
            # if we reached to the end we cannot score any value
            if index == n:
                return 0
            # we search if we have solved the same case earlier
            if (index,M) in dp:
                return dp[(index,M)] 
            # total remaining score is the sum of array from index to the end
            total = sum(piles[index:])           
            # if we can take the complete array it is the best choice
            if index + 2*M >= n :return total
            # my_score is the score we are getting as the player who is playing
            my_score = 0
            for x in range(index,index+2*M):
                # opponent score will be calculated by next recursion
                opponent_score = recursion(x+1,max(M,x-index+1))
                # my_score is the remaining value of total - opponent_score
                my_score = max(my_score,total - opponent_score)          
            # this is memoization part
            dp[(index,M)] = my_score
            # return the score
            return my_score
        
        return recursion(0,1)";"def juego_de_piedras(pilas):
    n = len(pilas)

    sumas_sufijo = []
    i = 0
    while i < n + 1:
        sumas_sufijo.append(0)
        i = i + 1

    i = n - 1
    while i >= 0:
        sumas_sufijo[i] = sumas_sufijo[i + 1] + pilas[i]
        i = i - 1

    tabla_dp = []
    i = 0
    while i < n + 1:
        fila = []
        j = 0
        while j < n + 1:
            fila.append(0)
            j = j + 1
        tabla_dp.append(fila)
        i = i + 1

    i = n - 1
    while i >= 0:
        m = 1
        while m <= n:
            if i + 2 * m >= n:
                tabla_dp[i][m] = sumas_sufijo[i]
            else:
                mejor_puntaje = 0
                x = 1
                limite_x = 2 * m
                while x <= limite_x:
                    nuevo_m = m
                    if x > m:
                        nuevo_m = x

                    puntaje_oponente = tabla_dp[i + x][nuevo_m]
                    puntaje_actual = sumas_sufijo[i] - puntaje_oponente

                    if puntaje_actual > mejor_puntaje:
                        mejor_puntaje = puntaje_actual
                    
                    x = x + 1
                
                tabla_dp[i][m] = mejor_puntaje
            m = m + 1
        i = i - 1

    resultado = tabla_dp[0][1]
    return resultado"
"class Solution:
    def countBits(self, n: int) -> List[int]:
        #knowing the number of 1-bits in bin. rep of lower values of i than the current i
        #can have to solve current subproblem for i, since if i is odd,
        #number of 1 bits for i = number of 1 bits for previous number(even) + 1
        #number of 1 bits for i if it is even and power of 2 = 1
        #number of 1 bits for i if it not power of 2 but even = number of 
        #largest powers of 2 even numbers I can use to sum up to i!
        #Ex. 6 = 4 + 2 -> used 2 powers of 2 = need 2 1-bits in bin. rep of 6!
        #Ex. 7 = 6 + 1 -> 6 uses 2 1-bits so 7 requires 2+1 = 3 1-bits in its bin. rep!
        
        #I showed with above examples that this problem demonstrates optimal substructure
        #property! -> Might be useful in bottom-up solve for lower values of state
        #parameter i and work your way in inc. order -> State parameter i corresponds
        #to each and every index of ans array length n+1!
        
        #also, we may need to refer to same number multiple times while
        #building up our solution -> Overlapping subproblem property satisfied!
        
        
        #Let me first attempt recursive approach!
        #I know I will face TLE so let's add dp memo for memoization!
        dp = [-1] * (n+1)
        #base cases
        if(n == 0):
            return [0]
        if(n == 1):
            return [0, 1]
        
        #add a memo base case
        if(dp[n] != -1):
            return dp[n]
        
        #for n>1, array with at least 3 elements!
        
        #check if n is even and is power of 2!
        #if it is power of 2, taking bitwise and with itself and one less in value
        #bin. rep should produce all 0-bits1
        if(n % 2 == 0 and (n &amp, n-1) == 0):
            #answer will be array from recursive call on n-1 plus the 1 1-bit required
            #for base 2 power even numbered n!
            dp[n] = self.countBits(n-1) + [1]
            return  self.countBits(n-1) + [1]
        #last index n is odd case!
        if(n%2 != 0):
            recurse = self.countBits(n-1)
            num_bits_prev_num = recurse[-1]
            dp[n] = recurse + [num_bits_prev_num + 1]
            return recurse + [num_bits_prev_num + 1]
        
        #last case: even number n not power of 2!
        else:
            #as long as we didn't reduce n!
            i = 2
            ans = 0
            while n:
                if((n - i) &amp, (n-i-1) == 0):
                    n -= (n-i)
                    i = 2
                    continue
                else:
                    i += 2
            dp[n] = self.countBits(n-1) + [ans]
            return self.countBits(n-1) + [ans]";"def contar_bits(n):
    lista_resultado = []
    for i in range(n + 1):
        contador = 0
        numero = i
        while numero > 0:
            if numero % 2 == 1:
                contador = contador + 1
            numero = numero // 2
        lista_resultado.append(contador)
    return lista_resultado"
"class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        
        #Create a dictionary which will store the frequency of each of character 
        d={}  
        
        #iterate over all the characters in the string 's' 
        for element in s:
            if element in d:
                #increse the frequency count by 1 if it is already there in the dictionary 'd'
                d[element]+=1
            else:
                #initiate that element frequency by 1 in the 'd' if it is not there previously.
                d[element]=1
                
        #iterate over all the characters in the string 't'
        for element in t:
            if element in d:
        #decrease the frequency count by 1 so as to check the same frequency count of each character
                d[element]-=1
            else:
                #if the element is not there in the dictionary that means that particular element is not there in the string 's' which tends the result to False
                return False
        for key,value in d.items():
            if value!=0:
            #Return False if the any of element value is not 0 after cancelling their each occurence from both side 's' and 't'
                return False
        return True";"def es_anagrama(s, t):
    longitud_s = len(s)
    longitud_t = len(t)

    if longitud_s != longitud_t:
        return False

    conteo_s = {}
    for caracter in s:
        if caracter in conteo_s:
            conteo_s[caracter] = conteo_s[caracter] + 1
        else:
            conteo_s[caracter] = 1

    conteo_t = {}
    for caracter in t:
        if caracter in conteo_t:
            conteo_t[caracter] = conteo_t[caracter] + 1
        else:
            conteo_t[caracter] = 1

    if conteo_s == conteo_t:
        resultado = True
    else:
        resultado = False
    
    return resultado"
"class Solution:
    def decodeString(self, s: str) -> str:
        #base case: single character that's not a number!
        if(len(s) == 1 and s.isdigit() == False and s[0] != '[' and s[0] != ']'):
            return s
        
        #otherwise, we need to intialize the ans variable which we will return at the end!
        ans = """"
        i = 0
        
        current_num = """"
        #iterate through each and every char until it goes out of bounds!
        while i < len(s):
            cur = s[i]
            #append stand alone characters!
            if(cur.isdigit() == False and cur != '[' and cur != ']'):
                ans += cur
                i += 1
                continue
            #otherwise, the other case we have to take account is if
            #current character is number, in which we have to decode
            #in recursive manner!
            if(cur.isdigit()):
                current_num += cur
                i += 1
                continue
            if(cur == '['):
                num = int(current_num)
                #we have to find index positions of all characters
                #between open and closed brackets -> recurse over
                #those characters in substring -> append to ans
                #the result num times!
                
                #to know when we reached the appropriate closing char,
                #we can use a stack!
                
                #push initial opening char!
                stack = ['[']
                #since i assume input is valid, there gaurantees
                #corresponding closing char!
                #start index = i + 2 since i+1th index is bracket char!
                start = i+1
                while stack:
                    if(s[start] == '['):
                        stack.append('[')
                    if(s[start] == ']'):
                        stack.pop()
                    start += 1
                #once we exit, we know range of chars to recurse over!
                #it will go from index i +2 to index start - 2!
                recurse = self.decodeString(s[i+1:start - 1])
                #add to answer num times the rec. call!
                for i in range(num):
                    ans += recurse
                #update i to index start since start points to first char after the closing bracket of
                #current decoded string!
                i = start
                current_num = """"
                continue
                
        return ans";"class Solucion:
    def decodificar_cadena(self, s):
        pila = []
        cadena_actual = """"
        numero_actual = 0
        
        for caracter in s:
            if caracter.isdigit():
                numero_actual = numero_actual * 10 + int(caracter)
            elif caracter == '[':
                pila.append(cadena_actual)
                pila.append(numero_actual)
                cadena_actual = """"
                numero_actual = 0
            elif caracter == ']':
                repeticiones = pila.pop()
                cadena_anterior = pila.pop()
                cadena_actual = cadena_anterior + cadena_actual * repeticiones
            else:
                cadena_actual = cadena_actual + caracter
                
        return cadena_actual"
"class Solution:
    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:
        capital_profit = defaultdict(list)
        for p, c in zip(profits, capital):
            insort_left(capital_profit[c], p)
        sorted_capital = sorted(capital_profit.keys())
        if sorted_capital[-1] <= w and k == len(profits):
            return w + sum(profits)
        for _ in range(k):
            max_key, max_profit = -inf, -inf
            for key in sorted_capital:
                if key <= w:
                    if capital_profit[key][-1] > max_profit:
                        max_key, max_profit = key, capital_profit[key][-1]
                else:
                    break
            if max_profit > -inf:
                w += max_profit
                capital_profit[max_key].pop()
                if not capital_profit[max_key]:
                    capital_profit.pop(max_key)
                    sorted_capital.remove(max_key)
            else:
                break
        return w";"class Solucion:
    def encontrar_capital_maximizado(self, k, capital_inicial, ganancias, capitales_requeridos):
        numero_de_proyectos = len(ganancias)
        proyectos_realizados = []
        for i in range(numero_de_proyectos):
            proyectos_realizados.append(False)
        
        capital_actual = capital_inicial
        
        for i in range(k):
            indice_mejor_proyecto = -1
            maxima_ganancia_encontrada = -1
            
            for j in range(numero_de_proyectos):
                # Revisar si el proyecto no se ha realizado
                if proyectos_realizados[j] == False:
                    # Revisar si tenemos el capital necesario
                    if capital_actual >= capitales_requeridos[j]:
                        # Si es el proyecto más rentable que podemos hacer
                        if ganancias[j] > maxima_ganancia_encontrada:
                            maxima_ganancia_encontrada = ganancias[j]
                            indice_mejor_proyecto = j
            
            # Si no encontramos ningún proyecto para hacer, terminamos
            if indice_mejor_proyecto == -1:
                break
            
            # Si encontramos un proyecto, lo hacemos
            capital_actual = capital_actual + maxima_ganancia_encontrada
            proyectos_realizados[indice_mejor_proyecto] = True
            
        return capital_actual"
"class Solution:
    def candy(self, ratings: List[int]) -> int:
        # Analogy:
        # \   /    \
        #  \ / \  / \ /
        #   v   v    v  v
        #
        # Distribute candies such that it looks
        # like a bunch of troughs of varying heights aligned
        # side by side. Where the base of the troughs (v) are
        # the lowest rated children, and the heights of its
        # sides (\ or /) are the children with incrementally better
        # ratings
        
        # Problem is essentially looking for the next lowest ratings
        # and distributing candies in larger increments to the left
        # side and the right side IF their current rating is
        # greater than their previous rating
        
        # Use a priority queue to identify the lowest ratings
        heapq = [(ratings[i], i) for i in range(len(ratings))]
        heapify(heapq)
        
        # Array of candies parallel to the array of ratings of the child
        # where candies[i] represents the amount of candies the child at
        # ratings[i] will have
        candies = [1 for _ in range(len(ratings))]
        
        while(heapq):
            base = heappop(heapq) # Get next lowest rating
            
            # If the candy count has been modified, then it indicates
            # that this child isn't part of the lowest rating. We
            # only work with the lowest rating child (candy == 1), so skip
            if candies[base[1]] != 1:
                continue
            
            # Distribute candies to the left, when applicable
            curr = base[0]
            for i in range(base[1] - 1, -1, -1):
                # Give more candies when the current child has a greater
                # rating than the previous child AND when the current child
                # has fewer than or equal to the amount of candies than the
                # previous child
                #
                # The second condition is important since it will solve the
                # problem where the current child has already been
                # distributed candies, but may become overwritten in this new
                # distribution:
                # 
                # Distribute from lowest starting from left to right ========>
                # index:     0  1  2  3  4        0  1  2  3  4
                # ratings:  [1, 4, 3, 2, 1]  OR  [1, 2, 3, 4, 1]
                # candies:  [1, 2, 3, 2, 1]      [1, 2, 3, 4, 1]   
                #               ^                          ^
                # Solution: Let it overwrite WITH the larger amount of candies
                if ratings[i] > curr and candies[i] <= candies[i + 1]:
                    curr = ratings[i]
                    candies[i] = candies[i + 1] + 1
                else:
                    break
            
            # Distribute candies to the right, when applicable
            curr = base[0]
            for i in range(base[1] + 1, len(ratings)):
                # See line 41, same principle
                if ratings[i] > curr and candies[i] <= candies[i - 1]:
                    curr = ratings[i]
                    candies[i] = candies[i - 1] + 1
                else:
                    break
        
        return sum(candies)";"class Solucion:
    def dar_caramelos(self, calificaciones):
        numero_de_ninos = len(calificaciones)

        if numero_de_ninos == 0:
            return 0

        caramelos = []
        i = 0
        while i < numero_de_ninos:
            caramelos.append(1)
            i = i + 1

        i = 1
        while i < numero_de_ninos:
            if calificaciones[i] > calificaciones[i - 1]:
                caramelos[i] = caramelos[i - 1] + 1
            i = i + 1

        i = numero_de_ninos - 2
        while i >= 0:
            if calificaciones[i] > calificaciones[i + 1]:
                if caramelos[i] <= caramelos[i + 1]:
                    caramelos[i] = caramelos[i + 1] + 1
            i = i - 1

        total_de_caramelos = 0
        for cantidad in caramelos:
            total_de_caramelos = total_de_caramelos + cantidad

        return total_de_caramelos"
"class Solution:
    def convertToBase7(self, num: int) -> str:
        abs_num = abs(num)
        val = ''
        ans = ''
        while abs_num >= 7:# we want to add up every remainder until the dividend(num) equals to 7 or less than 7.
            val += str(abs_num % 7)
            abs_num = abs_num // 7
        val += str(abs_num % 7) # we add up the remainder first, then the quotient.
        val = val[::-1] # Revise its order.
        if num < 0: 
            ans += '-'
        ans += val
        return ans";"class Solucion:
  def convertir_a_base7(self, num):
    if num == 0:
      return ""0""

    es_negativo = False
    if num < 0:
      es_negativo = True
      num = -num

    resultado = """"
    numero_original = num

    while numero_original > 0:
      resto = numero_original % 7
      resultado = str(resto) + resultado
      numero_original = numero_original // 7

    if es_negativo:
      resultado = ""-"" + resultado
      
    return resultado"
"class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -> int:
        houses.sort()
        heaters.sort()
        total, size = len(houses), len(heaters)
		#dummy solution to check if heater with radius r, to cover all houses
        def valid_radius(r):
            house_offset = 0
            heater_offset = 0
            while house_offset < total:
                #case 1: current house is covered by current house, simply pass
                if abs(houses[house_offset] - heaters[heater_offset]) <= r:
                    house_offset += 1
                    continue
				#case 2 house cannot be covered, and locates on left side of heater, we can never find a heater to cover this house
                if houses[house_offset] < heaters[heater_offset]:
                    return False
                    break
				#case 3 go ahead to further heater, find the closest heater to cover the house or find no such heater valid
                while heater_offset < size and abs(houses[house_offset] - heaters[heater_offset]) > r:
                    heater_offset += 1
                if heater_offset >= size:return False
                if abs(houses[house_offset] - heaters[heater_offset]) <= r:
                    house_offset += 1
                    continue
                else:
                    return False
                    break
            return True
		#binary search to get radius
        low, high = 0, max(abs(heaters[0] - houses[0]), abs(heaters[0] - houses[-1]))
        mid = (low + high)//2
        while high - low > 1:
            if valid_radius(mid):
                high = mid
            else:low = mid
            mid = (low + high)//2

        return low if valid_radius(low) else high";"def encontrar_radio(casas, calentadores):
    radio_final = 0

    casas.sort()
    calentadores.sort()

    indice_calentador = 0
    numero_de_calentadores = len(calentadores)

    for casa in casas:
        while indice_calentador < numero_de_calentadores - 1 and calentadores[indice_calentador + 1] <= casa:
            indice_calentador = indice_calentador + 1
        
        distancia_izquierda = casa - calentadores[indice_calentador]
        
        distancia_derecha = 1000000001 # Un numero muy grande
        if indice_calentador + 1 < numero_de_calentadores:
            distancia_derecha = calentadores[indice_calentador + 1] - casa
        
        distancia_minima_actual = 0
        if distancia_izquierda < distancia_derecha:
            distancia_minima_actual = distancia_izquierda
        else:
            distancia_minima_actual = distancia_derecha

        if distancia_minima_actual > radio_final:
            radio_final = distancia_minima_actual
            
    return radio_final"
"class Solution:
    def hIndex(self, citations: List[int]) -> int:
        """"""
        citations = [3,0,6,1,5]
        
        n : length of citations
        
        H - index defination: A scientist has an index h if h of their n 
        papers have at least h citations each, and the other n ? h papers 
        have no more than h citations each.
        
        [0, 0, 0, 0, 0, 0] we define a list of size n + 1
         0  1  2  3  4  5
        
        The above list will be used as a bucket which will keep the count
        of papers with i(index in the list) citations.
        
        citations[0] = 3 
        [0, 0, 0, 1, 0, 0]
         0  1  2  3  4  5
         
         citations[1] = 0
        [1, 0, 0, 1, 0, 0]
         0  1  2  3  4  5
         
         citations[2] = 6
        [1, 0, 0, 1, 0, 1] when cits for a paper is > 5 then put the value in n lst index
         0  1  2  3  4  5
         
         citations[3] = 1
        [1, 1, 0, 1, 0, 1]
         0  1  2  3  4  5
         
         citations[4] = 5
        [1, 1, 0, 1, 0, 2]
         0  1  2  3  4  5
         
         
         Find suffix sum of above list:
         [5, 4, 3, 3, 2, 2]  Find the larget index where index value(i) <= A[i]
          0  1  2  3  4  5
          
          which is 3
          ans : 3
        """"""
        
        n = len(citations)
        b = [0] * (n + 1)
        for i in range(n):
            b[min(citations[i], n)] += 1
        for i in range(n, -1, -1):
            if b[i] >= i:
                return i
            b[i - 1] += b[i]
        return -1";"class Solucion:
    def hIndex(self, citaciones):
        longitud = len(citaciones)
        
        h_candidato = longitud
        while h_candidato > 0:
            
            contador_de_papeles = 0
            for numero_de_citas in citaciones:
                if numero_de_citas >= h_candidato:
                    contador_de_papeles = contador_de_papeles + 1
            
            if contador_de_papeles >= h_candidato:
                return h_candidato
            
            h_candidato = h_candidato - 1
            
        return 0"
"class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        
        #Brute Force way of thinking
        #Generate all subarrays and as soon as we find the condition getting fulfilled, append it to our answer
        #Note - as per question, only 1 valid answer exists, so repetition will not be an issue
        #If at all there was repetition, it can be avoided by traversing as below
        #O(N^2) Time -- Accepted Solution
        

        n = len(nums)
        answer = list()
        for i in range(n):
            for j in range(i+1,n):
                if (nums[i] + nums[j] == target):
                    answer.append(i)
                    answer.append(j)
        return answer        

        
        #Let us try to optimize 
        
        #NOTE - We CANNOT SORT THIS array as we have to retrieve the indices and sorting it 
        #would change the original indices at which elements are present
        #If the given array would have already been sorted, this would have worked completely fine
        
        #if we fix one of the numbers as arr[i], so other would be arr[j] = (target - arr[i]) 
        #now, we simply have to see if this arr[j] exists in the given array or not
        #O(N) Time --- Accepted Solution (TAKEN HELP FROM DISCUSSION SECTION)
        
        #NOTE - Looking up an element in a dictionary is O(1) and not O(N) 
        
        n = len(nums)
        seen = {} #empty dictionary

        for index, value in enumerate(nums): 
            
            remaining = target - value 
            #here, value is nums[i]
            #we are looking for this remaining, which is nums[j] 
            #we have to find if remaining or nums[j] is present in the given array or not
            #this equation comes from the fact that as per question : 
            #nums[i] + nums[j] = target 
           
            if remaining in seen: 
                
                #if nums[j] is present in dictionary
                #just return index of nums[i] and nums[j] 
                return [index, seen[remaining]] 
                #index represents index of nums[i] and seen[remaining] will
                #hold index of nums[j]
            
            else: 
            #otherwise, add the value corresponding to its index in the dictionary
            #so, if it searched again, we can directly retrieve its index
                seen[value] = index";"class Solucion:
    def dos_sumas(self, numeros, objetivo):
        cantidad_de_numeros = len(numeros)
        i = 0
        while i < cantidad_de_numeros:
            j = i + 1
            while j < cantidad_de_numeros:
                suma = numeros[i] + numeros[j]
                if suma == objetivo:
                    lista_de_indices = [i, j]
                    return lista_de_indices
                j = j + 1
            i = i + 1"
"class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        
        mp = {}
        count = 0
        
        # nested loop 1 
        for uno in nums1:
            for dos in nums2:
                # get = value for the key, value if you don't get it 
                # if uno+dos exists in hashmap, increment value 
                # else: increment with value 1 
                mp[uno + dos] = mp.get(uno + dos, 0) + 1
                
        # nested loop 2
        for tres in nums3:
            for quatro in nums4:
                # get(value for key, value if you don't get it)
                # getting hashmap value if the added number already exists in hashmap
                # if there is no complimentary value in the hashmap -> return 0 -> doesn't change count
                count += mp.get(-(tres + quatro), 0)
        # return mp
        return count";"def contar_cuatro_sumas(lista1, lista2, lista3, lista4):
    mapa_de_sumas = {}
    
    for numero1 in lista1:
        for numero2 in lista2:
            suma = numero1 + numero2
            if suma in mapa_de_sumas:
                mapa_de_sumas[suma] = mapa_de_sumas[suma] + 1
            else:
                mapa_de_sumas[suma] = 1
                
    contador = 0
    
    for numero3 in lista3:
        for numero4 in lista4:
            objetivo = 0 - (numero3 + numero4)
            if objetivo in mapa_de_sumas:
                contador = contador + mapa_de_sumas[objetivo]
                
    return contador"
"class Solution:
    def canWinNim(self, n: int) -> bool:        
        if n <= 3:
            return True
        new_size = n + 1
        memo = [False] * (new_size)
        
        for i in range(4): 
            memo[i] = True
        
        for i in range(4,new_size):
            for j in range(1,4):
                if memo[i] == True:
                    break
                if memo[i-j] == True:
                    memo[i] = False
                else:
                    memo[i] = True
        
        return memo[n]";"class Solucion:
    def puede_ganar_nim(self, numero_de_piedras):
        residuo = numero_de_piedras % 4
        
        if residuo == 0:
            puedo_ganar = False
        else:
            puedo_ganar = True
            
        return puedo_ganar"
"class Solution:
    def sumGame(self, num: str) -> bool:
        n = len(num)
        q_cnt_1 = s1 = 0
        for i in range(n//2):    # get digit sum and question mark count for the first half of `num`
            if num[i] == '?':
                q_cnt_1 += 1
            else:    
                s1 += int(num[i])
        q_cnt_2 = s2 = 0				
        for i in range(n//2, n): # get digit sum and question mark count for the second half of `num`
            if num[i] == '?':
                q_cnt_2 += 1
            else:    
                s2 += int(num[i])
        s_diff = s1 - s2         # calculate sum difference and question mark difference
        q_diff = q_cnt_2 - q_cnt_1
        return not (q_diff % 2 == 0 and q_diff // 2 * 9 == s_diff) # When Bob can't win, Alice wins";"class Solucion:
    def juegoDeSuma(self, num: str) -> bool:
        longitud = 0
        for caracter in num:
            longitud = longitud + 1
        
        mitad = longitud // 2
        
        suma_izquierda = 0
        interrogantes_izquierda = 0
        i = 0
        while i < mitad:
            caracter_actual = num[i]
            if caracter_actual == '?':
                interrogantes_izquierda = interrogantes_izquierda + 1
            else:
                suma_izquierda = suma_izquierda + int(caracter_actual)
            i = i + 1
            
        suma_derecha = 0
        interrogantes_derecha = 0
        i = mitad
        while i < longitud:
            caracter_actual = num[i]
            if caracter_actual == '?':
                interrogantes_derecha = interrogantes_derecha + 1
            else:
                suma_derecha = suma_derecha + int(caracter_actual)
            i = i + 1
            
        diferencia_suma = suma_izquierda - suma_derecha
        diferencia_interrogantes = interrogantes_izquierda - interrogantes_derecha
        
        total_interrogantes = interrogantes_izquierda + interrogantes_derecha
        
        if total_interrogantes % 2 == 1:
            return True
        
        if 2 * diferencia_suma + 9 * diferencia_interrogantes == 0:
            return False
        else:
            return True"
"class Solution:
#     Follow-up Solution DP Iterative, Time = O(N), Space = O(1), In-Place Algorithm
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        for lvl in range(len(triangle) - 2, -1, -1):
            for idx in range(len(triangle[lvl])):
                triangle[lvl][idx] += min(triangle[lvl + 1][idx], triangle[lvl + 1][idx + 1])
        return triangle[0][0]

#     DP Iterative, Time = O(N), Space = O(triangle)
#     def minimumTotal(self, triangle: List[List[int]]) -> int:
#         sum_cp = triangle
#         for lvl in range(len(triangle) - 2, -1, -1):
#             for idx in range(len(triangle[lvl])):
#                 sum_cp[lvl][idx] += min(sum_cp[lvl + 1][idx], sum_cp[lvl + 1][idx + 1])
#         return sum_cp[0][0]
        
#     DP Recursion, Time = O(N), Space = O(triangle)
#     def minimumTotal(self, triangle: List[List[int]]) -> int:
#         sum_dp = [[[False, 0] for j in range(len(triangle[i]))] for i in range(len(triangle))]
#         self.rec(triangle, sum_dp, 0, 0, len(triangle) - 1)
#         return sum_dp[0][0][1]
#     
#     def rec(self, triangle, sum_dp, lvl, idx, hgt):
#         if sum_dp[lvl][idx][0] == True:
#             return sum_dp[lvl][idx][1]
#         elif lvl == hgt:
#             sum_dp[lvl][idx][0] = True
#             sum_dp[lvl][idx][1] = triangle[lvl][idx]
#         else:
#             sum_dp[lvl][idx][0] = True
#             sum_dp[lvl][idx][1] = min(self.rec(triangle, sum_dp, lvl + 1, idx, hgt), self.rec(triangle, sum_dp, lvl + 1, idx + 1, hgt)) + triangle[lvl][idx]
#         return sum_dp[lvl][idx][1]
        
#     Simple Recursion, Time = O(2^N), Space = O(2^N), TLE
#     def minimumTotal(self, triangle: List[List[int]]) -> int:
#         return self.rec(triangle, 0, 0, len(triangle) - 1)
#         
#     def rec(self, triangle, lvl, idx, hgt):
#         if lvl == hgt:
#             return triangle[lvl][idx]
#         return min(self.rec(triangle, lvl + 1, idx, hgt), self.rec(triangle, lvl + 1, idx + 1, hgt)) + triangle[lvl][idx]";"def camino_minimo_total(triangulo):
    numero_filas = len(triangulo)
    
    if numero_filas == 0:
        return 0
    if numero_filas == 1:
        return triangulo[0][0]

    fila_actual_indice = numero_filas - 2
    while fila_actual_indice >= 0:
        fila_actual = triangulo[fila_actual_indice]
        fila_siguiente = triangulo[fila_actual_indice + 1]
        
        columna_actual_indice = 0
        while columna_actual_indice < len(fila_actual):
            valor_actual = fila_actual[columna_actual_indice]
            
            valor_inferior_izquierdo = fila_siguiente[columna_actual_indice]
            valor_inferior_derecho = fila_siguiente[columna_actual_indice + 1]
            
            minimo_valor_inferior = 0
            if valor_inferior_izquierdo < valor_inferior_derecho:
                minimo_valor_inferior = valor_inferior_izquierdo
            else:
                minimo_valor_inferior = valor_inferior_derecho
            
            suma = valor_actual + minimo_valor_inferior
            triangulo[fila_actual_indice][columna_actual_indice] = suma
            
            columna_actual_indice = columna_actual_indice + 1
        
        fila_actual_indice = fila_actual_indice - 1
        
    resultado_final = triangulo[0][0]
    return resultado_final"
"class Solution:
    def racecar(self, target: int) -> int:
        q = [(0, 1)]
        steps = 0
        
        while q:
            num = len(q)
            for i in range(num):
                pos, speed = q.pop(0)
                if pos == target:
                    return steps
                q.append((pos+speed, speed*2))
                rev_speed = -1 if speed > 0 else 1
                if (pos+speed) < target and speed < 0 or (pos+speed) > target and speed > 0:
                    q.append((pos, rev_speed))
            steps += 1";"def carrera_de_autos(objetivo):
    cola = []
    # (posicion, velocidad, numero_de_pasos)
    cola.append((0, 1, 0))

    visitado = set()
    visitado.add((0, 1))

    while len(cola) > 0:
        posicion, velocidad, pasos = cola.pop(0)

        if posicion == objetivo:
            return pasos

        # Opcion 1: Acelerar 'A'
        siguiente_posicion_a = posicion + velocidad
        siguiente_velocidad_a = velocidad * 2
        
        # Condición para evitar explorar estados muy lejanos
        es_valido_a = False
        if abs(siguiente_posicion_a) < 2 * objetivo and objetivo > 0:
             es_valido_a = True
        elif objetivo <= 0 and abs(siguiente_posicion_a) < 2 * abs(objetivo) + 5: # Manejar objetivos negativos
             es_valido_a = True

        if es_valido_a and (siguiente_posicion_a, siguiente_velocidad_a) not in visitado:
            visitado.add((siguiente_posicion_a, siguiente_velocidad_a))
            cola.append((siguiente_posicion_a, siguiente_velocidad_a, pasos + 1))

        # Opcion 2: Reversa 'R'
        siguiente_velocidad_r = 0
        if velocidad > 0:
            siguiente_velocidad_r = -1
        else:
            siguiente_velocidad_r = 1

        siguiente_posicion_r = posicion

        if (siguiente_posicion_r, siguiente_velocidad_r) not in visitado:
            visitado.add((siguiente_posicion_r, siguiente_velocidad_r))
            cola.append((siguiente_posicion_r, siguiente_velocidad_r, pasos + 1))

    return -1"
"class Solution:
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
	
		# Recursive dfs. 
		# Accumulate the number as you traverse the tree and compare with targetSum
		# T: O(N)
		# S: O(N)
		
        return self.dfs(root, targetSum, 0)
        
    def dfs(self, root, targetSum, total):
        if not root:
            return False
        
        total += root.val
        #print(total)
        
        if not root.left and not root.right:
            return total == targetSum
        
        return self.dfs(root.left, targetSum, total) or self.dfs(root.right, targetSum, total) 
        
        
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        
        # Iterative DFS
		# Same logic
        # T: O(N)
        # S: O(N)
        
        if not root:
            return False
        
        stack = [root]
        total = root.val
        while stack:
            node = stack.pop()
            #print(node.val)
            if node.left:
                node.left.val += node.val
                stack.append(node.left)
                
            if node.right:
                node.right.val += node.val
                stack.append(node.right)
            
            if not node.right and not node.left:
                if node.val == targetSum:
                    return True
        return False
		
	def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        
        # Optimized recursive DFS
		# Instead of accumulation, we substract the value of node from the targetSum
        # T: O(N)
        # S: O(N)
        
        if not root:
            return False
        
        targetSum -= root.val
        if not root.left and not root.right:
            return targetSum == 0
        
        return self.hasPathSum(root.left, targetSum) or self.hasPathSum(root.right, targetSum)";"# Definición para un nodo de árbol binario.
# class NodoArbol:
#     def __init__(self, val=0, izquierda=None, derecha=None):
#         self.val = val
#         self.izquierda = izquierda
#         self.derecha = derecha

class Solucion:
    def tiene_camino_con_suma(self, raiz, suma_objetivo):
        if raiz is None:
            return False

        suma_actual = suma_objetivo - raiz.val

        es_un_nodo_hoja = raiz.izquierda is None and raiz.derecha is None

        if es_un_nodo_hoja:
            if suma_actual == 0:
                return True
            else:
                return False

        resultado_izquierda = self.tiene_camino_con_suma(raiz.izquierda, suma_actual)
        resultado_derecha = self.tiene_camino_con_suma(raiz.derecha, suma_actual)

        if resultado_izquierda or resultado_derecha:
            return True
        else:
            return False"
"class Solution:
    
    def modpow(self, a: int, b: int, m: int) -> int:
        """""" Compute a^b mod m with fast exponentiation""""""
        if b == 0:
            return 1
        r = self.modpow(a, b//2, m)
        if b % 2 == 0:
            return (r * r) % m
        else:
            return (a * r * r) % m
    
    def superPow(self, a: int, b: List[int]) -> int:
        m = 1337
        r = 1  # this will contain the final result
        base = a  # this is the starting base
        for e in b[::-1]:  # note that I will traverse the list backward
            r = (r * self.modpow(base, e, m)) % m
            base = self.modpow(base, 10, m)  #  updating base
            if base == 1:  # this trick will save computation: if you find a base==1 no need to compute more
                return r
        return r";"class Solucion:
    def super_potencia(self, a, b):
        modulo = 1337
        resultado = 1
        
        base = a % modulo

        for digito in b:
            # Primero, elevamos el resultado actual a la 10
            # (resultado ^ 10) % modulo
            resultado_potencia_10 = 1
            i = 0
            while i < 10:
                resultado_potencia_10 = (resultado_potencia_10 * resultado) % modulo
                i = i + 1
            
            # Segundo, elevamos la base 'a' al dígito actual
            # (base ^ digito) % modulo
            base_potencia_digito = 1
            j = 0
            while j < digito:
                base_potencia_digito = (base_potencia_digito * base) % modulo
                j = j + 1
            
            # Combinamos los resultados
            resultado = (resultado_potencia_10 * base_potencia_digito) % modulo
            
        return resultado"
"class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        # * merge sort constant space (bottom up)

        cnt = 0
        node = head
        while node is not None:
            node = node.next
            cnt += 1
        
        if cnt < 2:
            return head
        
        dummy = ListNode(-1)
        dummy.next = head

        merge_size = 1
        # merging all sublists with size <merge_size>
        # this loop will go on for log n times
        while merge_size < cnt:
            pre = dummy
            end = None
            i = 0
            # this loop takes O(n) time
            while cnt - i > merge_size:
                # find two sublists
                list0 = pre.next
                node = pre

                for _ in range(merge_size):
                    node = node.next
                
                i += merge_size
                
                # mark the break point
                mid = node
                
                for _ in range(min(merge_size, cnt - i)):
                    node = node.next

                i += min(merge_size, cnt - i)
                
                # break up the sublist from the nodes after it
                end = None
                if node is not None:
                    end = node.next
                    node.next = None
                
                # break the sublist into two parts
                list1 = mid.next
                mid.next = None

                # break the sublist from the nodes before it (optional)
                pre.next = None

                # merge the two sublists (and concatenate the new sublist to the nodes before)
                # the following steps take linear time because we are essentially concatenating nodes to ''pre''
                while list0 is not None and list1 is not None:
                    if list0.val < list1.val:
                        pre.next = list0
                        list0 = list0.next
                    else:
                        pre.next = list1
                        list1 = list1.next
                    
                    pre = pre.next
                
                pre.next = list0 if list0 is not None else list1
                while pre.next is not None:
                    pre = pre.next
                
                # concatenate these nodes to the rest
                pre.next = end

            merge_size <<= 1

        return dummy.next";"class NodoLista:
    def __init__(self, val=0, siguiente=None):
        self.val = val
        self.siguiente = siguiente

class Solucion:
    def ordenar_lista(self, cabeza):
        if cabeza is None:
            return None

        cambio_realizado = True
        while cambio_realizado:
            cambio_realizado = False
            nodo_actual = cabeza
            while nodo_actual.siguiente is not None:
                if nodo_actual.val > nodo_actual.siguiente.val:
                    valor_temporal = nodo_actual.val
                    nodo_actual.val = nodo_actual.siguiente.val
                    nodo_actual.siguiente.val = valor_temporal
                    cambio_realizado = True
                
                nodo_actual = nodo_actual.siguiente
        
        return cabeza"
"class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:
        # Calculate the max time for a pig to test buckets...
        # Note that, max time will not be (minutesToTest / minutesToDie)...
        # Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...
        max_time = minutesToTest / minutesToDie + 1
        # Initialize the required minimum number of pigs...
        req_pigs = 0
        # To find the minimum number of pigs, find the minimum req_pigs such that Math.pow(max_time, req_pigs) >= buckets...
        while (max_time) ** req_pigs < buckets:
            # Increment until it will be greater or equals to bucket...
            req_pigs += 1
        # Return the required minimum number of pigs...
        return req_pigs";"def minimo_cerdos_necesarios(cubos, minutos_para_morir, minutos_para_probar):
    pruebas_posibles = minutos_para_probar // minutos_para_morir
    estados = pruebas_posibles + 1
    
    numero_de_cerdos = 0
    cubos_verificados = 1
    
    while cubos_verificados < cubos:
        cubos_verificados = cubos_verificados * estados
        numero_de_cerdos = numero_de_cerdos + 1
        
    return numero_de_cerdos"
"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        lis=[]
        #First way to solve this question
        
        for val in range(1,n+1):
            #print(val%3, val%5)
            if (val%3==0 and val%5==0):
                lis.append(""FizzBuzz"")
            elif val%3==0:
                lis.append(""Fizz"")
            elif val%5==0:
                lis.append(""Buzz"")
            else:
                lis.append(str(val))
		return lis
        #Runtime: 88 ms, faster than 42.22% of Python3 online submissions for Fizz Buzz.
        #Memory Usage: 14.9 MB, less than 85.86% of Python3 online submissions for Fizz Buzz
        
        #Second way to solve this question
         
        for val in range(1,n+1):
            lis.append(""FizzBuzz"") if (val%3==0 and val%5==0) else (lis.append(""Fizz"") if val%3==0 else (lis.append(""Buzz"") if val%5==0 else lis.append(str(val)) ) )
        return lis,
         
        #Runtime: 87 ms, faster than 44.84% of Python3 online submissions for Fizz Buzz.
        #Memory Usage: 15.1 MB, less than 43.11% of Python3 online submissions for Fizz Buzz.
        
        #Third way to solve this solution
        
        # Learned this way to solve the question from https://leetcode.com/problems/fizz-buzz/discuss/2704645/Python-One-liner
        
        #Runtime: 96 ms, faster than 22.65% of Python3 online submissions for Fizz Buzz.
        #Memory Usage: 15.2 MB, less than 17.01% of Python3 online submissions for Fizz Buzz.
        return [ ""Fizz""*(val%3==0)+""Buzz""*(val%5==0) or f""{val}"" for val in range(1,n+1)]";"class Solucion:
    def resolver_fizz_buzz(self, n):
        respuesta = []
        numero_actual = 1
        while numero_actual <= n:
            if numero_actual % 3 == 0 and numero_actual % 5 == 0:
                respuesta.append(""FizzBuzz"")
            elif numero_actual % 3 == 0:
                respuesta.append(""Fizz"")
            elif numero_actual % 5 == 0:
                respuesta.append(""Buzz"")
            else:
                cadena_numero = str(numero_actual)
                respuesta.append(cadena_numero)
            
            numero_actual = numero_actual + 1
        
        return respuesta"
"class Solution:
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        """"""
        sort the start position.
        the car behind can only catch up no exceed.
        so if the car start late and speed is faster, it will catch up the car ahead of itself and they become a fleet.
        there is a target(or desitination),so use arrive time to measure. 
        
        start late but arrive ealier means the car is behind and will catch up before arriving the destination.
        
        position  10  8  5  3  0
        distance  2   4  7  9  12
        speed.    2   4  1  3  1
        time.     1   1  7  3  12
                      ^     ^
                      |     |
                     catch  catch up the previous car before target, join the fleet
		stack = [1] , [1],[1,7],[1,7][1,7,12] 			 
                                
        """"""
        stack = []
        for pos, v in sorted(zip(position, speed),reverse = True):

            dist = target - pos
            time = dist / v 
            
            if not stack:
                stack.append(time)
            elif time > stack[-1]:
                stack.append(time)

        return len(stack)";"class Solucion:
    def flotas_de_coches(self, objetivo, posicion, velocidad):
        numero_de_coches = len(posicion)
        if numero_de_coches == 0:
            return 0

        coches = []
        for i in range(numero_de_coches):
            coche_info = (posicion[i], velocidad[i])
            coches.append(coche_info)

        coches.sort()

        pila_tiempos = []
        i = numero_de_coches - 1
        while i >= 0:
            pos_actual = coches[i][0]
            vel_actual = coches[i][1]
            
            distancia_restante = objetivo - pos_actual
            tiempo_llegada = float(distancia_restante) / vel_actual

            if not pila_tiempos:
                pila_tiempos.append(tiempo_llegada)
            else:
                tiempo_lider = pila_tiempos[-1]
                if tiempo_llegada > tiempo_lider:
                    pila_tiempos.append(tiempo_llegada)
            
            i = i - 1
            
        return len(pila_tiempos)"
"class MinStack:

    def __init__(self):
                
        self.Stack = []
        self.minVal = None
        

    def push(self, val: int) -> None:
        
        if not self.Stack or self.minVal == None:
            self.minVal = val
        
        
        if not self.Stack: 
            self.Stack.append(val)
        elif val < self.minVal: 
            self.Stack.append(2*val - self.minVal)
            self.minVal = val
        else: 
            self.Stack.append(val)
        

    def pop(self) -> None:
        
        if not self.Stack: 
            return
        elif self.Stack[-1] < self.minVal: 
            self.minVal = 2*self.minVal - self.Stack[-1]
            self.Stack.pop()
        else: 
            self.Stack.pop()
        

    def top(self) -> int:
        
        if self.Stack[-1] > self.minVal : 
            return self.Stack[-1]
        else: 
            return self.minVal
        

    def getMin(self) -> int:
        
        return self.minVal
        
        


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()";"class PilaMinima:
    def __init__(self):
        self.pila = []
        self.pila_minimos = []

    def empujar(self, valor):
        self.pila.append(valor)
        if not self.pila_minimos:
            self.pila_minimos.append(valor)
        else:
            minimo_actual = self.pila_minimos[-1]
            if valor <= minimo_actual:
                self.pila_minimos.append(valor)

    def sacar(self):
        valor_sacado = self.pila.pop()
        minimo_actual = self.pila_minimos[-1]
        if valor_sacado == minimo_actual:
            self.pila_minimos.pop()

    def cima(self):
        return self.pila[-1]

    def obtenerMinimo(self):
        return self.pila_minimos[-1]"
"class Node:
    def __init__(self, key, val):
        self.val = val
        self.key = key
        self.prev = None
        self.nxt_ = None

# use a DL
class DLinked:
    def __init__(self):
        self.head = None
        self.tail = None
    
    def remove(self, node):
        """""" return the deleted node key
        """"""
        # 3 basic postion cases
        prev = node.prev
        nxt_  = node.nxt_
        
        # if the removing node is the single node in the list
        if prev is None and nxt_ is None:
            # eariler termination
            self.head = None
            self.tail = None
            return node.key
        
        # head node and not single, happy 2.14's day !
        if prev is None:
            self.head = nxt_
            nxt_.prev  = None
        
        # tail node not single
        elif nxt_ is None:
            self.tail = prev
            prev.nxt_ = None
            
        else:
            # mid node
            prev.nxt_ = nxt_
            nxt_.prev = prev
        
        # either way you should return the old key        
        return node.key
    
    def add(self, node):
        """""" return the node ref if added
        """"""
        # when head is None
        if self.head is None:
            self.head = node
        
            if self.tail is None:
                self.tail = node
        else:
            node.nxt_ = self.head
            node.prev = None
            self.head.prev = node
            self.head = node
        
        return self.head
    
    
class LRUCache:
    def __init__(self, capacity):
        self.cap = capacity
        self.table = {}
        self.dlinked = DLinked()
    
    def get(self, key):
        # also check key first
        node = self.table.get(key, None)
        if node is not None:
            # update hit
            self.dlinked.remove(node)
            self.dlinked.add(node)
            return node.val
        else:
            return -1
    
    def put(self, key, val):
        # let Dlinked class to handle add / remove
        # let cache class to handle capacity cases
        # use forward logic to make thing clear
        
        # no need to check cap first, instead, we need to check key in table or not.
		# becase if key exist, there is nothing to deal with the capacity
        node = self.table.get(key, None)
        if node is not None:
            # update key hit
            self.dlinked.remove(node)
            node.val = val  # same key overwrite
            self.dlinked.add(node)
			# return as soon as possible to prevent logic twists
            return
        
        # if key not in table, then we need to add key, hence we need to check capacity
        
        if len(self.table) == self.cap:
            # cache full, kill the tail and add to head
			# seperating the operations by returning the old key
            old_key = self.dlinked.remove(self.dlinked.tail)
            del self.table[old_key]
            node = self.dlinked.add(Node(key, val)) 
            self.table[key] = node
        else:    
            # cache not full, add directly
            node = self.dlinked.add(Node(key, val))
            self.table[key] = node

        return";"class Nodo:
    def __init__(self, clave, valor):
        self.clave = clave
        self.valor = valor
        self.anterior = None
        self.siguiente = None

class LRUCache:
    def __init__(self, capacidad):
        self.capacidad = capacidad
        self.mapa = {}
        self.cabeza = Nodo(0, 0)
        self.cola = Nodo(0, 0)
        self.cabeza.siguiente = self.cola
        self.cola.anterior = self.cabeza

    def get(self, clave):
        if clave in self.mapa:
            nodo = self.mapa[clave]
            
            # Remover nodo de la lista
            nodo_anterior = nodo.anterior
            nodo_siguiente = nodo.siguiente
            nodo_anterior.siguiente = nodo_siguiente
            nodo_siguiente.anterior = nodo_anterior

            # Mover nodo al frente
            siguiente_de_cabeza = self.cabeza.siguiente
            self.cabeza.siguiente = nodo
            nodo.anterior = self.cabeza
            nodo.siguiente = siguiente_de_cabeza
            siguiente_de_cabeza.anterior = nodo
            
            return nodo.valor
        else:
            return -1

    def put(self, clave, valor):
        if clave in self.mapa:
            nodo = self.mapa[clave]
            nodo.valor = valor
            
            # Remover nodo de la lista
            nodo_anterior = nodo.anterior
            nodo_siguiente = nodo.siguiente
            nodo_anterior.siguiente = nodo_siguiente
            nodo_siguiente.anterior = nodo_anterior

            # Mover nodo al frente
            siguiente_de_cabeza = self.cabeza.siguiente
            self.cabeza.siguiente = nodo
            nodo.anterior = self.cabeza
            nodo.siguiente = siguiente_de_cabeza
            siguiente_de_cabeza.anterior = nodo
        else:
            if len(self.mapa) >= self.capacidad:
                # Sacar el ultimo nodo
                nodo_a_eliminar = self.cola.anterior
                
                # Remover de la lista
                anterior_a_eliminar = nodo_a_eliminar.anterior
                anterior_a_eliminar.siguiente = self.cola
                self.cola.anterior = anterior_a_eliminar
                
                # Remover del mapa
                del self.mapa[nodo_a_eliminar.clave]

            # Agregar nuevo nodo al frente
            nuevo_nodo = Nodo(clave, valor)
            self.mapa[clave] = nuevo_nodo
            
            siguiente_de_cabeza = self.cabeza.siguiente
            self.cabeza.siguiente = nuevo_nodo
            nuevo_nodo.anterior = self.cabeza
            nuevo_nodo.siguiente = siguiente_de_cabeza
            siguiente_de_cabeza.anterior = nuevo_nodo"
"class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:
        # 1,2,3,4,5 -> player 1
        # 2,3,4,5 -> player 2, choose any of them, cannot win
        # Then 1 win
        candidate = [i for i in range(1, maxChoosableInteger + 1)]

        if sum(candidate) < desiredTotal:
            return False
        
        memo = dict()
        def dfs(candidate, remain):
            if candidate[-1] >= remain:
                return True
            
            if tuple(candidate) in memo:
                return memo[tuple(candidate)]
            
            for i in range(len(candidate)):
                if not dfs(candidate[:i] + candidate[i + 1:], remain - candidate[i]):
                    memo[tuple(candidate)] = True
                    return True
            
            memo[tuple(candidate)] = False
            return False
                
        return dfs(candidate, desiredTotal)";"class Solucion:
    def puedo_ganar(self, maximo_entero_elegible, total_deseado):
        suma_total_posible = 0
        i = 1
        while i <= maximo_entero_elegible:
            suma_total_posible = suma_total_posible + i
            i = i + 1

        if suma_total_posible < total_deseado:
            return False

        if total_deseado <= 0:
            return True

        memoria = {}

        def puede_ganar_recursivo(numeros_usados):
            estado_actual_tupla = tuple(numeros_usados)
            if estado_actual_tupla in memoria:
                return memoria[estado_actual_tupla]

            total_actual = 0
            for numero in numeros_usados:
                total_actual = total_actual + numero

            numero_candidato = 1
            while numero_candidato <= maximo_entero_elegible:
                esta_usado = False
                for n_usado in numeros_usados:
                    if n_usado == numero_candidato:
                        esta_usado = True
                        break
                
                if not esta_usado:
                    if total_actual + numero_candidato >= total_deseado:
                        memoria[estado_actual_tupla] = True
                        return True

                numero_candidato = numero_candidato + 1

            numero_candidato = 1
            while numero_candidato <= maximo_entero_elegible:
                esta_usado = False
                for n_usado in numeros_usados:
                    if n_usado == numero_candidato:
                        esta_usado = True
                        break

                if not esta_usado:
                    siguiente_lista_numeros = []
                    for n_usado in numeros_usados:
                        siguiente_lista_numeros.append(n_usado)
                    siguiente_lista_numeros.append(numero_candidato)
                    
                    if not puede_ganar_recursivo(siguiente_lista_numeros):
                        memoria[estado_actual_tupla] = True
                        return True
                
                numero_candidato = numero_candidato + 1

            memoria[estado_actual_tupla] = False
            return False

        numeros_iniciales = []
        return puede_ganar_recursivo(numeros_iniciales)"
"class Solution:
    # optimized prefix sum
    def gridGame(self, grid: List[List[int]]) -> int:
        n = len(grid[0])
        ans = math.inf
        topSum = sum(grid[0])
        bottomSum = 0

        for i in range(n):
            topSum -= grid[0][i]
            ans = min(ans, max(topSum, bottomSum))
            bottomSum += grid[1][i]

        return ans

    # neetcode's prefix sum method
    def gridGame(self, grid: List[List[int]]) -> int:
        res = float('inf') # max value
        prefixSum1 = [grid[0][0]]
        prefixSum2 = [grid[1][0]] # has the first value done so that we can iterate more smoothly
        length = len(grid[0])

        for i in range(1, length): # from 1 to end because we don't want to deal with an out of bounds error
            prefixSum1.append(grid[0][i] + prefixSum1[i-1]) # doing it this way bc it seems faster but you really just want to calculate the prefix sums of each row and save it to the index
            prefixSum2.append(grid[1][i] + prefixSum2[i-1])
        for i in range(length): # so here we want to calculate the turning point of the first robot
            # calculate the values excluding the current index
            top_row = prefixSum1[-1] - prefixSum1[i] # so total - the current index (which is the accumulated value of the left side, index inclusive)
            bottom_row = prefixSum2[i-1] if i > 0 else 0 # bounds checking here bc 0-1 is -1 and that is not the right place to be.
            current = max(top_row, bottom_row) # take the max values of this index that the second robot can grab
            res = min(res, current) # the first robot is a bad robot so we want to take the minimum values of all the maxes that we calculate and this here is O(1) space complexity instead of saving it all to an array. In taking the minimum, we take thus maximize robot 1's take and robot 2's take per the properties.
        return res



    # simple solution (runs out of time due to not storing the calculations)
    def gridGame(self, grid: List[List[int]]) -> int:

        # this is the simpler code but it doesn't work because of a time limit problem. simply having the prefix sum's already calculated makes this problem ultra efficient
        res = float('inf') # max
        length = len(grid[0])
        for i in range(length): # check each index of the array
            # take the sum of everything after the index on the top row and before the index on the bottom row
            top = sum(grid[0][i+1:])
            bot = sum(grid[1][:i])
            current = max(top, bot) # max of robot 2's take if robot 1 were to turn at this specific index
            res = min(res, current) # determines robot 2's real take that would maximize robot 1's take
        return res";"class Solucion:
    def robotSim(self, cuadricula):
        numero_columnas = len(cuadricula[0])

        suma_total_arriba = 0
        columna = 0
        while columna < numero_columnas:
            suma_total_arriba = suma_total_arriba + cuadricula[0][columna]
            columna = columna + 1
        
        suma_total_abajo = 0
        columna = 0
        while columna < numero_columnas:
            suma_total_abajo = suma_total_abajo + cuadricula[1][columna]
            columna = columna + 1

        resultado_final = suma_total_arriba + suma_total_abajo

        suma_arriba = suma_total_arriba
        suma_abajo = 0

        indice = 0
        while indice < numero_columnas:
            suma_arriba = suma_arriba - cuadricula[0][indice]
            
            puntos_maximos_segundo_robot = 0
            if suma_arriba > suma_abajo:
                puntos_maximos_segundo_robot = suma_arriba
            else:
                puntos_maximos_segundo_robot = suma_abajo
            
            if puntos_maximos_segundo_robot < resultado_final:
                resultado_final = puntos_maximos_segundo_robot
            
            suma_abajo = suma_abajo + cuadricula[1][indice]
            
            indice = indice + 1
            
        return resultado_final"
"class Solution:
    def canCross(self, stones: List[int]) -> bool:
        jump_mods = [-1,0,1]
        stone_ref = {}
        prev = 0
        
        # Make dictionary of the indexes of each stone
        for i,stone in enumerate(stones):
            stone_ref[stone] = i
            
            # if any stone is further away from the previous one than its index,
            # it is unreachable in all scenarios and we can return False early
            if stone-prev > i:
                return False
            
            prev = stone
        
        stack = [(0,0)]
        seen = set()    
        
        # DFS
        while stack:
            jump,stone = stack.pop()
            
            seen.add((jump,stone))
            
            # Return true if we reached our goal
            if stone == stones[-1]:
                return True
            
            # Go through each of the jump modifiers to see if any of them result in the following conditions:
            # 1) There is a stone that matches the current stone's value plus that modified jump value
            # 2) The index of that matching stone is greater than the index that the frog is currently on
            # 3) We have not visited that stone with the same jump value in the past
            for mod in jump_mods:
                if stone+jump+mod in stone_ref and stone_ref[stone+jump+mod] > stone_ref[stone]:
                    if (jump+mod,stone+jump+mod) not in seen:
                        stack.append((jump+mod,stone+jump+mod))
        return False";"def puede_cruzar_rio(piedras):
    saltos_por_piedra = {}
    
    # Inicializar el diccionario con un conjunto vacío para cada piedra
    for posicion_piedra in piedras:
        saltos_por_piedra[posicion_piedra] = set()

    # La rana empieza en la piedra 0 y su primer salto debe ser de 1
    # Entonces, desde la piedra 0, el único salto posible es 1
    saltos_por_piedra[0].add(1)

    # Guardar la posición de la última piedra para saber cuándo hemos llegado
    posicion_final = piedras[-1]

    # Recorrer cada piedra en el orden en que aparecen
    for posicion_actual in piedras:
        
        # Obtener los tamaños de salto que nos pueden llevar a la siguiente piedra
        saltos_disponibles = saltos_por_piedra[posicion_actual]
        
        # Probar cada tamaño de salto posible desde la piedra actual
        for k in saltos_disponibles:
            
            siguiente_posicion = posicion_actual + k
            
            # Si la siguiente posición es la última piedra, la rana puede cruzar
            if siguiente_posicion == posicion_final:
                return True
            
            # Si la siguiente posición es una piedra que existe en el río
            if siguiente_posicion in saltos_por_piedra:
                
                # El siguiente salto puede ser k-1, pero solo si es mayor que 0
                if k - 1 > 0:
                    saltos_por_piedra[siguiente_posicion].add(k - 1)
                
                # El siguiente salto puede ser igual al anterior, k
                saltos_por_piedra[siguiente_posicion].add(k)
                
                # El siguiente salto puede ser k+1
                saltos_por_piedra[siguiente_posicion].add(k + 1)
    
    # Si recorrimos todas las piedras y no pudimos llegar al final, es imposible
    return False"
"class Solution:
    def findNthDigit(self, n: int) -> int:
        """"""
        imagine the number you need to find have 4 digit
        so you need to go throught all num have 1 digit, 2 digit, 3 digit
        number have 1 digit:  10 ** 1 - 1 = 9 => 9 * 1 = 9 digit
        number have 2 digit:  10 ** 2 - 1 = 90 => 90 * 2 = 180 digit
        number have 3 digit:  10 ** 3 - 1 = 900 => 900 * 3 = 2700 digit
        ...
        just subtract until you find how many digit of the number you need to find
        when you got the number of digit 
        """"""
        if n < 10:
            return n
        
        number_of_digit = 0 # check how many digit of the number you need to find
        while n > 0:
            number_of_digit += 1
            n -= 9 * 10 ** ((number_of_digit - 1)) * number_of_digit
        n += 9 * 10 ** ((number_of_digit - 1)) * number_of_digit
        
        """""" 
        print(n , number_of_digit) if you dont understand 
        after subtract you will find number of digit
        all you need to do now is find exactly number by just a little bit of math
        """""" 
        tmp_num = 0
        
        if n % number_of_digit == 0:
            n //= number_of_digit 
            tmp_num += 10 ** ((number_of_digit - 1)) - 1
            return int(str(tmp_num + n)[-1])
        else:
            n /= number_of_digit
            digit = int((n * number_of_digit) % number_of_digit)
            tmp_num += 10 ** ((number_of_digit - 1)) - 1
            return int(str(int(tmp_num + n) + 1)[digit - 1])";"class Solucion:
    def encontrar_enesimo_digito(self, n: int) -> int:
        longitud_numero = 1
        cantidad_numeros = 9
        numero_inicial = 1

        while n > longitud_numero * cantidad_numeros:
            n = n - (longitud_numero * cantidad_numeros)
            longitud_numero = longitud_numero + 1
            cantidad_numeros = cantidad_numeros * 10
            numero_inicial = numero_inicial * 10

        indice_numero_en_bloque = (n - 1) // longitud_numero
        numero_real = numero_inicial + indice_numero_en_bloque

        cadena_del_numero = str(numero_real)
        
        indice_del_digito = (n - 1) % longitud_numero
        caracter_del_digito = cadena_del_numero[indice_del_digito]
        
        resultado_final = int(caracter_del_digito)
        
        return resultado_final"
"class Solution:
    def findMinStep(self, board: str, hand: str) -> int:
        
        # start from i and remove continues ball
        def remove_same(s, i):
            if i < 0:
                return s
            
            left = right = i
            while left > 0 and s[left-1] == s[i]:
                left -= 1
            while right+1 < len(s) and s[right+1] == s[i]:
                right += 1
            
            length = right - left + 1
            if length >= 3:
                new_s = s[:left] + s[right+1:]
                return remove_same(new_s, left-1)
            else:
                return s



        hand = """".join(sorted(hand))

        # board, hand and step
        q = collections.deque([(board, hand, 0)])
        visited = set([(board, hand)])

        while q:
            curr_board, curr_hand, step = q.popleft()
            for i in range(len(curr_board)+1):
                for j in range(len(curr_hand)):
                    # skip the continue balls in hand
                    if j > 0 and curr_hand[j] == curr_hand[j-1]:
                        continue
                    
                    # only insert at the begin of continue balls in board
                    if i > 0 and curr_board[i-1] == curr_hand[j]: # left side same color
                        continue
                    
                    pick = False
                    # 1. same color with right
                    # 2. left and right are same but pick is different
                    if i < len(curr_board) and curr_board[i] == curr_hand[j]:
                        pick = True
                    if 0<i<len(curr_board) and curr_board[i-1] == curr_board[i] and curr_board[i] != curr_hand[j]:
                        pick = True
                    
                    if pick:
                        new_board = remove_same(curr_board[:i] + curr_hand[j] + curr_board[i:], i)
                        new_hand = curr_hand[:j] + curr_hand[j+1:]
                        if not new_board:
                            return step + 1
                        if (new_board, new_hand) not in visited:
                            q.append((new_board, new_hand, step+1))
                            visited.add((new_board, new_hand))

        return -1";"def encontrar_pasos_minimos(tablero, mano):
    mano_ordenada = """".join(sorted(mano))

    cola = []
    # La cola guarda tuplas de (tablero, mano, numero_de_pasos)
    cola.append((tablero, mano_ordenada, 0))

    # El conjunto de visitados guarda tuplas de (tablero, mano) para no repetir trabajo
    visitados = set()
    visitados.add((tablero, mano_ordenada))

    cabeza_de_cola = 0
    while cabeza_de_cola < len(cola):
        tablero_actual, mano_actual, pasos_actuales = cola[cabeza_de_cola]
        cabeza_de_cola = cabeza_de_cola + 1

        # Intentamos usar cada bola de la mano
        i = 0
        while i < len(mano_actual):
            bola_a_usar = mano_actual[i]
            
            # Intentamos insertar la bola en cada posicion del tablero
            j = 0
            while j < len(tablero_actual) + 1:
                # Insertar la bola
                nuevo_tablero = tablero_actual[:j] + bola_a_usar + tablero_actual[j:]

                # Limpiar el tablero de grupos de 3 o mas
                tablero_despues_de_limpiar = nuevo_tablero
                while True:
                    se_encontro_grupo = False
                    k = 0
                    while k < len(tablero_despues_de_limpiar):
                        letra_actual = tablero_despues_de_limpiar[k]
                        contador = 0
                        puntero = k
                        while puntero < len(tablero_despues_de_limpiar) and tablero_despues_de_limpiar[puntero] == letra_actual:
                            contador = contador + 1
                            puntero = puntero + 1
                        
                        if contador >= 3:
                            tablero_despues_de_limpiar = tablero_despues_de_limpiar[:k] + tablero_despues_de_limpiar[puntero:]
                            se_encontro_grupo = True
                            break 
                        else:
                            k = k + contador
                    
                    if not se_encontro_grupo:
                        break
                
                # Si el tablero esta vacio, ganamos
                if not tablero_despues_de_limpiar:
                    return pasos_actuales + 1

                # Preparamos el siguiente estado
                mano_restante = mano_actual[:i] + mano_actual[i+1:]
                
                estado_nuevo = (tablero_despues_de_limpiar, mano_restante)
                if estado_nuevo not in visitados:
                    cola.append((tablero_despues_de_limpiar, mano_restante, pasos_actuales + 1))
                    visitados.add(estado_nuevo)
                
                # Optimizacion: Si insertamos una bola del mismo color que la siguiente,
                # podemos saltar todas las bolas de ese color.
                if j < len(tablero_actual) and tablero_actual[j] == bola_a_usar:
                    puntero_salto = j
                    while puntero_salto < len(tablero_actual) and tablero_actual[puntero_salto] == bola_a_usar:
                        puntero_salto = puntero_salto + 1
                    j = puntero_salto
                else:
                    j = j + 1

            # Optimizacion: No procesar la misma bola de la mano dos veces seguidas
            puntero_salto_mano = i
            while puntero_salto_mano < len(mano_actual) and mano_actual[puntero_salto_mano] == bola_a_usar:
                puntero_salto_mano = puntero_salto_mano + 1
            i = puntero_salto_mano

    return -1"
"class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        '''
        The idea is similar to Unique Paths, https://leetcode.com/problems/unique-paths/
        in that, we get the minimum of the accumulated path totals from TOP + LEFT
		but here, we also then compare against accumulated path costs from BOTTOM + RIGHT
            
        Specifics of why 2 at a time and not all 4 is not fully clear but when done with 4
            runs infinitely / maxes out / keeps looping
        '''
        R, C = len(mat), len(mat[0])
        
        # Get the min of accumulated totals for NON-0's from TOP and LEFT
        # Out of bounds are rendered irrelevant by assigning infinity
        for r in range(R):
            for c in range(C):
                if mat[r][c] != 0:
                    top = float('inf') if r == 0 else mat[r - 1][c]
                    left = float('inf') if c == 0 else mat[r][c - 1]
                    mat[r][c] = 1 + min(top, left) # Note the +1 to account for the path-move
        
        # Do the same, but with BOTTOM and RIGHT and this time also compare against current value
        # Likewise, igore out of bounds by setting them as infinity
        for r in range(R-1, -1, -1):
            for c in range(C-1, -1, -1):
                if mat[r][c] != 0:
                    bottom = float('inf') if (r + 1) == R else mat[r + 1][c]
                    right = float('inf') if (c + 1) == C else mat[r][c + 1]
                    mat[r][c] = min(mat[r][c], 1 + bottom, 1 + right) # Note the pre-calculated one from last loop is fine but the others need +1 to pay for path move
                    
        # We got our minimums, let's return
        return mat";"def encontrar_distancias(matriz):
    if not matriz or not matriz[0]:
        return []

    filas = len(matriz)
    columnas = len(matriz[0])

    distancias = []
    for i in range(filas):
        fila_distancia = []
        for j in range(columnas):
            fila_distancia.append(-1)
        distancias.append(fila_distancia)

    cola = []

    for i in range(filas):
        for j in range(columnas):
            if matriz[i][j] == 0:
                distancias[i][j] = 0
                cola.append((i, j))

    cabeza = 0
    while cabeza < len(cola):
        fila, columna = cola[cabeza]
        cabeza = cabeza + 1

        direcciones = [[-1, 0], [1, 0], [0, -1], [0, 1]]

        for direccion in direcciones:
            nueva_fila = fila + direccion[0]
            nueva_columna = columna + direccion[1]

            if nueva_fila >= 0 and nueva_fila < filas and nueva_columna >= 0 and nueva_columna < columnas:
                if distancias[nueva_fila][nueva_columna] == -1:
                    distancias[nueva_fila][nueva_columna] = distancias[fila][columna] + 1
                    cola.append((nueva_fila, nueva_columna))

    return distancias"
"class Solution:
    def restoreString(self, s: str, indices: List[int]) -> str:
        res = [''] * len(s)
        for i in range(len(s)):
            res[indices[i]] = s[i]
        
        return ''.join(res)

class Solution:
    def restoreString(self, s: str, indices: List[int]) -> str:
        s = list(s)
        
        for i in range(len(indices)):
            while i != indices[i]:
                tmp = indices[i]
                indices[i] = indices[tmp]
                indices[tmp] = tmp
    
                s[i], s[tmp] = s[tmp], s[i]

        return ''.join(s)";"class Solucion:
  def restaurar_cadena(self, s: str, indices: list[int]) -> str:
    longitud = len(s)
    lista_temporal = [None] * longitud

    contador = 0
    while contador < longitud:
      caracter_actual = s[contador]
      indice_destino = indices[contador]
      lista_temporal[indice_destino] = caracter_actual
      contador = contador + 1

    cadena_resultado = """"
    for caracter in lista_temporal:
      cadena_resultado = cadena_resultado + caracter
    
    return cadena_resultado"
"class Solution:
    #Time-Complexity: O(n + n^2) -> O(n^2)
    #Space-Complexity: O(n + n + n) -> O(n)
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        
        q = collections.deque()
        number_of_rooms = len(rooms)
        #if we visited every room, our visited set will match wanted_set!
        wanted_set = set()
        for i in range(number_of_rooms):
            wanted_set.add(i)
        #visited will keep track of all distinct visited rooms which will be updated as bfs traversal                   progresess!
        visited = set()
        
        #before initiating bfs, we append to queue room 0 and mark room 0 as visited!
        visited.add(0)
        q.append(0)
        
        #as long as queue is non-emtpy, continue bfs!
        #all elements of queue are waited to be processed and are not already visited!
        #in worst case, our queue have to process all n rooms if we can simply hop from ith room to i+1th room
        #until we visit every single room!
        while q:
            cur_room = q.popleft()
            set_of_keys = rooms[cur_room]
            #For each room our current room can lead to, check that it is not already visited to avoid
            #revisiting node(stuck in cycle) and make sure it's not a self loop!
            #this inner for loop in worst case runs n-1 times, cause ith room may provide keys to 
            #all other rooms!
            for key in set_of_keys:
                if(key not in visited and key != cur_room):
                    q.append(key)
                    visited.add(key)
        #once our queue ends, see if visited == wanted_set
        if(visited == wanted_set):
            return True
        return False";"def puede_visitar_todas_las_habitaciones(habitaciones):
    numero_total_de_habitaciones = len(habitaciones)
    
    visitadas = []
    for i in range(numero_total_de_habitaciones):
        visitadas.append(False)
    
    cola_de_llaves = [0]
    visitadas[0] = True
    
    habitaciones_abiertas = 1
    
    indice = 0
    while indice < len(cola_de_llaves):
        llave_actual = cola_de_llaves[indice]
        indice = indice + 1
        
        nuevas_llaves = habitaciones[llave_actual]
        
        for llave in nuevas_llaves:
            if visitadas[llave] == False:
                visitadas[llave] = True
                cola_de_llaves.append(llave)
                habitaciones_abiertas = habitaciones_abiertas + 1
                
    if habitaciones_abiertas == numero_total_de_habitaciones:
        return True
    else:
        return False"
"class Solution:
    def minPatches(self, nums: List[int], n: int) -> int:
        ans = prefix = k = 0 
        while prefix < n: 
            if k < len(nums) and nums[k] <= prefix + 1: 
                prefix += nums[k]
                k += 1
            else: 
                ans += 1
                prefix += prefix + 1
        return ans";"def minParches(numeros, n):
    parches_necesarios = 0
    alcance = 0
    indice = 0
    longitud_numeros = len(numeros)

    while alcance < n:
        if indice < longitud_numeros and numeros[indice] <= alcance + 1:
            alcance = alcance + numeros[indice]
            indice = indice + 1
        else:
            alcance = alcance + (alcance + 1)
            parches_necesarios = parches_necesarios + 1
            
    return parches_necesarios"
"class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        
        def mergeSort(arr, l, r):
            if l < r:
                m = l + (r-l)//2
                mergeSort(arr, l, m)
                mergeSort(arr, m+1, r)
                merge(arr, l, m, r)
        
        def merge(arr, l, m, r):
            ans = []
            i = l
            j = m+1
            while i <= m and j <= r:
                if int(arr[i]+arr[j]) > int(arr[j]+arr[i]):
                    ans.append(arr[i])
                    i += 1
                else:
                    ans.append(arr[j])
                    j += 1
            while i <= m:
                ans.append(arr[i])
                i+=1
            while j <= r:
                ans.append(arr[j])
                j+=1
            
            for i in range(len(ans)):
                arr[l+i] = ans[i]
        
        arr = [str(num) for num in nums]

        mergeSort(arr, 0, len(arr)-1)

        return ""0"" if arr and arr[0] == ""0"" else """".join(arr)";"class Solucion:
    def numero_mas_grande(self, nums):
        cadenas_de_numeros = []
        for numero in nums:
            cadena = str(numero)
            cadenas_de_numeros.append(cadena)

        longitud = len(cadenas_de_numeros)
        i = 0
        while i < longitud:
            indice_maximo = i
            j = i + 1
            while j < longitud:
                primera_combinacion = cadenas_de_numeros[j] + cadenas_de_numeros[indice_maximo]
                segunda_combinacion = cadenas_de_numeros[indice_maximo] + cadenas_de_numeros[j]
                if primera_combinacion > segunda_combinacion:
                    indice_maximo = j
                j = j + 1
            
            temporal = cadenas_de_numeros[i]
            cadenas_de_numeros[i] = cadenas_de_numeros[indice_maximo]
            cadenas_de_numeros[indice_maximo] = temporal
            
            i = i + 1

        resultado_final = """"
        for cadena in cadenas_de_numeros:
            resultado_final = resultado_final + cadena
        
        if int(resultado_final) == 0:
            return ""0""
        
        return resultado_final"
"class Solution:
    # each state 6 len and 012345 permutation => (mn)! = 720 -> space = vis array of (mn)!
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        
        def getState(board):
            return ''.join(str(x) for row in board  for x in row)
        
        # print(getState(board))
        
        def setState(state):
            si = 0
            zx, zy = 0, 0
            for row in range(2):
                for i in range(3):
                    board[row][i] = int(state[si])
                    if board[row][i] == 0:
                        zx,zy = row, i
                    si += 1
                    
            # returns the position of zero ,)
            return zx, zy
        
        parent = dict() 
        def findPath(state):
            res = []
            while state in parent
                res.append(state)
                state = parent[state]
            return res
        
        # now template BFS...
        q = deque([getState(board)])
        dist = 0
        vis = set()
        while q: # level order traversal, expand one level at a time 
            # print(q)
            level_len = len(q)
            for _ in range(level_len):
                if q[0] == '123450':
                    return findPath(q[0])
                
                parent_state = q[0]
                
                zx, zy = setState(q.popleft())
                # now check all four neighbours.. after swap what happens :)
                for x, y in [[zx,zy+1], [zx+1,zy],[zx,zy-1],[zx-1,zy]]:
                    if 0<=x<2 and 0<=y<3:
                        board[zx][zy], board[x][y] = board[x][y], board[zx][zy]
                        
                        kid_state = getState(board)
                        
                        parent[kid_state] = parent_state
                        
                        if state not in vis:
                            vis.add(state)
                            q.append(state)
                        board[zx][zy], board[x][y] = board[x][y], board[zx][zy]
            dist += 1
        
        return -1";"def resolver_puzzle(tablero):
    tablero_objetivo = ((1, 2, 3), (4, 5, 0))
    
    fila1_inicial = tuple(tablero[0])
    fila2_inicial = tuple(tablero[1])
    estado_inicial = (fila1_inicial, fila2_inicial)
    
    if estado_inicial == tablero_objetivo:
        return 0

    cola = []
    cola.append((estado_inicial, 0))
    
    visitados = set()
    visitados.add(estado_inicial)
    
    while len(cola) > 0:
        estado_actual, movimientos = cola.pop(0)

        if estado_actual == tablero_objetivo:
            return movimientos
            
        fila_cero = -1
        columna_cero = -1
        
        for i in range(2):
            for j in range(3):
                if estado_actual[i][j] == 0:
                    fila_cero = i
                    columna_cero = j
                    break
            if fila_cero != -1:
                break
        
        direcciones = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        
        for df, dc in direcciones:
            nueva_fila = fila_cero + df
            nueva_columna = columna_cero + dc
            
            if 0 <= nueva_fila < 2 and 0 <= nueva_columna < 3:
                tablero_lista = []
                for fila_tupla in estado_actual:
                    fila_lista = list(fila_tupla)
                    tablero_lista.append(fila_lista)

                valor_temporal = tablero_lista[fila_cero][columna_cero]
                tablero_lista[fila_cero][columna_cero] = tablero_lista[nueva_fila][nueva_columna]
                tablero_lista[nueva_fila][nueva_columna] = valor_temporal
                
                nueva_fila1 = tuple(tablero_lista[0])
                nueva_fila2 = tuple(tablero_lista[1])
                nuevo_estado = (nueva_fila1, nueva_fila2)
                
                if nuevo_estado not in visitados:
                    visitados.add(nuevo_estado)
                    cola.append((nuevo_estado, movimientos + 1))

    return -1"
"class Solution:
    def heightChecker(self, heights: List[int]) -> int:
        # O(N)
        sortedList = []
        count = 0
        
        # initialize 1 to 100 count dictionary
        oneToHundredDict = dict((k, 0) for k in range(1,101))
        
        # count the repeatations and updating the dictionary
        for i in range(0, len(heights)):
            oneToHundredDict[heights[i]] = oneToHundredDict[heights[i]] + 1
            
        # sorting the list
        for key,value in oneToHundredDict.items():
            if value > 0:
                # Reapting key by value times thereby sorting the list
                sortedList.extend(repeat(key, value))
        
        # compare
        for i in range(0,len(heights)):
            if sortedList[i] != heights[i]:
                count = count + 1
        
        return count";"class Solucion:
    def heightChecker(self, alturas):
        alturas_esperadas = []
        for altura in alturas:
            alturas_esperadas.append(altura)
        
        n = len(alturas_esperadas)
        i = 0
        while i < n:
            j = 0
            while j < n - i - 1:
                if alturas_esperadas[j] > alturas_esperadas[j + 1]:
                    temp = alturas_esperadas[j]
                    alturas_esperadas[j] = alturas_esperadas[j + 1]
                    alturas_esperadas[j + 1] = temp
                j = j + 1
            i = i + 1
            
        contador = 0
        indice = 0
        while indice < len(alturas):
            if alturas[indice] != alturas_esperadas[indice]:
                contador = contador + 1
            indice = indice + 1
            
        return contador"
"class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        nums = [1] + nums + [1]
        size = len(nums)        
        
        t = [[-1 for p in range(0,size+1)]
            for q in range(0,size+1)]
        
        return self.solve(nums,1,size-1,t)
        
    def solve(self,arr,i,j,t):
        if i >= j:
            return 0
        
        if t[i][j] > 0:
            return t[i][j]
        
        ans = float('-inf')
        
        for k in range(i,j):
            if t[i][k] != -1:
                left = t[i][k]
            else:
                left = self.solve(arr,i,k,t)
                t[i][k] = left
                
            if t[k+1][j] != -1:
                right = t[k+1][j]
            else:
                right = self.solve(arr,k+1,j,t)
                t[k+1][j] = right
                
            temp = left + right + (arr[i-1]*arr[k]*arr[j])
            
            ans = max(ans,temp)
            
        t[i][j] = ans
        return t[i][j]";"class Solucion:
    def maximas_monedas(self, numeros):
        cantidad_original = len(numeros)
        
        nuevos_numeros = [1]
        for numero in numeros:
            nuevos_numeros.append(numero)
        nuevos_numeros.append(1)
        
        cantidad_nueva = cantidad_original + 2
        
        tabla_dp = []
        for i in range(cantidad_nueva):
            fila = []
            for j in range(cantidad_nueva):
                fila.append(0)
            tabla_dp.append(fila)
            
        for longitud in range(2, cantidad_nueva):
            for izquierda in range(0, cantidad_nueva - longitud):
                derecha = izquierda + longitud
                
                max_monedas_para_intervalo = 0
                for k in range(izquierda + 1, derecha):
                    monedas_actuales = tabla_dp[izquierda][k] + tabla_dp[k][derecha] + nuevos_numeros[izquierda] * nuevos_numeros[k] * nuevos_numeros[derecha]
                    
                    if monedas_actuales > max_monedas_para_intervalo:
                        max_monedas_para_intervalo = monedas_actuales
                
                tabla_dp[izquierda][derecha] = max_monedas_para_intervalo
                        
        return tabla_dp[0][cantidad_nueva - 1]"
"class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        
        # Setup counts for bulls and cows
        bulls = cows = 0
        
        # Copy secret and guess into lists that are easier to work with
        secretCopy = list(secret)
        guessCopy = list(guess)
        
        # In a for loop, check every pair of letters at the same index in both guess and secret for matching letters, AKA bulls
        for i in range(len(secret)):
            
            # If they match, bulls += 1 and pop() the letters from the copy lists via their .index()
            if secret[i] == guess[i]:
                bulls += 1
                secretCopy.pop(secretCopy.index(secret[i]))
                guessCopy.pop(guessCopy.index(guess[i]))
                
                
        # Count() the letters remaining in secret and guess lists
        secretCounter = Counter(secretCopy)
        guessCounter = Counter(guessCopy)
        
        # Counter1 - Counter2 gives us Counter1 with any matching values of Counter1 and Counter2 removed, leftover Counter2 values are trashed
        # secretCounter - guessCounter gives us the secretCounter except for any correctly guessed letters
        # Therefore, subtract this difference from the OG secretCounter to be left with a counter of only correctly guessed letters
        dif = secretCounter - (secretCounter - guessCounter)
        
        # The .total() of the dif Counter is the number of cows
        cows = dif.total()

        # return the formatted string with req. info
        return f'{bulls}A{cows}B'";"class Solucion:
    def obtener_pista(self, secreto, suposicion):
        toros = 0
        vacas = 0

        frecuencia_secreto = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        frecuencia_suposicion = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

        longitud = len(secreto)
        for i in range(longitud):
            caracter_secreto = secreto[i]
            caracter_suposicion = suposicion[i]

            if caracter_secreto == caracter_suposicion:
                toros = toros + 1
            else:
                numero_secreto = int(caracter_secreto)
                numero_suposicion = int(caracter_suposicion)
                frecuencia_secreto[numero_secreto] = frecuencia_secreto[numero_secreto] + 1
                frecuencia_suposicion[numero_suposicion] = frecuencia_suposicion[numero_suposicion] + 1

        for i in range(10):
            coincidencias = 0
            if frecuencia_secreto[i] < frecuencia_suposicion[i]:
                coincidencias = frecuencia_secreto[i]
            else:
                coincidencias = frecuencia_suposicion[i]
            vacas = vacas + coincidencias
        
        resultado_final = str(toros) + ""A"" + str(vacas) + ""B""
        
        return resultado_final"
"class Solution:
    def imageSmoother(self, img: List[List[int]]) -> List[List[int]]:
        
        #Pull the dimensions
        m_rows = len( img ),
        n_cols = len( img[ 0 ] ),
        
        #Kernel size is 3,
        k = 3,
        
        #Create a new image for each averaged total to be stored
        newImage = [ [ 0 for _ in range( n_cols ) ] for _ in range( m_rows ) ],
        
        #Start is the grid cordinate [ column , row ],
        start = [ 0, 0 ],
        
        #direction right tells us if we are true
        directionRight = [ True ],
        
        #Total keeps track of our total
        total = [ 0 ],
        
        #Initialize the kernel at [ 0 , 0 ],
        #Valid kernel will tell us how many valid squares
        #We are averaging
        total[ 0 ] , validKernel = self.initializeKernel( img, m_rows, n_cols, start ),
        
        #Previous direction will help us snake down the matrix
        #By snake down, we go right to left, then down, then left to right
        #As we find the total
        
        #This allows us to reuse our counts, and prevents overlapping calculations
        
        #When previous direction is True
        #It means we are going from right to left
        #When it is False, we are going from left to right
        prevDirection = True,

        #While our row value is at a valid index, process:
        while start[ 1 ] < m_rows:

            #Pull the x and y coordinate
            x = start[ 0 ],
            y = start[ 1 ],
            
            #Assign the average value
            newImage[ y ][ x ] = total[ 0 ] // validKernel,
            
            #Find the next coordinate by calling self.snake() to snake through the matri
            #Instead of scanning and going back to the beginning at the end,
            #Like when we read,
            #We continue our calculations in the other direction
            
            #next cord will go from
            #BEGIN [ 0, 0] , [ 1 , 0 ] , [ 2 ,  0] , END , [ 2, 1 ], [ 1 , 1 ], [ 0, 1 ] 
            # BEGIN [ 0, 2 ] [ 1, 2 ] [ 2, 2 ] END [ 2, 3 ]  ...
            nextCoord = self.snake(img, m_rows , n_cols, start, directionRight ),
            
            #nextCoord modifies the directionRight flag if it changes
            #to false, and thus begins going left
            
            #When we change directions, we want to go down a row
            if prevDirection != directionRight[ 0 ]:
                #We adjust the slice of the kernel by KEEPING
                #the overlapped elements
                
                #Adjust prev will remove from the total a slice of the kernel
                #That does not overlap
                
                #Since we are always going down, the below call to change slice
                #Will always remove the non overlapping top part of the kernel
                adjustPrev = self.changeSlice( img, m_rows, n_cols, [ x, y ] ,total, False, 0 ),
                validKernel -= adjustPrev,
                #We remove the count so our average will only consider the overlapped
                
                #Next we add the new slice that comes with our new coordinate
                #This will always be the bottom part of the kernel
                adjustCurr = self.changeSlice( img, m_rows, n_cols, [ x, y + 1 ] ,total, True, 1 ),
                validKernel += adjustCurr ,
                #and same thing, we add to the count the pieces of our new slice
                

            #If we are going in the same direction, 
            else: 
                #These values keep track of changeSlice
                #Minus condition and plus condition
                #Tell us which part of the kernel we are changing
                
                #If we are going right:
                #We remove the left slice of the old kernel
                #And add the right slice of the new kernel
                if directionRight[ 0 ]:
                    minusCondition = 3,
                    plusCondition = 2,
                    
                #If we are going left:
                #It is the opposide
                #We remove the right slice of the old kernel
                #And add the left slice of the new kernel
                else:
                    minusCondition = 2,
                    plusCondition = 3,
                    
                #Like with the above, We adjust the slices and update the validKernel count
                adjustPrev = self.changeSlice( img, m_rows, n_cols, [ x, y ], total, False, minusCondition ),
                validKernel -= adjustPrev,
                adjustCurr = self.changeSlice( img, m_rows, n_cols, nextCoord, total, True, plusCondition ),
                validKernel += adjustCurr,
                
                
            
           
            
            #At the end, we update the start value with our nextCoord
            #And we overWrite our prevDirection flag with our current direction
            start = nextCoord,
            prevDirection = directionRight[ 0 ],
        return newImage,
        
        
    #Is validCoord takes in the dimensions of the matrix
    #And returns if a current coordinate pair is not a valid index
    def isValidCoord( self, m, n, current ):
        x = current[ 0 ],
        y = current[ 1 ],
        
        if x < 0 or y < 0:
            return False,
        if x >= n or y >= m:
            return False,
        return True,
        
    #Intialize kernel will create the first instance of our kernel
    #at the top left of our matrix
    def initializeKernel( self, grid, m, n, start , k = 3):
        x = start[ 0 ],
        y = start[ 1 ],
        
        starting_total = 0,
        validCoord = 0,
        
        #It is generalized to take any slice of k
        #Since we are starting at the top left
        #We only need half of the kernel to begin with
        #Which is k // 2
        #The plus one comes from including the middle section of the kernel
        for i in range( ( k // 2) + 1 ):
            for j in range( (k // 2 ) + 1 ):
                #For each potential kernel location, 
                #We see if it is a valid coordinate
                #This is needed for when the kernel is larger than the matrix
                if self.isValidCoord( m , n , [ x + j, y + i ] ):
                    starting_total += grid[ y + i ][ x + j ],
                    validCoord += 1,

        #We return our starting total 
        #And our count, validCoord, which is used to divide the total to find
        #the average
        return starting_total, validCoord,

    
    #Change slice will tally slices of the kernel
    #The top or bottom row,
    #The left or right hand side of the column
    #Change slice will find the valid coordinates of the slice
    #And will either add them or subtract them from the total
    #Depending on the passed in paratmeters
    
    #It is the swiss-army-knife of this solution
    def changeSlice( self, grid, m , n, current, total, addition = True, condition = 0 ,k = 3 ):
        
        
        #Condition 0 tallies the top row
        #Condition 1 tallies the bottom row
        #Condition 2 tallies the right column
        #Condition 3 tallies the left column
        
        #If addition is True, we add to the total
        #If addition is False, we subtract from the total
        
        #We take the current center of the kernel
        x = current[ 0 ],
        y = current[ 1 ],
        
        #Adjust slice allows us to generalize to other sizes of k
        adjustSlice = ( k // 2 ),
        
        #We see how many valid coordinates are being modified
        #That is, how many are going into the addition or subtraction of the total
        validCoord = 0,
        
        #Going down or right from the top left of the kernel
        if condition == 0 or condition == 3:
            start = [ x - adjustSlice , y - adjustSlice ],
        #Going right from bottom left of the kernel
        elif condition == 1:
            start = [ x - adjustSlice , y + adjustSlice ],
        #Going down from top right of the kernel
        elif condition == 2:
            start = [ x + adjustSlice , y - adjustSlice ],
        else:
            raise ValueError,
        
        #For the size of the slice
        for i in range( k ):
            #Horizontal slice of k: condition 0 is top, 1 is bottom
            if condition == 0 or condition == 1:
                a = start[ 0 ] + i,
                b = start[ 1 ] ,
            #Vertical slice of k: 2 is righthand side, 3 is lefthand side
            else:
                a = start[ 0 ] ,
                b = start[ 1 ] + i,
                
            #Check to see if the generated coordinate is on the matrix
            if self.isValidCoord( m , n , [ a ,b ] ):
                #If it is, add to our subtotal count
                validCoord += 1,
            
                #If the addition flag is true:
                #Add the value to the total
                if addition:
                    total[ 0 ] += grid[ b ][ a ],  
                #If it is subtraction, remove the value from the total
                else:
                    total[ 0 ] -= grid[ b ][ a ],
                    
        #Return the number of coordinates that changed the total
        return validCoord,
                
        #Snake will, given the current coordinate, generate the next one
        #If directionRight is True, we are going right
        #If directionRight is False, we are going left
    def snake( self, grid, m, n, current , directionRight):
        
        #Pull the coordinates
        x = current[ 0 ],
        y = current[ 1 ],
        
        #Adjust the x value in accordance with the direction 
        if directionRight[ 0 ]:
            x = x + 1,
        else:
            x = x - 1,
        
        #If we are outside of a valid coordinate,
        if x == -1 or x == n:
            #Change direction
            directionRight[ 0 ] = not directionRight[ 0 ],
            
            #Return the original x, and increment y
            return [ current[ 0 ] , y + 1 ]
            
        #Otherwise, return the modified x, and the original y
        return [ x , y ],";"class Solucion:
    def suavizador_de_imagen(self, imagen):
        filas = len(imagen)
        columnas = len(imagen[0])

        resultado = []
        for i in range(filas):
            fila_resultado = []
            for j in range(columnas):
                fila_resultado.append(0)
            resultado.append(fila_resultado)

        for i in range(filas):
            for j in range(columnas):
                suma_total = 0
                contador = 0

                for fila_vecina in range(i - 1, i + 2):
                    for columna_vecina in range(j - 1, j + 2):
                        
                        es_fila_valida = fila_vecina >= 0 and fila_vecina < filas
                        es_columna_valida = columna_vecina >= 0 and columna_vecina < columnas

                        if es_fila_valida and es_columna_valida:
                            suma_total = suma_total + imagen[fila_vecina][columna_vecina]
                            contador = contador + 1
                
                valor_suavizado = suma_total // contador
                resultado[i][j] = valor_suavizado
        
        return resultado"
"class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        #create a adjacent lists that have connections 
        dic = collections.defaultdict(set)
        email_to_name={}
        visited = set()
        ans = []
        for account in accounts:
            name = account[0]
            for email in account[1:]:
                dic[email].add(account[1])
                dic[account[1]].add(email)
                email_to_name[email] = name
        def dfs(intial_email,dic,visited):
            if intial_email in visited:
                return 
            stack = [intial_email]
            visited.add(intial_email)
            lst = []
            lst.append(intial_email)
            while stack:
                sub_email = stack.pop()
                if dic[sub_email]:
                    for other_email in dic[sub_email]:
                        if other_email not in visited:
                            lst.append(other_email)
                            stack.append(other_email)
                            visited.add(other_email)
                        else:
                            continue
            result = sorted(lst)
            return result
        for email in dic:
            result = dfs(email,dic,visited)
            if result:
                ans.append([email_to_name[email]]+result)
        return ans 

            

                    



        


        # dic_emails = {}
        # for account in accounts:
        #     for i in range(1,len(account)):
        #         if account[i] not in dic_emails:
        #             dic_emails[account[i]] =1
        #         else:
        #             dic_emails[account[i]] +=1
        # dic_email2 = {}
        # dic_email3 = []
        # for key,value in dic_emails.items():
        #     if value > 1:
        #         for account in accounts:
        #             if key in account and key not in dic_email2:
        #                 dic_email2[key] = []
        #                 dic_email2[key].append(account)
        #             elif key in account and key in dic_email2:
        #                 dic_email2[key].append(account)
        #             elif key not in account:
        #                 dic_email3.append(account)
        # total = []
        # for key,value in dic_email2.items():
        #     lst = []
        #     if len(value) > 1:
        #         for infor in value:
        #             for in_f in infor:
        #                 if in_f not in lst:
        #                     lst.append(in_f)
        #     total.append(lst[:1]+sorted(lst[1:]))
        # print(total)
        # print(dic_email3)
        # return sorted((total + dic_email3))";"def fusionar_cuentas(cuentas):
    mapa_de_correos = {}
    padre = {}

    def encontrar_raiz(i):
        if padre[i] == i:
            return i
        padre[i] = encontrar_raiz(padre[i])
        return padre[i]

    def unir_conjuntos(i, j):
        raiz_i = encontrar_raiz(i)
        raiz_j = encontrar_raiz(j)
        if raiz_i != raiz_j:
            padre[raiz_j] = raiz_i

    indice_cuenta = 0
    while indice_cuenta < len(cuentas):
        cuenta = cuentas[indice_cuenta]
        padre[indice_cuenta] = indice_cuenta
        indice_correo = 1
        while indice_correo < len(cuenta):
            correo = cuenta[indice_correo]
            if correo in mapa_de_correos:
                unir_conjuntos(mapa_de_correos[correo], indice_cuenta)
            else:
                mapa_de_correos[correo] = indice_cuenta
            indice_correo = indice_correo + 1
        indice_cuenta = indice_cuenta + 1

    grupos_fusionados = {}
    indice = 0
    while indice < len(cuentas):
        raiz = encontrar_raiz(indice)
        if raiz not in grupos_fusionados:
            grupos_fusionados[raiz] = []
        
        correos_para_anadir = []
        indice_correo = 1
        while indice_correo < len(cuentas[indice]):
            correo = cuentas[indice][indice_correo]
            correos_para_anadir.append(correo)
            indice_correo = indice_correo + 1

        for correo in correos_para_anadir:
            grupos_fusionados[raiz].append(correo)
        
        indice = indice + 1

    resultado_final = []
    for indice_grupo in grupos_fusionados:
        nombre_persona = cuentas[indice_grupo][0]
        
        correos_unicos = list(set(grupos_fusionados[indice_grupo]))
        correos_unicos.sort()

        cuenta_final = [nombre_persona]
        for correo in correos_unicos:
            cuenta_final.append(correo)
            
        resultado_final.append(cuenta_final)

    return resultado_final"
"class Solution:
		def isEvenOddTree(self, root: Optional[TreeNode]) -> bool:
			if root is None:
				return False

			level_order = self.level_order(root)

			# check level 0
			if level_order[0][0] % 2 == 0:
				return False

			# check level 1 ~ end
			for i, level in enumerate(level_order[1:], 2):
				if i % 2 == 0:
					# even and decreasing order
					previous_element = level[0]
					if previous_element % 2 != 0:
						return False

					for element in level[1:]:
						if element % 2 != 0 or previous_element < element:
							return False
						previous_element = element

				else:
					# odd and increasing order
					previous_element = level[0]
					if previous_element % 2 == 0:
						return False

					for element in level[1:]:
						if element % 2 == 0 or element < previous_element:
							return False
						previous_element = level

			return True

		def level_order(self, root: Optional[TreeNode]) -> List[List[int]]:
				queue = [root]
				level_order = []
				while queue:
					size = len(queue)
					level = []
					for _ in range(size):
						node = queue.pop(0)

						if node.left:
							queue.append(node.left)

						if node.right:
							queue.append(node.right)

						level.append(node.val)

					level_order.append(level)

				return level_order";"class Solucion:
    def esArbolParImpar(self, raiz):
        if not raiz:
            return True

        cola = [raiz]
        nivel = 0

        while len(cola) > 0:
            tamano_nivel = len(cola)
            
            if nivel % 2 == 0:  # Nivel par
                valor_previo = 0
                indice = 0
                while indice < tamano_nivel:
                    nodo_actual = cola.pop(0)
                    
                    # El valor debe ser impar
                    if nodo_actual.val % 2 == 0:
                        return False
                    
                    # Debe ser estrictamente creciente
                    if nodo_actual.val <= valor_previo:
                        return False
                    
                    valor_previo = nodo_actual.val
                    
                    if nodo_actual.left:
                        cola.append(nodo_actual.left)
                    if nodo_actual.right:
                        cola.append(nodo_actual.right)
                    
                    indice = indice + 1
            else:  # Nivel impar
                valor_previo = 1000002
                indice = 0
                while indice < tamano_nivel:
                    nodo_actual = cola.pop(0)
                    
                    # El valor debe ser par
                    if nodo_actual.val % 2 != 0:
                        return False
                        
                    # Debe ser estrictamente decreciente
                    if nodo_actual.val >= valor_previo:
                        return False
                        
                    valor_previo = nodo_actual.val
                    
                    if nodo_actual.left:
                        cola.append(nodo_actual.left)
                    if nodo_actual.right:
                        cola.append(nodo_actual.right)
                    
                    indice = indice + 1

            nivel = nivel + 1

        return True"
"class Solution:
    def sumFourDivisors(self, nums: List[int]) -> int:
        res = 0
        for num in nums:
            divisor = set() 
            for i in range(1, floor(sqrt(num)) + 1):
                if num % i == 0:
                    divisor.add(num//i)
                    divisor.add(i)
                if len(divisor) > 4:    
                    break
                    
            if len(divisor) == 4:
                res += sum(divisor)
        return res";"def suma_cuatro_divisores(numeros):
    suma_total = 0
    for numero_actual in numeros:
        lista_de_divisores = []
        
        i = 1
        while i <= numero_actual:
            if numero_actual % i == 0:
                lista_de_divisores.append(i)
            i = i + 1
            
        if len(lista_de_divisores) == 4:
            suma_de_divisores_actual = 0
            for divisor in lista_de_divisores:
                suma_de_divisores_actual = suma_de_divisores_actual + divisor
            suma_total = suma_total + suma_de_divisores_actual
            
    return suma_total"
"class Solution:
    def findRotateSteps(self, ring: str, key: str) -> int:
        char_pos = defaultdict(set)
        for i, c in enumerate(ring):
            char_pos[c].add(i)
        
        def minStep(fromm, to):
            if fromm == to:
                return 0
            minSteps = abs(fromm - to)
            minSteps = min(minSteps, abs(len(ring) - minSteps))
            return minSteps
        
        n = len(key)
        dp = [0] * len(ring)
        for p in char_pos[key[0]]:
            dp[p] = minStep(0, p)
        prev_char = key[0]
        for c in key[1:]:
            if prev_char == c:
                continue
            for next_pos in char_pos[c]:
                dp[next_pos] = min(dp[prev_pos] + minStep(prev_pos, next_pos) for prev_pos in char_pos[prev_char])
            prev_char = c
        return min(dp[p] for p in char_pos[prev_char]) + len(key)";"class Solucion:
    def encontrar_pasos_rotacion(self, anillo, clave):
        longitud_anillo = len(anillo)
        longitud_clave = len(clave)
        
        posiciones_caracteres = {}
        indice = 0
        while indice < longitud_anillo:
            caracter = anillo[indice]
            if caracter not in posiciones_caracteres:
                posiciones_caracteres[caracter] = []
            posiciones_caracteres[caracter].append(indice)
            indice = indice + 1
            
        dp = {0: 0}
        
        indice_clave = 0
        while indice_clave < longitud_clave:
            caracter_clave = clave[indice_clave]
            dp_siguiente = {}
            
            posiciones_destino = posiciones_caracteres[caracter_clave]
            
            indice_pos_destino = 0
            while indice_pos_destino < len(posiciones_destino):
                posicion_final = posiciones_destino[indice_pos_destino]
                costo_minimo_para_llegar = float('inf')
                
                for posicion_inicial in dp:
                    costo_anterior = dp[posicion_inicial]
                    
                    distancia = abs(posicion_final - posicion_inicial)
                    distancia_rotacion = min(distancia, longitud_anillo - distancia)
                    
                    costo_nuevo = costo_anterior + distancia_rotacion + 1
                    
                    if costo_nuevo < costo_minimo_para_llegar:
                        costo_minimo_para_llegar = costo_nuevo
                
                dp_siguiente[posicion_final] = costo_minimo_para_llegar
                indice_pos_destino = indice_pos_destino + 1

            dp = dp_siguiente
            indice_clave = indice_clave + 1

        resultado = float('inf')
        for posicion_final in dp:
            costo_final = dp[posicion_final]
            if costo_final < resultado:
                resultado = costo_final
                
        return resultado"
"class Solution:
    def isValid(self, code: str) -> bool:
        if code[0] != '<' or code[-1] != '>': return False
        i, n = 0, len(code)
        stk = []
        while i < n:
            if code[i] == '<':
                if i != 0 and code[i: i + 9] == '<![CDATA[':
                    if not stk: return False
                    j = i + 9
                    while j + 3 <= n and code[j: j + 3] != ']]>': j += 1
                    if code[j: j + 3] == ']]>': i = j + 3
                    else: return False
                else:
                    start = i
                    isend = False
                    i += 1
                    if i >= n: return False
                    if code[i] == r'/':
                        isend = True
                        i += 1
                    if i >= n: return False
                    tag = ''
                    while i < n and code[i] != '>':
                        if not code[i].isupper(): return False
                        tag += code[i]
                        i += 1
                    if i >= n or len(tag) == 0 or len(tag) > 9: return False
                    if isend:
                        if not stk or stk[-1] != tag: return False
                        stk.pop(-1)
                    else:
                        if start != 0 and not stk: return False
                        stk.append(tag)
                    i += 1
            else:
                if not stk: return False
                while i < n and code[i] != '<': i += 1
        return not stk";"class Solucion:
    def es_valido(self, codigo):
        pila = []
        i = 0
        longitud_codigo = len(codigo)

        while i < longitud_codigo:
            if codigo[i] == '<':
                if i + 8 < longitud_codigo and codigo[i:i+9] == '<![CDATA[':
                    if len(pila) == 0:
                        return False

                    indice_fin_cdata = -1
                    j = i + 9
                    while j <= longitud_codigo - 3:
                        if codigo[j:j+3] == ']]>':
                            indice_fin_cdata = j
                            break
                        j = j + 1
                    
                    if indice_fin_cdata == -1:
                        return False
                    
                    i = indice_fin_cdata + 3
                elif i + 1 < longitud_codigo and codigo[i+1] == '/':
                    if len(pila) == 0:
                        return False

                    indice_cierre_corchete = -1
                    j = i + 2
                    while j < longitud_codigo:
                        if codigo[j] == '>':
                            indice_cierre_corchete = j
                            break
                        j = j + 1
                    
                    if indice_cierre_corchete == -1:
                        return False
                    
                    nombre_etiqueta = codigo[i+2 : indice_cierre_corchete]
                    etiqueta_abierta = pila.pop()

                    if etiqueta_abierta != nombre_etiqueta:
                        return False

                    i = indice_cierre_corchete + 1
                    
                    if len(pila) == 0 and i < longitud_codigo:
                        return False
                else:
                    indice_cierre_corchete = -1
                    j = i + 1
                    while j < longitud_codigo:
                        if codigo[j] == '>':
                            indice_cierre_corchete = j
                            break
                        j = j + 1
                    
                    if indice_cierre_corchete == -1:
                        return False
                        
                    nombre_etiqueta = codigo[i+1 : indice_cierre_corchete]
                    
                    es_nombre_valido = True
                    longitud_nombre = len(nombre_etiqueta)
                    if longitud_nombre < 1 or longitud_nombre > 9:
                        es_nombre_valido = False
                    else:
                        for caracter in nombre_etiqueta:
                            if not ('A' <= caracter <= 'Z'):
                                es_nombre_valido = False
                                break
                    
                    if not es_nombre_valido:
                        return False
                        
                    pila.append(nombre_etiqueta)
                    i = indice_cierre_corchete + 1
            else:
                if len(pila) == 0:
                    return False
                i = i + 1
        
        if len(pila) == 0:
            return True
        else:
            return False"
"class Solution:
    def toLowerCase(self, s: str) -> str:
        # Instead of using .lower(), let's implement with ASCII
        # ord() returns the ascii value of a passed character
        
        # Uncomment the line below to see the ASCII value of some important characters
        # print(ord('a'), ord('z'), ord('A'), ord('Z'))
        
        # Notice 'a'=97, and 'A'=65
        # This can be used to tell whether a character is upper/lower case, and can help us convert between them
        
        # First, make the string a list so we can change each char individually
        s = list(s)
        
        # Then, loop through the characters, and if their ascii value is <= 90 and >= 65, they must be upper case
        # Use the difference (97 - 65 = 32) to convert it from upper to lower, then use chr() to convert from ascii to char
        #   - ord('A') + 32 = 97 = ord('a')
        for i in range(len(s)):
            if ord(s[i]) <= 90 and ord(s[i]) >= 65:
                s[i] = chr(ord(s[i])+32)
        return ''.join(s)";"cadena_entrada = s
cadena_salida = """"

for caracter in cadena_entrada:
    if 'A' <= caracter and 'Z' >= caracter:
        valor_ascii = ord(caracter)
        valor_nuevo = valor_ascii + 32
        caracter_nuevo = chr(valor_nuevo)
        cadena_salida = cadena_salida + caracter_nuevo
    else:
        cadena_salida = cadena_salida + caracter

s = cadena_salida"
"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        # self.selectionSort(nums)
        # self.bubbleSort(nums)
        # self.insertionSort(nums)
        # self.mergeSort(nums)       
        self.quickSort(nums)
        return nums
    
    ''' 
    Selection Sort (TLE)
    TC: O(n^2) ,  SC: O(1), in-place
    Not Stable
    Minimum swaps
    '''
    def selectionSort(self, nums):
        for i in range(len(nums)):
            min_idx=i
            for j in range(i, len(nums)):
                if nums[j]<nums[min_idx]:
                    min_idx=j
            nums[i], nums[min_idx] = nums[min_idx], nums[i]
            
    '''
    Bubble Sort (TLE)
    TC: best-O(n), worst-O(n^2)
    SC: O(1)
    Stable
    Use when array is almost sorted
    '''
    def bubbleSort(self, nums):
        for i in range(len(nums)):
            swapped = False
            for j in range(len(nums)-i-1):
                if nums[j]>nums[j+1]:
                    nums[j], nums[j+1] = nums[j+1], nums[j]
                    swapped = True
            
            if not swapped:
                break
                
    '''
    Insertion Sort (TLE)
    TC: best-O(n), worst-O(n^2)
    SC: O(1)
    Stable
    '''
    def insertionSort(self, nums):
        for i in range(1, len(nums)):
            key = nums[i]
            j=i-1
            while j>=0 and key<nums[j]:
                nums[j+1]=nums[j]
                j-=1
            nums[j+1]=key
    
    '''
    Merge Sort
    Recursive
    TC: O(nlogn)
    SC: O(n)
    Stable
    '''
    def mergeSort(self, nums):
        def merge(nums,L,R):
            i = j = k = 0
            while i < len(L) and j < len(R): 
                if L[i] < R[j]: 
                    nums[k] = L[i] 
                    i+=1
                else: 
                    nums[k] = R[j] 
                    j+=1
                k+=1
                
            while i < len(L): 
                nums[k] = L[i] 
                i+=1
                k+=1

            while j < len(R): 
                nums[k] = R[j] 
                j+=1
                k+=1
                
        if len(nums)>1:
                mid=len(nums)//2
                L=nums[:mid]
                R=nums[mid:]
                self.mergeSort(L)
                self.mergeSort(R)
                merge(nums,L,R)
        
    '''
    QuickSort
    Recursive
    TC: average-O(nlogn), worst-O(n^2)
    SC: average-O(logn), worst-O(n) recursion stack, in-place
    Not stable
    '''
    def quickSort(self, nums):
        # 3-way randomized
        def partition(l, r):
            pivot_idx = random.choice(range(l,r+1))
            pivot = nums[pivot_idx]
            # print(pivot)
            left, move, right = l,l,r
            while move<=right:
                if nums[move]<pivot:
                    nums[left], nums[move] = nums[move], nums[left]
                    move+=1
                    left+=1
                elif nums[move]>pivot:
                    nums[right], nums[move] = nums[move], nums[right]
                    right-=1
                else:
                    move+=1
            return left-1, move
        
        def quicksort(nums, low, high):
            if low<high:
                l,r = partition(low, high)
                quicksort(nums, low, l)
                quicksort(nums, r, high)
                
        quicksort(nums, 0, len(nums)-1)
        
        #---------------------------------------------------------------
        # def helper(head, tail):
        #     if head >= tail: return 
        #     l, r = head, tail
        #     m = (r - l) // 2 + l
        #     pivot = nums[m]
        #     while r >= l:
        #         while r >= l and nums[l] < pivot: l += 1
        #         while r >= l and nums[r] > pivot: r -= 1
        #         if r >= l:
        #             nums[l], nums[r] = nums[r], nums[l]
        #             l += 1
        #             r -= 1
        #     helper(head, r)
        #     helper(l, tail)

        # helper(0, len(nums)-1)";"def ordenar_lista(numeros):
    longitud = len(numeros)
    
    for i in range(longitud):
        intercambio_hecho = False
        for j in range(0, longitud - i - 1):
            if numeros[j] > numeros[j + 1]:
                temporal = numeros[j]
                numeros[j] = numeros[j + 1]
                numeros[j + 1] = temporal
                intercambio_hecho = True
        
        if intercambio_hecho == False:
            break
            
    return numeros"
"class Solution:
    def calPoints(self, ops: List[str]) -> int:
        stack = [] # taking an empty stack. 
        prod = 2 # taking a variable to double a provided number. 
        prev_sum = 0 # taking a variable to have sum of previous elems of the stack. 
        
        for i in range(len(ops)): # Traversing through the provided list.
            if ops[i] is not ""C"" and ops[i] is not ""D"" and ops[i] is not ""+"": # if we are having other then a number then we`ll just add it to stack. 
                stack.append(int(ops[i])) # pushing elements to the stack and making it as int bcz originally it is provided as char.
            elif ops[i] is ""C"": # if its other then a number we`ll check what it is.
                stack.pop() # removing the previous record, we as coder refer it as a last element in the stack. 
            elif ops[i] is ""D"": # if its other then a number we`ll check what it is.
                prod*=int(stack[-1]) # Again making stack element as a integer for performing product operation. 
                stack.append(prod) # Pushing the product to the stack. 
                prod=2 # reseting variable. 
            elif ops[i] is ""+"": # if its other then a number we`ll check what it is.
                prev_sum = int(stack[-2]) + int(stack[-1]) # Again as we have list elem as char, to perform adding we have to change it to int. 
                stack.append(prev_sum) # Pushing the sum to the stack. 
                prev_sum=0 # reseting variable. 
        return sum(stack) # Returning the sum of all the scores on the record(sum of elements in the stack).";"class Solucion:
    def calcular_puntuacion(self, operaciones):
        puntuaciones = []
        for operacion in operaciones:
            if operacion == '+':
                ultima_puntuacion = puntuaciones[-1]
                penultima_puntuacion = puntuaciones[-2]
                nueva_puntuacion = ultima_puntuacion + penultima_puntuacion
                puntuaciones.append(nueva_puntuacion)
            elif operacion == 'D':
                ultima_puntuacion = puntuaciones[-1]
                nueva_puntuacion = ultima_puntuacion * 2
                puntuaciones.append(nueva_puntuacion)
            elif operacion == 'C':
                puntuaciones.pop()
            else:
                puntuacion_entero = int(operacion)
                puntuaciones.append(puntuacion_entero)

        suma_total = 0
        for puntuacion in puntuaciones:
            suma_total = suma_total + puntuacion
        
        return suma_total"
"class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        # Solution 1 using recursion
        while n % 4 == 0 and n > 0:
            return self.isPowerOfFour(n/4)
        return n == 1
        
        # Solution 2 iteration
        if n == 1:
            return True
        if n % 4:
            return False
        while n > 1:
            if n % 4:
                return False
            n //= 4
        return n == 1
        
        # Solution 3 using bit manipulation
        '''
        Once we write numbers in it's binary representation, from there we can observe:=>
        i. 000001 , power of 2 and 4
        ii. 000010, power of only 2
        iii. 000100 , power of 2 and 4
        iv. 001000, power of only 2
        v. 010000 , power of 2 and 4
        vi. 100000, power of only 2
        We can see if the set bit is at an odd position and is a power of 2, it's also power of 4.
        '''
        return n.bit_length() &amp, 1 and not(n &amp, (n-1))";"def es_potencia_de_cuatro(n):
    if n <= 0:
        return False
    
    numero_actual = 1
    
    while numero_actual < n:
        numero_actual = numero_actual * 4
        
    if numero_actual == n:
        return True
    else:
        return False"
"class Solution:
    def oddEvenJumps(self, A: List[int]) -> int:
        
		# find next index of current index that is the least larger/smaller
        def getNextIndex(sortedIdx):
            stack = []
            result = [None] * len(sortedIdx)
        
            for i in sortedIdx:
                while stack and i > stack[-1]:
                    result[stack.pop()] = i
                stack.append(i)
            return result
        
        sortedIdx = sorted(range(len(A)), key= lambda x: A[x])
        oddIndexes = getNextIndex(sortedIdx)
        sortedIdx.sort(key=lambda x: -A[x])
        evenIndexes = getNextIndex(sortedIdx)
        
		# [odd, even], the 0th jump is even
        dp = [[0,1] for _ in range(len(A))]
        
        for i in range(len(A)):
            if oddIndexes[i] is not None:
                dp[oddIndexes[i]][0] += dp[i][1]
            if evenIndexes[i] is not None:
                dp[evenIndexes[i]][1] += dp[i][0]
				
        return dp[-1][0] + dp[-1][1]";"def calcular_saltos(arr):
    longitud = len(arr)
    
    if longitud <= 1:
        return longitud

    # Paso 1: Para cada índice, encontrar el próximo salto impar y par posible.
    # Un salto impar va a un índice j > i con arr[j] >= arr[i], donde arr[j] es el menor posible.
    # Un salto par va a un índice j > i con arr[j] <= arr[i], donde arr[j] es el mayor posible.

    proximo_salto_impar = [-1] * longitud
    proximo_salto_par = [-1] * longitud

    i = 0
    while i < longitud:
        # Encontrar el próximo salto impar desde el índice i
        mejor_valor_impar = -1
        mejor_indice_impar = -1
        
        j = i + 1
        while j < longitud:
            if arr[j] >= arr[i]:
                if mejor_indice_impar == -1:
                    mejor_valor_impar = arr[j]
                    mejor_indice_impar = j
                else:
                    if arr[j] < mejor_valor_impar:
                        mejor_valor_impar = arr[j]
                        mejor_indice_impar = j
            j = j + 1
        
        proximo_salto_impar[i] = mejor_indice_impar

        # Encontrar el próximo salto par desde el índice i
        mejor_valor_par = -1
        mejor_indice_par = -1
        
        j = i + 1
        while j < longitud:
            if arr[j] <= arr[i]:
                if mejor_indice_par == -1:
                    mejor_valor_par = arr[j]
                    mejor_indice_par = j
                else:
                    if arr[j] > mejor_valor_par:
                        mejor_valor_par = arr[j]
                        mejor_indice_par = j
            j = j + 1

        proximo_salto_par[i] = mejor_indice_par
        
        i = i + 1

    # Paso 2: Usar programación dinámica para determinar si se puede llegar al final.
    # Empezamos desde el final y vamos hacia atrás.
    
    impar_llega_al_final = [False] * longitud
    par_llega_al_final = [False] * longitud

    # El último índice siempre es un punto de partida bueno.
    impar_llega_al_final[longitud - 1] = True
    par_llega_al_final[longitud - 1] = True

    i = longitud - 2
    while i >= 0:
        destino_impar = proximo_salto_impar[i]
        if destino_impar != -1:
            # Si hago un salto impar, el siguiente será par.
            # Así que, si desde el destino se puede llegar con un salto par, este camino es bueno.
            impar_llega_al_final[i] = par_llega_al_final[destino_impar]

        destino_par = proximo_salto_par[i]
        if destino_par != -1:
            # Si hago un salto par, el siguiente será impar.
            par_llega_al_final[i] = impar_llega_al_final[destino_par]
        
        i = i - 1

    # Paso 3: Contar los puntos de partida buenos.
    # Un punto de partida es bueno si el primer salto (que siempre es impar)
    # nos permite llegar al final.
    
    conteo_de_indices_buenos = 0
    for es_bueno in impar_llega_al_final:
        if es_bueno:
            conteo_de_indices_buenos = conteo_de_indices_buenos + 1
            
    return conteo_de_indices_buenos"
"class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        
        visited = set()
        
        size = len(nums)
        
        max_subset_size = 0
        
        # check each index in input array
        for i in range(size):
            
            if nums[i] in visited:
                
                # current number has been visited
                continue
            
            # reset picking subset size to zero
            cur_subset_size = 0
            
            # keep picking if current nums[i] has not been visited 
            while nums[i] not in visited:
                
                # update current nums[i] as visited
                visited.add( nums[i] )
                
                # update subset size
                cur_subset_size += 1
                
                # i goes to next nesting index
                i = nums[i]
            
            # finished current element picking
            max_subset_size = max(max_subset_size, cur_subset_size)
            
        return max_subset_size";"class Solucion:
    def array_anidado(self, numeros):
        longitud_maxima = 0
        longitud_total = len(numeros)
        visitado = []
        for i in range(longitud_total):
            visitado.append(False)

        for i in range(longitud_total):
            if visitado[i] == False:
                indice_actual = i
                longitud_actual = 0
                while visitado[indice_actual] == False:
                    visitado[indice_actual] = True
                    indice_actual = numeros[indice_actual]
                    longitud_actual = longitud_actual + 1
                
                if longitud_actual > longitud_maxima:
                    longitud_maxima = longitud_actual
                    
        return longitud_maxima"
"class Solution:
    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        self.cyclic(grid, k, len(grid), len(grid[0]))
        self.redact(grid, len(grid), len(grid[0]))
        return grid
    
    def cyclic(self, grid: List[List[int]], k: int, rows: int, cols: int):
        for r in range(rows):
            for c in range(cols):
                cell = grid[r][c]
                if cell > 1000:
                    continue
                destx, desty = self.calculate(k, r, c, rows, cols)
                while not (r == destx and c == desty):
                    self.swap(grid, r, c, destx, desty)
                    destx, desty = self.calculate(k, destx, desty, rows, cols)
                self.mark(grid, r, c)
                
    def calculate(self, k: int, currx: int, curry: int, rows: int, cols: int) -> Tuple[int, int]:
        desty = (curry + k) % cols
        destx = (currx + ((curry + k) // cols)) % rows
        return destx, desty
    
    def swap(self, m: List[List[int]], fromx: int, fromy: int, tox: int, toy: int):
        temp = m[tox][toy]
        m[tox][toy] = m[fromx][fromy] + 2001
        m[fromx][fromy] = temp
        
    def mark(self, m:List[List[int]], x: int, y: int):
        m[x][y] += 2001
        
    def redact(self, m: List[List[int]], rows: int, cols: int):
        for r in range(rows):
            for c in range(cols):
                m[r][c] -= 2001";"def desplazar_rejilla(rejilla, k):
    numero_filas = len(rejilla)
    numero_columnas = len(rejilla[0])
    
    total_elementos = numero_filas * numero_columnas
    
    desplazamiento_real = k % total_elementos
    
    lista_plana = []
    for i in range(numero_filas):
        for j in range(numero_columnas):
            lista_plana.append(rejilla[i][j])

    lista_plana_desplazada = []
    indice_de_corte = total_elementos - desplazamiento_real
    
    for i in range(indice_de_corte, total_elementos):
        lista_plana_desplazada.append(lista_plana[i])
        
    for i in range(0, indice_de_corte):
        lista_plana_desplazada.append(lista_plana[i])

    rejilla_resultado = []
    indice_actual = 0
    for i in range(numero_filas):
        fila_nueva = []
        for j in range(numero_columnas):
            fila_nueva.append(lista_plana_desplazada[indice_actual])
            indice_actual = indice_actual + 1
        rejilla_resultado.append(fila_nueva)
        
    return rejilla_resultado"
"class Solution:
    def soupServings(self, n: int) -> float:
        if n > 4275: return 1                                        # handle special case
        n = n // 25 + (n%25 > 0)                                     # count size of tabulation
        dp = [[0] * (n+1) for _ in range(n+1)]
        dp[n][n] = 1
        for i in range(n, 0, -1):                                    # starting from (n, n) for each soup
            for j in range(n, 0, -1):
                for a, b in [[4, 0], [3, 1], [2, 2], [1, 3]]:
                    dp[max(0, i-a)][max(0, j-b)] += dp[i][j] * 0.25  # traverse backwards from (n,n) to (0,0)
        ans = dp[0][0] / 2                                           # half the probability when `a` &amp, `b` both use up at the same time
        for j in range(1, n+1):                                      # plus when `a` use up first
            ans += dp[0][j]
        return ans";"def probabilidad_sopa(n):
    if n >= 4800:
        return 1.0

    unidades = (n + 24) // 25

    tabla_dp = []
    i = 0
    while i <= unidades:
        fila = []
        j = 0
        while j <= unidades:
            fila.append(0.0)
            j = j + 1
        tabla_dp.append(fila)
        i = i + 1

    tabla_dp[0][0] = 0.5
    
    i = 1
    while i <= unidades:
        tabla_dp[0][i] = 1.0
        tabla_dp[i][0] = 0.0
        i = i + 1

    i = 1
    while i <= unidades:
        j = 1
        while j <= unidades:
            
            idx_a1 = i - 4
            if idx_a1 < 0:
                idx_a1 = 0
            
            idx_a2 = i - 3
            if idx_a2 < 0:
                idx_a2 = 0
            
            idx_b2 = j - 1
            if idx_b2 < 0:
                idx_b2 = 0
            
            idx_a3 = i - 2
            if idx_a3 < 0:
                idx_a3 = 0

            idx_b3 = j - 2
            if idx_b3 < 0:
                idx_b3 = 0

            idx_a4 = i - 1
            if idx_a4 < 0:
                idx_a4 = 0

            idx_b4 = j - 3
            if idx_b4 < 0:
                idx_b4 = 0

            termino1 = tabla_dp[idx_a1][j]
            termino2 = tabla_dp[idx_a2][idx_b2]
            termino3 = tabla_dp[idx_a3][idx_b3]
            termino4 = tabla_dp[idx_a4][idx_b4]
            
            tabla_dp[i][j] = 0.25 * (termino1 + termino2 + termino3 + termino4)
            
            j = j + 1
        i = i + 1

    return tabla_dp[unidades][unidades]"
"class Solution:
    def findRelativeRanks(self, score: List[int]) -> List[str]:
        
        sorted_score = sorted(score, reverse=True)
        
        hashmap = {}
        
        if len(score) > 2:
            hashmap[sorted_score[0]] = ""Gold Medal""
            hashmap[sorted_score[1]] = ""Silver Medal""
            hashmap[sorted_score[2]] = ""Bronze Medal""
        
        elif len(score) == 1:
            return [""Gold Medal""]
        
        else:
            if score[0] > score[1]:
                return [""Gold Medal"", ""Silver Medal""]
            else:
                return [""Silver Medal"", ""Gold Medal""]
            
        rank = 4
        for index in range(3, len(sorted_score)):
            hashmap[sorted_score[index]] = str(rank)
            rank += 1
            
        
        return [hashmap[x] for x in score]";"class Solucion:
    def encontrar_rangos_relativos(self, puntuacion):
        puntuacion_con_indice = []
        indice = 0
        for puntaje in puntuacion:
            par_puntuacion_indice = (puntaje, indice)
            puntuacion_con_indice.append(par_puntuacion_indice)
            indice = indice + 1

        puntuacion_con_indice.sort(reverse=True)
        
        tamanio = len(puntuacion)
        respuesta = []
        i = 0
        while i < tamanio:
            respuesta.append("""")
            i = i + 1
            
        posicion = 0
        for elemento in puntuacion_con_indice:
            indice_original = elemento[1]
            
            rango = """"
            if posicion == 0:
                rango = ""Gold Medal""
            elif posicion == 1:
                rango = ""Silver Medal""
            elif posicion == 2:
                rango = ""Bronze Medal""
            else:
                numero_de_lugar = posicion + 1
                rango = str(numero_de_lugar)
            
            respuesta[indice_original] = rango
            
            posicion = posicion + 1
            
        return respuesta"
"class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:        
        # Define some CORNER Cases #
		if len(nums) == 0:
            # Nothing to do if no integers are given
			return nums
        elif len(nums) == 1:
            # Nothing to do if single integer is given
			return list(map(str, nums))
        else:
            # MAIN program begins only if 2(+) integers are provided.
			# 1st convert all integers to strings
			str_num_list = list(map(str, nums))
			# Initiate 2 lists - Slave list constitutes the 1st element of the above list, while Master is initiated as blank list.  
            slave_list = [str_num_list[0]] , master_list = [] 
			# Invoke a Lambda function to be used later.  
			# The function appends the slave element to the master list if slave list only has a single element. 
			# Otherwise, it clips the 1st and last element of the slave list, adds a ""->"" character in between them, and then appends this new element in the master list. 
            add_2_master_list = lambda mlist, slist : mlist.append(slist[0] + str(""->"") + slist[-1]) if len(slist) > 1 else mlist.append(slist[0])
            # Run a loop from 2nd element to last 
			for i in str_num_list[1:]:
				# Check if reducing 1 from i doesn't gives us last element of slave list 
				if int(i)-1 != int(slave_list[-1]):
                    # If yes, invoke that lambda function &amp, start appending elements to the master list based on elements present in slave list
					add_2_master_list(master_list, slave_list)
                    # Clear the slave_list to prepare for the next element
					slave_list.clear()
                # After every iteration, keep on appending the items in slave. Note : Slave must never be kept empty.
				slave_list.append(i)
            # Once all iterations are done, whatever items are there in the slave list have to be now added to the master list.
			# Hence again invoke the lambda function. 
			add_2_master_list(master_list, slave_list)
            # Return the master list
			return master_list";"class Solucion:
    def resumen_de_rangos(self, numeros):
        if not numeros:
            return []

        lista_rangos = []
        indice = 0
        longitud_numeros = len(numeros)

        while indice < longitud_numeros:
            inicio_rango = numeros[indice]

            while indice + 1 < longitud_numeros and numeros[indice + 1] == numeros[indice] + 1:
                indice = indice + 1
            
            fin_rango = numeros[indice]

            if inicio_rango == fin_rango:
                rango_como_texto = str(inicio_rango)
                lista_rangos.append(rango_como_texto)
            else:
                rango_como_texto = str(inicio_rango) + ""->"" + str(fin_rango)
                lista_rangos.append(rango_como_texto)
            
            indice = indice + 1
        
        return lista_rangos"
"class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        """"""
        Using a 2-pointer approach, compare two strings and determines if the first string is a subset of the second string.

        :param s:
            str: String of alpha characters
        :param t:
            str: String of alpha characters
        :return
            bool: True if first string is a contiguous subset of the second string
        """"""
        # Set variables equal to the length of each input string
        left_bound, right_bound = len(s), len(t)

        # Initialize index for each pointer
        p_left = p_right = 0

        while p_left < left_bound and p_right < right_bound:
            # Move both pointers if the equal each other
            if s[p_left] == t[p_right]:
                p_left += 1
            p_right += 1
        # Return when left pointer equals length of source string
        return p_left == left_bound";"def es_subsequencia(s, t):
    puntero_s = 0
    puntero_t = 0

    longitud_s = len(s)
    longitud_t = len(t)

    while puntero_s < longitud_s and puntero_t < longitud_t:
        caracter_s = s[puntero_s]
        caracter_t = t[puntero_t]

        if caracter_s == caracter_t:
            puntero_s = puntero_s + 1

        puntero_t = puntero_t + 1

    if puntero_s == longitud_s:
        resultado = True
    else:
        resultado = False

    return resultado"
"class Solution:
    def brute_force(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N*N)
        Space Complexity: O(1)
        """"""
        for i in range(len(nums)):
            if i not in nums:
                return i
        return len(nums)
    
    def sorting(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(Nlog(N))
        Space Complexity: O(N)
        """"""
        nums.sort()
        
        for i, num in enumerate(nums):
            if i != num:
                return i
        return len(nums)
    
    def binary_search(self, nums: List[int]) -> int:
        """"""
        Time Complexity:
            O(Nlog(N)) if nums not sorted
            O(log(N)) if nums already sorted
        
        Space Complexity:
            O(N) if nums not sorted
            O(1) if nums sorted
        """"""
        nums.sort()
        left, right = 0, len(nums)
        mid = (left+right)//2
        while left < right:
            if nums[mid] == mid:
                left = mid+1
            else:
                right = mid - 1
            
            mid = (left + right)//2
        
        return mid + 1
    
    def hashing(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(N)
        """"""
        nums_set = set(nums)
        N = len(nums)
        for i in range(N):
            if i not in nums_set:
                return i
        
        return len(nums)
        
    def gauss_formula(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(1)
        """"""
        N = len(nums)
        return N*(N + 1)//2 - sum(nums)
    
    def xor(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(1)
        """"""
        result = len(nums)
        for i, v in enumerate(nums):
            result ^= i^v
        
        return result
    
    def cyclic_swapping(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(1)
        """"""
        current = 0
        N = len(nums)
        count = 0
        while current < N:
            count+= 1
            if nums[current] == N:
                current += 1
                continue
            
            if nums[current] == nums[nums[current]]:
                current += 1
            else:
                temp = nums[current]
                nums[current] = nums[nums[current]]
                nums[temp] = temp
        
        for i, v in enumerate(nums):
            if i != v:
                return i
        
        return N
    
    def value_inversion(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(1)
        
        Advantages:
            - Original Input array can be restored
        """"""
        
        for i, _ in enumerate(nums):
            nums[i] += 1
        
        for i, v in enumerate(nums):
            if abs(v) > len(nums):
                continue
        
            nums[abs(v)-1] = -abs(nums[abs(v)-1])
        
        for i, v in enumerate(nums):
            if v > 0:
                return i
        
        return len(nums)
                
    
    def missingNumber(self, nums: List[int]) -> int:
        # return self.brute_force(nums)
        # return self.sorting(nums)
        # return self.hashing(nums)
        # return self.gauss_formula(nums)
        # return self.xor(nums)
        # return self.cyclic_swapping(nums)
        # return self.binary_search(nums)
        return self.value_inversion(nums)";"def encontrar_numero_faltante(numeros):
    longitud_lista = len(numeros)
    suma_esperada = 0
    
    numero_actual = 0
    while numero_actual <= longitud_lista:
        suma_esperada = suma_esperada + numero_actual
        numero_actual = numero_actual + 1
        
    suma_real = 0
    for numero in numeros:
        suma_real = suma_real + numero
        
    numero_faltante = suma_esperada - suma_real
    return numero_faltante"
"class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        
        @cache
        def fn(n, k):
            """"""Return min moves given n floors and k eggs.""""""
            if k == 1: return n
            if n == 0: return 0 
            lo, hi = 1, n + 1
            while lo < hi: 
                mid = lo + hi >> 1
                if fn(mid-1, k-1) < fn(n-mid, k): lo = mid + 1
                else: hi = mid 
            return 1 + max(fn(lo-1, k-1), fn(n-lo, k))
        
        return fn(n, k)";"def super_lanzamiento_huevo(k, n):
    numero_huevos = k
    numero_pisos = n

    # tabla_dp[h][p] almacenara el numero minimo de movimientos
    # para h huevos y p pisos.
    tabla_dp = []
    i = 0
    # Crear una matriz de (numero_huevos + 1) x (numero_pisos + 1)
    while i < numero_huevos + 1:
        fila = []
        j = 0
        while j < numero_pisos + 1:
            fila.append(0)
            j = j + 1
        tabla_dp.append(fila)
        i = i + 1

    # Llenar los casos base
    # Si tenemos 1 piso, necesitamos 1 movimiento.
    # Si tenemos 0 pisos, necesitamos 0 movimientos.
    h = 1
    while h < numero_huevos + 1:
        tabla_dp[h][1] = 1
        tabla_dp[h][0] = 0
        h = h + 1

    # Si tenemos 1 huevo, necesitamos p movimientos para p pisos.
    p = 1
    while p < numero_pisos + 1:
        tabla_dp[1][p] = p
        p = p + 1

    # Llenar el resto de la tabla de programacion dinamica
    h = 2
    while h < numero_huevos + 1:
        p = 2
        while p < numero_pisos + 1:
            # Inicializamos con un valor grande
            tabla_dp[h][p] = 999999
            
            # Probamos lanzando desde cada piso 'piso_prueba' de 1 a p
            piso_prueba = 1
            while piso_prueba < p + 1:
                # Si lanzamos un huevo desde el piso_prueba, pueden pasar dos cosas:
                
                # 1. El huevo se rompe. Ahora tenemos h-1 huevos y necesitamos
                #    revisar los pisos de abajo, que son piso_prueba-1 pisos.
                se_rompe = tabla_dp[h - 1][piso_prueba - 1]
                
                # 2. El huevo no se rompe. Todavia tenemos h huevos y necesitamos
                #    revisar los pisos de arriba. Quedan p - piso_prueba pisos por revisar.
                no_se_rompe = tabla_dp[h][p - piso_prueba]
                
                # En el peor de los casos, tomara el maximo de los dos resultados.
                resultado_peor_caso = 0
                if se_rompe > no_se_rompe:
                    resultado_peor_caso = se_rompe
                else:
                    resultado_peor_caso = no_se_rompe
                
                # El resultado para este piso_prueba es 1 (por el lanzamiento actual)
                # mas el resultado del peor caso.
                resultado_actual = 1 + resultado_peor_caso
                
                # Queremos encontrar el piso_prueba que nos de el minimo de movimientos.
                if resultado_actual < tabla_dp[h][p]:
                    tabla_dp[h][p] = resultado_actual
                
                piso_prueba = piso_prueba + 1
        h = h + 1
        
    return tabla_dp[numero_huevos][numero_pisos]"
"class Solution:
    def removeKdigits(self, nums: str, k: int) -> str:
       
        # Base Case
        if len(nums) == k:
            return ""0""
        
        # Init
        m = len(nums)
        
        # Build a monotonic stack, by removing
        # greater element previous to current
        # index
        stack = []
        for i in range(m):
            if stack:
                curr = int(nums[i])
                while k and stack and int(stack[-1]) > curr:
                    stack.pop()
                    k -= 1
            stack.append(nums[i])
        
        # Pop remaining k elements,
        # as they will be greatest in the
        # monotonic stack so created
        while k and stack:
            stack.pop()
            k -= 1
        
        # Join all the element in the stack
        # and first convert it to int, to
        # remove the leading zeros, and
        # then convert to string before
        # returning
        return str(int("""".join(stack)))
        
        """"""
        def REC(s: int, k: int, n: int):
            if n < 0 or k==0 or s=="""":
                return -1 if s=="""" else int(s)
            else:
                return min(REC(s[:n] + s[n+1:], k-1, n-1), REC(s,k,n-1))
        """"""
        
        """"""
        def REC(s: int, k: int, n: int, t: Dict = dict()):
            if n < 0 or k==0 or s=="""":
                return -1 if s=="""" else int(s)
            else:
                key = s 
                if key not in t:
                    t[key] = min(REC(s[:n] + s[n+1:], k-1, n-1, t), REC(s,k,n-1,t))
            return t[key]
        
        val = REC(nums, k, m-1)
        
        return """" if val == -1 else str(val) 
        """"""";"def remover_digitos(numero, k):
    pila = []

    for digito in numero:
        while len(pila) > 0 and k > 0 and digito < pila[-1]:
            pila.pop()
            k = k - 1
        pila.append(digito)

    while k > 0:
        pila.pop()
        k = k - 1

    resultado_parcial = """"
    for elemento in pila:
        resultado_parcial = resultado_parcial + elemento

    if len(resultado_parcial) == 0:
        return ""0""

    indice = 0
    while indice < len(resultado_parcial) - 1:
        if resultado_parcial[indice] == '0':
            indice = indice + 1
        else:
            break
    
    resultado_final = """"
    posicion = indice
    while posicion < len(resultado_parcial):
        resultado_final = resultado_final + resultado_parcial[posicion]
        posicion = posicion + 1
        
    return resultado_final"
"class Solution(object):
    def removeComments(self, source):
        """"""
        :type source: List[str]
        :rtype: List[str]
        """"""
        
        # initialize some variables to save lines and valid characters
        result = []
        current_line = """"
        
        # initialize some state variables
        in_block = False
        in_line = False
        skip_next = False
        
        for line in source:
            
            # in a new line we will never skip the first character
            skip_next = False
            
            # a new line can never be part of an inline comment
            in_line = False
            
            for index, character in enumerate(line):
                
                # ----------------------------------------------------------------
                # Guard clauses that will always skip the character, if we are in
                # a comment or notified the loop to skip the next
                # -----------------------------------------------------------------
                
                # guard clause whether we want to skip the current character
                if skip_next:
                    
                    # reset the boolean in case we skip
                    skip_next = False
                    continue
                
                # guard clause whether we are in an in line comment
                # this comment can only be ended by a new line so we do not need
                # to check the current character
                if in_line:
                    continue
                    
                # guard clause whether we are in a block comment
                if in_block:
                    
                    # since the block comment can be ended, we need to check whether we find
                    # our ending symbol
                    # line[index:index+2] slicing works also at the end of a line
                    # (even if index+2 is out of scope)
                    if line[index:index+2] == '*/':
                        
                        # in case we found the end of the block comment we switch the bool to false
                        # and we need to skip the next character
                        # Our current character (line[index]) is '*' and the next is '/' which we skip
                        in_block = False
                        skip_next = True
                        continue
                    else:
                        
                        # we are still in block comment and therefore can continue
                        continue
                
                
                # ----------------------------------------------------------------
                # After all guard clauses passed, we are not in a comment and
                # we need to check the current character whether it starts one
                # -----------------------------------------------------------------
                
                # check whether block comment begins
                # slicing of list works even if index+2 is out of scope
                if line[index:index+2] == '/*':
                    
                    # switch the comment boolean and 
                    # tell our loop we need to skip the next character
                    # since it will be a '*'
                    in_block = True
                    skip_next = True
                    continue
                
                # check whether in line comment starts
                # slicing works also at end of line
                if line[index:index+2] == '//':
                    
                    # we switch the boolean and  skip the next character as it will be
                    # '/'
                    in_line = True
                    skip_next = True
                    continue
                
                # ----------------------------------------------------------------
                # Now that all checks have passed we found
                # a character that is part of the code
                # -----------------------------------------------------------------
                
                
                # append our character to the current line
                current_line += character
            
            
            # we will append the current line to our result (finalize a line in the output)
            # a) if we are not in a block comment that hasn't ended
            # b) and the current line has characters in it
            if not in_block and current_line:
                
                # append the line and reset the current line
                result.append(current_line)
                current_line = """"
                
        return result";"class Solucion:
    def removerComentarios(self, fuente):
        codigo_resultado = []
        en_bloque_de_comentario = False
        linea_actual_construida = """"

        for linea_fuente in fuente:
            indice = 0
            
            if not en_bloque_de_comentario:
                linea_actual_construida = """"

            while indice < len(linea_fuente):
                if en_bloque_de_comentario:
                    if indice + 1 < len(linea_fuente) and linea_fuente[indice] == '*' and linea_fuente[indice + 1] == '/':
                        en_bloque_de_comentario = False
                        indice = indice + 2
                    else:
                        indice = indice + 1
                else:
                    if indice + 1 < len(linea_fuente) and linea_fuente[indice] == '/' and linea_fuente[indice + 1] == '/':
                        break
                    elif indice + 1 < len(linea_fuente) and linea_fuente[indice] == '/' and linea_fuente[indice + 1] == '*':
                        en_bloque_de_comentario = True
                        indice = indice + 2
                    else:
                        linea_actual_construida = linea_actual_construida + linea_fuente[indice]
                        indice = indice + 1
            
            if len(linea_actual_construida) > 0 and not en_bloque_de_comentario:
                codigo_resultado.append(linea_actual_construida)
        
        return codigo_resultado"
"class Solution:
    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
        a,b,c = sorted((a,b,c))
        ans = inf
        def hcf(a,b):
            if a %b == 0: return b
            return hcf(b , a % b)
        p,q,r= hcf(a,b),hcf(b,c),hcf(a,c)
        s = hcf(r,b)
        x1 = (a*b) // p
        x2 = (b*c) // q 
        x3 = (a*c) // r
        x4 = (a * b * c * s)// (p * q * r )
        low,high = a , a *n
        while low <= high:
            mid = (low + high)//2
            times = mid//a + mid//b + mid//c - mid//x1 - mid//x2 - mid//x3 + mid//x4
            if times < n : low = mid + 1
            elif times == n:
                ans = min(ans,mid)
                high = mid - 1
            else: high = mid - 1
        return ans";"def enesimo_numero_feo(n, a, b, c):
    temp_a = a
    temp_b = b
    while temp_b:
        temp_a, temp_b = temp_b, temp_a % temp_b
    mcm_ab = (a * b) // temp_a

    temp_a = a
    temp_c = c
    while temp_c:
        temp_a, temp_c = temp_c, temp_a % temp_c
    mcm_ac = (a * c) // temp_a

    temp_b = b
    temp_c = c
    while temp_c:
        temp_b, temp_c = temp_c, temp_b % temp_c
    mcm_bc = (b * c) // temp_b

    temp_mcm = mcm_ab
    temp_c = c
    while temp_c:
        temp_mcm, temp_c = temp_c, temp_mcm % temp_c
    mcm_abc = (mcm_ab * c) // temp_mcm

    izquierda = 1
    derecha = 2 * 10**9
    resultado = 0

    while izquierda <= derecha:
        medio = izquierda + (derecha - izquierda) // 2
        
        contador = 0
        contador = contador + (medio // a)
        contador = contador + (medio // b)
        contador = contador + (medio // c)
        contador = contador - (medio // mcm_ab)
        contador = contador - (medio // mcm_ac)
        contador = contador - (medio // mcm_bc)
        contador = contador + (medio // mcm_abc)

        if contador >= n:
            resultado = medio
            derecha = medio - 1
        else:
            izquierda = medio + 1
            
    return resultado"
"class Solution:
    def countAsterisks(self, s: str) -> int:
        count = 0
        if '|' not in s:
            count += s.count('*')
        while '|' in s:
            split_list = s.split('|', 2)
            count += split_list[0].count('*')
            s = split_list[2]
            if '|' not in split_list[2]:
                count += split_list[2].count('*')
        return count
    
# assert Solution().countAsterisks('""yo|uar|e**|b|e***au|tifu|l""') == 5
# assert Solution().countAsterisks('iamprogrammer') == 0
# assert Solution().countAsterisks('l|*e*et|c**o|*de|') == 2
# assert Solution().countAsterisks(""||*"") == 1
# assert Solution().countAsterisks(""|*|"") == 0
# assert Solution().countAsterisks(""||"") == 0
# assert Solution().countAsterisks(""*||"") == 1
# assert Solution().countAsterisks(""*"") == 1";"class Solucion:
  def contar_asteriscos_fuera_de_pares(self, s):
    contador_barras = 0
    contador_asteriscos = 0
    
    for caracter in s:
      if caracter == '|':
        contador_barras = contador_barras + 1
      
      if contador_barras % 2 == 0:
        if caracter == '*':
          contador_asteriscos = contador_asteriscos + 1
          
    return contador_asteriscos"
"class Solution:
    def duplicateZeros(self, arr: List[int]) -> None:
        """"""
        Do not return anything, modify arr in-place instead.
        """"""
        possible_duplicates = 0
        length = len(arr) - 1
        # going left to right 
        # and counting zeros to be considered for duplication
        # why considering whole length of array and not leaving last element?
        # Ans:=> in this case last element could be zero and if we don't iterate over the whole array we would end up duplicating it in the next iteration as we would miss not considering the last element for no-duplication
        for left in range(length + 1):
            # left goes beyond allowed elements, stop iteration
            if left > length - possible_duplicates:
                break
            
            # count zeros
            if arr[left] == 0:
                # edge case: don't include the last element which can not be duplicated due to no more space available in the array
                if left == length - possible_duplicates:
                    # move this zero to the end of the array
                    arr[length] = arr[left]  # or 0
                    length -= 1  # we don't have to consider placing this element to its correct position because we already did so
                    break  # break out of the loop, we have already visited and seen all the elements that could be part of resulting arr, we don't have to calculate this 0 too.
                possible_duplicates += 1
        
        last_index = length - possible_duplicates
        # going right to left and placing elements at their correct index
        # also, duplicating zeros
        for right in range(last_index, -1, -1):
            if arr[right] == 0:
                arr[right + possible_duplicates] = arr[right]  # or 0
                # decrement zero
                possible_duplicates -= 1
                arr[right + possible_duplicates] = arr[right]  # or 0, duplicating zero
            
            else:
                arr[right + possible_duplicates] = arr[right]";"def duplicar_ceros(arr):
    longitud = len(arr)
    indice = 0
    while indice < longitud:
        if arr[indice] == 0:
            indice_corrimiento = longitud - 1
            while indice_corrimiento > indice:
                arr[indice_corrimiento] = arr[indice_corrimiento - 1]
                indice_corrimiento = indice_corrimiento - 1
            
            indice = indice + 2
        else:
            indice = indice + 1"
"class Solution:
    def maximumGap(self, arr: List[int]) -> int:
        min1 = float('inf')
        max1 = float('-inf')
        n = len(arr)
        if (n < 2):
            return 0
        
        for i in range(0, n):
            min1 = min(min1, arr[i])
            max1 = max(max1, arr[i])
                
        if (max1 == min1):
            return 0
        gap = (max1 - min1) // (n-1)
        # print((max1-min1)/(n-1), min1, max1, n-1, max1-min1, 8/3)
        # print(gap)
        if ((max1 - min1) % (n-1) != 0):
            gap += 1 
        
        # print(gap, min1, max1)
        
        # new_arr = [0]*(n+1)
        # for i in range(0, n+1):
        #     new_arr[i]= [min1 + (i* gap), min1 + (i+1)*gap-1]
        # print(new_arr)
        min_bucket = [float('inf')] * (n)
        max_bucket = [float('-inf')] * (n)
        # print(min_bucket, max_bucket)
        for i in range(0, n):
            bucket_num = (arr[i] - min1) // gap
            # print(bucket_num)
            
            min_bucket[bucket_num] = min(arr[i], min_bucket[bucket_num])
            
            max_bucket[bucket_num] = max(arr[i], max_bucket[bucket_num])
            
            
        # print(min_bucket, max_bucket)
        
#         print(max_bucket[1])
        
#         if (max_bucket[1] == -inf):
#             print('es')
        
        prev = max_bucket[0]
        ans = float('-inf')
        for i in range(1, len(min_bucket)):
        # print(""Ok"", prev)
            if (prev == float('-inf') or min_bucket[i] == float('inf')): 
                # print(""EXE"")
                continue
            ans = max(ans, min_bucket[i] - prev)
            # print(""prev"",min_bucket[i], ans, prev)
            prev = max_bucket[i]

        return ans";"def diferencia_maxima(numeros):
    cantidad = len(numeros)
    if cantidad < 2:
        return 0

    valor_minimo = numeros[0]
    valor_maximo = numeros[0]
    for num in numeros:
        if num < valor_minimo:
            valor_minimo = num
        if num > valor_maximo:
            valor_maximo = num

    if valor_minimo == valor_maximo:
        return 0

    tamanio_cubeta = (valor_maximo - valor_minimo) // (cantidad - 1)
    if tamanio_cubeta == 0:
        tamanio_cubeta = 1
    
    numero_de_cubetas = ((valor_maximo - valor_minimo) // tamanio_cubeta) + 1

    cubetas_minimos = []
    cubetas_maximos = []
    cubetas_usadas = []
    i = 0
    while i < numero_de_cubetas:
        cubetas_minimos.append(0)
        cubetas_maximos.append(0)
        cubetas_usadas.append(False)
        i = i + 1

    for num in numeros:
        indice_cubeta = (num - valor_minimo) // tamanio_cubeta
        
        if cubetas_usadas[indice_cubeta] == False:
            cubetas_usadas[indice_cubeta] = True
            cubetas_minimos[indice_cubeta] = num
            cubetas_maximos[indice_cubeta] = num
        else:
            if num < cubetas_minimos[indice_cubeta]:
                cubetas_minimos[indice_cubeta] = num
            if num > cubetas_maximos[indice_cubeta]:
                cubetas_maximos[indice_cubeta] = num

    resultado_diferencia_maxima = 0
    maximo_anterior = valor_minimo
    
    i = 0
    while i < numero_de_cubetas:
        if cubetas_usadas[i] == False:
            i = i + 1
            continue

        diferencia_actual = cubetas_minimos[i] - maximo_anterior
        if diferencia_actual > resultado_diferencia_maxima:
            resultado_diferencia_maxima = diferencia_actual
        
        maximo_anterior = cubetas_maximos[i]
        i = i + 1
        
    return resultado_diferencia_maxima"
"class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if amount == 0 or not coins: return 0
        
        # this dp will hold the number of coins
        # required for every amount from 0..amount
        dp = [float('inf')] * (amount+1)
        
        # to have a sum of zero
        # we don't need any coins i.e 0
        dp[0] = 0
        
        # brute force, we'll calculate
        # the coins needed for every amount
        # starting from 1 since we've calculated 0
        for a in range(1, amount+1):
            # for every amount, we'll
            # try to form coins with every
            # available coin
            for c in coins:
                # if the current amount is less
                # than the current coin, you can't
                # make that amount with this coin
                # so skip it. i.e. if a = 2 and coin = 5
                # you should not bother computing anything here
                if a-c >= 0:
                    # otherwise, you check the min
                    # of the num(coins) for current amount
                    # and the 1 plus the coins required
                    # by amount-c i.e. to make the amount 0
                    # for e.g. if amount = 7 and coin = 3,
                    # we can say the coins needed to make 7
                    # would be the coin of denomination 4 (+1) and
                    # the number of coins taken to reach 3
                    # => 1 + dp[3] so that we can easily reach the sum i.e 7
                    dp[a] = min(dp[a], dp[a-c]+1)
            
        # we need to return -1 if we weren't able to find
        # an answer i.e. no updates were made and the amount
        # still has the initial value we had set i.e float('inf')
        return dp[amount] if dp[amount] != float('inf') else -1";"class Solucion:
    def coinChange(self, monedas, cantidad):
        valor_infinito = cantidad + 1
        dp = []
        for i in range(cantidad + 1):
            dp.append(valor_infinito)

        dp[0] = 0

        monto_actual = 1
        while monto_actual <= cantidad:
            for moneda in monedas:
                if moneda <= monto_actual:
                    cantidad_previa = dp[monto_actual - moneda]
                    if cantidad_previa != valor_infinito:
                        nueva_cantidad = cantidad_previa + 1
                        if nueva_cantidad < dp[monto_actual]:
                            dp[monto_actual] = nueva_cantidad
            monto_actual = monto_actual + 1

        resultado_final = dp[cantidad]

        if resultado_final == valor_infinito:
            return -1
        else:
            return resultado_final"
"class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """"""
        Do not return anything, modify board in-place instead.
        """"""
        life = []
        for i in range(len(board)):
            col = []
            for j in range(len(board[0])):
                col.append(board[i][j])
            life.append(col)
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == 1:
                    if self.check(board,i,j) == True:
                        life[i][j] = 0
                else:
                    if self.check(board,i,j) == True:
                        life[i][j] = 1
        for i in range(len(life)):
            for j in range(len(life[0])):
                board[i][j] = life[i][j]
                
    def check(self,board,i,j):
        count = 0
        if board[i][j]==1:
            #diagonal top left to bottom right
            if i !=0 and j !=0 :
                if board[i-1][j-1] == 1:
                    count+=1
            if i != len(board)-1 and j != len(board[0])-1:
                if board[i+1][j+1] == 1:
                    count+=1
            #diagonal top right to bottom left
            if i!=0 and j != len(board[0])-1:
                if board[i-1][j+1] ==1:
                    count+=1
            if i!= len(board)-1 and j!=0:
                if board[i+1][j-1] == 1:
                    count +=1
            #top and bottom vertically
            if i!=0 and board[i-1][j]==1:
                count+=1
            if i!= len(board)-1 and board[i+1][j]==1:
                count +=1
            #left and right horizontally
            if j!=0 and board[i][j-1] ==1:
                count+=1
            if j!= len(board[0])-1 and board[i][j+1]==1:
                count+=1
            if count ==2 or count == 3:
                return False
            else:
                return True
        else:
            if board[i][j]==0:
                #diagonal top left to bottom right
                if i !=0 and j !=0 :
                    if board[i-1][j-1] == 1:
                        count+=1
                if i != len(board)-1 and j != len(board[0])-1:
                    if board[i+1][j+1] == 1:
                        count+=1
                #diagonal top right to bottom left
                if i!=0 and j != len(board[0])-1:
                    if board[i-1][j+1] ==1:
                        count+=1
                if i!= len(board)-1 and j!= 0:
                    if board[i+1][j-1] ==1:
                        count +=1
                #top and bottom vertically
                if i!=0 and board[i-1][j]==1:
                    count+=1
                if i!= len(board)-1 and board[i+1][j]==1:
                    count +=1
                #left and right horizontally
                if j!=0 and board[i][j-1] ==1:
                    count+=1
                if j!= len(board[0])-1 and board[i][j+1]==1:
                    count+=1
                if count == 3:
                    return True
                else:
                    return False";"def juego_de_la_vida(tablero):
    if not tablero:
        return []
    
    filas = len(tablero)
    columnas = len(tablero[0])
    
    nuevo_tablero = []
    i = 0
    while i < filas:
        fila_nueva = []
        j = 0
        while j < columnas:
            fila_nueva.append(0)
            j = j + 1
        nuevo_tablero.append(fila_nueva)
        i = i + 1

    fila_actual = 0
    while fila_actual < filas:
        columna_actual = 0
        while columna_actual < columnas:
            vecinos_vivos = 0
            
            # Revisar los 8 vecinos
            # Arriba-izquierda
            if fila_actual > 0 and columna_actual > 0 and tablero[fila_actual - 1][columna_actual - 1] == 1:
                vecinos_vivos = vecinos_vivos + 1
            # Arriba
            if fila_actual > 0 and tablero[fila_actual - 1][columna_actual] == 1:
                vecinos_vivos = vecinos_vivos + 1
            # Arriba-derecha
            if fila_actual > 0 and columna_actual < columnas - 1 and tablero[fila_actual - 1][columna_actual + 1] == 1:
                vecinos_vivos = vecinos_vivos + 1
            # Izquierda
            if columna_actual > 0 and tablero[fila_actual][columna_actual - 1] == 1:
                vecinos_vivos = vecinos_vivos + 1
            # Derecha
            if columna_actual < columnas - 1 and tablero[fila_actual][columna_actual + 1] == 1:
                vecinos_vivos = vecinos_vivos + 1
            # Abajo-izquierda
            if fila_actual < filas - 1 and columna_actual > 0 and tablero[fila_actual + 1][columna_actual - 1] == 1:
                vecinos_vivos = vecinos_vivos + 1
            # Abajo
            if fila_actual < filas - 1 and tablero[fila_actual + 1][columna_actual] == 1:
                vecinos_vivos = vecinos_vivos + 1
            # Abajo-derecha
            if fila_actual < filas - 1 and columna_actual < columnas - 1 and tablero[fila_actual + 1][columna_actual + 1] == 1:
                vecinos_vivos = vecinos_vivos + 1
            
            estado_celda = tablero[fila_actual][columna_actual]
            
            if estado_celda == 1:
                if vecinos_vivos == 2 or vecinos_vivos == 3:
                    nuevo_tablero[fila_actual][columna_actual] = 1
            else:
                if vecinos_vivos == 3:
                    nuevo_tablero[fila_actual][columna_actual] = 1
            
            columna_actual = columna_actual + 1
        fila_actual = fila_actual + 1
                    
    return nuevo_tablero"
"class Solution:
	#Time-Complexity: O(logn * (n/2)) -> O(nlogn) -> while loop runs at most logn times since
	#we divide nums array size by half each iteration, and the for loop runs at most n/2 times!
	#Space-Complexity: O(logn * (n/2)) -> for each iteration of while loop, we allocate
	#copy array of size at worst (n/2) -> O(nlogn)
    def minMaxGame(self, nums: List[int]) -> int:
        
        #just simulate it?
        min_flag = True
        
        while len(nums) > 1:
            copy = []
            for i in range(0, len(nums)-1, 2):
                if(min_flag):
                    copy.append(min(nums[i], nums[i+1]))
                    min_flag = (not min_flag)
                    continue
                
                else:
                    copy.append(max(nums[i], nums[i+1]))
                    min_flag = (not min_flag)
                    continue
            
            nums = copy
            min_flag = True
        
        return nums[0]";"class Solucion:
    def minMaxJuego(self, numeros):
        longitud_numeros = len(numeros)
        
        while longitud_numeros > 1:
            nuevos_numeros = []
            
            mitad_longitud = longitud_numeros // 2
            
            for i in range(mitad_longitud):
                es_par = i % 2 == 0
                
                if es_par:
                    valor_minimo = min(numeros[2 * i], numeros[2 * i + 1])
                    nuevos_numeros.append(valor_minimo)
                else:
                    valor_maximo = max(numeros[2 * i], numeros[2 * i + 1])
                    nuevos_numeros.append(valor_maximo)
            
            numeros = nuevos_numeros
            longitud_numeros = len(numeros)
            
        resultado = numeros[0]
        return resultado"
"class Solution:
    def rob(self, nums: List[int]) -> int:
        # How many money we can make we we reach last house
        # How many money we can make when we reach i house
        # iterate from left to right
        # when reach i'th  house the money we can make is from
        # (First) dp[i-2] which is the maimum value we can make when reach (i-2)'th house plus the curr nums[i]
        # (Second) get the money from dp[i-1] which is the maximum value we can make when reach (i-1)'th house. However, we can't add current num[i], since when we take the money from (i-1)'th house, we can not take the adjacent house
        # store the maximum between (First) and (Second)
        # check the base case dp[0] give nums[0] is ok, However, dp[1] =  max(dp[1-1],dp[1-2]+nums[1]), we don't have dp[-1], therefore we give a extra space at the frony.
        # dp = [0]*(n+1). Therefore, i in dp correspond to i-1 in nums, That is now the dp[1] = nums[0]
        
        # Method 1
        # Time: O(n), Space: O(n)
        
        n = len(nums) 
        dp = [0]*(n+1)
        dp[1] = nums[0]
        for i in range(2,n+1):
            dp[i] = max(dp[i-1],dp[i-2]+nums[i-1])
        return dp[-1]
        
        # Method 2
        # Since we only need dp[i-1], dp[i-2]. we can create variable and save space
        # Time: O(n), Space: O(1)
        first = 0
        second = 0
        for num in nums:
            first, second =  second, max(first + num, second)
        return second            
            
        # Method 3 same as method 2
        # Time: O(n), Space: O(1)
        first_value = 0 
        second_value = 0
        
        for num in nums:
            temp = max(num + first_value, second_value)
            first_value = second_value
            second_value = temp
        return second_value";"def solucion(numeros):
    cantidad_de_casas = len(numeros)

    if cantidad_de_casas == 0:
        return 0

    if cantidad_de_casas == 1:
        return numeros[0]

    ganancia_maxima = [0] * cantidad_de_casas
    ganancia_maxima[0] = numeros[0]

    if numeros[1] > numeros[0]:
        ganancia_maxima[1] = numeros[1]
    else:
        ganancia_maxima[1] = numeros[0]

    indice = 2
    while indice < cantidad_de_casas:
        ganancia_al_robar = numeros[indice] + ganancia_maxima[indice - 2]
        ganancia_al_no_robar = ganancia_maxima[indice - 1]

        if ganancia_al_robar > ganancia_al_no_robar:
            ganancia_maxima[indice] = ganancia_al_robar
        else:
            ganancia_maxima[indice] = ganancia_al_no_robar
        
        indice = indice + 1

    return ganancia_maxima[cantidad_de_casas - 1]"
"class Solution:
    def minimizeXor(self, num1: int, num2: int) -> int:
        # determine number of 1's in binary representation
        # which is also equal to bin(num2[1:]).count(""1"")
        n2 = 0
        while num2:
            if num2 &amp, 1:    # last bit is 1
                n2 += 1     # increase count
            num2 >>= 1      # shift the binary number to the right

        # search for indices for 0's and 1's
        # n = 110 (binary form) => bits1{0: [0], 1: [1, 2]}
        bits1 = {0: [], 1: []}
        i = 0    # index from the right side
        while num1:
            if num1 &amp, 1:   # decide which list to append
                bits1[1].append(i)
            else:
                bits1[0].append(i)
            i += 1        # increase index
            num1 >>= 1    # shift the number to the right

        # list of positions - reversed for 1 (left to right)
        # straight for 0 (right to left)
        target_pos = bits1[1][::-1] + bits1[0]    # positions for 1
        # if we need more 1's to be placed into the target number
        if len(target_pos) < n2:
            next_pos = target_pos[0] + 1    # most left position
            # fill it in with consecutive positions
            target_pos += list(range(next_pos,
                                     next_pos + n2 - len(target_pos)))
        # cut the list to the required length n2
        target_pos = target_pos[:n2]
        # find the final number by shifting 1's to the target positions
        # e.g. target = 101 == 100 + 001 in binary
        return sum(1 << pos for pos in target_pos)";"class Solucion:
    def minimizarXor(self, num1, num2):
        bits_objetivo = 0
        copia_num2 = num2
        while copia_num2 > 0:
            if (copia_num2 & 1) == 1:
                bits_objetivo = bits_objetivo + 1
            copia_num2 = copia_num2 >> 1

        x = 0
        bits_restantes = bits_objetivo

        for i in range(30, -1, -1):
            mascara = 1 << i
            if (num1 & mascara) > 0:
                if bits_restantes > 0:
                    x = x | mascara
                    bits_restantes = bits_restantes - 1
        
        if bits_restantes > 0:
            for i in range(31):
                mascara = 1 << i
                if (num1 & mascara) == 0:
                    if bits_restantes > 0:
                        x = x | mascara
                        bits_restantes = bits_restantes - 1

        return x"
"class Solution:
    def wordPattern(self, letters: str, words: str) -> bool:
        '''
		Renamed parameters to less confusing names.
		""patterns"" to ""letters"".
		""s"" to ""words"".
		
		Solution:
		
        Return False if the number of letters and words are not the same.
   
        Traverse the letters, one by one and return False if:
        
        A letter together with its corresponding word in words
        (same index as in letters) meets a condition when compared:
        
        With letters as keys in the dictonary and words as
        corresponding values:
        
        1. Return False if: 
           Current letter/key in loop already exists but
           isn't the same as the letter/word pair currently in comparison.
        
        2. Return False if:
           Current letter in loop is not yet a key but the corresponding
           word is a value in the dictionary already. 
           (Otherwise add the letter and word 
           as key/value pairs to the dict)
           
        Return True if the loop is complete, which means that all letters 
		have been compared with corresponding words without finding any of the
		above issues.
        '''
        
        words = words.split()
        
        if len(letters) != len(words):
            return False
			
		pairs = dict()
        
        for i, letter in enumerate(letters):
            if letter in pairs.keys():
                if pairs[letter] != words[i]:
                    return False
            elif words[i] not in pairs.values():
                pairs[letter] = words[i]
            else:
                return False
            
        return True";"class Solucion:
    def patron_de_palabras(self, patron: str, s: str) -> bool:
        palabras = s.split(' ')

        if len(patron) != len(palabras):
            return False

        mapeo_letra_a_palabra = {}
        mapeo_palabra_a_letra = {}

        contador = 0
        while contador < len(patron):
            letra_actual = patron[contador]
            palabra_actual = palabras[contador]

            if letra_actual in mapeo_letra_a_palabra:
                if mapeo_letra_a_palabra[letra_actual] != palabra_actual:
                    return False
            else:
                if palabra_actual in mapeo_palabra_a_letra:
                    return False
                
                mapeo_letra_a_palabra[letra_actual] = palabra_actual
                mapeo_palabra_a_letra[palabra_actual] = letra_actual
            
            contador = contador + 1

        return True"
"class Solution:            # Suppose for example:
                           #    words1 = ['food', 'coffee', 'foofy']
                           #    words2 = ['foo', 'off']
                           #  
                           # Here's the plan:
                           #   1) Construct a dict in which the key is a char in
                           #      one or more words in words2, and the key's max
                           #      count in those words.
                           #            for 'foo': c2 = {'o': 2, 'f': 1}
                           #            for 'off': c2 = {'o': 1, 'f': 2}
                           #            so: d = {'o': 2, 'f': 2}
                           #
                           #   2) Use a counter for each word in words1 to determine 
                           #      whether the word has at least the quantity of each char
                           #      in d:
                           #            for 'food'  : c1 = {'o': 2, 'f': 1, 'd': 1}          (fails at 'f')
                           #            for 'coffee': c1 = {'f': 2, 'e': 2, 'o': 1, 'c': 1 } (fails at 'o')
                           #            for 'foofy ': c1 = {'f': 2, 'o': 2, 'y': 1}          (success)
                           #
                           #   3) return answer:
                           #            answer = ['foofy'] 
                           #
    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:
        d, ans = defaultdict(int), []

        for word in words2:                     #  <-- 1)
            c2 = Counter(word)
            for ch in c2:
                d[ch] = max(d[ch], c2[ch])

        for word in words1:                     #  <-- 2)
            c1 = Counter(word)

            for ch in d:
                if c1[ch] < d[ch]: break
            else:
                ans.append(word)                #  <-- else executes only if the for-loop
                                                #      completes without break

        return ans                              #  <-- 3)";"frecuencia_maxima_requerida = [0] * 26

for palabra_subconjunto in words2:
    frecuencia_palabra_actual = [0] * 26
    for letra in palabra_subconjunto:
        indice = ord(letra) - ord('a')
        frecuencia_palabra_actual[indice] = frecuencia_palabra_actual[indice] + 1
    
    i = 0
    while i < 26:
        if frecuencia_palabra_actual[i] > frecuencia_maxima_requerida[i]:
            frecuencia_maxima_requerida[i] = frecuencia_palabra_actual[i]
        i = i + 1

palabras_universales = []

for palabra_principal in words1:
    frecuencia_palabra_principal = [0] * 26
    for letra in palabra_principal:
        indice = ord(letra) - ord('a')
        frecuencia_palabra_principal[indice] = frecuencia_palabra_principal[indice] + 1
        
    es_universal = True
    i = 0
    while i < 26:
        if frecuencia_palabra_principal[i] < frecuencia_maxima_requerida[i]:
            es_universal = False
            break
        i = i + 1
        
    if es_universal == True:
        palabras_universales.append(palabra_principal)"
"class Solution:
    def isHappy(self, n: int) -> bool:   
        # Maintain the additions we have done, so we know when the loop goes infinite
        duplicate = {}
        
        # Use recursion: calculate sum of digits, add to duplicates map, and re-call the method
        def check(n: int) -> bool:
            if n == 1:
                # we return true -> since it is a happy number
                return True
            
            # Find the digits. Note: order in the list does not matter here. 
            res = []
            while n > 0:
                w = n%10
                res.append(w)
                n = n//10
        
            # Since we have the digits now, add the digits
            add = 0
            for num in res:
                add += num**2
            
            # Return False if sum in duplicate map, or re-call the method with new sum
            if add in duplicate:
                # Loop detected
                return False
            else:
                duplicate[add] = 0
                return check(add)
        
        # calling the main method
        return check(n)";"class Solucion:
    def es_feliz(self, n):
        numeros_vistos = []
        while n != 1 and n not in numeros_vistos:
            numeros_vistos.append(n)
            
            suma_de_cuadrados = 0
            numero_temporal = n
            
            while numero_temporal > 0:
                digito = numero_temporal % 10
                suma_de_cuadrados = suma_de_cuadrados + (digito * digito)
                numero_temporal = numero_temporal // 10
            
            n = suma_de_cuadrados
            
        if n == 1:
            return True
        else:
            return False"
"class Solution:
    def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:
        # Stack: go from back and use stack to get ans
        # Time: O(n)
        # Space: O(n)
        
        stack = [] # index
        ans = [-1] * len(cars)
        for i in range(len(cars)-1,-1,-1):
            # remove cars that are faster than current car since it will never collide
            while stack and cars[i][1] <= cars[stack[-1]][1]: 
                stack.pop()

            while stack: # if car left, we can compute collide time with current car. 
                collision_t = (cars[stack[-1]][0] - cars[i][0]) / (cars[i][1] - cars[stack[-1]][1])
                # if current car's collide time is greater than previous car's collide time 
                # (previous collided before current), then we have to find previous car's previous car
                # to compute collide time with that car, so we pop from stack and re-process
                # Otherwise, we add that collide time to answer and break
                if ans[stack[-1]] == -1 or collision_t <= ans[stack[-1]]:
                    ans[i] = collision_t
                    break
                stack.pop()
            stack.append(i)
        return ans";"def tiempos_de_colision(coches):
    numero_coches = len(coches)
    
    respuesta = []
    i = 0
    while i < numero_coches:
        respuesta.append(-1.0)
        i = i + 1

    pila = []

    indice = numero_coches - 1
    while indice >= 0:
        posicion_actual = coches[indice][0]
        velocidad_actual = coches[indice][1]

        while len(pila) > 0:
            indice_siguiente_coche = pila[-1]
            posicion_siguiente = coches[indice_siguiente_coche][0]
            velocidad_siguiente = coches[indice_siguiente_coche][1]

            if velocidad_actual <= velocidad_siguiente:
                pila.pop()
            else:
                tiempo_de_colision = (posicion_siguiente - posicion_actual) / (velocidad_actual - velocidad_siguiente)
                
                if respuesta[indice_siguiente_coche] == -1.0 or tiempo_de_colision <= respuesta[indice_siguiente_coche]:
                    respuesta[indice] = tiempo_de_colision
                    break
                else:
                    pila.pop()
        
        pila.append(indice)
        indice = indice - 1

    return respuesta"
"class Solution:
    def closestRoom(self, rooms: List[List[int]], queries: List[List[int]]) -> List[int]:
        ans = [0] * len(queries)
        
        # sort queries to handle largest size queries first
        q = deque(sorted([(size, room, i) for i, (room, size) in enumerate(queries)], key=lambda a: (-a[0], a[1], a[2])))

        # sort rooms by descending size
        rooms = deque(sorted(rooms, key=lambda x: -x[1]))

        # current available room ids
        cands = []
        
        
        while q:
            size, room, i = q.popleft()
            # add room ids to candidates as long as top of room size meet the requirements
            while rooms and rooms[0][1] >= size:
                bisect.insort(cands, rooms.popleft()[0])
                    
            # if no room size available, return -1
            if not cands: ans[i] = -1
                
            # else use bisect to find optimal room ids
            else:
                loc = bisect.bisect_left(cands, room)
                if loc == 0: ans[i] = cands[loc]
                elif loc == len(cands): ans[i] = cands[-1]
                else: ans[i] = cands[loc - 1] if room - cands[loc - 1] <= cands[loc] - room else cands[loc]
        
        return ans";"respuestas = []

for consulta in consultas:
    preferido = consulta[0]
    tamanio_minimo = consulta[1]

    mejor_id_habitacion = -1
    minima_diferencia = 1000000001

    for habitacion in habitaciones:
        id_habitacion = habitacion[0]
        tamanio = habitacion[1]

        if tamanio >= tamanio_minimo:
            diferencia = id_habitacion - preferido
            if diferencia < 0:
                diferencia = -diferencia

            if diferencia < minima_diferencia:
                minima_diferencia = diferencia
                mejor_id_habitacion = id_habitacion
            elif diferencia == minima_diferencia:
                if id_habitacion < mejor_id_habitacion:
                    mejor_id_habitacion = id_habitacion

    respuestas.append(mejor_id_habitacion)"
"class Solution:
    def stoneGameV(self, stoneValue: List[int]) -> int:
        def getPartialSum():
            for i in range(n):
                partial_sum[i][i] = stoneValue[i]
            for i in range(n):
                for j in range(i+1, n):
                    partial_sum[i][j] = partial_sum[i][j-1]+stoneValue[j]
                               
        # (O(n) search)    
        def preCalCutIdx():
            # based on the fact that cut index is increasing with k for 
            # partial_sum[start][k]
            for i in range(n-1):
                cp = i
                cut_index[i][i+1] = i
                for j in range(i+2, n):
                    while cp < j-1 and partial_sum[i][cp] < partial_sum[cp+1][j]:
                        cp += 1  
                    cut_index[i][j] = cp
		
			
        @lru_cache(None)
        def dfs(start, end):
            if start >= end:
                return 0
            max_score = 0
            # find first cut s.t. left sum >= right sum 
            cut = cut_index[start][end]
            # we can't find cut s.t. left sum >= right sum
            if cut == -1:
                cut = end-1
            sum1 = partial_sum[start][cut]
            sum2 = partial_sum[cut+1][end]
            if sum1 < sum2:
                # calcuate left[start][cut] if not yet
                dfs(start, cut)
                # the remaining will be the left part for sure, no 
                # matter where the cut is. 
                max_score = left[start][cut]
            elif sum1 == sum2:
                dfs(start, cut)
                dfs(cut+1, end)
                # if real cut in the range of [cut+1, end], remaining will be the right part
                # if real cut in the range of [0, cut], remaing will be the left part
                # if real cut is cut, either can be the remaining. 
                max_score = max(left[start][cut], right[cut+1][end])
            else:
                dfs(cut+1, end)
                # we are selecting the cut in the range of [cut, end] having 
                # the max score. For cut in that range, the remaining is 
                # the right part of the cut for sure. 
                max_score = right[cut+1][end]
                if cut > start:
                    dfs(start, cut-1)
                    # we are selecting the cut in the range of [0, cut] having 
                    # the max score. The remaining is the left part for sure. 
                    max_score = max(max_score, left[start][cut-1])
            dfs(start, end-1)
            dfs(start+1, end)
            # updating left and right arrays. 
            left[start][end] = max(left[start][end-1], partial_sum[start][end]+max_score)
            right[start][end] = max(right[start+1][end], partial_sum[start][end]+max_score)
            return max_score
            
        n = len(stoneValue)
        partial_sum = [[0]*n for _ in range(n)]
        cut_index = [[-1]*n for _ in range(n)]
        # left[i][j]: cut in the range of [i, j], max score of left part
        # right[i][j]: cut in the range of [i, j], max score of right part
        left = [[0]*n for _ in range(n)]
        right = [[0]*n for _ in range(n)]
        for i in range(n):
            left[i][i] = stoneValue[i]
            right[i][i] = stoneValue[i]
        getPartialSum()
        # for partial_sum[i][j], find cut index between i and j 
        # s.t partial_sum[i][cut_index] >= partial_sum[cut_index+1][j] or 
        # cut_index = j-1 if not exist. 
        preCalCutIdx()
        return dfs(0, n-1)";"class Solucion:
    def puntajeMaximo(self, valor_piedra):
        n = len(valor_piedra)

        if n <= 1:
            return 0

        sumas_prefijo = [0] * (n + 1)
        acumulado = 0
        for i in range(n):
            acumulado = acumulado + valor_piedra[i]
            sumas_prefijo[i + 1] = acumulado

        tabla_dp = []
        for i in range(n):
            fila = [0] * n
            tabla_dp.append(fila)

        longitud = 2
        while longitud <= n:
            i = 0
            while i <= n - longitud:
                j = i + longitud - 1
                max_puntuacion_subproblema = 0

                k = i
                while k < j:
                    suma_izquierda = sumas_prefijo[k + 1] - sumas_prefijo[i]
                    suma_derecha = sumas_prefijo[j + 1] - sumas_prefijo[k + 1]

                    puntuacion_division_actual = 0
                    if suma_izquierda < suma_derecha:
                        puntuacion_division_actual = suma_izquierda + tabla_dp[i][k]
                    elif suma_derecha < suma_izquierda:
                        puntuacion_division_actual = suma_derecha + tabla_dp[k + 1][j]
                    else:
                        puntuacion_futura_izquierda = tabla_dp[i][k]
                        puntuacion_futura_derecha = tabla_dp[k + 1][j]
                        if puntuacion_futura_izquierda > puntuacion_futura_derecha:
                            puntuacion_division_actual = suma_izquierda + puntuacion_futura_izquierda
                        else:
                            puntuacion_division_actual = suma_derecha + puntuacion_futura_derecha
                    
                    if puntuacion_division_actual > max_puntuacion_subproblema:
                        max_puntuacion_subproblema = puntuacion_division_actual
                    
                    k = k + 1
                
                tabla_dp[i][j] = max_puntuacion_subproblema
                i = i + 1
            longitud = longitud + 1

        return tabla_dp[0][n - 1]"
"class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:  # Time: O(n) and Space: O(1)

        # Find Middle: find middle and divide the list in to two
        slow, fast = head, head.next  # head(slow) -> 1 -> 2(fast) -> ...
        while fast and fast.next:     # while fast exists and there is next element to travel keep moving
            slow = slow.next          # fast moving twice as much as slow, will lead slow to point in the middle 
            fast = fast.next.next     # Even(4): slow = 2, fast = 4 &amp, Odd(5): slow = 3, fast = None 

        # Reverse: reverse the second list
        second = slow.next       # in Odd case lets say 1-> 2(slow) -> 3 -> 4(fast): second = 3(2.next) 
        prev = slow.next = None  # Created Two separate nodes 1->2 &amp, 3->4 
        while second:
            tmp = second.next   # tmp = 4
            second.next = prev  # 3 -> None
            prev = second       # prev = 3
            second = tmp        # second = 4
        # So, in the next iteration 
            # tmp = None 
            # 4.next = prev(3) and our linked is reversed
			# prev = 4 
			# second = None

        # Merge: merge the first with the reversed second  
        first, second = head, prev  # first will point to starting of the 1st Node and second to 2nd Node
        while second:
            tmp1, tmp2 = first.next, second.next  # tmp1 = 2, tmp2 = 3
            first.next = second                   # 1 -> 4
            second.next = tmp1                    # 4.next = 2 i.e. 1 -> 4 -> 2 
            first, second = tmp1, tmp2            # first = 2, second = 3
        # So, in the next iteration 
            # tmp1 = tmp2 = None
            # 2 -> 3 i.e. 1 -> 4 -> 2 -> 3
            # 1 -> 4 -> 2 -> 3 -> None
			# first = second = None";"class NodoLista:
    def __init__(self, val=0, siguiente=None):
        self.val = val
        self.siguiente = siguiente

def reordenar_lista(cabeza):
    if cabeza is None or cabeza.siguiente is None:
        return

    nodos = []
    nodo_actual = cabeza
    while nodo_actual is not None:
        nodos.append(nodo_actual)
        nodo_actual = nodo_actual.siguiente

    puntero_izquierdo = 1
    puntero_derecho = len(nodos) - 1
    
    nodo_para_enlazar = cabeza
    
    es_turno_del_final = True
    while puntero_izquierdo <= puntero_derecho:
        if es_turno_del_final:
            nodo_siguiente = nodos[puntero_derecho]
            puntero_derecho = puntero_derecho - 1
        else:
            nodo_siguiente = nodos[puntero_izquierdo]
            puntero_izquierdo = puntero_izquierdo + 1
        
        nodo_para_enlazar.siguiente = nodo_siguiente
        nodo_para_enlazar = nodo_siguiente
        
        es_turno_del_final = not es_turno_del_final

    nodo_para_enlazar.siguiente = None"
"class Solution:
    def countPrimes(self, n: int) -> int:
        # Prerequisite:
        # What is prime number. What are they just the starting. 
        
        truth = [True]*n # making a list of lenght n. And keep all the values as True.
        if n<2: # as 0 &amp, 1 are not prime numbers. 
            return 0
        truth[0], truth[1] = False, False #as we added True in the truth list. So will make false for ) &amp, 1 as they are not prime numbers.
        
        i=2 # As we know 0 &amp, 1 are not prime.
        while i*i<n: # why we are doing it as i*i here is bcz lets say 5*2 = 10 is divisble by 2 as well as 5 so if 10 is already removed why to traverse a value which is already travered once. so in case of n=5 - 5<5. CONCLUSION : i<sqrt(n)
#why we are running the loop till n is bcz question says "" prime numbers that are strictly less than n"".
            if truth[i] == True:
                for j in range(i*i,n,i): # if we have mutiple of a number in the range of n, we have to remove them as they can be prime. i.e 2 is prime, but its multiple in n = 10 are 4,6,8 they cant be prime. So we will make them false(means not a prime).
                    truth[j]=False
            i += 1 # increasing our iterator.
        return truth.count(True) # will count true value";"def contar_primos(n):
    contador = 0
    if n <= 2:
        return 0

    for numero in range(2, n):
        es_primo = True
        for divisor in range(2, numero):
            if numero % divisor == 0:
                es_primo = False
                break
        if es_primo:
            contador = contador + 1
    
    return contador"
"class Solution:
    def isPowerOfTwo(self, x: int) -> bool:
        
        # TC = O(1), SC = O(1)
        
        # a power of 2 has only kth bit set in its binary representation 
        # and ( power of 2 ) - 1 -> has all bits set except the kth bit
        # so taking bitwise of these two numbers would always give 0
        
        return (x!=0) and (x &amp, (x-1)) == 0
		
		# Example 1:
        # if x = 0 ans = False 
        # if x = 1 ans = True and 1 &amp, 0 == 0 -> True so True and True = True
        #   00000
        # &amp, 00001
        # ---------
        #   00000
        # ---------
		
		# Example 2:
		# if x = 16 , then x - 1 = 15, so x &amp, x-1 == 0 will check:
		# 16 =     10000       
		# 15 =  &amp,  01111
		# --------------------
		#          00000
		# --------------------";"def es_potencia_de_dos(numero):
    if numero <= 0:
        return False

    potencia_actual = 1

    while potencia_actual < numero:
        potencia_actual = potencia_actual * 2
    
    if potencia_actual == numero:
        return True
    else:
        return False"
"class Solution:
    def reverseBits(self, n: int) -> int:
        
    # Short Version
        out = str(bin(n))[::-1][:-2]
        while len(out) < 32:
            out += '0'
        return int(out, 2)
    
    # Long, step-by-step version
    # First, let's see the binary of the original number
        #print(bin(n))
        
    # Then, let's turn the number into binary, and a string and save it to a variable
        #out = str(bin(n))
        #print(out)
        
    # Next, this is fancy python for: iterate through the list from end to start in increments of -1 (backwards)
    # returning each element. This effectively reverses the string from the step above.
        #out = out[::-1]
        #print(out)

    # Now, since we turned the binary representation into a string, we have a ""0b"" at the end (since we reversed order)
    # We can remove it with python indexing [:-2]
        #out = out[:-2]
    
    # The input binary may have had leading zeros that would have been truncated
    #   i.e. 000101 -> 101
    # When reversed, those zeros are important
    #   101000 =/= 101 
    # Since we know the input number is always 32 bits, we can just add trailing zeros until we reach a length of 32
        #while len(out) < 32:
        #    out += '0'
        #print(out)
    
    # Finally, we can convert back to base-10 and return!
        #out = int(out, 2)
        #return out";"class Solucion:
  def invertir_bits(self, n):
    resultado = 0
    
    # Iteramos 32 veces para cada bit del entero.
    for i in range(32):
      
      # 1. Desplazamos el resultado un bit a la izquierda para hacer espacio.
      resultado = resultado << 1
      
      # 2. Obtenemos el bit menos significativo de n.
      bit = n & 1
      
      # 3. Añadimos ese bit al resultado.
      resultado = resultado | bit
      
      # 4. Desplazamos n un bit a la derecha para procesar el siguiente bit.
      n = n >> 1
      
    return resultado"
"class Solution:
    def readBinaryWatch(self, turnedOn: int) -> List[str]:
        ans = set()
        m_so_far = 0
        h_so_far = 0
        #hashmap tells the possible hr and min values we can recurse on!
        hashmap = {}
        hashmap[""hr""] = [1, 2, 4, 8]
        hashmap[""min""] = [1, 2, 4, 8, 16, 32]
        
        #Paramters:
        #1. LEDS -> tell number of LEDS turned on so far!
        #2. hr_set -> set of all hour values that are already used and not available!
        #3. min_set -> similar idea as hr_set!
        def helper(LEDS, hr_set, min_set):
            nonlocal m_so_far, h_so_far, ans, turnedOn, hashmap
            #check if m_so_far or h_so_far is out of range -> invalid time!
            if(m_so_far > 59 or h_so_far > 11):
                return
            
            #base case: LEDS == input: number of turnedOn!
            #we used all LEDs and current time is valid! So we need to record it!
            if(LEDS == turnedOn):
                m_string = """"
                #if minute is single digit, we need a leading zero!
                if(0<= m_so_far <= 9):
                    m_string = m_string + ""0"" + str(m_so_far)
                else:
                    m_string = str(m_so_far)
                #no leading zero for hour!
                res = str(h_so_far) + "":"" + m_string
                ans.add(res)
                return
            
            #otherwise, we can recurse over all 4 hour values nad 6 minutes values and
            #use them only if they are not already in set! 
            for hour in hashmap[""hr""]:
                if(hour in hr_set):
                    continue
                hr_set.add(hour)
                #update the hour count and add to set before recursing!
                h_so_far += hour
                
                helper(LEDS + 1, hr_set, min_set)
                #once rec. call returns, update the count of hours as well as state of hr!
                h_so_far -= hour
                hr_set.remove(hour)
            
            for minute in hashmap[""min""]:
                if(minute in min_set):
                    continue
                
                min_set.add(minute)
                m_so_far += minute
                
                helper(LEDS + 1, hr_set, min_set)
                m_so_far -= minute
                min_set.remove(minute)
        
        helper(0, set(), set())
        return list(ans)";"class Solucion:
    def leerRelojBinario(self, leds_encendidos: int):
        tiempos_validos = []
        for hora in range(12):
            for minuto in range(60):
                
                bits_hora = 0
                temp_hora = hora
                while temp_hora > 0:
                    bits_hora = bits_hora + (temp_hora % 2)
                    temp_hora = temp_hora // 2
                
                bits_minuto = 0
                temp_minuto = minuto
                while temp_minuto > 0:
                    bits_minuto = bits_minuto + (temp_minuto % 2)
                    temp_minuto = temp_minuto // 2

                if bits_hora + bits_minuto == leds_encendidos:
                    minuto_texto = """"
                    if minuto < 10:
                        minuto_texto = ""0"" + str(minuto)
                    else:
                        minuto_texto = str(minuto)
                    
                    tiempo_formateado = str(hora) + "":"" + minuto_texto
                    tiempos_validos.append(tiempo_formateado)
        
        return tiempos_validos"
"class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        swaps, i = 0, 0
        while swaps < len(nums): # we only make the necessary amount of swaps for each entry
            start, num = i, nums[i] # start index and current number to swap
            while True:
                temp = nums[(i+k) % len(nums)] # save the value at the final location of the current value
                nums[(i+k) % len(nums)] = num # store current value at final location
                num = temp # value at final location will now be placed at its final location next iteration
                swaps += 1 # update number of swaps
                i = (i+k) % len(nums) # update index
                if start == i: break # if we have swapped all entries in the group then break
            i += 1 # if we have to loop again, when len(nums) % k == 0, then we move to the next index";"def rotar_lista(lista_numeros, k):
    longitud_lista = len(lista_numeros)

    if longitud_lista == 0:
        return

    pasos_reales = k % longitud_lista

    contador = 0
    while contador < pasos_reales:
        
        ultimo_elemento = lista_numeros[longitud_lista - 1]

        indice = longitud_lista - 1
        while indice > 0:
            lista_numeros[indice] = lista_numeros[indice - 1]
            indice = indice - 1

        lista_numeros[0] = ultimo_elemento
        
        contador = contador + 1"
"class Solution:
    def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:
        if not p1 != p2 != p3 != p4: return False            # 4 points have to be different
        dis = lambda x, y: (y[1]-x[1])**2 + (y[0]-x[0])**2   # lambda function to calc distance**2
        points = [p1, p2, p3, p4]
        d = collections.defaultdict(list)
        for i in range(4):                                   # calculate distance between each points to other 3
            for j in range(i+1, 4):
                distance = dis(points[i], points[j])
                d[tuple(points[i])].append(distance)
                d[tuple(points[j])].append(distance)
        for point, distances in d.items():                   # check neighbour edges equality &amp, Pythagoras theorem
            distances.sort()
            if not (distances[0] == distances[1] and sum(distances[:2]) == distances[2]): return False
        return True";"def es_cuadrado_valido(p1, p2, p3, p4):
    distancias_cuadradas = []

    distancia_1_2 = (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2
    distancias_cuadradas.append(distancia_1_2)

    distancia_1_3 = (p1[0] - p3[0])**2 + (p1[1] - p3[1])**2
    distancias_cuadradas.append(distancia_1_3)

    distancia_1_4 = (p1[0] - p4[0])**2 + (p1[1] - p4[1])**2
    distancias_cuadradas.append(distancia_1_4)

    distancia_2_3 = (p2[0] - p3[0])**2 + (p2[1] - p3[1])**2
    distancias_cuadradas.append(distancia_2_3)

    distancia_2_4 = (p2[0] - p4[0])**2 + (p2[1] - p4[1])**2
    distancias_cuadradas.append(distancia_2_4)

    distancia_3_4 = (p3[0] - p4[0])**2 + (p3[1] - p4[1])**2
    distancias_cuadradas.append(distancia_3_4)

    distancias_cuadradas.sort()

    lado1 = distancias_cuadradas[0]
    lado2 = distancias_cuadradas[1]
    lado3 = distancias_cuadradas[2]
    lado4 = distancias_cuadradas[3]
    diagonal1 = distancias_cuadradas[4]
    diagonal2 = distancias_cuadradas[5]

    if lado1 == 0:
        return False

    es_cuadrado = False
    if lado1 == lado2 and lado2 == lado3 and lado3 == lado4:
        if diagonal1 == diagonal2:
            if (2 * lado1) == diagonal1:
                es_cuadrado = True

    return es_cuadrado"
"class Solution:
    def minJumps(self, arr: List[int]) -> int:
        
        n = len(arr)
        visited = set()
        
        
        if n <= 1:
            return 0
        
        same_value = dict()
        
        for i, v in enumerate(arr):
            if v not in same_value.keys():
                same_value[v]= [i]
            else:
                same_value[v].append(i)
                
        stack = list()
        level = 0
        
        stack.append((0,0))
        total = -1
        
        
        while stack:
            level,node = stack.pop(0)
        
            visited.add(node)
            
            if node == n-1:
                return level
            else:
                for a in same_value[arr[node]] :
                    if a != node and a not in visited:
                        stack.append((level+1,a))
                
                same_value[arr[node]].clear()
                
                if node+1 < n and node+1 not in visited:
                    stack.append((level+1,node+1))
                 
                if node-1 >=0 and node-1 not in visited:
                    stack.append((level+1,node-1))
                    

                                 
        return level";"def salto_minimo(arr):
    longitud = len(arr)
    if longitud <= 1:
        return 0

    indices_con_mismo_valor = {}
    indice = 0
    while indice < longitud:
        valor = arr[indice]
        if valor not in indices_con_mismo_valor:
            indices_con_mismo_valor[valor] = []
        lista_indices = indices_con_mismo_valor[valor]
        lista_indices.append(indice)
        indice = indice + 1

    cola = []
    cola.append((0, 0))

    visitado = [False] * longitud
    visitado[0] = True

    cabeza_de_cola = 0
    while cabeza_de_cola < len(cola):
        elemento_actual = cola[cabeza_de_cola]
        indice_actual = elemento_actual[0]
        pasos = elemento_actual[1]
        cabeza_de_cola = cabeza_de_cola + 1

        if indice_actual == longitud - 1:
            return pasos

        valor_actual = arr[indice_actual]
        if valor_actual in indices_con_mismo_valor:
            for proximo_indice in indices_con_mismo_valor[valor_actual]:
                if not visitado[proximo_indice]:
                    visitado[proximo_indice] = True
                    cola.append((proximo_indice, pasos + 1))
            
            indices_con_mismo_valor[valor_actual] = []

        proximo_indice_derecha = indice_actual + 1
        if proximo_indice_derecha < longitud:
            if not visitado[proximo_indice_derecha]:
                visitado[proximo_indice_derecha] = True
                cola.append((proximo_indice_derecha, pasos + 1))

        proximo_indice_izquierda = indice_actual - 1
        if proximo_indice_izquierda >= 0:
            if not visitado[proximo_indice_izquierda]:
                visitado[proximo_indice_izquierda] = True
                cola.append((proximo_indice_izquierda, pasos + 1))
    
    return -1"
"class Solution:
    def findWords(self, words: List[str]) -> List[str]:
        l=[""qwertyuiop"",""asdfghjkl"",""zxcvbnm""] #This list contains alphabets which are in one row of keyboard , total three rows, hence three strings
        l1=[]
		'''
		i.)We now check if all the letter in word is present in a row or not
        ii.)For instance: ""Hello""---> 'H' is in second row, hence y will be incremented by 1 and 'e' is in first row , so x will be incremented by 1
		iii.)At the end , x=2, y=z and z=0 , with none of them equal to length of word, hence we dont append it to the result
		'''
		for word in words:
            x,y,z=0,0,0
            for letter in word.lower():                        
                if letter not in l[1] and letter not in l[2]:  
				    x+=1                                                       
                elif letter not in l[0] and letter not in l[2]: # To accout for casing of words, we have used word.lower()
                    y+=1
                elif letter not in l[0] and letter not in l[1]:
                    z+=1
            if x==len(word) or y==len(word) or z==len(word):
                l1.append(word)
        return l1";"class Solucion:
    def encontrar_palabras(self, palabras):
        fila_uno = ""qwertyuiop""
        fila_dos = ""asdfghjkl""
        fila_tres = ""zxcvbnm""
        
        palabras_validas = []
        
        for palabra in palabras:
            palabra_minuscula = palabra.lower()
            
            valida_en_fila_uno = True
            for letra in palabra_minuscula:
                if letra not in fila_uno:
                    valida_en_fila_uno = False
                    break
            
            if valida_en_fila_uno:
                palabras_validas.append(palabra)
                continue

            valida_en_fila_dos = True
            for letra in palabra_minuscula:
                if letra not in fila_dos:
                    valida_en_fila_dos = False
                    break
            
            if valida_en_fila_dos:
                palabras_validas.append(palabra)
                continue

            valida_en_fila_tres = True
            for letra in palabra_minuscula:
                if letra not in fila_tres:
                    valida_en_fila_tres = False
                    break
            
            if valida_en_fila_tres:
                palabras_validas.append(palabra)

        return palabras_validas"
"class Solution {
    public int[] findErrorNums(int[] nums) {
        var st = new HashSet<Integer>(),
        int dup = Arrays.stream(nums).boxed().filter(i -> !st.add(i)).toList().get(0), n = nums.length, s = (n * (n + 1)) / 2, ts = Arrays.stream(nums).sum(),
        return new int[]{dup, s - (ts - dup)},
    }
}




python :

class Solution:
    def findErrorNums(self, nums: list[int]) -> list[int]:
        n, a, b = len(nums), sum(nums), sum(set(nums))
        s = n*(n+1)//2
        return [a-b, s-b]



C++:

vector<int> findErrorNums(vector<int>&amp, nums) {
    //sum of elements on nums
    int initialSum = accumulate(nums.begin(), nums.end(), 0),

    //put the element of nums into set to remove the duplicate number
    set<int> s,
    for(auto &amp,i: nums){
        s.insert(i),
    }

    //sum of elements of the set
    int sum = accumulate(s.begin(), s.end(), 0),

    //difference of initialSum and sum will give us the repeated number
    int repeatedNum = initialSum - sum,

    //sum of all the natural numbers from 1 to n
    int n = nums.size() + 1,

    //subtracting the sum of elements in set i.e. sum from the sum of the natural numbers will give us the missing number
    int missingNum = n * (n-1)/2 - sum,

    return {repeatedNum, missingNum},
}";"def encontrar_numeros_con_error(numeros):
    numero_duplicado = 0
    numero_faltante = 0
    n = len(numeros)

    mapa_frecuencia = {}

    for numero in numeros:
        if numero in mapa_frecuencia:
            mapa_frecuencia[numero] = mapa_frecuencia[numero] + 1
        else:
            mapa_frecuencia[numero] = 1

    for numero in numeros:
        if mapa_frecuencia[numero] == 2:
            numero_duplicado = numero
            break

    i = 1
    while i <= n:
        if i not in mapa_frecuencia:
            numero_faltante = i
            break
        i = i + 1

    resultado = [numero_duplicado, numero_faltante]
    return resultado"
"class Solution:
    def divisorGame(self, n: int) -> bool:
        #here, the state will have single parameter: current number on chalkboard!
        #Depending on current number on chalkboard, the player to make the first move
        #can either win or lose!
        
        #I will take bottom-up approach and use a dp table filling it from the most
        #trivial base case of n=1 up to original n!
        #size n+1 for indices from 0 to n, where we don't use index 0!
        dp = [None] * (n+1)
        #player who plays when 1 on board loses!
        dp[1] = False
        
        #iterate through state's parameters in inc. order to fill our dp table!
        for i in range(2, n+1, 1):
            #iterate through each and every number btw 1 and i//2 
            #we know that any number greater than i//2  can never be a factor of i!
            can_win = False
            for a in range(1, (i//2) + 1, 1):
                if(i % a == 0):
                    #if player playing at i-a number on board will lose, then
                    #current player that played first when i was on board can win
                    #since he will choose the most optimal path for him!
                    if(dp[i - a] == False):
                        can_win = True
                        break
            #once we tried all possible numbers btw 0 and i that are factors of i,
            #we check boolean flag!
            if(can_win):
                dp[i] = True
            else:
                dp[i] = False
        #since dp[n] equals True if Alice starts first and can win or False otherewise!
        return dp[n]";"def gana_alicia(n):
    if n % 2 == 0:
        resultado = True
    else:
        resultado = False
    
    return resultado"
"class Solution:
    # O(n) time,
    # O(n) space,
    # Approach: greedy, hashset
    def predictPartyVictory(self, senate: str) -> str:
        n = len(senate)
        count = Counter(senate)
        
        skip_r = 0
        skip_d = 0
        removed_r = set()
        removed_d = set()
        while count['D'] > 0 and count['R'] > 0:
            for i in range(n):
                s = senate[i]
                if s == 'R':
                    if skip_r <= 0 and i not in removed_r:
                        count['D'] -=1
                        skip_d +=1
                    else:
                        if i not in removed_r:
                            skip_r -=1
                            removed_r.add(i)
                else:
                    if skip_d <= 0 and i not in removed_d:
                        count['R'] -=1
                        skip_r +=1
                    else:
                        if i not in removed_d:
                            skip_d -=1
                            removed_d.add(i)
                        
        if count['D'] > 0:
            return 'Dire'
        else:
            return 'Radiant'";"class Solucion:
    def predecir_victoria(self, senado):
        numero_senadores = len(senado)
        
        cola_radiante = []
        cola_dire = []
        
        indice = 0
        while indice < numero_senadores:
            if senado[indice] == 'R':
                cola_radiante.append(indice)
            else:
                cola_dire.append(indice)
            indice = indice + 1

        while len(cola_radiante) > 0 and len(cola_dire) > 0:
            indice_radiante = cola_radiante.pop(0)
            indice_dire = cola_dire.pop(0)
            
            if indice_radiante < indice_dire:
                cola_radiante.append(indice_radiante + numero_senadores)
            else:
                cola_dire.append(indice_dire + numero_senadores)
                
        if len(cola_radiante) > 0:
            return ""Radiant""
        else:
            return ""Dire"""
"class Solution:
    def calculateMinimumHP(self, li: List[List[int]]) -> int:
        """"""
        Bottom Up Approach (Faster than 97% Submissions)
        Array:
            -2  -3  3
            -5 -10  1
            10  30 -5
        Working:
                      2
                      5  
               0   0  6
               
                    4+1  2
               6+0  11   5
               0.    0   6
        
               3+4    5      2
                6     11     5
                0     0      6
              
              7  5  2
              6 11  5
              0  0. 6
        """"""
        n,m = len(li), len(li[0])
        dp = [[None for i in range(m)] for i in range(n)]
        
        if li[-1][-1] >= 0:
            dp[-1][-1] = 0
        else:
            dp[-1][-1] = abs(li[-1][-1]) + 1
        
        #Populate last Column Values
        j = m-1
        for i in range(n-2,-1, -1):
            reqHealth = dp[i+1][j]
            if li[i][j] >= 0:
                cHealth = li[i][j]
                print(cHealth, reqHealth)
                if cHealth >= reqHealth:
                    dp[i][j] = 0
                else:
                    dp[i][j] = reqHealth - cHealth
            else:
                mandatoryHealthToSurvive = abs(li[i][j])+1
                cHealth = 1
                if cHealth >= reqHealth:
                    dp[i][j] = mandatoryHealthToSurvive
                else:
                    dp[i][j] = mandatoryHealthToSurvive + reqHealth - cHealth
        
        #Populate last Row Value
        i = n-1
        for j in range(m-2,-1,-1):
            reqHealth = dp[i][j+1]
            if li[i][j] >= 0:
                cHealth = li[i][j]
                if cHealth >= reqHealth:
                    dp[i][j] = 0
                else:
                    dp[i][j] = reqHealth - cHealth
            else:
                mandatoryHealthToSurvive = abs(li[i][j])+1
                cHealth = 1
                if cHealth >= reqHealth:
                    dp[i][j] = mandatoryHealthToSurvive
                else:
                    dp[i][j] = mandatoryHealthToSurvive + reqHealth - cHealth
          
        #Dp
        for i in range(n-2, -1, -1):
            for j in range(m-2, -1, -1):
                reqHealth = min(dp[i+1][j], dp[i][j+1])
                if li[i][j] >= 0:
                    cHealth = li[i][j]
                    if cHealth >= reqHealth:
                        dp[i][j] = 0
                    else:
                        dp[i][j] = reqHealth - cHealth
                else:
                    mandatoryHealthToSurvive = abs(li[i][j])+1
                    cHealth = 1
                    if cHealth >= reqHealth:
                        dp[i][j] = mandatoryHealthToSurvive
                    else:
                        dp[i][j] = mandatoryHealthToSurvive + reqHealth - cHealth
        for i in dp:
            print(i)
        return max(1, dp[0][0])";"def calcular_vida_minima(mazmorra):
    filas = len(mazmorra)
    columnas = len(mazmorra[0])

    tabla_dp = []
    valor_grande = 99999999
    
    i = 0
    while i < filas + 1:
        fila_nueva = []
        j = 0
        while j < columnas + 1:
            fila_nueva.append(valor_grande)
            j = j + 1
        tabla_dp.append(fila_nueva)
        i = i + 1

    tabla_dp[filas][columnas - 1] = 1
    tabla_dp[filas - 1][columnas] = 1

    i = filas - 1
    while i >= 0:
        j = columnas - 1
        while j >= 0:
            vida_siguiente = min(tabla_dp[i + 1][j], tabla_dp[i][j + 1])
            vida_necesaria = vida_siguiente - mazmorra[i][j]
            
            if vida_necesaria <= 0:
                tabla_dp[i][j] = 1
            else:
                tabla_dp[i][j] = vida_necesaria
            
            j = j - 1
        i = i - 1

    resultado_final = tabla_dp[0][0]
    return resultado_final"
"class Solution:
    def removeBoxes(self, boxes: List[int]) -> int:

        @cache
        def dp(l, r, count = 0):
            if l > r: return 0
            // Initial count for the letter at boxes[l]
            count += 1
            ptr = l + 1
            while ptr <= r and boxes[l] == boxes[ptr]:
                ptr += 1
                count += 1
            points = (count ** 2) + dp(ptr, r)
            for i in range(ptr + 1, r + 1):
                if boxes[l] == boxes[i]:
                    points = max(points, dp(i, r, count) + dp(ptr, i - 1))
            return points

        return dp(0, len(boxes) - 1)";"def quitar_cajas(cajas):
    n = len(cajas)
    if n == 0:
        return 0

    memo = []
    i = 0
    while i < n:
        fila = []
        j = 0
        while j < n:
            columna = []
            k = 0
            while k < n:
                columna.append(0)
                k = k + 1
            fila.append(columna)
            j = j + 1
        memo.append(fila)
        i = i + 1

    longitud = 1
    while longitud <= n:
        i = 0
        while i <= n - longitud:
            j = i + longitud - 1
            
            k_extra = 0
            while k_extra < n - longitud:

                puntos_base = (k_extra + 1) * (k_extra + 1)
                if i < j:
                    puntos_base = puntos_base + memo[i][j - 1][0]
                
                resultado = puntos_base
                
                pivote = i
                while pivote < j:
                    if cajas[pivote] == cajas[j]:
                        puntos_alternativos = memo[i][pivote][k_extra + 1]
                        if pivote + 1 <= j - 1:
                            puntos_alternativos = puntos_alternativos + memo[pivote + 1][j - 1][0]
                        
                        if puntos_alternativos > resultado:
                            resultado = puntos_alternativos
                    pivote = pivote + 1
                
                memo[i][j][k_extra] = resultado
                k_extra = k_extra + 1
            i = i + 1
        longitud = longitud + 1
        
    resultado_final = 0
    if n > 0:
        resultado_final = memo[0][n - 1][0]
        
    return resultado_final"
"class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n-1, -1, -1):
            for j in range(i, n):
                if(i == j):
                    dp[i][j] = nums[i]
                else:
                    dp[i][j] = nums[i] + self.getMax(dp, i+1,j, min(i+k, n-1, j))
        
        return dp[0][-1]
    
    def getMax(self, dp, startIndex, j, endIndex):
        x = -float(""inf"")
        for index in range(startIndex, endIndex+1):
            x = max(x, dp[index][j])
        return x";"class Solucion:
    def resultado_maximo(self, numeros, k):
        longitud = len(numeros)
        puntuaciones = [0] * longitud
        puntuaciones[0] = numeros[0]

        i = 1
        while i < longitud:
            maximo_en_ventana = -1000000001
            j = i - 1
            while j >= 0:
                if i - j > k:
                    break
                
                if puntuaciones[j] > maximo_en_ventana:
                    maximo_en_ventana = puntuaciones[j]
                
                j = j - 1
            
            puntuaciones[i] = numeros[i] + maximo_en_ventana
            i = i + 1
            
        return puntuaciones[longitud - 1]"
"class Solution(object):
    def pathSum(self, root, targetSum):
        """"""
        :type root: TreeNode
        :type targetSum: int
        :rtype: int
        """"""
        self.targetSum=targetSum
        self.hashmap={0:1}
        self.prefix=0
        self.result=0
        
        self.helper(root)
        
        return self.result
    def helper(self, root):
        
        if root is None:
            return
        
        self.prefix+=root.val
        if self.prefix-self.targetSum in self.hashmap:
            self.result+=self.hashmap[self.prefix-self.targetSum]
        
        if self.prefix in self.hashmap:
            self.hashmap[self.prefix]+=1
        else:
            self.hashmap[self.prefix]=1
            
        self.helper(root.left)
        self.helper(root.right)
        
        self.hashmap[self.prefix]-=1
        self.prefix-=root.val";"class NodoArbol:
    def __init__(self, val=0, izquierda=None, derecha=None):
        self.val = val
        self.izquierda = izquierda
        self.derecha = derecha

class Solucion:
    def numero_de_caminos(self, raiz, suma_objetivo):
        if raiz is None:
            return 0

        contador = 0
        pila = [(raiz, [])]

        while pila:
            nodo_actual, caminos_del_padre = pila.pop()

            caminos_hasta_actual = []
            for suma in caminos_del_padre:
                caminos_hasta_actual.append(suma + nodo_actual.val)
            caminos_hasta_actual.append(nodo_actual.val)
            
            for suma in caminos_hasta_actual:
                if suma == suma_objetivo:
                    contador = contador + 1

            if nodo_actual.izquierda is not None:
                pila.append((nodo_actual.izquierda, caminos_hasta_actual))
            
            if nodo_actual.derecha is not None:
                pila.append((nodo_actual.derecha, caminos_hasta_actual))

        return contador"
"class Solution:
    def maximumSwap(self, num: int) -> int:
        # larger digit to swap, digit position of this digit
        high_digit = high_pos = 0
        
        # smaller digit to swap, digit position of this digit
        low_digit = low_pos = 0
        
        # greatest digit seen so far, digit postion of this digit
        cur_high_digit, cur_high_pos = -1, 0
        
        # current digit position
        pos = 1
        
        res = num
        while num: # iterate through digits from right to left
            digit = num % 10
            
            # if digit is greatest digit yet
            if digit > cur_high_digit:
                cur_high_digit, cur_high_pos = digit, pos
            
            # if digit is less than greatest digit yet
            elif digit < cur_high_digit:
                # set the digits to swap as the greatest digit yet, and this digit
                high_digit, high_pos = cur_high_digit, cur_high_pos
                low_digit, low_pos = digit, pos
            
            pos *= 10
            num //= 10
        
        # swap the digits
        res += high_digit*(low_pos - high_pos) + low_digit*(high_pos - low_pos)
        return res";"def intercambio_maximo(num):
    cadena_numero = str(num)
    lista_caracteres = list(cadena_numero)
    longitud = len(lista_caracteres)
    numero_maximo = num

    for i in range(longitud):
        for j in range(i + 1, longitud):
            
            lista_temporal = list(lista_caracteres)
            
            caracter_temporal = lista_temporal[i]
            lista_temporal[i] = lista_temporal[j]
            lista_temporal[j] = caracter_temporal
            
            cadena_nueva = """"
            for caracter in lista_temporal:
                cadena_nueva = cadena_nueva + caracter
            
            numero_nuevo = int(cadena_nueva)
            
            if numero_nuevo > numero_maximo:
                numero_maximo = numero_nuevo
                
    return numero_maximo"
"class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:

        @cache
        def dp(x1, y1, x2):
            y2 = x1+y1-x2

            if not(0 <= x1 < len(grid) and 0 <= y1 < len(grid[0]) and 0 <= x2 < len(grid) and 0 <= y2 < len(grid[0])):
                return -float('inf')

            if grid[x1][y1] == -1 or grid [x2][y2] == -1 :
                return -float('inf')

            if x1 == len(grid)-1 and x2 == len(grid)-1 and y1 == len(grid[0])-1 and y1 == len(grid[0])-1 :
                if grid[x1][y1] == 1 :
                    return 1 
                else :
                    return 0 

            if x1 == x2 and y1 == y2 :
                if grid[x1][y1] == 1 :
                    return 1+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                else:
                    return max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
            else :
                if grid[x1][y1] == 1 and grid[x2][y2] == 1:
                    return 2+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                elif grid[x1][y1] == 1:
                    return 1+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                elif grid[x2][y2] == 1:
                    return 1+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                else:
                    return max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
        
        if dp(0,0,0) == -float('inf'):
            return 0
        else :
            return dp(0,0,0)";"class Solucion:
    def recoger_cerezas(self, cuadricula):
        n = len(cuadricula)
        
        if n == 0:
            return 0

        max_pasos = 2 * n - 2

        dp = []
        for i in range(max_pasos + 1):
            capa_paso = []
            for j in range(n):
                fila_dp = []
                for k in range(n):
                    fila_dp.append(-1)
                capa_paso.append(fila_dp)
            dp.append(capa_paso)

        dp[0][0][0] = cuadricula[0][0]

        paso = 1
        while paso <= max_pasos:
            fila1 = 0
            while fila1 < n:
                fila2 = 0
                while fila2 < n:
                    columna1 = paso - fila1
                    columna2 = paso - fila2

                    if columna1 < 0 or columna1 >= n or columna2 < 0 or columna2 >= n:
                        fila2 = fila2 + 1
                        continue
                    
                    if cuadricula[fila1][columna1] == -1 or cuadricula[fila2][columna2] == -1:
                        fila2 = fila2 + 1
                        continue
                    
                    max_previo = -1

                    # Caso 1: ambos vienen de la izquierda
                    valor_previo = dp[paso - 1][fila1][fila2]
                    if valor_previo > max_previo:
                        max_previo = valor_previo
                    
                    # Caso 2: P1 de izquierda, P2 de arriba
                    if fila2 > 0:
                        valor_previo = dp[paso - 1][fila1][fila2 - 1]
                        if valor_previo > max_previo:
                            max_previo = valor_previo

                    # Caso 3: P1 de arriba, P2 de izquierda
                    if fila1 > 0:
                        valor_previo = dp[paso - 1][fila1 - 1][fila2]
                        if valor_previo > max_previo:
                            max_previo = valor_previo

                    # Caso 4: ambos vienen de arriba
                    if fila1 > 0 and fila2 > 0:
                        valor_previo = dp[paso - 1][fila1 - 1][fila2 - 1]
                        if valor_previo > max_previo:
                            max_previo = valor_previo
                    
                    if max_previo == -1:
                        fila2 = fila2 + 1
                        continue

                    cerezas_actuales = cuadricula[fila1][columna1]
                    if fila1 != fila2:
                        cerezas_actuales = cerezas_actuales + cuadricula[fila2][columna2]
                    
                    dp[paso][fila1][fila2] = max_previo + cerezas_actuales
                    
                    fila2 = fila2 + 1
                fila1 = fila1 + 1
            paso = paso + 1

        resultado_final = dp[max_pasos][n - 1][n - 1]

        if resultado_final < 0:
            return 0
        else:
            return resultado_final"
"class Solution:
    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:
        if s[-1] == ""1"": # If last one equal to ""1"", then just return False.
            return False
        if minJump <= len(s)-1 <= maxJump: # If the first jump can reach the end point, then return True.
            return True
        # Initialize th max index of s, the current and previous start point, end point.
        Len, start, end, pre_start, pre_end = len(s), minJump, maxJump, -1, -1
        
        while True:
            if pre_start == start and pre_end == end: # If we can't go any further(we'll never reach the last index), return False.
                return False
            pre_start, pre_end = start, end # Update previous values.
            # Search next round ""0""s
            for i in range(pre_start, pre_end+1):
                # If s[i] equals ""0"", then we can jump
                # and make sure that at least one ""0"" in the range if we jump from index i.
                if s[i] == ""0"" and ""0"" in s[i + minJump:i + maxJump + 1]:
                    if start <= pre_end: # Update start point to a minimum value that greater than previous end point.
                        start = i + minJump
                    end = i + maxJump # Update end point to the maximum of this round.
                    if start <= Len-1 <= end: # If the start and end points contain the last index, return True.
                        return True";"class Solucion:
    def puede_alcanzar(self, s, salto_minimo, salto_maximo):
        longitud = len(s)
        
        if s[0] == '1':
            return False

        alcanzable = [False] * longitud
        alcanzable[0] = True
        
        posiciones_previas_alcanzables = 0
        
        i = 1
        while i < longitud:
            if i >= salto_minimo:
                if alcanzable[i - salto_minimo] == True:
                    posiciones_previas_alcanzables = posiciones_previas_alcanzables + 1
            
            if i > salto_maximo:
                if alcanzable[i - salto_maximo - 1] == True:
                    posiciones_previas_alcanzables = posiciones_previas_alcanzables - 1
            
            if s[i] == '0' and posiciones_previas_alcanzables > 0:
                alcanzable[i] = True
            
            i = i + 1
            
        return alcanzable[longitud - 1]"
"class Solution:
    def stoneGameVI(self, alice: List[int], bob: List[int]) -> int:
        n = len(alice)
        arr = [alice[i] + bob[i] for i in range(n)]
        s = sum(bob)
        res = 0
        k = (n+1)//2
        arr.sort(reverse=True)
        for i in range(0, n, 2):
            res += arr[i]
        
        
        if res > s:
            return 1
        elif res == s:
            return 0 
        else:
            return -1";"class Solucion:
    def juegoDePiedras(self, valores_alicia, valores_bob):
        numero_de_piedras = len(valores_alicia)
        
        piedras_con_valor_total = []
        for i in range(numero_de_piedras):
            valor_total = valores_alicia[i] + valores_bob[i]
            info_piedra = [valor_total, valores_alicia[i], valores_bob[i]]
            piedras_con_valor_total.append(info_piedra)
            
        n = len(piedras_con_valor_total)
        intercambio = True
        while intercambio:
            intercambio = False
            for i in range(n - 1):
                if piedras_con_valor_total[i][0] < piedras_con_valor_total[i+1][0]:
                    temporal = piedras_con_valor_total[i]
                    piedras_con_valor_total[i] = piedras_con_valor_total[i+1]
                    piedras_con_valor_total[i+1] = temporal
                    intercambio = True
                    
        puntos_alicia = 0
        puntos_bob = 0
        
        for i in range(numero_de_piedras):
            piedra_actual = piedras_con_valor_total[i]
            
            es_turno_de_alicia = (i % 2 == 0)
            
            if es_turno_de_alicia:
                puntos_alicia = puntos_alicia + piedra_actual[1]
            else:
                puntos_bob = puntos_bob + piedra_actual[2]
                
        if puntos_alicia > puntos_bob:
            return 1
        elif puntos_bob > puntos_alicia:
            return -1
        else:
            return 0"
"class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        
        # Sorting method
        # Time: O(nlogn) Space: O(1)
        
        # Here, we'll simply sort the list and then check if the next element == current element
        # if yes, then we'll continue
        # else we'll return the element
        
        if len(nums) == 1:
            return nums[0]
        nums.sort()
        for i in range(1,len(nums),2):
            if nums[i] != nums[i-1]:
                return nums[i-1]
        return nums[len(nums)-1]
    
    
        # Using Dictionary
        # Time: O(n) Space:O(n)
        
        # Here, we'll simply traverse through the list and 
        # insert the element and it's count as (key,value) pair
        # then we'll start iterating through the dictionary 
        # and if we find any element having count 1
        # we'll return the element
        
        res = {}
        for el in nums:
            if el in res:
                res[el] += 1
            else:
                res[el] = 1
        for key in res.keys():
            if res[key] == 1:
                return key
        
        
        # XOR method
        # Time: O(n) Space: O(1)
        
        # If you know how XOR operation works then it's pretty straight forward for you.
        
        for i in range(1,len(nums)):
            nums[0] ^= nums[i]
        return nums[0]";"def encontrar_numero_unico(lista_de_numeros):
    numero_aislado = 0
    for numero in lista_de_numeros:
        numero_aislado = numero_aislado ^ numero
    return numero_aislado"
"class Solution:
    #n = len(arr)
    #Time-Complexity: O(n), in worst case we visit each and every index position and finds out
    #there's no indices with integer 0 !
    #Space-Complexity: O(n + n), by same argument as T.C! -> O(n)
    def canReach(self, arr: List[int], start: int) -> bool:
        #We can model this as a general directed graph problem!
        #If we are at node i(at position index i), we can either
        #jump to two descendants: arr[i] + i or arr[i] - i!
        
        #We will only add to queue index positions not already visited
        #and in-bounds!
        visited = set()
        q = collections.deque()
        q.append(start)
        visited.add(start)
        #as long as queue is not empty, keep bfs going!
        while q:
            cur_index = q.popleft()
            #check if at current index has value 0! If so, immediately
            #break and return True
            if(arr[cur_index] == 0):
                return True
            #otherwise, process the two descendants and only add to queue
            #if it's not already visited and is in-bounds!
            neighbor1 = arr[cur_index] + cur_index
            neighbor2 = cur_index - arr[cur_index]
            if(neighbor1 not in visited and 0<=neighbor1 < len(arr)):
                q.append(neighbor1)
                visited.add(neighbor1)
            if(neighbor2 not in visited and 0<=neighbor2 < len(arr)):
                q.append(neighbor2)
                visited.add(neighbor2)
        
        #once bfs is over, we tried every possible path from start!
        #could not reach index position with value of 0!
        return False";"def puede_llegar_a_cero(arr, inicio):
    longitud_arreglo = len(arr)
    
    if inicio < 0 or inicio >= longitud_arreglo:
        return False

    cola_de_indices = []
    cola_de_indices.append(inicio)

    visitados = []
    for i in range(longitud_arreglo):
        visitados.append(False)
    
    visitados[inicio] = True

    cabeza_de_cola = 0
    while cabeza_de_cola < len(cola_de_indices):
        indice_actual = cola_de_indices[cabeza_de_cola]
        cabeza_de_cola = cabeza_de_cola + 1

        if arr[indice_actual] == 0:
            return True

        salto_adelante = indice_actual + arr[indice_actual]
        if salto_adelante < longitud_arreglo:
            if not visitados[salto_adelante]:
                visitados[salto_adelante] = True
                cola_de_indices.append(salto_adelante)

        salto_atras = indice_actual - arr[indice_actual]
        if salto_atras >= 0:
            if not visitados[salto_atras]:
                visitados[salto_atras] = True
                cola_de_indices.append(salto_atras)

    return False"
"# Binary Search Tree Solution -> If exact matching of intervals found then return False
#                                Else you can add this interval to that particular node's left or right
class Node:
    def __init__(self, s, e):
        self.s = s
        self.e = e
        self.left = None
        self.right = None
class MyCalendar:
    def __init__(self):
        self.head = None
        
    def insert(self, s, e, node):
        if s >= node.e:
            if node.right: return self.insert(s, e, node.right)
            else: 
                nn = Node(s, e)
                node.right = nn
                return True
        elif e <= node.s:
            if node.left: return self.insert(s, e, node.left)
            else:
                nn = Node(s, e)
                node.left = nn
                return True
        else: return False
        
    def book(self, s: int, e: int) -> bool:
        if self.head == None:
            nn = Node(s, e)
            self.head = nn
            return True
        return self.insert(s, e, self.head)";"class MiCalendario:
    def __init__(self):
        self.eventos = []

    def reservar(self, inicio, fin):
        for evento_existente in self.eventos:
            inicio_existente = evento_existente[0]
            fin_existente = evento_existente[1]
            
            if inicio < fin_existente and inicio_existente < fin:
                return False
        
        nuevo_evento = [inicio, fin]
        self.eventos.append(nuevo_evento)
        return True"
"class Solution:
    def reformatDate(self, date: str) -> str:
        
        month_dict = {
            'Jan':'01', 'Feb':'02', 'Mar':'03', 'Apr':'04', 'May':'05', 'Jun':'06',
            'Jul':'07', 'Aug':'08', 'Sep':'09', 'Oct':'10', 'Nov':'11', 'Dec':'12',
        }
        
        date_list = date.split()
        
        #defining empty string
        date_string = ''
        
        #year
        date_string = date_string + date_list[2] + '-' 
        
        #month
        date_string = date_string + month_dict[date_list[1]] + '-'
        
        #day
        date_day = [x for x in date_list[0] if not x.isalpha()]
        date_day_digits = ''.join(date_day)
        if len(date_day_digits) == 1:
            date_string = date_string+'0'+date_day_digits
        else:
            date_string = date_string+date_day_digits
        
        
        return date_string
        # date_String = date_string + date_list[]";"def convertir_fecha(fecha_cadena):
    partes = fecha_cadena.split(' ')
    dia_con_sufijo = partes[0]
    mes_abreviado = partes[1]
    anio = partes[2]

    dia_numerico_cadena = """"
    for caracter in dia_con_sufijo:
        if caracter.isdigit():
            dia_numerico_cadena = dia_numerico_cadena + caracter
    
    dia_formateado = """"
    if len(dia_numerico_cadena) == 1:
        dia_formateado = ""0"" + dia_numerico_cadena
    else:
        dia_formateado = dia_numerico_cadena

    mes_formateado = """"
    if mes_abreviado == ""Jan"":
        mes_formateado = ""01""
    elif mes_abreviado == ""Feb"":
        mes_formateado = ""02""
    elif mes_abreviado == ""Mar"":
        mes_formateado = ""03""
    elif mes_abreviado == ""Apr"":
        mes_formateado = ""04""
    elif mes_abreviado == ""May"":
        mes_formateado = ""05""
    elif mes_abreviado == ""Jun"":
        mes_formateado = ""06""
    elif mes_abreviado == ""Jul"":
        mes_formateado = ""07""
    elif mes_abreviado == ""Aug"":
        mes_formateado = ""08""
    elif mes_abreviado == ""Sep"":
        mes_formateado = ""09""
    elif mes_abreviado == ""Oct"":
        mes_formateado = ""10""
    elif mes_abreviado == ""Nov"":
        mes_formateado = ""11""
    elif mes_abreviado == ""Dec"":
        mes_formateado = ""12""
        
    fecha_resultado = anio + ""-"" + mes_formateado + ""-"" + dia_formateado
    
    return fecha_resultado"
"class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        trie=Trie()
        out=[]
        words=sentence.split("" "")
        for word in dictionary:
            trie.insert(word)
        for word in words:
            out.append(trie.transfer(word))
        return "" "".join(out)
        

class TrieNode(object):
        def __init__(self):
            self.children = {}
            self.isWord = False
class Trie:

    def __init__(self):
        self.root = TrieNode()
    def insert(self, word: str) -> None:
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.isWord = True
    def transfer(self, successor: str) -> bool:
        node = self.root
        out=""""
        for char in successor:
            if node.isWord:
                return out
            if char not in node.children:
                return successor
            out+=char
            node = node.children[char]
        return successor";"class Solucion:
    def reemplazar_palabras(self, diccionario, oracion):
        conjunto_raices = set(diccionario)
        palabras_de_la_oracion = oracion.split(' ')
        
        nueva_lista_de_palabras = []
        
        for palabra in palabras_de_la_oracion:
            raiz_reemplazo = """"
            
            # Iteramos sobre los posibles prefijos de la palabra
            # desde el más corto hasta el más largo
            longitud_palabra = len(palabra)
            i = 1
            while i <= longitud_palabra:
                prefijo = palabra[0:i]
                if prefijo in conjunto_raices:
                    # Encontramos la raíz más corta posible, la guardamos y salimos del bucle
                    raiz_reemplazo = prefijo
                    break
                i = i + 1
                
            # Si encontramos una raíz, la usamos. Si no, usamos la palabra original.
            if raiz_reemplazo != """":
                nueva_lista_de_palabras.append(raiz_reemplazo)
            else:
                nueva_lista_de_palabras.append(palabra)
                
        # Unimos la nueva lista de palabras para formar la oración final
        oracion_resultado = "" "".join(nueva_lista_de_palabras)
        
        return oracion_resultado"
"class Solution:
    def containVirus(self, mat: List[List[int]]) -> int:
        m,n = len(mat),len(mat[0])

        def dfs(i,j,visited,nextInfected):  # return no. of walls require to quarantined dfs area
            if 0<=i<m and 0<=j<n and (i,j) not in visited:
                if mat[i][j]==2: # Already quarantined cell
                    return 0
                if mat[i][j]==0:
                    nextInfected.add((i,j)) # add cell which will be infected next day
                    return 1   # require one wall to quarantined cell from one side
                    
                else:
                    visited.add((i,j))
                    return dfs(i-1,j,visited,nextInfected) + dfs(i+1,j,visited,nextInfected) + dfs(i,j-1,visited,nextInfected) + dfs(i,j+1,visited,nextInfected)  # traverse all four direction
            else:
                return 0
				
        ans = 0 
        while True:   # this loop running ""how many days we should installing the walls"" times
            # For every day check which area infect more cells
            visited = set()  # Using in dfs
            All_nextinfect  = set()
            stop , walls = set(),0   # here stop store the indices of maximum no. of cells in which we stop spreading of virus this day
            
            for i in range(m):
                for j in range(n):
                    if mat[i][j]==1 and (i,j) not in visited:
                        nextInfected = set()
                        a = dfs(i,j,visited,nextInfected)
                        
                        if len(stop)<len(nextInfected):
                            All_nextinfect  = All_nextinfect | stop # leave previous saved area from virus
                            stop = nextInfected  # pick new area which we want to save
                            walls = a  # require walls
                            p,q = i,j  # starting position(indices) of this area
                        else:
                            All_nextinfect  = All_nextinfect | nextInfected   
                            
            if not stop : # if our job is done i.e. No cell will be infect Later
                break
            ans += walls  # add new walls installed this day
            
            # change each cell value to 2 which will be covered by quarantined area
            def fun(p,q):
                if 0<=p<m and 0<=q<n and mat[p][q]==1:
                    mat[p][q]=2
                    fun(p+1,q)
                    fun(p-1,q)
                    fun(p,q-1)
                    fun(p,q+1)
            fun(p,q) # start dfs from start point of quarantined area
            
            for a,b in All_nextinfect: # set new infected cell value = 1 for iterating next day
                mat[a][b] = 1

        return ans   # Final answer";"def cuarentena_viral(rejilla_infectada):
    if not rejilla_infectada:
        return 0
    if not rejilla_infectada[0]:
        return 0

    filas = len(rejilla_infectada)
    columnas = len(rejilla_infectada[0])
    total_muros = 0

    while True:
        regiones = []
        visitado = []
        
        fila_indice = 0
        while fila_indice < filas:
            fila_visitada = []
            col_indice = 0
            while col_indice < columnas:
                fila_visitada.append(False)
                col_indice = col_indice + 1
            visitado.append(fila_visitada)
            fila_indice = fila_indice + 1

        f = 0
        while f < filas:
            c = 0
            while c < columnas:
                if rejilla_infectada[f][c] == 1 and not visitado[f][c]:
                    region_actual = []
                    frontera_actual = set()
                    muros_region = 0
                    
                    pila_para_buscar = []
                    pila_para_buscar.append((f, c))
                    visitado[f][c] = True

                    while len(pila_para_buscar) > 0:
                        coordenada_actual = pila_para_buscar.pop()
                        fila_actual = coordenada_actual[0]
                        col_actual = coordenada_actual[1]
                        
                        region_actual.append((fila_actual, col_actual))

                        direcciones = [(0, 1), (0, -1), (1, 0), (-1, 0)]
                        
                        indice_dir = 0
                        while indice_dir < len(direcciones):
                            direccion = direcciones[indice_dir]
                            df = direccion[0]
                            dc = direccion[1]
                            
                            vecino_f = fila_actual + df
                            vecino_c = col_actual + dc

                            if 0 <= vecino_f < filas and 0 <= vecino_c < columnas:
                                if rejilla_infectada[vecino_f][vecino_c] == 0:
                                    frontera_actual.add((vecino_f, vecino_c))
                                    muros_region = muros_region + 1
                                elif rejilla_infectada[vecino_f][vecino_c] == 1 and not visitado[vecino_f][vecino_c]:
                                    visitado[vecino_f][vecino_c] = True
                                    pila_para_buscar.append((vecino_f, vecino_c))
                            indice_dir = indice_dir + 1
                    
                    if len(region_actual) > 0:
                        info_region = (region_actual, frontera_actual, muros_region)
                        regiones.append(info_region)
                c = c + 1
            f = f + 1

        if not regiones:
            break

        indice_region_mas_amenazante = -1
        max_amenaza = -1
        
        contador_indice = 0
        while contador_indice < len(regiones):
            region_info = regiones[contador_indice]
            frontera_a_infectar = region_info[1]
            tamano_amenaza = len(frontera_a_infectar)
            if tamano_amenaza > max_amenaza:
                max_amenaza = tamano_amenaza
                indice_region_mas_amenazante = contador_indice
            contador_indice = contador_indice + 1
        
        region_a_contener_info = regiones[indice_region_mas_amenazante]
        celdas_a_contener = region_a_contener_info[0]
        muros_a_construir = region_a_contener_info[2]
        total_muros = total_muros + muros_a_construir

        indice_celda = 0
        while indice_celda < len(celdas_a_contener):
            celda = celdas_a_contener[indice_celda]
            f_celda = celda[0]
            c_celda = celda[1]
            rejilla_infectada[f_celda][c_celda] = -1
            indice_celda = indice_celda + 1

        contador_indice = 0
        while contador_indice < len(regiones):
            if contador_indice != indice_region_mas_amenazante:
                region_info = regiones[contador_indice]
                frontera_a_infectar = region_info[1]
                
                lista_frontera = list(frontera_a_infectar)
                indice_frontera = 0
                while indice_frontera < len(lista_frontera):
                    celda_frontera = lista_frontera[indice_frontera]
                    f_celda = celda_frontera[0]
                    c_celda = celda_frontera[1]
                    rejilla_infectada[f_celda][c_celda] = 1
                    indice_frontera = indice_frontera + 1
                    
            contador_indice = contador_indice + 1

    return total_muros"
"class Solution:
    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:
        #Let len(richer) = n and let len(quiet) = m!
        #Time: O(n + m + m + m*m + m +  m) -> O(m^2 + n)
        #Space: O(m*m + m + m + m*m + m) -> O(m^2)
        #step 1: build adjacency list representation and update indegrees of every node initially!
        adj = [[] for _ in range(len(quiet))]
        indegrees = [0] * len(quiet)
        #we want edges to go from richer to poorer so that ancestors of every node are all people
        #who have more money than the node person!
        for rel in richer:
            richer, poorer = rel[0], rel[1]
            adj[richer].append(poorer)
            indegrees[poorer] += 1
        
        queue = deque()
        ancestors = []
        for i in range(len(quiet)):
            new = set()
            new.add(i)
            ancestors.append(new)
        #step 2: fill in the queue all nodes that have indegrees of 0!

        #step 3: proceeding with Kahn's algorithm and recording list of all ancestors to every node!
        while queue:
            cur = queue.pop()
            for neighbor in adj[cur]:
                ancestors[neighbor].add(cur)
                ancestors[neighbor].update(ancestors[cur])
                indegrees[neighbor] -= 1
                if(indegrees[neighbor] == 0):
                    queue.append(neighbor)
        
        ancestors = [list(s) for s in ancestors]
        output = []
        #step 4:for each person, find the least quiet person who also has more money than the current               #person we're iterating on!
        for a in range(len(ancestors)):
            cur_ancestors = ancestors[a]
            if(len(cur_ancestors) == 1):
                output.append(a)
                continue
            minimum = cur_ancestors[0]
            for ancestor in cur_ancestors:
                #check if current person with more money than person a has lower quiet level!
                if(quiet[ancestor] < quiet[minimum]):
                    minimum = ancestor
            output.append(minimum)
        return output";"def resolver(mas_ricos, tranquilidad):
    numero_personas = len(tranquilidad)
    
    respuesta = []
    i = 0
    while i < numero_personas:
        respuesta.append(i)
        i = i + 1

    contador = 0
    while contador < numero_personas:
        for relacion in mas_ricos:
            persona_rica = relacion[0]
            persona_pobre = relacion[1]
            
            if tranquilidad[respuesta[persona_rica]] < tranquilidad[respuesta[persona_pobre]]:
                respuesta[persona_pobre] = respuesta[persona_rica]
        
        contador = contador + 1
                
    return respuesta"
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        
        # Using the ITERATIVE APPROACH with O(logn)
        
        '''
        Step-by-step Binary Search Algorithm: We basically ignore half of the elements just after one comparison.

        1. Compare x with the middle element.
        2. If x matches with the middle element, we return the mid index.
        3. Else If x is greater than the mid element, then x can only lie in the right half subarray after the mid element. So we recur for the right half.
        4. Else (x is smaller) recur for the left half.    
        
        '''
        
        # Two containers
        low_value  = 0              # Index of first element    
        high_value = len(nums) - 1  # Index of last element
        
        while low_value <= high_value:                  # check if the �high_value� is higher than the �low_value�
            middle_value = (low_value + high_value)//2  # middle index of our list which will be the floor of the average of �high_value� plus �low_value�
            
            if nums[middle_value] == target:    # check if the middle element and the target are equal 
                return middle_value             # If they are equal, the position of the item will be returned
            
            if target < nums[middle_value]:     # check if the middle element is less than the item to be searched
                
                high_value = middle_value - 1   # the new position will shift to the right once.
                
            else:                               # check if the value of the last index is greater than or equal to the value of the first index
                                                
                low_value = middle_value + 1    #  the new position will shift to the left once
                     
        return -1  # If the target is not in the list, it will return a statement";"def buscar(numeros, objetivo):
    izquierda = 0
    derecha = len(numeros) - 1

    while izquierda <= derecha:
        medio = (izquierda + derecha) // 2
        valor_en_medio = numeros[medio]

        if valor_en_medio == objetivo:
            return medio
        
        if valor_en_medio < objetivo:
            izquierda = medio + 1
        else:
            derecha = medio - 1
            
    return -1"
"class Solution:
    def stoneGameVII(self, stones: List[int]) -> int:
        dp = [[0 for _ in range(len(stones))] for _ in range(len(stones))]     # dp table n x n
        run_sum = [0]                            # running sum -> sum [i..j] = run_sum[j] - run_sum[i]
        s = 0
        
		## Calculation of running sum
        for i in stones:
            s += i
            run_sum.append(s)
		
        n = len(stones) 
        
        for k in range(1, n):               # no. of stones left
            for i in range(0, n - k):   # from each starting point
                remove_i_stone = (run_sum[i+k+1] - run_sum[i+1])    # score after removing i th stone
                remove_j_stone = (run_sum[i+k] - run_sum[i])             # score after removing j th stone
                
                if (n-(k+1))%2 == 0:        # alice's move 
                    dp[i][i+k] = max(remove_i_stone + dp[i+1][i+k],
                                    remove_j_stone + dp[i][i+k-1])
                else:                       # bob's move
                    dp[i][i+k] = min(-remove_i_stone + dp[i+1][i+k],
                                    - remove_j_stone + dp[i][i+k-1])
                    
        return dp[0][n - 1]";"class Solucion:
    def diferencia_puntuacion(self, piedras):
        numero_de_piedras = len(piedras)

        if numero_de_piedras == 0:
            return 0

        tabla_dp = []
        for i in range(numero_de_piedras):
            fila = []
            for j in range(numero_de_piedras):
                fila.append(0)
            tabla_dp.append(fila)

        sumas_parciales = []
        for i in range(numero_de_piedras + 1):
            sumas_parciales.append(0)
        
        suma_acumulada = 0
        for i in range(numero_de_piedras):
            suma_acumulada = suma_acumulada + piedras[i]
            sumas_parciales[i + 1] = suma_acumulada
        
        longitud = 2
        while longitud <= numero_de_piedras:
            i = 0
            while i <= numero_de_piedras - longitud:
                j = i + longitud - 1
                
                suma_opcion_izquierda = sumas_parciales[j + 1] - sumas_parciales[i + 1]
                resultado_opcion_izquierda = suma_opcion_izquierda - tabla_dp[i + 1][j]
                
                suma_opcion_derecha = sumas_parciales[j] - sumas_parciales[i]
                resultado_opcion_derecha = suma_opcion_derecha - tabla_dp[i][j - 1]
                
                if resultado_opcion_izquierda > resultado_opcion_derecha:
                    tabla_dp[i][j] = resultado_opcion_izquierda
                else:
                    tabla_dp[i][j] = resultado_opcion_derecha
                
                i = i + 1
            longitud = longitud + 1
            
        resultado_final = tabla_dp[0][numero_de_piedras - 1]
        return resultado_final"
"# Linked List Solution
class MyHashSet(object):
    
    def __init__(self):
        self.keyRange = 769
        self.bucketArray = [LinkedList() for i in range(self.keyRange)]
        
    def _hash(self, key):
        return key % self.keyRange
    
    def add(self, key):
        bucketIndex = self._hash(key)
        self.bucketArray[bucketIndex].append(key)
        
    def remove(self, key):
        bucketIndex = self._hash(key)
        self.bucketArray[bucketIndex].deleteNodeKeyAll(key)
        # while self.bucketArray[bucketIndex].search(key):
        #     self.bucketArray[bucketIndex].deleteNodeKeyOne(key)
        
    def contains(self, key):
        bucketIndex = self._hash(key)
        return self.bucketArray[bucketIndex].search(key)
    
# ---------------------------------------------------------
## Define a linked list

class Node:
    
    def __init__(self, val, next = None):
        self.val = val
        self.next = next
        
class LinkedList:
    
    def __init__(self):
        self.head = None

# ---------------------------------------------------------
## Insert a new node

### Insert the new node at the front of the linked list
    def push(self, new_val):
        new_node = Node(new_val)
        new_node.next = self.head
        self.head = new_node
        
### Insert the new node at the end of the linked list
    def append(self, new_val):
        new_node = Node(new_val)
        if self.head is None:
            self.head = new_node
            return
        # Traverse till the end of the linked list
        last = self.head
        while last.next:
            last = last.next
        last.next = new_node

### Insert the new node after a given node
    def insertAfter(self, new_val, prev_node):
        if prev_node is None:
            print(""Please enter the node which is the previous node of the inserted node."")
            return
        new_node = Node(new_val)
        new_node.next = prev_node.next
        prev_node.next = new_node
        
# ---------------------------------------------------------
## Delete a node

### Delete a node by value
# Iterative Method
    def deleteNodeKeyOne(self, key): # delete a single node
        temp = self.head
        if temp is None:
            return
        if temp.val == key:
            self.head = temp.next
            temp = None
            return
        while temp is not None:
            if temp.val == key:
                break
            prev = temp
            temp = temp.next
        if temp is None:
            return
        prev.next = temp.next
        temp = None
        
    def deleteNodeKeyAll(self, key): # delete all the nodes with value key
        temp = self.head
        if temp is None:
            return
        while temp.val == key:
            deletedNode = temp
            self.head = temp.next
            temp = self.head
            deletedNode = None
            if temp is None:
                return
        nxt = temp.next
        while nxt is not None:
            if nxt.val == key:
                deletedNode = nxt
                temp.next = nxt.next
                deletedNode = None
            temp = nxt
            nxt = nxt.next

### Delete a node by position and return the value of the deleted node
    def deleteNodePosition(self, position):
        if self.head is None:
            return
        if position == 0:
            temp = self.head
            self.head = self.head.next
            temp = None
            return
        idx = 0
        current = self.head
        prev = self.head
        nxt = self.head
        while current is not None:
            if idx == position:
                nxt = current.next
                break
            prev = current
            current = current.next
            idx += 1
        prev.next = nxt
        current = None
        
# ---------------------------------------------------------
# Print a linked list
    def printList(self):
        temp = self.head
        while temp:
            print ("" %d"" %(temp.val))
            temp = temp.next

# ---------------------------------------------------------
## Search an element in a linked list
    def search(self, x):
        current = self.head
        while current is not None:
            if current.val == x:
                return True
            current = current.next
        return False";"class MiConjuntoHash:
    def __init__(self):
        self.tamano_tabla = 1000
        self.tabla = []
        for i in range(self.tamano_tabla):
            self.tabla.append([])

    def agregar(self, clave):
        indice_hash = clave % self.tamano_tabla
        cubeta = self.tabla[indice_hash]
        
        clave_existe = False
        for elemento in cubeta:
            if elemento == clave:
                clave_existe = True
                break
        
        if not clave_existe:
            cubeta.append(clave)

    def eliminar(self, clave):
        indice_hash = clave % self.tamano_tabla
        cubeta = self.tabla[indice_hash]
        
        nueva_cubeta = []
        for elemento in cubeta:
            if elemento != clave:
                nueva_cubeta.append(elemento)
        
        self.tabla[indice_hash] = nueva_cubeta

    def contiene(self, clave):
        indice_hash = clave % self.tamano_tabla
        cubeta = self.tabla[indice_hash]
        
        for elemento in cubeta:
            if elemento == clave:
                return True
                
        return False"
"class Solution:
    def reachNumber(self, target: int) -> int:
        def gaussSum(n):
            return n*(n+1)//2
        
        def binaryFind(lower, upper):
            t = abs(target)
            sums, n = -1, -1
            while lower <= upper:
                mid = (lower+upper)//2
                if gaussSum(mid) >= t:
                    sums, n = gaussSum(mid), mid
                    upper = mid-1
                else:
                    lower = mid+1
            return sums, n
        
                    
        lower, upper = 0, 10**5
        # find min n s.t. 1+2+...+n>=abs(target)
        sums, n = binaryFind(lower, upper)
        while sums%2 != abs(target)%2:
            sums += n+1
            n += 1
        return n";"class Solucion:
    def alcance_objetivo(self, objetivo: int) -> int:
        
        objetivo_positivo = objetivo
        if objetivo_positivo < 0:
            objetivo_positivo = -objetivo_positivo

        movimientos = 0
        suma = 0

        while True:
            movimientos = movimientos + 1
            suma = suma + movimientos
            
            if suma >= objetivo_positivo:
                diferencia = suma - objetivo_positivo
                if diferencia % 2 == 0:
                    break
        
        return movimientos"
"class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        sortedList = sorted(nums)
        n = len(nums)
        if n%2==0:
            small = sortedList[:((n//2))][::-1]
            large = (sortedList[(n//2):])[::-1]
            for i in range(1,n,2):
                nums[i] = large[i//2]
            for i in range(0,n,2):
                nums[i] = small[i//2]
        else:
            small = sortedList[:1+((n//2))][::-1]
            large = (sortedList[1+(n//2):])[::-1]
            for i in range(1,n,2):
                nums[i] = large[i//2]
            for i in range(0,n,2):
                nums[i] = small[i//2]";"def ordenar_en_zigzag(numeros):
    numeros.sort()
    
    indice = 1
    longitud = len(numeros)
    
    while indice < longitud - 1:
        temporal = numeros[indice]
        numeros[indice] = numeros[indice + 1]
        numeros[indice + 1] = temporal
        
        indice = indice + 2"
"class Solution:
    def rotatedDigits(self, N: int) -> int:
        smallSet = {0,1,8}
        bigSet = {2,5,6,9}
        smallNum = [0,0,1,1,1,2,3,3,3,4][N % 10]
        bigNum = [1,2,3,3,3,4,5,5,6,7][N % 10]
        N = N // 10
        smInc, bgInc = 4, 7
        while N:
            x = N % 10
            N = N // 10
            sm, bg = 0, 0
            for i in range(x):
                if i in smallSet:
                    sm += smInc
                    bg += bgInc
                elif i in bigSet:
                    sm += bgInc
                    bg += bgInc
            if x in smallSet:
                smallNum += sm
                bigNum += bg
            elif x in bigSet:
                smallNum = bigNum + sm
                bigNum += bg
            else:
                smallNum = sm
                bigNum = bg
            smInc, bgInc = 4*bgInc + 3*smInc, bgInc * 7
        return smallNum";"class Solucion:
    def numeros_buenos_rotados(self, n):
        contador_buenos = 0
        for numero_actual in range(1, n + 1):
            cadena_del_numero = str(numero_actual)
            
            es_valido = True
            es_diferente = False
            
            for digito in cadena_del_numero:
                if digito == '3' or digito == '4' or digito == '7':
                    es_valido = False
                    break
                
                if digito == '2' or digito == '5' or digito == '6' or digito == '9':
                    es_diferente = True
            
            if es_valido and es_diferente:
                contador_buenos = contador_buenos + 1
                
        return contador_buenos"
"class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:

		""Edge Case checking""
        
        if endWord not in wordList:
            return []
        
        size = len(beginWord)
        
        
        ""create llokup got all the possible wordpatters""
        
        lookup = defaultdict(list)                                  
        
        for word in wordList:                                     
            for i in range(size):
                lookup[word[:i] + ""*"" + word[i+1:]].append(word)    
        
        cur_len = 9999
        
        ans = []      
        
        ""enter the first element in the queue""
        
        queue =  collections.deque([[beginWord, 1,[beginWord]]])
        
        visited = {beginWord: True}
        
        while(queue):
            
            currWord, pathLength,words_till_now = queue.popleft()
            
            """"""
            instead of marking an elemnt vistied , when we insert it in the queue,
            we mark it as visited only when we pop and element
            this way , same word can be used by other curWords
            <ex :>
            ""red""
            ""tax""
            [""ted"",""tex"",""red"",""tax"",""tad"",""den"",""rex"",""pee""]                        
            and we make sure that element can not be used again           
            """"""
            visited[currWord] = True
            
            """"""
            run a for loop for all values for all the possible patterns for the popped word
            """"""
            
            for i in range(size):
                
                possibleWordPattern = currWord[:i] + ""*"" + currWord[i+1:]
                
                for word in lookup[possibleWordPattern]:            
                    
                    if(currWord == word):
                        continue
                    
                    """"""
                    if the word for the possibleWordPattern key matches with the end word we add it to the 
                    ans list
                    """"""
                        
                    if(word == endWord):                                                    
                        
                        if cur_len == pathLength + 1:
                                                    
                            ans.append(words_till_now+[word])
                        elif cur_len > pathLength + 1:
                            
                            ans = [words_till_now+[word]]
                            
                            cur_len = pathLength + 1
                    
                    if(word not in visited):                        
                        queue.append([word, pathLength + 1,words_till_now+[word]])
        
        return ans";"def encontrar_escaleras(palabra_inicio, palabra_fin, lista_palabras):
    cola = []
    camino_inicial = [palabra_inicio]
    cola.append(camino_inicial)

    resultados = []
    
    palabras_visitadas = []
    palabras_visitadas.append(palabra_inicio)

    longitud_palabra = len(palabra_inicio)
    
    while len(cola) > 0:
        tamano_del_nivel = len(cola)
        visitadas_en_este_nivel = []
        
        for i in range(tamano_del_nivel):
            camino_actual = cola.pop(0)
            ultima_palabra = camino_actual[len(camino_actual) - 1]

            lista_de_letras = []
            for letra in ultima_palabra:
                lista_de_letras.append(letra)
            
            for j in range(longitud_palabra):
                letra_original = lista_de_letras[j]
                
                # Iterar a través del alfabeto
                alfabeto = ""abcdefghijklmnopqrstuvwxyz""
                for caracter in alfabeto:
                    lista_de_letras[j] = caracter
                    
                    palabra_nueva = """"
                    for letra in lista_de_letras:
                        palabra_nueva = palabra_nueva + letra

                    esta_en_la_lista = False
                    for p in lista_palabras:
                        if p == palabra_nueva:
                            esta_en_la_lista = True
                            break
                    
                    fue_visitada = False
                    for p_visitada in palabras_visitadas:
                        if p_visitada == palabra_nueva:
                            fue_visitada = True
                            break
                            
                    if esta_en_la_lista and not fue_visitada:
                        nuevo_camino = []
                        for palabra_en_camino in camino_actual:
                            nuevo_camino.append(palabra_en_camino)
                        nuevo_camino.append(palabra_nueva)
                        
                        if palabra_nueva == palabra_fin:
                            resultados.append(nuevo_camino)
                        else:
                            cola.append(nuevo_camino)
                        
                        esta_en_visitadas_nivel = False
                        for p_visitada_nivel in visitadas_en_este_nivel:
                            if p_visitada_nivel == palabra_nueva:
                                esta_en_visitadas_nivel = True
                                break
                        if not esta_en_visitadas_nivel:
                            visitadas_en_este_nivel.append(palabra_nueva)

                lista_de_letras[j] = letra_original
        
        if len(resultados) > 0:
            return resultados
        
        for palabra_a_agregar in visitadas_en_este_nivel:
            palabras_visitadas.append(palabra_a_agregar)
            
    return resultados"
"class Solution:
    def numDecodings(self, s: str) -> int:
        non_zero = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
        first_incl, second_incl = 1, 0
        first_excl, second_excl = 0, 0
        
        if s[0] in non_zero:
            second_incl = 1
        if s[0] == '*':
            second_incl = 9
            
        for i in range(1, len(s)):
            new_incl, new_excl = 0, 0
            if s[i] == '*':
                new_incl = 9 * (second_incl + second_excl)
                
                if s[i-1] == '1':
                    # number is of type (1, *)
                    new_excl = 9 * (first_incl + first_excl)
                    
                elif s[i-1] == '2':
                    # number is of type (2, *)
                    new_excl = 6 * (first_incl + first_excl)
                    
                elif s[i-1] == '*':
                    # number is of type (*, *)
                    new_excl = 15 * (first_incl + first_excl)
            else:
                if s[i] in non_zero:
                    new_incl = second_incl + second_excl
                        
                if s[i-1] == '*':
                    # number is of type (*,digit)
                    if int(s[i]) <= 6:
                        new_excl = 2 * (first_excl + first_incl)
                    else:
                        new_excl = first_incl + first_excl
                        
                else:
                    # number is of type (digit,digit)
                    val = int(s[i-1:i+1])
                    if 10 <= val <= 26:
                        new_excl = first_incl + first_excl
                    else:
                        new_excl = 0
            first_incl, first_excl = second_incl, second_excl
            second_incl, second_excl = new_incl, new_excl
        return (second_incl + second_excl) % (10**9 + 7)";"class Solucion:
    def num_decodificaciones(self, s):
        longitud = len(s)
        modulo = 1000000007

        if longitud == 0:
            return 1

        maneras_de_decodificar = [0] * (longitud + 1)
        maneras_de_decodificar[0] = 1

        if s[0] == '0':
            maneras_de_decodificar[1] = 0
        elif s[0] == '*':
            maneras_de_decodificar[1] = 9
        else:
            maneras_de_decodificar[1] = 1

        indice = 2
        while indice <= longitud:
            caracter_actual = s[indice - 1]
            caracter_anterior = s[indice - 2]

            maneras_un_digito = 0
            if caracter_actual == '*':
                maneras_un_digito = 9 * maneras_de_decodificar[indice - 1]
            elif caracter_actual != '0':
                maneras_un_digito = maneras_de_decodificar[indice - 1]

            maneras_dos_digitos = 0
            if caracter_anterior == '1':
                if caracter_actual == '*':
                    maneras_dos_digitos = 9 * maneras_de_decodificar[indice - 2]
                else:
                    maneras_dos_digitos = maneras_de_decodificar[indice - 2]
            elif caracter_anterior == '2':
                if caracter_actual == '*':
                    maneras_dos_digitos = 6 * maneras_de_decodificar[indice - 2]
                elif caracter_actual >= '0' and caracter_actual <= '6':
                    maneras_dos_digitos = maneras_de_decodificar[indice - 2]
            elif caracter_anterior == '*':
                if caracter_actual == '*':
                    maneras_dos_digitos = 15 * maneras_de_decodificar[indice - 2]
                elif caracter_actual >= '0' and caracter_actual <= '6':
                    maneras_dos_digitos = 2 * maneras_de_decodificar[indice - 2]
                else:
                    maneras_dos_digitos = maneras_de_decodificar[indice - 2]
            
            total = (maneras_un_digito + maneras_dos_digitos) % modulo
            maneras_de_decodificar[indice] = total
            
            indice = indice + 1

        return maneras_de_decodificar[longitud]"
"class Solution:
    def isThree(self, n):
        
        answers =  [4, 9, 25, 49, 121, 169, 289, 361, 529, 841, 961, 1369, 1681, 1849, 2209, 2809, 3481, 3721, 4489, 5041, 5329, 6241, 6889, 7921, 9409]
        
        while True:
            size = len(answers)
            if size == 1:
                return answers[0] == n
            elif size == 0:
                return False
            mp = size // 2
            
            if answers[mp] == n:
                return True
            elif answers[mp] > n:
                answers = answers[:mp]
            else:
                answers = answers[mp + 1:]";"def tiene_tres_divisores(n):
    contador_divisores = 0
    numero_actual = 1

    if n < 1:
        return False

    while numero_actual <= n:
        if n % numero_actual == 0:
            contador_divisores = contador_divisores + 1
        
        numero_actual = numero_actual + 1

    if contador_divisores == 3:
        return True
    else:
        return False"
"class Solution:
    def nthUglyNumber(self, n: int) -> int:
        lst=[1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45, 48, 50, 54, 60, 64, 72, 75, 80, 81, 90, 96, 100, 108, 120, 125, 128, 135, 144, 150, 160, 162, 180, 192, 200, 216, 225, 240, 243, 250, 256, 270, 288, 300, 320, 324, 360, 375, 384, 400, 405, 432, 450, 480, 486, 500, 512, 540, 576, 600, 625, 640, 648, 675, 720, 729, 750, 768, 800, 810, 864, 900, 960, 972, 1000, 1024, 1080, 1125, 1152, 1200, 1215, 1250, 1280, 1296, 1350, 1440, 1458, 1500, 1536, 1600, 1620, 1728, 1800, 1875, 1920, 1944, 2000, 2025, 2048, 2160, 2187, 2250, 2304, 2400, 2430, 2500, 2560, 2592, 2700, 2880, 2916, 3000, 3072, 3125, 3200, 3240, 3375, 3456, 3600, 3645, 3750, 3840, 3888, 4000, 4050, 4096, 4320, 4374, 4500, 4608, 4800, 4860, 5000, 5120, 5184, 5400, 5625, 5760, 5832, 6000, 6075, 6144, 6250, 6400, 6480, 6561, 6750, 6912, 7200, 7290, 7500, 7680, 7776, 8000, 8100, 8192, 8640, 8748, 9000, 9216, 9375, 9600, 9720, 10000, 10125, 10240, 10368, 10800, 10935, 11250, 11520, 11664, 12000, 12150, 12288, 12500, 12800, 12960, 13122, 13500, 13824, 14400, 14580, 15000, 15360, 15552, 15625, 16000, 16200, 16384, 16875, 17280, 17496, 18000, 18225, 18432, 18750, 19200, 19440, 19683, 20000, 20250, 20480, 20736, 21600, 21870, 22500, 23040, 23328, 24000, 24300, 24576, 25000, 25600, 25920, 26244, 27000, 27648, 28125, 28800, 29160, 30000, 30375, 30720, 31104, 31250, 32000, 32400, 32768, 32805, 33750, 34560, 34992, 36000, 36450, 36864, 37500, 38400, 38880, 39366, 40000, 40500, 40960, 41472, 43200, 43740, 45000, 46080, 46656, 46875, 48000, 48600, 49152, 50000, 50625, 51200, 51840, 52488, 54000, 54675, 55296, 56250, 57600, 58320, 59049, 60000, 60750, 61440, 62208, 62500, 64000, 64800, 65536, 65610, 67500, 69120, 69984, 72000, 72900, 73728, 75000, 76800, 77760, 78125, 78732, 80000, 81000, 81920, 82944, 84375, 86400, 87480, 90000, 91125, 92160, 93312, 93750, 96000, 97200, 98304, 98415, 100000, 101250, 102400, 103680, 104976, 108000, 109350, 110592, 112500, 115200, 116640, 118098, 120000, 121500, 122880, 124416, 125000, 128000, 129600, 131072, 131220, 135000, 138240, 139968, 140625, 144000, 145800, 147456, 150000, 151875, 153600, 155520, 156250, 157464, 160000, 162000, 163840, 164025, 165888, 168750, 172800, 174960, 177147, 180000, 182250, 184320, 186624, 187500, 192000, 194400, 196608, 196830, 200000, 202500, 204800, 207360, 209952, 216000, 218700, 221184, 225000, 230400, 233280, 234375, 236196, 240000, 243000, 245760, 248832, 250000, 253125, 256000, 259200, 262144, 262440, 270000, 273375, 276480, 279936, 281250, 288000, 291600, 294912, 295245, 300000, 303750, 307200, 311040, 312500, 314928, 320000, 324000, 327680, 328050, 331776, 337500, 345600, 349920, 354294, 360000, 364500, 368640, 373248, 375000, 384000, 388800, 390625, 393216, 393660, 400000, 405000, 409600, 414720, 419904, 421875, 432000, 437400, 442368, 450000, 455625, 460800, 466560, 468750, 472392, 480000, 486000, 491520, 492075, 497664, 500000, 506250, 512000, 518400, 524288, 524880, 531441, 540000, 546750, 552960, 559872, 562500, 576000, 583200, 589824, 590490, 600000, 607500, 614400, 622080, 625000, 629856, 640000, 648000, 655360, 656100, 663552, 675000, 691200, 699840, 703125, 708588, 720000, 729000, 737280, 746496, 750000, 759375, 768000, 777600, 781250, 786432, 787320, 800000, 810000, 819200, 820125, 829440, 839808, 843750, 864000, 874800, 884736, 885735, 900000, 911250, 921600, 933120, 937500, 944784, 960000, 972000, 983040, 984150, 995328, 1000000, 1012500, 1024000, 1036800, 1048576, 1049760, 1062882, 1080000, 1093500, 1105920, 1119744, 1125000, 1152000, 1166400, 1171875, 1179648, 1180980, 1200000, 1215000, 1228800, 1244160, 1250000, 1259712, 1265625, 1280000, 1296000, 1310720, 1312200, 1327104, 1350000, 1366875, 1382400, 1399680, 1406250, 1417176, 1440000, 1458000, 1474560, 1476225, 1492992, 1500000, 1518750, 1536000, 1555200, 1562500, 1572864, 1574640, 1594323, 1600000, 1620000, 1638400, 1640250, 1658880, 1679616, 1687500, 1728000, 1749600, 1769472, 1771470, 1800000, 1822500, 1843200, 1866240, 1875000, 1889568, 1920000, 1944000, 1953125, 1966080, 1968300, 1990656, 2000000, 2025000, 2048000, 2073600, 2097152, 2099520, 2109375, 2125764, 2160000, 2187000, 2211840, 2239488, 2250000, 2278125, 2304000, 2332800, 2343750, 2359296, 2361960, 2400000, 2430000, 2457600, 2460375, 2488320, 2500000, 2519424, 2531250, 2560000, 2592000, 2621440, 2624400, 2654208, 2657205, 2700000, 2733750, 2764800, 2799360, 2812500, 2834352, 2880000, 2916000, 2949120, 2952450, 2985984, 3000000, 3037500, 3072000, 3110400, 3125000, 3145728, 3149280, 3188646, 3200000, 3240000, 3276800, 3280500, 3317760, 3359232, 3375000, 3456000, 3499200, 3515625, 3538944, 3542940, 3600000, 3645000, 3686400, 3732480, 3750000, 3779136, 3796875, 3840000, 3888000, 3906250, 3932160, 3936600, 3981312, 4000000, 4050000, 4096000, 4100625, 4147200, 4194304, 4199040, 4218750, 4251528, 4320000, 4374000, 4423680, 4428675, 4478976, 4500000, 4556250, 4608000, 4665600, 4687500, 4718592, 4723920, 4782969, 4800000, 4860000, 4915200, 4920750, 4976640, 5000000, 5038848, 5062500, 5120000, 5184000, 5242880, 5248800, 5308416, 5314410, 5400000, 5467500, 5529600, 5598720, 5625000, 5668704, 5760000, 5832000, 5859375, 5898240, 5904900, 5971968, 6000000, 6075000, 6144000, 6220800, 6250000, 6291456, 6298560, 6328125, 6377292, 6400000, 6480000, 6553600, 6561000, 6635520, 6718464, 6750000, 6834375, 6912000, 6998400, 7031250, 7077888, 7085880, 7200000, 7290000, 7372800, 7381125, 7464960, 7500000, 7558272, 7593750, 7680000, 7776000, 7812500, 7864320, 7873200, 7962624, 7971615, 8000000, 8100000, 8192000, 8201250, 8294400, 8388608, 8398080, 8437500, 8503056, 8640000, 8748000, 8847360, 8857350, 8957952, 9000000, 9112500, 9216000, 9331200, 9375000, 9437184, 9447840, 9565938, 9600000, 9720000, 9765625, 9830400, 9841500, 9953280, 10000000, 10077696, 10125000, 10240000, 10368000, 10485760, 10497600, 10546875, 10616832, 10628820, 10800000, 10935000, 11059200, 11197440, 11250000, 11337408, 11390625, 11520000, 11664000, 11718750, 11796480, 11809800, 11943936, 12000000, 12150000, 12288000, 12301875, 12441600, 12500000, 12582912, 12597120, 12656250, 12754584, 12800000, 12960000, 13107200, 13122000, 13271040, 13286025, 13436928, 13500000, 13668750, 13824000, 13996800, 14062500, 14155776, 14171760, 14348907, 14400000, 14580000, 14745600, 14762250, 14929920, 15000000, 15116544, 15187500, 15360000, 15552000, 15625000, 15728640, 15746400, 15925248, 15943230, 16000000, 16200000, 16384000, 16402500, 16588800, 16777216, 16796160, 16875000, 17006112, 17280000, 17496000, 17578125, 17694720, 17714700, 17915904, 18000000, 18225000, 18432000, 18662400, 18750000, 18874368, 18895680, 18984375, 19131876, 19200000, 19440000, 19531250, 19660800, 19683000, 19906560, 20000000, 20155392, 20250000, 20480000, 20503125, 20736000, 20971520, 20995200, 21093750, 21233664, 21257640, 21600000, 21870000, 22118400, 22143375, 22394880, 22500000, 22674816, 22781250, 23040000, 23328000, 23437500, 23592960, 23619600, 23887872, 23914845, 24000000, 24300000, 24576000, 24603750, 24883200, 25000000, 25165824, 25194240, 25312500, 25509168, 25600000, 25920000, 26214400, 26244000, 26542080, 26572050, 26873856, 27000000, 27337500, 27648000, 27993600, 28125000, 28311552, 28343520, 28697814, 28800000, 29160000, 29296875, 29491200, 29524500, 29859840, 30000000, 30233088, 30375000, 30720000, 31104000, 31250000, 31457280, 31492800, 31640625, 31850496, 31886460, 32000000, 32400000, 32768000, 32805000, 33177600, 33554432, 33592320, 33750000, 34012224, 34171875, 34560000, 34992000, 35156250, 35389440, 35429400, 35831808, 36000000, 36450000, 36864000, 36905625, 37324800, 37500000, 37748736, 37791360, 37968750, 38263752, 38400000, 38880000, 39062500, 39321600, 39366000, 39813120, 39858075, 40000000, 40310784, 40500000, 40960000, 41006250, 41472000, 41943040, 41990400, 42187500, 42467328, 42515280, 43046721, 43200000, 43740000, 44236800, 44286750, 44789760, 45000000, 45349632, 45562500, 46080000, 46656000, 46875000, 47185920, 47239200, 47775744, 47829690, 48000000, 48600000, 48828125, 49152000, 49207500, 49766400, 50000000, 50331648, 50388480, 50625000, 51018336, 51200000, 51840000, 52428800, 52488000, 52734375, 53084160, 53144100, 53747712, 54000000, 54675000, 55296000, 55987200, 56250000, 56623104, 56687040, 56953125, 57395628, 57600000, 58320000, 58593750, 58982400, 59049000, 59719680, 60000000, 60466176, 60750000, 61440000, 61509375, 62208000, 62500000, 62914560, 62985600, 63281250, 63700992, 63772920, 64000000, 64800000, 65536000, 65610000, 66355200, 66430125, 67108864, 67184640, 67500000, 68024448, 68343750, 69120000, 69984000, 70312500, 70778880, 70858800, 71663616, 71744535, 72000000, 72900000, 73728000, 73811250, 74649600, 75000000, 75497472, 75582720, 75937500, 76527504, 76800000, 77760000, 78125000, 78643200, 78732000, 79626240, 79716150, 80000000, 80621568, 81000000, 81920000, 82012500, 82944000, 83886080, 83980800, 84375000, 84934656, 85030560, 86093442, 86400000, 87480000, 87890625, 88473600, 88573500, 89579520, 90000000, 90699264, 91125000, 92160000, 93312000, 93750000, 94371840, 94478400, 94921875, 95551488, 95659380, 96000000, 97200000, 97656250, 98304000, 98415000, 99532800, 100000000, 100663296, 100776960, 101250000, 102036672, 102400000, 102515625, 103680000, 104857600, 104976000, 105468750, 106168320, 106288200, 107495424, 108000000, 109350000, 110592000, 110716875, 111974400, 112500000, 113246208, 113374080, 113906250, 114791256, 115200000, 116640000, 117187500, 117964800, 118098000, 119439360, 119574225, 120000000, 120932352, 121500000, 122880000, 123018750, 124416000, 125000000, 125829120, 125971200, 126562500, 127401984, 127545840, 128000000, 129140163, 129600000, 131072000, 131220000, 132710400, 132860250, 134217728, 134369280, 135000000, 136048896, 136687500, 138240000, 139968000, 140625000, 141557760, 141717600, 143327232, 143489070, 144000000, 145800000, 146484375, 147456000, 147622500, 149299200, 150000000, 150994944, 151165440, 151875000, 153055008, 153600000, 155520000, 156250000, 157286400, 157464000, 158203125, 159252480, 159432300, 160000000, 161243136, 162000000, 163840000, 164025000, 165888000, 167772160, 167961600, 168750000, 169869312, 170061120, 170859375, 172186884, 172800000, 174960000, 175781250, 176947200, 177147000, 179159040, 180000000, 181398528, 182250000, 184320000, 184528125, 186624000, 187500000, 188743680, 188956800, 189843750, 191102976, 191318760, 192000000, 194400000, 195312500, 196608000, 196830000, 199065600, 199290375, 200000000, 201326592, 201553920, 202500000, 204073344, 204800000, 205031250, 207360000, 209715200, 209952000, 210937500, 212336640, 212576400, 214990848, 215233605, 216000000, 218700000, 221184000, 221433750, 223948800, 225000000, 226492416, 226748160, 227812500, 229582512, 230400000, 233280000, 234375000, 235929600, 236196000, 238878720, 239148450, 240000000, 241864704, 243000000, 244140625, 245760000, 246037500, 248832000, 250000000, 251658240, 251942400, 253125000, 254803968, 255091680, 256000000, 258280326, 259200000, 262144000, 262440000, 263671875, 265420800, 265720500, 268435456, 268738560, 270000000, 272097792, 273375000, 276480000, 279936000, 281250000, 283115520, 283435200, 284765625, 286654464, 286978140, 288000000, 291600000, 292968750, 294912000, 295245000, 298598400, 300000000, 301989888, 302330880, 303750000, 306110016, 307200000, 307546875, 311040000, 312500000, 314572800, 314928000, 316406250, 318504960, 318864600, 320000000, 322486272, 324000000, 327680000, 328050000, 331776000, 332150625, 335544320, 335923200, 337500000, 339738624, 340122240, 341718750, 344373768, 345600000, 349920000, 351562500, 353894400, 354294000, 358318080, 358722675, 360000000, 362797056, 364500000, 368640000, 369056250, 373248000, 375000000, 377487360, 377913600, 379687500, 382205952, 382637520, 384000000, 387420489, 388800000, 390625000, 393216000, 393660000, 398131200, 398580750, 400000000, 402653184, 403107840, 405000000, 408146688, 409600000, 410062500, 414720000, 419430400, 419904000, 421875000, 424673280, 425152800, 429981696, 430467210, 432000000, 437400000, 439453125, 442368000, 442867500, 447897600, 450000000, 452984832, 453496320, 455625000, 459165024, 460800000, 466560000, 468750000, 471859200, 472392000, 474609375, 477757440, 478296900, 480000000, 483729408, 486000000, 488281250, 491520000, 492075000, 497664000, 500000000, 503316480, 503884800, 506250000, 509607936, 510183360, 512000000, 512578125, 516560652, 518400000, 524288000, 524880000, 527343750, 530841600, 531441000, 536870912, 537477120, 540000000, 544195584, 546750000, 552960000, 553584375, 559872000, 562500000, 566231040, 566870400, 569531250, 573308928, 573956280, 576000000, 583200000, 585937500, 589824000, 590490000, 597196800, 597871125, 600000000, 603979776, 604661760, 607500000, 612220032, 614400000, 615093750, 622080000, 625000000, 629145600, 629856000, 632812500, 637009920, 637729200, 640000000, 644972544, 645700815, 648000000, 655360000, 656100000, 663552000, 664301250, 671088640, 671846400, 675000000, 679477248, 680244480, 683437500, 688747536, 691200000, 699840000, 703125000, 707788800, 708588000, 716636160, 717445350, 720000000, 725594112, 729000000, 732421875, 737280000, 738112500, 746496000, 750000000, 754974720, 755827200, 759375000, 764411904, 765275040, 768000000, 774840978, 777600000, 781250000, 786432000, 787320000, 791015625, 796262400, 797161500, 800000000, 805306368, 806215680, 810000000, 816293376, 819200000, 820125000, 829440000, 838860800, 839808000, 843750000, 849346560, 850305600, 854296875, 859963392, 860934420, 864000000, 874800000, 878906250, 884736000, 885735000, 895795200, 900000000, 905969664, 906992640, 911250000, 918330048, 921600000, 922640625, 933120000, 937500000, 943718400, 944784000, 949218750, 955514880, 956593800, 960000000, 967458816, 972000000, 976562500, 983040000, 984150000, 995328000, 996451875, 1000000000, 1006632960, 1007769600, 1012500000, 1019215872, 1020366720, 1024000000, 1025156250, 1033121304, 1036800000, 1048576000, 1049760000, 1054687500, 1061683200, 1062882000, 1073741824, 1074954240, 1076168025, 1080000000, 1088391168, 1093500000, 1105920000, 1107168750, 1119744000, 1125000000, 1132462080, 1133740800, 1139062500, 1146617856, 1147912560, 1152000000, 1162261467, 1166400000, 1171875000, 1179648000, 1180980000, 1194393600, 1195742250, 1200000000, 1207959552, 1209323520, 1215000000, 1220703125, 1224440064, 1228800000, 1230187500, 1244160000, 1250000000, 1258291200, 1259712000, 1265625000, 1274019840, 1275458400, 1280000000, 1289945088, 1291401630, 1296000000, 1310720000, 1312200000, 1318359375, 1327104000, 1328602500, 1342177280, 1343692800, 1350000000, 1358954496, 1360488960, 1366875000, 1377495072, 1382400000, 1399680000, 1406250000, 1415577600, 1417176000, 1423828125, 1433272320, 1434890700, 1440000000, 1451188224, 1458000000, 1464843750, 1474560000, 1476225000, 1492992000, 1500000000, 1509949440, 1511654400, 1518750000, 1528823808, 1530550080, 1536000000, 1537734375, 1549681956, 1555200000, 1562500000, 1572864000, 1574640000, 1582031250, 1592524800, 1594323000, 1600000000, 1610612736, 1612431360, 1620000000, 1632586752, 1638400000, 1640250000, 1658880000, 1660753125, 1677721600, 1679616000, 1687500000, 1698693120, 1700611200, 1708593750, 1719926784, 1721868840, 1728000000, 1749600000, 1757812500, 1769472000, 1771470000, 1791590400, 1793613375, 1800000000, 1811939328, 1813985280, 1822500000, 1836660096, 1843200000, 1845281250, 1866240000, 1875000000, 1887436800, 1889568000, 1898437500, 1911029760, 1913187600, 1920000000, 1934917632, 1937102445, 1944000000, 1953125000, 1966080000, 1968300000, 1990656000, 1992903750, 2000000000, 2013265920, 2015539200, 2025000000, 2038431744, 2040733440, 2048000000, 2050312500, 2066242608, 2073600000, 2097152000, 2099520000, 2109375000, 2123366400]
        return lst[n-1]";"class Solucion:
    def encontrar_nesimo_feo(self, n):
        if n <= 0:
            return 0
        
        numeros_feos = [0] * n
        numeros_feos[0] = 1

        puntero2 = 0
        puntero3 = 0
        puntero5 = 0

        indice = 1
        while indice < n:
            multiplo_de_2 = numeros_feos[puntero2] * 2
            multiplo_de_3 = numeros_feos[puntero3] * 3
            multiplo_de_5 = numeros_feos[puntero5] * 5

            siguiente_feo = min(multiplo_de_2, multiplo_de_3, multiplo_de_5)
            numeros_feos[indice] = siguiente_feo

            if siguiente_feo == multiplo_de_2:
                puntero2 = puntero2 + 1
            
            if siguiente_feo == multiplo_de_3:
                puntero3 = puntero3 + 1

            if siguiente_feo == multiplo_de_5:
                puntero5 = puntero5 + 1
            
            indice = indice + 1

        return numeros_feos[n - 1]"
"class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        def isSameCase(l, r, word, isUpper):
            while l <= r:
                if word[l].isupper() != isUpper or word[r].isupper() != isUpper:
                    return False
                l += 1
                r -= 1
            return True
        
        if len(word) == 1: # Base Case
            return True
        
        if word[0].isupper() and word[1].isupper(): #Case 1 ""USA""
            return isSameCase(1, len(word) - 1, word, True)
        elif word[0].islower() and word[1].islower(): #Case 2 ""leetcode""
            return isSameCase(1, len(word) - 1, word, False)
        elif word[0].isupper() and word[1].islower(): # Case 3 ""Google""
            return isSameCase(1, len(word) - 1, word, False)
        else:
            return False";"class Solucion:
    def detectar_uso_mayusculas(self, palabra: str) -> bool:
        numero_de_mayusculas = 0
        longitud_palabra = len(palabra)

        for letra in palabra:
            if letra.isupper():
                numero_de_mayusculas = numero_de_mayusculas + 1

        if numero_de_mayusculas == longitud_palabra:
            return True

        if numero_de_mayusculas == 0:
            return True

        if numero_de_mayusculas == 1:
            if palabra[0].isupper():
                return True

        return False"
"class Solution:
    
    def reversePairs(self, arr: List[int]) -> int:
        count = 0
        if len(arr) > 1:
            mid = len(arr)//2
            L = arr[:mid]
            R = arr[mid:]
            count = self.reversePairs(L) 
            count += self.reversePairs(R)
            count += self.merge(L,R,arr)
        return count
    
    def merge(self,L,R,arr):
		#finding count for the condition
        count = 0
        i,j = 0,0
        while i < len(L):
            while j < len(R):
                if L[i] > 2*R[j]:
                    j += 1
                else:
                    break
            
            if j > 0:
                count += j
            i += 1

		#merging the sorted arrays
        i,j,k = 0,0,0        
        while i < len(L) and j < len(R):    
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1   
            else:
                arr[k] = R[j]
                j += 1
            k += 1

        while i < len(L):
            arr[k] = L[i]
            k += 1
            i += 1   
        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1
                
        return count";"class Solucion:
    def pares_invertidos(self, numeros):
        contador = 0
        longitud = len(numeros)
        
        i = 0
        while i < longitud:
            j = i + 1
            while j < longitud:
                if numeros[i] > 2 * numeros[j]:
                    contador = contador + 1
                j = j + 1
            i = i + 1
            
        return contador"
"class Solution:
    def stoneGameIX(self, stones: List[int]) -> bool:
        stones = [v % 3 for v in stones]
        
        d = defaultdict(int)
        for v in stones:
            d[v] += 1
        
        while d[1] >= 2 and d[2] >= 2:
            d[2] -= 1
            d[1] -= 1
        
        if d[0] % 2 == 0: # number of 0s will not influent the result
            if (d[1] == 1 and d[2] >= 1) or (d[2] == 1 and d[1] >= 1):
                return True
        else:
            if (d[1] == 0 and d[2] >= 3) or (d[2] == 0 and d[1] >= 3):
                return True
            if (d[1] == 1 and d[2] >= 4) or (d[2] == 1 and d[1] >= 4):
                return True

        return False";"def solucion_juego_piedras(piedras):
    contador_mod_0 = 0
    contador_mod_1 = 0
    contador_mod_2 = 0

    for piedra in piedras:
        residuo = piedra % 3
        if residuo == 0:
            contador_mod_0 = contador_mod_0 + 1
        elif residuo == 1:
            contador_mod_1 = contador_mod_1 + 1
        else:
            contador_mod_2 = contador_mod_2 + 1

    suma_total_mod_3 = (contador_mod_1 * 1 + contador_mod_2 * 2) % 3

    if suma_total_mod_3 == 0:
        if contador_mod_0 % 2 == 0:
            return True
        else:
            return False
    elif suma_total_mod_3 == 1:
        if contador_mod_1 > 0:
            if contador_mod_0 % 2 == 0:
                return True
            else:
                return False
        else:
            if contador_mod_0 % 2 == 0:
                return False
            else:
                if contador_mod_2 > 1:
                    return True
                else:
                    return False
    else: # suma_total_mod_3 == 2
        if contador_mod_2 > 0:
            if contador_mod_0 % 2 == 0:
                return True
            else:
                return False
        else:
            if contador_mod_0 % 2 == 0:
                return False
            else:
                if contador_mod_1 > 1:
                    return True
                else:
                    return False"
"class Solution:
    def rotateString(self, s: str, goal: str) -> bool:
        if len(s) != len(goal):
            return False
        
        txt = s + s
        n, m = len(txt), len(goal) 

        lps = self.build_lps(goal)
       
        i, j = 0, 0

        while i < n:
            if txt[i] == goal[j] :
                i, j = i + 1, j + 1
                
                if j == m:
                    return True
            else: 
                if j == 0:
                   i += 1 
                else:
                    j = lps[j-1]
                    
                    
        return False

    
    def build_lps(self, pattern):
        lps = [0] * len(pattern) 
        prev_lps, i = 0, 1

        while i < len(pattern):
            if pattern[i] == pattern[prev_lps]:
                lps[i] = prev_lps + 1
                prev_lps, i = prev_lps + 1, i + 1
            else:
                if prev_lps == 0:
                    lps[i] = 0
                    i += 1
                else:
                    prev_lps = lps[prev_lps - 1]

        return lps";"def es_rotacion(s, objetivo):
    longitud_s = len(s)
    longitud_objetivo = len(objetivo)

    if longitud_s != longitud_objetivo:
        return False

    if longitud_s == 0:
        return True

    cadena_actual = s
    
    intentos = 0
    while intentos < longitud_s:
        if cadena_actual == objetivo:
            return True

        primer_caracter = cadena_actual[0]
        
        resto_de_la_cadena = """"
        indice = 1
        while indice < longitud_s:
            resto_de_la_cadena = resto_de_la_cadena + cadena_actual[indice]
            indice = indice + 1
        
        cadena_actual = resto_de_la_cadena + primer_caracter
        
        intentos = intentos + 1

    return False"
"class Solution:
    def wordBreak(self, s: str, wordDict):
        output = []
        def backtracking(restString, candidate):
            # When the restString is empty, it means all substring/prefix of s are found in dictionary.
            # Add candidate to output answer.
            if restString == """":
                output.append(candidate)
                return
            
            # Process demonstration of the following for loop:
            # candidate = """"  <= 'cat'sanddog
            # candidate = ""cat""  <= 'sand'dog
            # candidate = ""cat sand""  <= dog
            # candidate = ""cat sand dog""  <= ''

            # candidate = """"  <= 'cats'anddog
            # candidate = ""cats""  <= 'and'dog
            # candidate = ""cats and""  <= dog
            # candidate = ""cats and dog""  <= ''

            # In the for loop range needs to add one, otherwise you will miss one char when you use restString[:i].
            # This for loop will keep checking if any prefix of restString was in dictionary.
            for i in range(len(restString)+1):
                if restString[:i] in wordDict:
                    # This if block can avoid the extra space in the from of candidate answer.
                    if candidate == """":
                        backtracking(restString[i:], restString[:i])
                    else:
                        backtracking(restString[i:], candidate+"" ""+restString[:i])
                    
        backtracking(s, """")
        return output

""""""
Input: s = ""catsanddog"", wordDict = [""cat"",""cats"",""and"",""sand"",""dog""]
Output: [""cats and dog"",""cat sand dog""]
""""""

if __name__ == ""__main__"":
    s = ""catsanddog"" 
    wordDict = [""cat"",""cats"",""and"",""sand"",""dog""]
    solution = Solution()
    print(f""s = {s}"")
    print(f""wordDict = {wordDict}"")
    print(f""wordBreak = {solution.wordBreak(s, wordDict)}"")";"def separar_palabras(s, diccionario_palabras):
    resultados_finales = []

    longitud_s = len(s)

    if longitud_s == 0:
        return [""""]

    indice = 0
    while indice < longitud_s:
        prefijo = s[0 : indice + 1]

        es_palabra_valida = False
        for palabra_diccionario in diccionario_palabras:
            if prefijo == palabra_diccionario:
                es_palabra_valida = True
                break

        if es_palabra_valida:
            sufijo = s[indice + 1 : longitud_s]
            resultados_para_sufijo = separar_palabras(sufijo, diccionario_palabras)

            for oracion_sufijo in resultados_para_sufijo:
                if len(oracion_sufijo) == 0:
                    resultados_finales.append(prefijo)
                else:
                    nueva_oracion = prefijo + "" "" + oracion_sufijo
                    resultados_finales.append(nueva_oracion)
        
        indice = indice + 1

    return resultados_finales"
"class Solution:
    def bagOfTokensScore(self, tokens: List[int], power: int) -> int:
        # Establish score to return
        score = 0
        
        # Why use Collections.deque instead of the list 
        # as-is? One word - optimization! Deque has been 
        # written in such a way where popping items off
        # the front of the list using popleft occurs in O(1)
        # time, while running tokens.pop(0) runs in O(n) time.
        # Since we care a lot about runtime, deque's
        # the way to go here
        d = deque(sorted(tokens))
        while d:
            # Since we've sorted the list in ascending 
            # order, we don't need to compare the power to 
            # all values - if it's smaller than the smallest, 
            # it'll be smaller than everything
            if power < d[0]:
                # Pop the tail of the list (play token face-down)
                if score > 0 and len(d) > 1:
                    power += d.pop()
                    score -= 1
                # It's possible power will be smaller than 
                # all scores but either our score's too low
                # to play anything face-down OR there's only
                # one piece left, making the play redundnat.
                # In either of these cases, we're done
                else:
                    return score
            else:
                #Pop the head (play token face-up)
                power -= d.popleft()
                score += 1
        # Game over - time to return our score!
        return score";"def calcular_puntuacion(fichas, poder):
    fichas.sort()

    puntuacion = 0
    puntuacion_maxima = 0
    izquierda = 0
    derecha = len(fichas) - 1

    while izquierda <= derecha:
        if poder >= fichas[izquierda]:
            poder = poder - fichas[izquierda]
            puntuacion = puntuacion + 1
            izquierda = izquierda + 1
            if puntuacion > puntuacion_maxima:
                puntuacion_maxima = puntuacion
        elif puntuacion > 0:
            poder = poder + fichas[derecha]
            puntuacion = puntuacion - 1
            derecha = derecha - 1
        else:
            break
            
    return puntuacion_maxima"
"class Solution:
    def buddyStrings(self, s: str, goal: str) -> bool:
        n1=len(s)
        n2=len(goal)
        if n1!=n2: #if length is not equal we cannot make them the same with interchange
            return False
        d=defaultdict(list)
        mx =0 #max count of individual
        cnt=defaultdict(int)
        for i in range(n1):
            cnt[s[i]]+=1
            if cnt[s[i]]>mx:
                mx=cnt[s[i]] # maximum times acharacter occurs in s 
            
            d[i]=[s[i],goal[i]] #store value of both strings at an index
        count=0
        dif=[]
       
        for k in d:
            
            
            a=d[k][0] #letter at index k of s
            b=d[k][1] #letter at index k of s
            if a!=b:
                count+=1 
                dif.append(k)
            if count>2: # only one interchange is allowed 
                return False 
        
        if count==1:
            return False #one index at has unmatched value , can never be interchanged
        if count==0:
            if mx >=2: #s='aa' goal='aa'
                
                return True
            return False #s='ab' goal='ab'
        
        if d[dif[0]][0]==d[dif[1]][1] and d[dif[1]][0]==d[dif[0]][1]: #if 2 values are at wrong index check if there interchange would make the strings same 
            return True 
        return False";"class Solucion:
    def intercambio_de_amigos(self, s, goal):
        longitud_s = len(s)
        longitud_goal = len(goal)

        if longitud_s != longitud_goal:
            return False

        if s == goal:
            frecuencia_caracteres = []
            for caracter in s:
                if caracter in frecuencia_caracteres:
                    return True
                frecuencia_caracteres.append(caracter)
            return False

        lista_diferencias = []
        for i in range(longitud_s):
            if s[i] != goal[i]:
                lista_diferencias.append(i)

        if len(lista_diferencias) != 2:
            return False

        primer_indice = lista_diferencias[0]
        segundo_indice = lista_diferencias[1]

        if s[primer_indice] == goal[segundo_indice] and s[segundo_indice] == goal[primer_indice]:
            return True
        else:
            return False"
"class Solution:
    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:
        """"""LeetCode 835

        Not hard in terms of figuring out a method, but very complicated in
        implementation. First turn both images into bitmaps. Then brute force
        it by traversing all possible overlap states. At each state, compute
        the number of overlapped positions.

        The difficulty lies in accurately finding out the correct bitmap from
        both images at each overlapped state to perform the AND operation.

        O(N^4), 645 ms, faster than 81.87%
        """"""
        n = len(img1)
        bitmap1 = [sum(v << (n - i - 1) for i, v in enumerate(row)) for row in img1]
        bitmap2 = [sum(v << (n - i - 1) for i, v in enumerate(row)) for row in img2]
        res = 0
        for i in range(2 * n - 1):
            for j in range(2 * n - 1):
                cur = 0
                if i <= n - 1:
                    if j <= n - 1:
                        for ii in range(n - i - 1, n):
                            ol = ((bitmap1[ii] &amp, ((1 << (j + 1)) - 1)) << (n - j - 1)) &amp, (bitmap2[ii - (n - i - 1)])
                            cur += bin(ol).count('1')
                    else:
                        for ii in range(n - i - 1, n):
                            ol = (bitmap1[ii] >> (j - n + 1)) &amp, (bitmap2[ii - (n - i - 1)])
                            cur += bin(ol).count('1')
                else:
                    if j <= n - 1:
                        for ii in range(2 * n - i - 1):
                            ol = ((bitmap1[ii] &amp, ((1 << (j + 1)) - 1)) << (n - j - 1)) &amp, (bitmap2[ii + i - n + 1])
                            cur += bin(ol).count('1')
                    else:
                        for ii in range(2 * n - i - 1):
                            ol = (bitmap1[ii] >> (j - n + 1)) &amp, (bitmap2[ii + i - n + 1])
                            cur += bin(ol).count('1')
                res = max(res, cur)
        return res";"class Solucion:
    def superposicion_mas_grande(self, imagen1, imagen2):
        n = len(imagen1)
        superposicion_maxima = 0

        for desplazamiento_fila in range(1 - n, n):
            for desplazamiento_columna in range(1 - n, n):
                
                superposicion_actual = 0
                
                for fila in range(n):
                    for columna in range(n):
                        
                        fila_trasladada = fila - desplazamiento_fila
                        columna_trasladada = columna - desplazamiento_columna
                        
                        esta_dentro_fila = fila_trasladada >= 0 and fila_trasladada < n
                        esta_dentro_columna = columna_trasladada >= 0 and columna_trasladada < n
                        
                        if esta_dentro_fila and esta_dentro_columna:
                            valor_imagen1 = imagen1[fila_trasladada][columna_trasladada]
                            valor_imagen2 = imagen2[fila][columna]
                            
                            if valor_imagen1 == 1 and valor_imagen2 == 1:
                                superposicion_actual = superposicion_actual + 1
                
                if superposicion_actual > superposicion_maxima:
                    superposicion_maxima = superposicion_actual

        return superposicion_maxima"
"class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
	
        def helper(full, empty, drank):
		    # Base case, make sure we can continue (we have enough to cash in)
            if full + empty < numExchange:
                return drank+full
			# If we have any full bottles we'll make them empty
            if full:
                empty += full
            # Exchange empties for fulls
            new = empty // numExchange
			# Don't forget there might be remainders!
            remaining_empt = empty - (new*numExchange)
            return helper(new, remaining_empt, drank + full)
            
        return helper(numBottles, 0, 0)";"def intercambiar_botellas(num_botellas, num_intercambio):
    botellas_bebidas = num_botellas
    botellas_vacias = num_botellas

    while botellas_vacias >= num_intercambio:
        botellas_nuevas_llenas = botellas_vacias // num_intercambio
        botellas_vacias_restantes = botellas_vacias % num_intercambio
        
        botellas_bebidas = botellas_bebidas + botellas_nuevas_llenas
        
        botellas_vacias = botellas_nuevas_llenas + botellas_vacias_restantes

    return botellas_bebidas"
"class Solution:
    def bulbSwitch(self, n: int) -> int:
        bulb_on = 0
        v = 2
        while n >= 1:
            bulb_on += 1
            n -= v + 1
            v += 2
        return bulb_on";"def interruptor_de_bombillas(numero_de_bombillas):
    bombillas = []
    i = 0
    while i < numero_de_bombillas:
        bombillas.append(False)
        i = i + 1

    ronda_actual = 1
    while ronda_actual <= numero_de_bombillas:
        indice = ronda_actual - 1
        while indice < numero_de_bombillas:
            if bombillas[indice] == True:
                bombillas[indice] = False
            else:
                bombillas[indice] = True
            
            indice = indice + ronda_actual
        
        ronda_actual = ronda_actual + 1

    bombillas_encendidas = 0
    for bombilla_esta_encendida in bombillas:
        if bombilla_esta_encendida == True:
            bombillas_encendidas = bombillas_encendidas + 1
            
    return bombillas_encendidas"
"class Solution:
    def orderlyQueue(self, s: str, k: int) -> str:
        # case1 : ? s ??????????? return ??? s ??
        if len(set(s)) == 1: return s
        # case2 : ? k ?? 1???? return ?????????(????????????)
        if k != 1: return """".join(sorted(s))
        # case3 : ? k ? 1????????????????
        Len = len(s)
        Min = ""{""
        Min_idxs = dict() # ???????? index ????key = index, val = smallest char
        for i in range(Len):
            if Min > s[i]: # ??????????????? {index:char}??????? == 1
                Min = s[i]
                Min_idxs = {i:s[i]}
            elif Min == s[i]: # ????????????? index:char??????? > 1
                Min_idxs[i] = s[i]
                
        step = 1 # ????? index ?????????????
        # ??????? 1 (????????????????????)?????????????????
        while len(Min_idxs) != 1 and step < Len:

            Min = ""{""
            for idx in Min_idxs:
                comp_idx = (idx+step)%Len # ? index ?? s ????? s[0] ?????
                if Min > s[comp_idx]: # ???? index ? step ????????
                    Min = s[comp_idx]
                Min_idxs[idx] = s[comp_idx] # ??? k,v ?? value ????? step ???
            
            # ? value ???????? key ????
            del_list = [k for k, v in Min_idxs.items() if v != Min]
            # ?? value ???????? k,v ?
            for idx in del_list:
                Min_idxs.pop(idx)
            # ????? step ???
            step += 1

        split_idx = list(Min_idxs.keys())[0] # ??????

        return s[split_idx:] + s[:split_idx] # ????? return";"if k > 1:
    lista_caracteres = []
    for caracter in s:
        lista_caracteres.append(caracter)

    longitud = 0
    for caracter in lista_caracteres:
        longitud = longitud + 1

    i = 0
    while i < longitud:
        j = 0
        while j < longitud - 1 - i:
            if lista_caracteres[j] > lista_caracteres[j + 1]:
                temporal = lista_caracteres[j]
                lista_caracteres[j] = lista_caracteres[j + 1]
                lista_caracteres[j + 1] = temporal
            j = j + 1
        i = i + 1

    cadena_resultado = """"
    for caracter in lista_caracteres:
        cadena_resultado = cadena_resultado + caracter

else:
    mejor_cadena = s
    cadena_temporal = s

    longitud = 0
    for caracter in s:
        longitud = longitud + 1

    contador = 0
    while contador < longitud:
        primer_caracter = cadena_temporal[0]
        
        resto_de_la_cadena = """"
        indice = 1
        while indice < longitud:
            resto_de_la_cadena = resto_de_la_cadena + cadena_temporal[indice]
            indice = indice + 1
        
        cadena_temporal = resto_de_la_cadena + primer_caracter

        if cadena_temporal < mejor_cadena:
            mejor_cadena = cadena_temporal
        
        contador = contador + 1
    
    cadena_resultado = mejor_cadena"
"class Solution:
    def leastBricks(self, wall: List[List[int]]) -> int:
        
        """"""
        
        Line can be drawn at one unit distance.
        
        Idea here is to create map of points where each row would like to have line
        Such that no brick is cut.
        
        Post this, check max row fine with particualr point.
        
        Ex For this row, [1,2,2,1]
        
        we can draw line without cutting any brick 
        at 1 or 1+2, or 1+2+2
        
        
        
        """"""
        
        
        lenMap  = collections.defaultdict(int)
        
        for w in wall:
            s = 0 
            for i in w[:-1]:
                s = s + i
                lenMap[s] = lenMap[s] + 1
        
        
        fine = 0
        if lenMap.values():
            fine = max(lenMap.values())
        
        return (len(wall) - fine)";"class Solucion:
    def menor_numero_de_ladrillos_cruzados(self, pared):
        mapa_de_bordes = {}
        numero_de_filas = len(pared)

        for fila in pared:
            posicion_borde = 0
            numero_de_ladrillos_en_fila = len(fila)
            
            if numero_de_ladrillos_en_fila > 1:
                indice = 0
                while indice < numero_de_ladrillos_en_fila - 1:
                    ancho_ladrillo = fila[indice]
                    posicion_borde = posicion_borde + ancho_ladrillo
                    if posicion_borde in mapa_de_bordes:
                        mapa_de_bordes[posicion_borde] = mapa_de_bordes[posicion_borde] + 1
                    else:
                        mapa_de_bordes[posicion_borde] = 1
                    indice = indice + 1

        max_bordes = 0
        for borde in mapa_de_bordes:
            cuenta_actual = mapa_de_bordes[borde]
            if cuenta_actual > max_bordes:
                max_bordes = cuenta_actual
        
        resultado = numero_de_filas - max_bordes
        return resultado"
"class Solution:
    # O(logn) time,
    # O(1) space,
    # Approach: binary search,
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        
        def findLowerBoundIndexToNum(lo, hi, num):
            while True:
                mid = (lo+hi)//2
                curr = citations[mid]
                
                if curr == num and (mid == 0 or citations[mid-1] < num):
                    return mid
                elif curr == num:
                    hi = mid-1
                elif curr > num:
                    if mid == 0 or citations[mid-1] < num:
                        return mid
                    hi = mid-1
                else:
                    if lo >= hi:
                        if citations[hi] >= num:
                            return hi
                        else:
                            return n
                    lo = mid+1
        
        def valid(hindex):
            index = findLowerBoundIndexToNum(0, n-1, hindex)
            citation_num = n - index
            return citation_num >= hindex
        
        
        def findMaxHindex(lo, hi):
            while True:
                mid = (lo+hi)//2
                validCitation = valid(mid)
                
                if validCitation and (mid == n or not valid(mid+1)):
                    return mid
                elif not validCitation:
                    hi = mid-1
                else:
                    if lo >= hi:
                        return hi
                    lo = mid+1
                
        return findMaxHindex(0, n)";"def calcular_indice_h(citaciones):
    numero_total = len(citaciones)
    izquierda = 0
    derecha = numero_total - 1
    respuesta = 0

    while izquierda <= derecha:
        medio = izquierda + (derecha - izquierda) // 2
        
        numero_de_papeles_desde_medio = numero_total - medio
        
        if citaciones[medio] >= numero_de_papeles_desde_medio:
            respuesta = numero_de_papeles_desde_medio
            derecha = medio - 1
        else:
            izquierda = medio + 1
            
    return respuesta"
"class Solution:
    def addDigits(self, num: int) -> int:

        num = [int(i) for i in str(num)]

        if len(num) == 1:
          return num[0]

        while(len(num) != 1): 
          sum = 0
          for i in range(len(num)):
            sum += num[i]
          num = sum
          num = [int(i) for i in str(num)]
        return num[0]";"def sumar_digitos_repetidamente(num):
    while num > 9:
        suma_de_digitos = 0
        numero_temporal = num
        while numero_temporal > 0:
            digito = numero_temporal % 10
            suma_de_digitos = suma_de_digitos + digito
            numero_temporal = numero_temporal // 10
        num = suma_de_digitos
    return num"
"class Solution:

    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        # Step 0: Special case of an empty route
        if source == target: return 0

        # Step 1: Create a dict of [stop -> busses stopping at this stop]
        stop2bus = dict()
        for i in range(len(routes)):
            for stop in routes[i]:
                if stop not in stop2bus: stop2bus[stop] = set()
                stop2bus[stop].add(i)

        # Step 2: BFS over the bus stops
        bfs_queue = [(source,0)] # Tuple of (bus stop, number of busses taken to get to the stop)
        visited = {source} # Set of visited bus stops to avoid cycles
        
        while len(bfs_queue) > 0: # BFS
            stop, numBusses = bfs_queue.pop(0)
            if stop==target: return numBusses # If we arrived at the target, stop here!
            if stop in stop2bus:
                for bus in stop2bus[stop]: # Check all busses at this stop
                    for neighbour in routes[bus]: # Check all stops of each bus
                        if neighbour not in visited:
                            # Add all new stops to the neighbours
                            bfs_queue.append((neighbour,numBusses+1))
                            visited.add(neighbour)
                    routes[bus]=[]
            
        return -1 # If we finished the BFS and did not reach the target, it is unreachable";"class Solucion:
    def numero_de_buses(self, rutas, origen, destino):
        if origen == destino:
            return 0

        paradas_a_rutas = {}
        indice_ruta = 0
        while indice_ruta < len(rutas):
            ruta = rutas[indice_ruta]
            for parada in ruta:
                if parada not in paradas_a_rutas:
                    paradas_a_rutas[parada] = []
                paradas_a_rutas[parada].append(indice_ruta)
            indice_ruta = indice_ruta + 1

        cola = []
        rutas_visitadas = []

        if origen in paradas_a_rutas:
            rutas_de_origen = paradas_a_rutas[origen]
            for indice in rutas_de_origen:
                cola.append((indice, 1))
                rutas_visitadas.append(indice)

        cabeza_de_cola = 0
        while cabeza_de_cola < len(cola):
            elemento_actual = cola[cabeza_de_cola]
            cabeza_de_cola = cabeza_de_cola + 1
            
            indice_ruta_actual = elemento_actual[0]
            cantidad_buses = elemento_actual[1]

            paradas_actuales = rutas[indice_ruta_actual]
            for parada in paradas_actuales:
                if parada == destino:
                    return cantidad_buses

            for parada in paradas_actuales:
                if parada in paradas_a_rutas:
                    rutas_siguientes = paradas_a_rutas[parada]
                    for indice_siguiente in rutas_siguientes:
                        fue_visitada = False
                        for ruta_visitada_indice in rutas_visitadas:
                            if ruta_visitada_indice == indice_siguiente:
                                fue_visitada = True
                                break
                        
                        if not fue_visitada:
                            rutas_visitadas.append(indice_siguiente)
                            cola.append((indice_siguiente, cantidad_buses + 1))

        return -1"
"class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        n = len(piles)
        memo = [[0] * n for i in range(n)]
        
        def dp(i, j):
            if (i > j): return 0
            if (memo[i][j] != 0):
                return memo[i][j]
            
            player_turn = (n - (j - i)) % 2
            if (player_turn == 1):
                # increasing player1's score when player1 picks a max pile
                memo[i][j] = max(piles[i] + dp(i+1, j), piles[j] + dp(i, j-1))
            else:
                # decreasing player1's score when player2 picks a pile and player2 is assumed to pick the larger pile leading to a min score for player1
                memo[i][j] = min(-piles[i] + dp(i+1, j), -piles[j] + dp(i, j-1))
            return memo[i][j]
                
        return dp(0, n-1) > 0";"def juego_de_piedras(pilas):
    numero_de_pilas = len(pilas)
    tabla_dp = []
    
    fila_vacia = []
    i = 0
    while i < numero_de_pilas:
        fila_vacia.append(0)
        i = i + 1

    i = 0
    while i < numero_de_pilas:
        tabla_dp.append(list(fila_vacia))
        i = i + 1

    i = 0
    while i < numero_de_pilas:
        tabla_dp[i][i] = pilas[i]
        i = i + 1

    longitud = 2
    while longitud <= numero_de_pilas:
        i = 0
        while i < numero_de_pilas - longitud + 1:
            j = i + longitud - 1
            opcion_izquierda = pilas[i] - tabla_dp[i + 1][j]
            opcion_derecha = pilas[j] - tabla_dp[i][j - 1]
            if opcion_izquierda > opcion_derecha:
                tabla_dp[i][j] = opcion_izquierda
            else:
                tabla_dp[i][j] = opcion_derecha
            i = i + 1
        longitud = longitud + 1

    if tabla_dp[0][numero_de_pilas - 1] > 0:
        return True
    else:
        return False"
"class Solution:
    #Time-Complexity: O(rows*cols)
    #Space-Complexity: O(rows*cols + rows*cols) -> O(rows*cols)
    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:
        #this is a standard bfs problem!
        #we will add to queue pixels that share same color as the starting pixel point 
        #that have not already been visited!
        #For each element we dequeue from queue, we will overwrite that entry with the new
        #color!
        #our answer will return image parameter that is modified in-place!
        rows, cols = len(image), len(image[0])
        visited = set()
        q = collections.deque()
        orig_color = image[sr][sc]
        q.append([sr, sc])
        visited.add((sr, sc))
        four_directions = [[1,0],[-1,0], [0,1], [0,-1]]
        #initiate bfs!
        while q:
            cr, cc = q.popleft()
            image[cr][cc] = color
            #iterate through each of four directional neighbors!
            for direction in four_directions:
                r_change, c_change = direction
                if(cr + r_change in range(rows) and
                   cc + c_change in range(cols) and 
                   image[cr+r_change][cc+c_change] == orig_color and
                   (cr+r_change, cc+c_change) not in visited):
                    q.append([cr+r_change, cc+c_change])
                    visited.add((cr+r_change, cc+c_change))
        #once bfs ends, return grid changed in place!
        return image";"class Solucion:
    def relleno_por_inundacion(self, imagen, fila_inicial, columna_inicial, nuevo_color):
        filas = len(imagen)
        columnas = len(imagen[0])
        color_original = imagen[fila_inicial][columna_inicial]

        if color_original == nuevo_color:
            return imagen

        pila = []
        pila.append((fila_inicial, columna_inicial))

        while len(pila) > 0:
            coordenadas = pila.pop()
            fila = coordenadas[0]
            columna = coordenadas[1]

            if fila < 0 or fila >= filas or columna < 0 or columna >= columnas:
                continue

            if imagen[fila][columna] == color_original:
                imagen[fila][columna] = nuevo_color
                
                # Vecino de arriba
                pila.append((fila - 1, columna))
                # Vecino de abajo
                pila.append((fila + 1, columna))
                # Vecino de la izquierda
                pila.append((fila, columna - 1))
                # Vecino de la derecha
                pila.append((fila, columna + 1))

        return imagen"
"class Solution:
    def toGoatLatin(self, sentence: str) -> str:
        new = sentence.split() # Breaks up the input into individual sentences
        count = 1 # Starting at 1 since we only have one ""a"" to begin with.
        
        for x in range(len(new)):
            if new[x][0].casefold() in 'aeiou': # Checks if the first value of x is a vowel. The casefold, can be replaced with lower, lowers the case. Can also just be removed and have ""in 'aeiouAEIOU'
                new[x] = new[x] + 'ma' + 'a'*count # Brings it together with the count multiplying number of ""a""'s as needed.
                count += 1
            elif new[x].casefold() not in 'aeiou': # Same comment as above.
                new[x] = new[x][1:] + new[x][0] + 'ma' + 'a'*count # Just moves the first value to the end then does the a.
                count += 1
        
        return "" "".join(x for x in new) # Converts the list back into a string.";"class Solucion:
    def a_goat_latin(self, oracion: str) -> str:
        palabras = oracion.split(' ')
        vocales = ""aeiouAEIOU""
        lista_resultado = []
        
        indice = 1
        for palabra in palabras:
            palabra_modificada = """"
            primera_letra = palabra[0]
            
            if primera_letra in vocales:
                palabra_modificada = palabra + ""ma""
            else:
                resto_de_la_palabra = palabra[1:]
                palabra_modificada = resto_de_la_palabra + primera_letra + ""ma""

            sufijo_con_a = """"
            contador = 0
            while contador < indice:
                sufijo_con_a = sufijo_con_a + ""a""
                contador = contador + 1
            
            palabra_final = palabra_modificada + sufijo_con_a
            lista_resultado.append(palabra_final)
            
            indice = indice + 1

        oracion_resultado = "" "".join(lista_resultado)
        return oracion_resultado"
"class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        # Break words into pieces
        # Empty word can be found in the dictionary
        # can the whole s be also represented in the dictionary?
        
        # BUILDING THE INTUITION HERE
        """"""
        1. can I generate all substrings and check if the strings in the 
        dictionary are present in the substring.
        2. This will not work, why? Because strings in the mother set 
        may have been used already to create another string
        
        SOLUTION
        --------------------------
        1. Go through the dictionary of words and find the string which is the 
        potential begining of the string
        2. segment the length of that string from the string.
        3. Check if the remaining string can also be segmented in words from 
        the dictionary.
        4. if there are no more strings to segment then we can return True.
        5. This is a recurrence problem and can be solved with the recurrence 
        solution.
        
        6. The recurrence function should go through the word dictionary 
        and the one which qualifies will now segment the rest of the string 
        and check for the rest of the segment of the string.
        
        FOR THE RECURRENCE RELATION
        
        1. With every word in the dictionary, get the length of the word.
        2. Check if a segment of the string is equal to that word.
        3. if True, call the function of the rest of the segment of the string.
        
        Base Case:
        1. If all strings are segmented, which means we have the empty ("""") string
        so we can then return True
        
        2. Else we return False
        
        """"""
        """""" RECURRENCE SOLUTION """"""
        def sectionBreak(string):
            if len(string) == 0:
                return True

            for word in wordDict:
                prefix = string[:len(word)]

                if prefix == word and sectionBreak(string[len(word):]):
                    return True
            return False
        
        return sectionBreak(s)
        
        """"""
        MOMOIZATION
        """"""
        def sectionBreak(string, memo):
            if len(string) == 0:
                return True
            elif string in memo:
                return memo[string]

            for word in wordDict:
                prefix = string[:len(word)]

                if prefix == word and sectionBreak(string[len(word):], memo):
                    memo[string] = True
                    return True
            memo[string] = False
            return False
        
        return sectionBreak(s, {})

        """"""
        The dynammic programming approach 
        1. The empty substring can be segmented to any of the words in the dictionary.
        2. Let the index of the words represents the sufix of words in the dictionary.
        3. If suffix of a word is in the dictionary then and the suffix of the previous 
        word is also in the dictionary, then it stands to prove that, the substring of 
        the string up to the current suffix can also be segmented
        """"""
    
        # Initialize a dp table with the length of the string + 1
        # Plus 1 is to compensate for the empty string
        # You can either iterate from the back if you want to use the prefix instead of suffix pointers.
        
        wordSet = set(wordDict) # put words in a hashSet to optimize lookup to O(1)
        dp = [False for _ in range(len(s)+1)]
        dp[0] = True
        
        for i in range(1, len(s)+1):
            for j in range(i-1, -1, -1):
                if dp[j] and s[j:i] in wordSet:
                    dp[i] = True
                    break  # break from the loop if a segment is found
        return dp[-1]";"class Solucion:
    def puede_segmentar(self, cadena, diccionario_palabras):
        longitud_cadena = len(cadena)
        
        es_posible = []
        indice_inicializador = 0
        while indice_inicializador < longitud_cadena + 1:
            es_posible.append(False)
            indice_inicializador = indice_inicializador + 1

        es_posible[0] = True

        i = 1
        while i <= longitud_cadena:
            j = 0
            while j < i:
                if es_posible[j] == True:
                    subcadena = cadena[j:i]
                    if subcadena in diccionario_palabras:
                        es_posible[i] = True
                        break
                j = j + 1
            i = i + 1
        
        return es_posible[longitud_cadena]"
"class Solution:
    def binaryGap(self, n: int) -> int:
        
        #Bit mask
        mask = 1,
        
        #Max streak and streak default to zero
        maxStreak = 0,
        streak = 0,
        
        #Burn through all of the rightmost zeroes
        #Keep bitshifting n to the right
        #As long as the rightmost bit is not 1 ( which means its even)
        while n > 0 and n % 2 != 1:
            n = n >> 1,
        
        #Then we can begin finding our distances
        while n > 0:
            #Each iteration, we see if the rightmost bit is 1
            isOne = ( mask &amp, n ) == 1,
            
            #If it is, we update our max
            if isOne:
                maxStreak = max( maxStreak, streak ),
                
                #And then increment the streak
                streak = 1,
                
            #If it is a zero, we increment the streak
            else:  
                streak += 1,
                
            #Each time, we bitshift right
            n = n >> 1,
        
        #Note, we will always end at a valid 1 as leading zeros are not
        #processed and we stop when n == 0
        return maxStreak,";"class Solucion:
    def distancia_binaria(self, n):
        cadena_binaria = bin(n)[2:]
        
        distancia_mas_larga = 0
        indice_del_ultimo_uno = -1
        
        indice = 0
        while indice < len(cadena_binaria):
            caracter = cadena_binaria[indice]
            
            if caracter == '1':
                if indice_del_ultimo_uno != -1:
                    distancia_actual = indice - indice_del_ultimo_uno
                    if distancia_actual > distancia_mas_larga:
                        distancia_mas_larga = distancia_actual
                
                indice_del_ultimo_uno = indice
            
            indice = indice + 1
            
        return distancia_mas_larga"
"class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        
        """"""
        Let suppose we can divide the array in to two subsets S1 and S2.
        Such that, the difference of those subset is target value.
        sum(S1) + sum(S2) = total     --- (1)
        sum(S1) - sum(S2) = target    --- (2)
        _____________________________________
        2*sum(S1) = total + target    --- (1) + (2)
        
        Hence, sum(S1) = total + target // 2
        """"""
        
        # Total of array
        total = sum(nums)
        
        # Base Case:
        # If total is less than target it is not possible to find any subsets
        # If total + target is odd, no subset exists
        if (total < target) or ((total + target) % 2):
            return 0
        
        # Get the value of sum of subset S1
        sum_s1 = (total + target) // 2
        
        # Recurrsion with memoization
        def countSubsetSum(n: int, w : int, t: Dict):
            if n == 0:
                t[(n,w)] = (0 if w else 1)
            else:
                if (n,w) not in t:
                    if nums[n-1] <= w:
                        t[(n,w)] = countSubsetSum(n-1, w-nums[n-1], t) + countSubsetSum(n-1, w, t) 
                    else:
                        t[(n,w)] = countSubsetSum(n-1, w, t)
            return t[(n,w)]
            
        return countSubsetSum(len(nums), sum_s1, dict())";"def encontrar_maneras_de_suma_objetivo(nums, objetivo):
    calculos = {0: 1}

    for numero in nums:
        nuevos_calculos = {}
        for suma_actual, cantidad in calculos.items():
            
            suma_con_mas = suma_actual + numero
            if suma_con_mas in nuevos_calculos:
                nuevos_calculos[suma_con_mas] = nuevos_calculos[suma_con_mas] + cantidad
            else:
                nuevos_calculos[suma_con_mas] = cantidad

            suma_con_menos = suma_actual - numero
            if suma_con_menos in nuevos_calculos:
                nuevos_calculos[suma_con_menos] = nuevos_calculos[suma_con_menos] + cantidad
            else:
                nuevos_calculos[suma_con_menos] = cantidad
        
        calculos = nuevos_calculos
    
    resultado_final = 0
    if objetivo in calculos:
        resultado_final = calculos[objetivo]
        
    return resultado_final"
"class Solution:
    #Time-Complexity: O(16rows*cols), in worst case our bfs algorithm needs to         process, and each iteration of while loop in worst case will run for loop
    #2 times, with each going through each of eight directions for total of 16!
    #-> O(rows*cols)
    #Space-Complexity: O(2rows*cols)->O(rows*cols)
    #each and every entry of grid that could be updated!
    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:
        #click is going to be start position of our bfs!
        
        #first thing we got to check is if click position clicks a unrevealed mine directly -> Immediate
        #Game Over!
        rows, cols = len(board), len(board[0])
        sr, sc = click
        if(board[sr][sc] == 'M'):
            board[sr][sc] = 'X'
            return board
        
        #otherwise, we need to inititate bfs starting from click position using a queue data structure!
        q = collections.deque()
        #need a visited hashset so we don't revisit empty cell again! Since we may need to bfs
        #continuously from a cell with no adjacent mines in terms of its neighbors!
        visited = set()
        q.append(click)
        visited.add((sr, sc))
        eight_directions = [[1, 0], [-1, 0], [0, 1], [0,-1], [-1, -1], [-1, 1], [1, -1], [1, 1]]
        # as long as queue is non-empty initiate bfs!
        while q:
            #cr = current row, cc = current column!
            cr, cc = q.popleft()
            #for each new empty cell we are processing, the number of adjacent mines starts as 0!
            number_of_mines = 0
            #we have to loop through each of the 8 directional neighbors and check how many of them
            #are in-bounds, unrevealed mine cell!
            for direction in eight_directions:
                r_change, c_change = direction
                if(cr + r_change in range(rows) and 
                   cc + c_change in range(cols) and 
                   board[cr+r_change][cc+c_change] == 'M'):
                    number_of_mines += 1
            #once we iterated through all possible eight neighbors, check if current empty cell
            #has no adjacent mines or even at least 1!
            if(number_of_mines == 0):
                #then, check each of eight directional neighbors: in-bounds, unrevealed empty cell, and
                #and it's not already visited!
                for direction2 in eight_directions:
                    r_change2, c_change2 = direction2
                    if(cr + r_change2 in range(rows) and
                       cc + c_change2 in range(cols) and
                       board[cr+r_change2][cc+c_change2] == 'E' and
                       (cr+r_change2, cc+c_change2) not in visited):
                        q.append([cr+r_change2, cc+c_change2])
                        visited.add((cr+r_change2, cc+c_change2))
                #current empty cell 
                board[cr][cc] = 'B'
            else:
                #otherwise, we need to stop bfs from current cell and label current cell
                #by number of adjacent land mines! digits 1-8 at most!
                board[cr][cc] = str(number_of_mines)
        #once bfs is done, our game board is updated! Simply return it!
        return board";"def actualizar_tablero(tablero, click):
    filas = len(tablero)
    columnas = len(tablero[0])
    fila_click = click[0]
    columna_click = click[1]

    if tablero[fila_click][columna_click] == 'M':
        tablero[fila_click][columna_click] = 'X'
        return tablero

    if tablero[fila_click][columna_click] != 'E':
        return tablero

    cola_de_revelacion = []
    cola_de_revelacion.append((fila_click, columna_click))

    while len(cola_de_revelacion) > 0:
        posicion_actual = cola_de_revelacion.pop(0)
        fila_actual = posicion_actual[0]
        columna_actual = posicion_actual[1]
        
        if tablero[fila_actual][columna_actual] != 'E':
            continue

        minas_adyacentes = 0
        for i in range(-1, 2):
            for j in range(-1, 2):
                if i == 0 and j == 0:
                    continue
                
                fila_vecina = fila_actual + i
                columna_vecina = columna_actual + j

                if 0 <= fila_vecina < filas and 0 <= columna_vecina < columnas:
                    if tablero[fila_vecina][columna_vecina] == 'M':
                        minas_adyacentes = minas_adyacentes + 1
        
        if minas_adyacentes > 0:
            tablero[fila_actual][columna_actual] = str(minas_adyacentes)
        else:
            tablero[fila_actual][columna_actual] = 'B'
            for i in range(-1, 2):
                for j in range(-1, 2):
                    if i == 0 and j == 0:
                        continue

                    fila_vecina = fila_actual + i
                    columna_vecina = columna_actual + j

                    if 0 <= fila_vecina < filas and 0 <= columna_vecina < columnas:
                        if tablero[fila_vecina][columna_vecina] == 'E':
                            cola_de_revelacion.append((fila_vecina, columna_vecina))

    return tablero"
"class Solution:
    def isUgly(self, n):
        # Base Cases: 
        # For a number to be ""Ugly"" the first
        # prerequisite is that it is positive
        if n <= 0: return False
        if n == 1: return True

        # Initializing desired set for O(1) lookups later
        # Not a huge improvement, but it's non-zero improvement
        desired = {2,3,5}
        primes = (i for i in [2,3,5,7])

        current_prime = next(primes)
        while True:
            # As soon as our current prime exceeds 2,3,5 we know our n
            # has prime factors not included in the ""Ugly"" grouping
            if current_prime not in desired: return False
            
            # We want to divide n by said prime as many times as we can
            # If the prime doesn't divide evenly into n then we go to the
            # next prime. We would only do this shift 3 times, and once 
            # we have, we've gone into the realm of non-Ugly numbers
            while n % current_prime == 0:
                div= n/current_prime
                if div == 1: return True
                n = div
            current_prime = next(primes)";"def es_numero_feo(numero):
    if numero <= 0:
        return False

    while numero % 2 == 0:
        numero = numero / 2

    while numero % 3 == 0:
        numero = numero / 3

    while numero % 5 == 0:
        numero = numero / 5

    if numero == 1:
        return True
    else:
        return False"
"class Solution:
    def deserialize(self, s: str) -> NestedInteger:
        stack = []
        integerStr = ''
        
        for c in s:
            if c == '[':
                stack.append(NestedInteger())
            elif c == ']':
                if len(integerStr)>0:
                    stack[-1].add(NestedInteger(int(integerStr)))
                integerStr = ''
                poppedList = stack.pop()
                if len(stack)==0:
                    return poppedList
                stack[-1].add(poppedList)
            elif c == ',':
                if len(integerStr)>0:
                    stack[-1].add(NestedInteger(int(integerStr)))
                integerStr = ''
            else:
                integerStr += c
                
        return NestedInteger(int(s))";"# La clase NestedInteger es predefinida y no necesita ser implementada.
# class NestedInteger:
#    def __init__(self, value=None):
#        """"""
#        Si el valor es un entero, inicializa un NestedInteger con ese entero.
#        De lo contrario, inicializa un NestedInteger vacío (una lista anidada vacía).
#        """"""
#
#    def isInteger(self):
#        """"""
#        Devuelve True si este NestedInteger contiene un solo entero.
#        """"""
#
#    def add(self, elem):
#        """"""
#        Añade un NestedInteger a la lista anidada.
#        """"""
#
#    def setInteger(self, value):
#        """"""
#        Establece este NestedInteger para que contenga un solo entero.
#        """"""
#
#    def getInteger(self):
#        """"""
#        Devuelve el entero que contiene este NestedInteger si es un entero.
#        """"""
#
#    def getList(self):
#        """"""
#        Devuelve la lista anidada que contiene este NestedInteger si es una lista.
#        """"""

class Solucion:
    def deserializar(self, cadena: str) -> 'NestedInteger':
        if not cadena:
            objeto_vacio = NestedInteger()
            return objeto_vacio

        if cadena[0] != '[':
            valor_entero = int(cadena)
            objeto_entero = NestedInteger(valor_entero)
            return objeto_entero

        pila = []
        numero_actual = """"
        
        for caracter in cadena:
            if caracter == '[':
                lista_nueva = NestedInteger()
                if pila:
                    lista_padre = pila[-1]
                    lista_padre.add(lista_nueva)
                pila.append(lista_nueva)
            elif caracter == ']':
                if numero_actual != """":
                    valor = int(numero_actual)
                    entero_anidado = NestedInteger(valor)
                    lista_actual = pila[-1]
                    lista_actual.add(entero_anidado)
                    numero_actual = """"
                
                lista_terminada = pila.pop()
                
                if not pila:
                    return lista_terminada
            elif caracter == ',':
                if numero_actual != """":
                    valor = int(numero_actual)
                    entero_anidado = NestedInteger(valor)
                    lista_actual = pila[-1]
                    lista_actual.add(entero_anidado)
                    numero_actual = """"
            else:
                numero_actual = numero_actual + caracter
        
        return None"
"class Solution:
    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:
        prev_key, prev_ts = ('',0) ## this tuple will contain the previous key press and when that was released (prev_ts)
        slowest_key, max_duration = ('',0) ## this tuple will contain the slowest key and for how long it was pressed for
        for key,release_ts in zip(keysPressed,releaseTimes): ## convert keyPressed and releaseTimes into tuples and example the tuple one-by-one
            cur_duration = release_ts - prev_ts ## get the duration for which the key was pressed
            if prev_ts == 0: ## initial case, first key press
                prev_ts = release_ts
                max_duration=release_ts
            if cur_duration > max_duration: ## subsequent keys, check if current duration is more than max we have seen so far
                slowest_key, max_duration = key, cur_duration ## assign the max tuple with the new max and corresponding key
            elif cur_duration == max_duration: ## if current key press duration and max are the same, 
                if key > slowest_key: ## check which one is higher lexically, if current key is higher then update the slowest key to current key
                    slowest_key = key
            prev_key, prev_ts = key, release_ts ## set current key and release_ts to prev for next iteration
        return slowest_key";"class Solucion:
    def tecla_mas_lenta(self, tiempos_de_liberacion, teclas_presionadas):
        duracion_maxima = 0
        tecla_mas_larga = ''

        # Manejar el primer tecleo
        duracion_maxima = tiempos_de_liberacion[0]
        tecla_mas_larga = teclas_presionadas[0]

        # Iterar sobre el resto de los tecleos
        i = 1
        while i < len(teclas_presionadas):
            duracion_actual = tiempos_de_liberacion[i] - tiempos_de_liberacion[i - 1]
            tecla_actual = teclas_presionadas[i]

            if duracion_actual > duracion_maxima:
                duracion_maxima = duracion_actual
                tecla_mas_larga = tecla_actual
            elif duracion_actual == duracion_maxima:
                if tecla_actual > tecla_mas_larga:
                    tecla_mas_larga = tecla_actual
            
            i = i + 1
        
        return tecla_mas_larga"
"class Solution:
    # O(n * m^2) time, n --> len(wordList), m --> len(wordList[i])
    # O(n*m) space,
    # Approach: BFS, hashtable, string
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        
        vstd = set()
        pattern_map = {}
        
        def buildPattern() -> None:
            addWordPattern(beginWord)
            for word in wordList:
                addWordPattern(word)
                
        
        def addWordPattern(word: str) -> None:
            patterns = getPatterns(word)
            
            for pattern in patterns:
                if pattern not in pattern_map.keys():
                    pattern_map[pattern] = []
                pattern_map[pattern].append(word)
        
        
        def getPatterns(word: str) -> List[str]:
            patterns = []
            for i in range(len(word)):
                pattern = word[:i] + '#' + word[i+1:]
                patterns.append(pattern)
                
            return patterns
        
        
        def getNeighbours(root_word: str) -> List[str]:
            neighbours = []
            patterns = getPatterns(root_word)
            
            for pattern in patterns:
                words = pattern_map[pattern]
                for word in words:
                    if word != root_word:
                        neighbours.append(word)
                
            return neighbours
        
        
        def bfs(root_word:str) -> int:
            qu = deque()
            qu.append(root_word)
            depth = 0
            
            while qu:
                n = len(qu)
                depth +=1
                for i in range(n):
                    root_word = qu.popleft()
                    if root_word in vstd:   continue
                    
                    if root_word == endWord:
                        return depth
                    
                    vstd.add(root_word)
                    neighbours = getNeighbours(root_word)
                    for nb in neighbours:
                        qu.append(nb)
                    
            return 0
            
        buildPattern()
        ans = bfs(beginWord)
        return ans";"def escalera_de_palabras(palabra_inicial, palabra_final, lista_de_palabras):
    conjunto_palabras = set(lista_de_palabras)
    if palabra_final not in conjunto_palabras:
        return 0

    cola = []
    cola.append((palabra_inicial, 1))

    visitadas = set()
    visitadas.add(palabra_inicial)

    while len(cola) > 0:
        palabra_actual, nivel = cola.pop(0)

        if palabra_actual == palabra_final:
            return nivel

        longitud_palabra = len(palabra_actual)
        i = 0
        while i < longitud_palabra:
            palabra_como_lista = list(palabra_actual)
            caracter_original = palabra_como_lista[i]

            abecedario = ""abcdefghijklmnopqrstuvwxyz""
            j = 0
            while j < len(abecedario):
                letra_nueva = abecedario[j]
                palabra_como_lista[i] = letra_nueva
                palabra_nueva = """".join(palabra_como_lista)

                if palabra_nueva in conjunto_palabras and palabra_nueva not in visitadas:
                    visitadas.add(palabra_nueva)
                    cola.append((palabra_nueva, nivel + 1))
                
                j = j + 1
            
            palabra_como_lista[i] = caracter_original
            i = i + 1

    return 0"
"class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        drop = {}   # passengers drop location list        
        nxt = trips[0][2]   # next/earliest drop point
        
        # swap-> numPassengersi and fromi in the trips, then
        # sort(asc) trips as per pickup location
        for p in trips:
            p[0], p[1]  = p[1], p[0]
        heapq.heapify(trips)
        
			seats = capacity    #available seats
        while trips:
            # current stop, num of passenger, dest/to
            (curr, psg, dest) = heapq.heappop(trips)
            # drop passengers
            while nxt <= curr:
                if drop:
                    seats += drop[nxt]
                    del drop[nxt]
                    if drop:
                        nxt = min(drop)                
                    else:
                        nxt = dest                            
            # pick passengers/psg        
            seats -= psg            
            if seats < 0:                
                return False
            #number of passengers to drop at location dest
            if dest in drop:
                drop[dest] += psg
            else:                
                drop[dest] = psg
            nxt = min(nxt, dest)            
            
        return True";"class Solucion:
    def coche_compartido(self, capacidad, viajes):
        paradas = []
        i = 0
        while i < 1001:
            paradas.append(0)
            i = i + 1

        for viaje in viajes:
            numero_pasajeros = viaje[0]
            inicio = viaje[1]
            fin = viaje[2]
            paradas[inicio] = paradas[inicio] + numero_pasajeros
            paradas[fin] = paradas[fin] - numero_pasajeros

        pasajeros_a_bordo = 0
        i = 0
        while i < 1001:
            pasajeros_a_bordo = pasajeros_a_bordo + paradas[i]
            if pasajeros_a_bordo > capacidad:
                return False
            i = i + 1
        
        return True"
"class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        
        dict_1 = from_str_to_dict(ransomNote)
        dict_2 = from_str_to_dict(magazine)
        
        return check_compatibility(dict_1, dict_2)
    
# Define helper method that checks if to dictionaries have keys in common, and 
# if the ransomNote needs more letters then what the magazine can provide.

def check_compatibility(dict_1, dict_2):
    
    # Check for common keys.
    for key in list(dict_1.keys()):
        
        if not key in dict_2:
            
            return False
        
        # Check for valid quantity.
        if dict_1[key] > dict_2[key]:
            
            return False
        
    return True

# Convert a string into a dictionary.

def from_str_to_dict(string: str):
    
    dic = {}
    
    for i in string:
        
        if i in dic:
            
            dic[i] += 1
            
        else:
            
            dic[i] = 1
            
    return dic        

# Runtime: 134 ms, faster than 24.02% of Python3 online submissions for Ransom Note.
# Memory Usage: 14.1 MB, less than 93.55% of Python3 online submissions for Ransom Note.

# If you like my work and found it helpful, then I'll appreciate a like. Thanks!";"def puede_construirse(nota_rescate, revista):
    lista_letras_revista = list(revista)
    
    for letra in nota_rescate:
        if letra in lista_letras_revista:
            lista_letras_revista.remove(letra)
        else:
            return False
            
    return True"
"class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        self.targetSum, self.ans = targetSum, []            # variable initialization
        self.get_path_sum(root, 0, [])                      # calling function get path sum
        return self.ans                                     # return answer
        
    def get_path_sum(self, root, psum, path):
        if not root: return None                            # if not root return None
        if not root.left and not root.right:                # if curr node is leaf
            if root.val + psum == self.targetSum:           # if path sum from root to leaf = target sum
                path.append(root.val)                       # append node value to path
                self.ans.append([e for e in path])          # add path to ans list
                path.pop(-1)                                # remove node value from path
                return,                                     # return
        path.append(root.val)                               # append node value to path
        self.get_path_sum(root.left, psum + root.val, path) # left traversal
        self.get_path_sum(root.right, psum + root.val, path)# right traversal
        path.pop(-1)                                        # remove node value from path";"class NodoArbol:
    def __init__(self, val=0, izquierda=None, derecha=None):
        self.val = val
        self.izquierda = izquierda
        self.derecha = derecha

def encontrar_caminos(raiz, suma_objetivo):
    if raiz is None:
        return []

    resultados_finales = []
    pila_de_nodos = []
    
    camino_inicial = [raiz.val]
    pila_de_nodos.append((raiz, raiz.val, camino_inicial))

    while len(pila_de_nodos) > 0:
        nodo_actual, suma_actual, camino_actual = pila_de_nodos.pop()

        es_hoja = False
        if nodo_actual.izquierda is None and nodo_actual.derecha is None:
            es_hoja = True

        if es_hoja:
            if suma_actual == suma_objetivo:
                resultados_finales.append(camino_actual)

        if nodo_actual.derecha is not None:
            nuevo_camino_derecha = []
            for valor in camino_actual:
                nuevo_camino_derecha.append(valor)
            nuevo_camino_derecha.append(nodo_actual.derecha.val)
            
            nueva_suma_derecha = suma_actual + nodo_actual.derecha.val
            pila_de_nodos.append((nodo_actual.derecha, nueva_suma_derecha, nuevo_camino_derecha))

        if nodo_actual.izquierda is not None:
            nuevo_camino_izquierda = []
            for valor in camino_actual:
                nuevo_camino_izquierda.append(valor)
            nuevo_camino_izquierda.append(nodo_actual.izquierda.val)

            nueva_suma_izquierda = suma_actual + nodo_actual.izquierda.val
            pila_de_nodos.append((nodo_actual.izquierda, nueva_suma_izquierda, nuevo_camino_izquierda))
            
    return resultados_finales"
"class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        # To adhere to the problem's constraints, we should probably hardcode this!
        tables_of_addition = {str(x): {str(i): str(x+i) for i in range(10)} for x in range(0, 10)}
        # Corner case
        for i in range(10, 20): tables_of_addition[""1""][str(i)] = str(1+i)
        
        # Ensuring that the 2 numbers are the same size.
        num1 = num1.zfill(max(len(num1), len(num2)))
        num2 = num2.zfill(max(len(num1), len(num2)))

        p = len(num1)-1
        
        carry, results = ""0"", """"
        while p > -1:
            curr_res = tables_of_addition[num1[p]][num2[p]]
            
            # Carry is a bit tricky since current result can be in the range 0, 18 (inclusive)
            curr_res_with_carry = tables_of_addition[str(carry)][curr_res] if str(carry) == ""1"" else curr_res
            carry = ""0""
            
            # We know that the maximum addition (between 9 &amp, 9) is 2 digits and will equal 18
            if len(curr_res_with_carry) > 1:
                carry = curr_res_with_carry[0]
                results = curr_res_with_carry[1]+results
            else:
                results = curr_res_with_carry[0]+results
            p-=1
        
        return results if carry == ""0"" else carry + results";"class Solucion:
    def sumar_cadenas(self, numero1, numero2):
        puntero1 = len(numero1) - 1
        puntero2 = len(numero2) - 1
        
        acarreo = 0
        resultado_temporal = []
        
        while puntero1 >= 0 or puntero2 >= 0:
            suma = acarreo
            
            if puntero1 >= 0:
                suma = suma + int(numero1[puntero1])
                puntero1 = puntero1 - 1
            
            if puntero2 >= 0:
                suma = suma + int(numero2[puntero2])
                puntero2 = puntero2 - 1
            
            acarreo = suma // 10
            digito = suma % 10
            
            resultado_temporal.append(str(digito))
            
        if acarreo > 0:
            resultado_temporal.append(str(acarreo))
        
        resultado_final = """"
        indice = len(resultado_temporal) - 1
        while indice >= 0:
            resultado_final = resultado_final + resultado_temporal[indice]
            indice = indice - 1
            
        return resultado_final"
"class Solution:
    def maxJumps(self, nums: List[int], d: int) -> int:
        N = len(nums)
        seen = set() # seen for lookup, to memoize
        dp = [1]*N   # stores the values of jump we can make from Ith index in DP.                                    #  minimum being 1 jump (i.e its self)
        
        def recursion(indx):
            # if we have indx in seen return its value  dp[indx].
            if indx in seen:
                return dp[indx]
            # base case if indx is out of range we cant jump. return 0
            if indx<0 or indx >= N:
                return 0
            
        # tempR : all the jumps we can make to the right side of indx
        # tempL : all the jumps we can make to the left side of indx
            tempR,tempL= 0,0
            curr = nums[indx] # height of current indx so we only jump allowed jump 
                    # i.e nums[i] < curr <- allowed  if curr =< nums[i] break(jump not allowed)
            
            #max jump we can make to the right Side are stored in tempR, 
            for i in range(indx+1, min(indx+d+1,N) ):
                if nums[i] < curr:
                    tempR = max(tempR, recursion(i)) # store max jumps in right
                else:
                    break
            for i in range(indx-1, max(-1,indx-d-1) , -1): 
                if nums[i] < curr:
                    tempL = max(tempL, recursion(i)) # store max jumps in  left
                else:
                    break
            # update dp[indx] by (1 + maxjumps( right, left))   ( 1 becoz it can jump on itself)
            dp[indx] = max(tempR,tempL) + 1 
            seen.add(indx) # as Indx calculated, can use its value next time, so added to seen
            return dp[indx]
        
        
        # for all indices we check how many jumps we can make
        for i in range(N): 
            if i not in seen: # if ith index is not in seen then we have comupted its jumps.
                recursion(i)
        return max(dp)  # returns the max jumps";"class Solucion:
    def maxJumps(self, arr, d):
        longitud = len(arr)
        
        caminos = []
        for i in range(longitud):
            caminos.append(1)

        valor_e_indice_pares = []
        for i in range(longitud):
            par = (arr[i], i)
            valor_e_indice_pares.append(par)
        
        valor_e_indice_pares.sort()

        for par_actual in valor_e_indice_pares:
            i = par_actual[1]

            # Mirar a la derecha
            for j in range(i + 1, longitud):
                if j > i + d:
                    break
                if arr[i] <= arr[j]:
                    break
                
                nuevo_camino = 1 + caminos[j]
                if nuevo_camino > caminos[i]:
                    caminos[i] = nuevo_camino

            # Mirar a la izquierda
            for j in range(i - 1, -1, -1):
                if j < i - d:
                    break
                if arr[i] <= arr[j]:
                    break
                
                nuevo_camino = 1 + caminos[j]
                if nuevo_camino > caminos[i]:
                    caminos[i] = nuevo_camino

        resultado_final = 0
        for valor in caminos:
            if valor > resultado_final:
                resultado_final = valor
        
        return resultado_final"
"class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if node is None: return None #if we have an empty graph
        visited = [] #will store all visited nodes
        cloneNodes = {} #will store cloned nodes. In each k:v pair k is the val attribute of 
                        #the old node and v is the corresponding cloned node
        adj = {} #the adjacency list for the graph. In each k:v pair k is the val attribute
                 #of a node and v is a list of the val attributes of its neighbors.
        stack = [node] #stack of nodes to be visited. Each time we visit a node, we will add
                       #its neighbors in the stack.
        while stack != []:
            curr = stack.pop() #take a node out of the stack
            if curr.val not in visited: #if node was already visited we do nothing
                visited.append(curr.val)
                cloneNodes[curr.val] = Node(curr.val) #create new node with the same val and 
                                                      #no neighbors
                adj[curr.val] = []
                for nd in curr.neighbors:
                    stack.append(nd) #add neighbors in the stack
                    adj[curr.val].append(nd.val) #save neighbors in adjacency dictionary
        for k, v in adj.items():
            #update neighbors of cloned nodes to match the neighbors of old ones
            cloneNodes[k].neighbors = [cloneNodes[i] for i in v]
        return cloneNodes[node.val] #return clone of initial node";"class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return None

        mapa_de_clones = {}
        
        clon_del_nodo_raiz = Node(node.val, [])
        mapa_de_clones[node] = clon_del_nodo_raiz
        
        cola = []
        cola.append(node)
        
        indice_actual = 0
        while indice_actual < len(cola):
            nodo_original = cola[indice_actual]
            indice_actual = indice_actual + 1
            
            vecinos_originales = nodo_original.neighbors
            
            for vecino in vecinos_originales:
                if vecino not in mapa_de_clones:
                    clon_del_vecino = Node(vecino.val, [])
                    mapa_de_clones[vecino] = clon_del_vecino
                    cola.append(vecino)
            
                clon_del_nodo_actual = mapa_de_clones[nodo_original]
                clon_del_vecino_a_conectar = mapa_de_clones[vecino]
                clon_del_nodo_actual.neighbors.append(clon_del_vecino_a_conectar)

        return clon_del_nodo_raiz"
"class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        n=len(nums)
        
        # Brute Force: O(n^3) --> TLE
		# for i in range(n):
        #     for j in range(i+1, n):
        #         for k in range(j+1, n):
        #             if nums[i]<nums[k] and nums[k]<nums[j]:
        #                 return True
        
        # Optimised using BS: O(nlogn) --> TLE 
        # for i in range(n):
        #     j=i+1
        #     k=n-1
        #     while j<k:
        #         if nums[i]<nums[j] and nums[i]<nums[k]:
        #             if nums[j]<nums[k]:
        #                 k-=1
        #             elif nums[k]==nums[j]:
        #                 j+=1
        #             else:
        #                 return True
        #         elif nums[i]<nums[j]:
        #             k-=1
        #         else:
        #             j+=1
        
        # Optimised using Monotonic stack: O(n)
        st=[]
        mini=nums[0]
        for num in nums:
            while st and st[-1][0]<=num:
                st.pop()
            if st and st[-1][1]<num:
                return True
            st.append([num, mini])
            mini=min(mini, num)
        return False";"class Solucion:
    def encontrar_patron_132(self, numeros):
        longitud = len(numeros)
        if longitud < 3:
            return False

        indice_i = 0
        while indice_i < longitud:
            indice_j = indice_i + 1
            while indice_j < longitud:
                indice_k = indice_j + 1
                while indice_k < longitud:
                    valor_i = numeros[indice_i]
                    valor_j = numeros[indice_j]
                    valor_k = numeros[indice_k]
                    if valor_i < valor_k and valor_k < valor_j:
                        return True
                    indice_k = indice_k + 1
                indice_j = indice_j + 1
            indice_i = indice_i + 1
            
        return False"
"class Solution:
    def new21Game(self, n: int, k: int, maxPts: int) -> float:
        if n >= k - 1 + maxPts: return 1 #the last possible stop-point is k-1, if we roll a maxPts and it will end within n, that means anyway it will end within n with prob 1, there is no need to continue
        dp = [0] * (n + 1) #dp[i] is the probability we reach point i. As we care what's the probability within n, at most we need dp to calculate from 1 to n
        dp[0], curSum = 1, 0 #dp[0] is the probability we reach 0. As we start with 0, we have a probability of 1 reaching 0
        for i in range(1, n + 1):
            if i - 1 < k: # when the previous point hasn't reached k, that means we can still continue to roll, and we'll add that point. Otherwise, when i - 1 already reaches k, then the game stops and we cannot reach status i from  i - 1 (we cannot pick any more number)
                curSum += dp[i - 1]
            if i - 1 >= maxPts: # we can only reach point i from point i - 1, i - 2, ..., i - maxPts. and hence when we calculate point i, we need to make sure the previous points outside of the range drops out
                curSum -= dp[i - 1 - maxPts]
            dp[i] = curSum / maxPts
        return sum(dp[k:]) # we calculate all the probabilities that we land in point k, point k + 1, until point n";"class Solucion:
    def nueva_partida_21(self, n, k, puntos_maximos):
        if k == 0:
            return 1.0
        
        if n >= k - 1 + puntos_maximos:
            return 1.0

        probabilidades = [0.0] * (n + 1)
        probabilidades[0] = 1.0
        
        suma_ventana = 1.0
        resultado = 0.0

        for i in range(1, n + 1):
            probabilidades[i] = suma_ventana / puntos_maximos
            
            if i < k:
                suma_ventana = suma_ventana + probabilidades[i]
            else:
                resultado = resultado + probabilidades[i]
                
            indice_viejo = i - puntos_maximos
            if indice_viejo >= 0:
                if indice_viejo < k:
                     suma_ventana = suma_ventana - probabilidades[indice_viejo]

        return resultado"
"class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        return self.moveZerosOptimal(nums)
		return self.moveZerosOptimalTwo(nums)
        # return self.moveZeroesByPopAndAppend(nums)

#     O(n) || O(1)
# runtime: 291ms 32.26%
    def moveZerosOptimal(self, nums):
        if not nums:return nums

        nextPtr = 0

        for num in nums:
            if num != 0:
                nums[nextPtr] = num
                nextPtr += 1
        
        for i in range(nextPtr, len(nums)):
            nums[i] = 0

        return nums
    
	# O(n) || O(1)
	def moveZerosOptimalTwo(self, nums):
		if not nums:
			return nums
			
		left = 0
		for right in range(len(nums)):
			if nums[right]:
				nums[left], nums[right] = nums[right], nums[left]
				left += 1
		return nums
    
# O(n) || O(1) space: but its a bad practice,
# appending a element is an O(1) operation but when you pop(O(1)) 
# all the elements to its right move to fill the space. O(n)
# runtime: 1698ms 5.69%
    def moveZeroesByPopAndAppend(self, nums):
        if not nums:
            return nums

        for i in nums:
            if i == 0:
                nums.remove(i)
                nums.append(i)

        return nums";"def mover_ceros(numeros):
    posicion_escritura = 0
    
    for i in range(len(numeros)):
        if numeros[i] != 0:
            numeros[posicion_escritura] = numeros[i]
            posicion_escritura = posicion_escritura + 1
            
    while posicion_escritura < len(numeros):
        numeros[posicion_escritura] = 0
        posicion_escritura = posicion_escritura + 1"
"class Solution:
        #greedy algorithm
        def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
                #if the gas at all stations is less than the cost at all stations then gas will not be sufficient to travel the circuit once
                if sum(gas) < sum(cost):
                        #so return - 1
                        return - 1
                #if the gas is sufficient 
                #we have to find from which index we should start
                total = 0 
                #res is a variable which is created to store the index from which we are going to start
                res = 0 
                #iterate of the indexes of gas
                for i in range(len(gas)):
                        #add the difference of gas and cost at each station
                        total += (gas[i]  - cost[i])
                        #if the difference is less than 0 
                        if total < 0:
                                #then we have to check the positive difference
                                #so reset total to 0 
                                total = 0
                                #increse the res value to next index
                                res = i + 1
                #after finishing the for-loop 
                #we the return the index where first positive difference is occured
                return res";"class Solucion:
    def puede_completar_circuito(self, gas, costo):
        numero_de_estaciones = len(gas)
        balance_total = 0
        tanque_actual = 0
        estacion_de_inicio = 0

        for i in range(numero_de_estaciones):
            balance_en_estacion = gas[i] - costo[i]

            balance_total = balance_total + balance_en_estacion
            tanque_actual = tanque_actual + balance_en_estacion

            if tanque_actual < 0:
                estacion_de_inicio = i + 1
                tanque_actual = 0

        if balance_total < 0:
            return -1
        else:
            return estacion_de_inicio"
"class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        
        # Init
        m = len(matrix)
        n = len(matrix[0])
        max_len = 0
        
        # Convert matrix value of string to int
        for row in range(m):
            for col in range(n):
                matrix[row][col] = int(matrix[row][col])
        
        # Scan first row
        for col in range(n):
            max_len = max(max_len, matrix[0][col])
            
        # Scan first column
        for row in range(m):
            max_len = max(max_len, matrix[row][0])
        
        # For each row starting from second row
        for i in range(1,m):
            
            # For each col starting from second column
            for j in range(1,n):
                
                # If the current element is non-zero
                if matrix[i][j]:
                    
                    # If all three of it's adjacent elements are non-zero
                    # Three elements are:
                    # a) element in the previous row ""[i-1][j]""
                    # b) element in the previous column ""[i][j-1]""
                    # c) element in previous diagonal ""[i-1][j-1]""
                    if matrix[i-1][j] and matrix[i][j-1] and matrix[i-1][j-1]:
                        
                        # Get the minimum of all three adjacent elements and add one to it
                        # This updates length of the element w.r.t how many adjacent ones
                        # are available in the original matrix
                        matrix[i][j] = min(matrix[i-1][j], matrix[i][j-1], matrix[i-1][j-1]) + 1
                    
                    # Calc max len w.r.t the updated length of the current element
                    max_len = max(max_len, matrix[i][j])
                        
                    
        return max_len**2 # Area of a square of length ""l"" is l*l = l^2";"class Solucion:
    def cuadrado_maximo(self, matriz):
        if not matriz:
            return 0
        
        filas = len(matriz)
        columnas = len(matriz[0])
        
        tabla_dp = []
        for i in range(filas):
            fila_temporal = []
            for j in range(columnas):
                fila_temporal.append(0)
            tabla_dp.append(fila_temporal)
            
        lado_maximo = 0
        
        for i in range(filas):
            for j in range(columnas):
                if matriz[i][j] == '1':
                    if i == 0 or j == 0:
                        tabla_dp[i][j] = 1
                    else:
                        valor_minimo = tabla_dp[i-1][j]
                        if tabla_dp[i][j-1] < valor_minimo:
                            valor_minimo = tabla_dp[i][j-1]
                        if tabla_dp[i-1][j-1] < valor_minimo:
                            valor_minimo = tabla_dp[i-1][j-1]
                        
                        tabla_dp[i][j] = valor_minimo + 1
                
                if tabla_dp[i][j] > lado_maximo:
                    lado_maximo = tabla_dp[i][j]
                    
        area = lado_maximo * lado_maximo
        return area"
"class Solution2:
    def _get_all_divisors(self, num: int):
        for divisor in range(1, int(num ** 0.5) + 1):
            if num % divisor == 0:
                yield divisor
                other_divisor = num // divisor
                if divisor != other_divisor:
                    yield other_divisor

    def checkPerfectNumber(self, num: int) -> bool:
        sum_of_divisors = sum(self._get_all_divisors(num)) - num
        return sum_of_divisors == num";"class Solucion:
    def esNumeroPerfecto(self, numero: int) -> bool:
        if numero <= 1:
            return False
        
        suma_de_divisores = 0
        
        for divisor in range(1, numero):
            if numero % divisor == 0:
                suma_de_divisores = suma_de_divisores + divisor
        
        if suma_de_divisores == numero:
            return True
        else:
            return False"
"class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        words_out = []
        for w_x in words:
            inx_words = []
            inx_count = []
            for xx in range(len(w_x)):
                inx_words.append(self.index_all(board, w_x[xx]))
                inx_count.append(len(inx_words[xx]))
            if inx_count.count(0) > 0:
                pass
            else:
                board_2 = []
                for x in range(len(board)):
                    for y in range(len(board[0])):
                        try:
                            b2 = [f'{board[x][y]}{board[x][y + 1]}']
                        except IndexError:
                            b2 = [0]
                        try:
                            b2 += [f'{board[x][y]}{board[x + 1][y]}']
                        except IndexError:
                            b2 += [0]
                        b2 += [f'{board[x][y]}{board[x][y - 1]}', f'{board[x][y]}{board[x - 1][y]}']
                        if x == 0 and y == 0:
                            board_2 += b2[:2]
                        elif x == 0 and y != 0:
                            board_2 += b2[:3]
                        elif x != 0 and y == 0:
                            board_2 += [b2[0], b2[1], b2[3]]
                        else:
                            board_2 += b2

                break_c = False
                for x in range(len(w_x) - 1):
                    words_2 = w_x[x] + w_x[x + 1]
                    if board_2.count(words_2) == 0:
                        break_c = True
                        break

                if break_c:
                    continue

                w_x0 = w_x[:]
                if inx_count[-1] <= inx_count[0]:
                    w_x = w_x[::-1]
                    inx_words = inx_words[::-1]

                inx = [0 for i in range(len(w_x))]
                while inx[0] < len(inx_words[0]):
                    inx_s1 = inx_words[0][inx[0]]
                    i = 1
                    path = [inx_s1]
                    inx_words0 = [aa[:] for aa in inx_words]
                    while i < len(w_x):
                        try:
                            for ix in range(i, len(w_x)):
                                if inx_words0[ix].count(inx_s1) > 0:
                                    inx_words0[ix].remove(inx_s1)
                            inx_s2 = inx_words0[i][inx[i]]
                            inx_s12 = [[inx_s1[0] + 1, inx_s1[1]], [inx_s1[0] - 1, inx_s1[1]],
                                       [inx_s1[0], inx_s1[1] + 1], [inx_s1[0], inx_s1[1] - 1]]

                            if inx_s12.count(inx_s2) == 0:
                                inx[i] += 1
                                break
                            inx_s1 = inx_s2
                            path.append(inx_s1)
                            i += 1
                        except IndexError:
                            inx[i - 1] += 1
                            inx[i:] = [0] * (len(w_x) - i)
                            break

                    if i == len(w_x):
                        inx[i - 1] += 1
                        if len(w_x) == len(set(map(tuple, path))):
                            words_out.append(w_x0)
                            break
        return words_out

    def index_all(self, my_list, v):
        inx_s = []
        for i, x in enumerate(my_list):
            inx_c = [i for i, m in enumerate(x) if m == v]
            for xx in inx_c:
                inx_s.append([i, xx])
        return inx_s";"def encontrar_palabras(tablero, palabras):
    if not tablero or not palabras:
        return []

    resultados = []
    filas = len(tablero)
    columnas = len(tablero[0])

    palabras_unicas = []
    for p in palabras:
        esta_en_lista = False
        for up in palabras_unicas:
            if p == up:
                esta_en_lista = True
                break
        if not esta_en_lista:
            palabras_unicas.append(p)

    for palabra in palabras_unicas:
        palabra_fue_encontrada = False
        for fila_inicio in range(filas):
            for col_inicio in range(columnas):
                if tablero[fila_inicio][col_inicio] == palabra[0]:
                    
                    pila = []
                    camino_inicial = [(fila_inicio, col_inicio)]
                    # La pila guarda: (fila, columna, indice_de_letra, celdas_visitadas)
                    pila.append((fila_inicio, col_inicio, 0, camino_inicial))

                    while len(pila) > 0:
                        fila_actual, col_actual, indice_letra, camino_actual = pila.pop()

                        if indice_letra == len(palabra) - 1:
                            resultados.append(palabra)
                            palabra_fue_encontrada = True
                            break

                        # Explorar celdas vecinas: arriba, abajo, izquierda, derecha
                        movimientos = [(-1, 0), (1, 0), (0, -1), (0, 1)]
                        for mov_fila, mov_col in movimientos:
                            fila_siguiente = fila_actual + mov_fila
                            col_siguiente = col_actual + mov_col

                            # Verificar si la celda está dentro del tablero
                            if 0 <= fila_siguiente < filas and 0 <= col_siguiente < columnas:
                                
                                # Verificar si la celda ya fue visitada en el camino actual
                                celda_visitada = False
                                for celda in camino_actual:
                                    if celda[0] == fila_siguiente and celda[1] == col_siguiente:
                                        celda_visitada = True
                                        break
                                
                                if not celda_visitada:
                                    # Verificar si la letra coincide con la siguiente letra de la palabra
                                    if indice_letra + 1 < len(palabra):
                                        if tablero[fila_siguiente][col_siguiente] == palabra[indice_letra + 1]:
                                            
                                            nuevo_camino = []
                                            for celda in camino_actual:
                                                nuevo_camino.append(celda)
                                            nuevo_camino.append((fila_siguiente, col_siguiente))

                                            pila.append((fila_siguiente, col_siguiente, indice_letra + 1, nuevo_camino))
                    
                    if palabra_fue_encontrada:
                        break
            
            if palabra_fue_encontrada:
                break

    return resultados"
"class Solution:
    def minimumBoxes(self, m: int) -> int:
        def cbrt(x):
            return x**(1. / 3)

        # Find the first tetrahedral number greater than
        # or equal to m.
        x = cbrt(sqrt(3)*sqrt(243*(m**2) - 1) + 27*m)
        n = ceil(x/cbrt(9) + 1/(cbrt(3)*x) - 1)
        
        # If m is the nth tetrahedral number, return the
        # nth triangular number (the base).
        t_n =n*(n+1)*(n+2) // 6 
        if m == t_n:
            return n*(n+1)//2

        # Otherwise, we must adjust the answer.
        ans = n*(n+1)//2
        j = t_n + 1
        while m < j:
            j -= n
            ans -= 1
            n -= 1

        return ans + 1";"def solucion(n):
    cajas_totales = 0
    cajas_en_piso = 0
    altura_actual = 0

    while cajas_totales + cajas_en_piso + altura_actual + 1 <= n:
        altura_actual = altura_actual + 1
        cajas_en_piso = cajas_en_piso + altura_actual
        cajas_totales = cajas_totales + cajas_en_piso

    cajas_restantes = n - cajas_totales
    
    piso_adicional = 0
    cajas_colocadas_extra = 0
    
    while cajas_colocadas_extra < cajas_restantes:
        piso_adicional = piso_adicional + 1
        cajas_colocadas_extra = cajas_colocadas_extra + piso_adicional
    
    resultado = cajas_en_piso + piso_adicional
    return resultado"
"class Solution:
    def magicalString(self, n: int) -> int:
        ref = ""122112""
        actual = """"
        start = 0
        one = True
        
        while(len(ref) < n):
            for i in range(start, len(ref)):
                if(one):
                    actual += int(ref[i]) * ""1""
                    one = False
                else:
                    actual += int(ref[i]) * ""2""
                    one = True
                    
            if(len(actual) > len(ref)):
                start = len(ref)
                ref = actual
        
        return ref[:n].count(""1"")";"class Solucion:
    def cadena_magica(self, n: int) -> int:
        if n <= 0:
            return 0
        if n <= 3:
            return 1

        cadena = [1, 2, 2]
        puntero_generador = 2
        numero_a_escribir = 1
        
        while len(cadena) < n:
            longitud_grupo = cadena[puntero_generador]
            
            contador_interno = 0
            while contador_interno < longitud_grupo:
                cadena.append(numero_a_escribir)
                contador_interno = contador_interno + 1
            
            if numero_a_escribir == 1:
                numero_a_escribir = 2
            else:
                numero_a_escribir = 1
            
            puntero_generador = puntero_generador + 1
            
        contador_de_unos = 0
        
        indice = 0
        while indice < n:
            if cadena[indice] == 1:
                contador_de_unos = contador_de_unos + 1
            indice = indice + 1
            
        return contador_de_unos"
"class Solution:
    def reverseString(self, s: List[str]) -> None:
        """"""
        Do not return anything, modify s in-place instead.
        """"""
        return self.reverseStringOptimal(s)
    
#     O(n) || O(1)
# runtime: 342 19.09%
    def reverseStringOptimal(self, string):
        if not string: return string
        left, right = 0, len(string) - 1

        while left < right:
            string[left], string[right] = string[right], string[left]
            left += 1
            right -= 1

        return string
    
    
#     O(n) || O(n)
# brute force
    def reverseStringWithNewList(self, string):
        if not string:
            return string

        newList = [0] * len(string)

        j = 0
        for i in reversed(range(len(string))):
            newList[i] = string[j]
            j += 1

        return newList

# below are just 'some' python built in
    def reverseStringWithListCompression(self, string):
        if not string: return string
        return [string[i] for i in reversed(range(len(string)))]

    
    def reversedStringWithReverse(self, string):
        string.reverse() 
        return string or string[::-1]";"def invertir_cadena(s):
    puntero_izquierdo = 0
    puntero_derecho = len(s) - 1

    while puntero_izquierdo < puntero_derecho:
        variable_temporal = s[puntero_izquierdo]
        s[puntero_izquierdo] = s[puntero_derecho]
        s[puntero_derecho] = variable_temporal

        puntero_izquierdo = puntero_izquierdo + 1
        puntero_derecho = puntero_derecho - 1"
"class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        freq = [0] * 26
        for task in tasks: freq[ord(task) - ord('A')] += 1
        
        # highest freq, how many letters have it
        highest_freq, no_high_tasks = self.highest_freq1(freq, len(tasks))
        
        parts = highest_freq - 1
        empty_slots = (n - no_high_tasks + 1) * parts
        idle = max(0, empty_slots - ( len(tasks) - no_high_tasks * highest_freq))
        
        return len(tasks) + idle


    def highest_freq1(self, freq, total_tasks):
        '''
        sort in O(Nlog(N)) using heap, find the max frequency and 
        the no. of tasks that have it
        '''
        heapq.heapify(freq)
        max_so_far, high_tasks = -math.inf, 0
        
        while freq:
            occ = heapq.heappop(freq)
            if max_so_far < occ:
                max_so_far = occ
                high_tasks = 0
            if occ == max_so_far: high_tasks += 1
        
        return max_so_far, high_tasks
    
    
    def highest_freq2(self, freq, total_tasks):
        '''
        Sort in O(Nlog(N)) using Timsort and find the no. of tasks with max freq
        '''
        freq = sorted(freq, reverse=True)
        highest_freq, no_high_tasks = freq[0], 0
        
        for f in freq:
            if f == highest_freq: no_high_tasks += 1
        
        return highest_freq, no_high_tasks
    
    
    def highest_freq3(self, freq, total_tasks):
        '''
        Sort in O(N) using bucket sort and return the highest non-empty bucket
        and the number of elements in it
        '''
        buckets = [[] for _ in range(total_tasks + 1)]
        
        for i in range(len(freq)):
            f = freq[i]
            buckets[f].append(i)
        
        highest_freq = -1
        for i in range(len(buckets) - 1, 0, -1):
            if buckets[i]:
                highest_freq = i
                break
        
        return highest_freq, len(buckets[highest_freq])";"def intervalo_minimo(tareas, n):
    if not tareas:
        return 0

    frecuencias = [0] * 26
    for tarea in tareas:
        indice = ord(tarea) - ord('A')
        frecuencias[indice] = frecuencias[indice] + 1

    frecuencia_maxima = 0
    for f in frecuencias:
        if f > frecuencia_maxima:
            frecuencia_maxima = f

    if frecuencia_maxima == 0:
        return 0

    tareas_con_frecuencia_maxima = 0
    for f in frecuencias:
        if f == frecuencia_maxima:
            tareas_con_frecuencia_maxima = tareas_con_frecuencia_maxima + 1

    tiempo_calculado = (frecuencia_maxima - 1) * (n + 1) + tareas_con_frecuencia_maxima

    numero_total_tareas = 0
    for tarea in tareas:
        numero_total_tareas = numero_total_tareas + 1

    if numero_total_tareas > tiempo_calculado:
        return numero_total_tareas
    else:
        return tiempo_calculado"
"class Solution:
    def countPoints(self, rings: str) -> int:
        r = []
        g = []
        b = []
        ring_nums = set()
        count = 0
        for i in range(0, len(rings)):
            if rings[i] == 'R':
                r.append(int(rings[i+1]))
                if rings[i+1] not in ring_nums:
                    ring_nums.add(int(rings[i+1]))
            elif rings[i] == 'G':
                g.append(int(rings[i+1]))
                if rings[i+1] not in ring_nums:
                    ring_nums.add(int(rings[i+1]))
            elif rings[i] == 'B':
                b.append(int(rings[i+1]))
                if rings[i+1] not in ring_nums:
                    ring_nums.add(int(rings[i+1]))
        for i in ring_nums:
            if i in r and i in g and i in b:
                count += 1
        return count";"def contar_puntos(anillos):
    varillas = {}
    
    i = 0
    while i < len(anillos):
        color = anillos[i]
        posicion_varilla = anillos[i + 1]
        
        if posicion_varilla not in varillas:
            varillas[posicion_varilla] = set()
            
        varillas[posicion_varilla].add(color)
        
        i = i + 2
        
    contador = 0
    for posicion_varilla in varillas:
        colores_en_varilla = varillas[posicion_varilla]
        if len(colores_en_varilla) == 3:
            contador = contador + 1
            
    return contador"
"class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        
        """"""
        Input: Array of integers
        constraints:
        1. Infinite number of each coin
        output: integer
        
        1. Do I have duplicate integers in the array
        2. Choose a single coin and add it up till it hits the targetj
        or greater than the target.
        
        Input variables are going to be the target, and the coins
        Base Case:
        if target hits zero, then return 1
        elif target is less than zero return 0
        Can we have a target less than zero
        Can the target be zero itself
        """"""
        if amount <= 0 and not coins:
            return 0
        if not coins:
            return 0
        memo = {}
        def dfs(target, n, memo):
            if (target, n) in memo:
                return memo[(target, n)]
            if target == 0:
                return 1
            if target < 0 or n == 0:
                return 0
            
            if (coins[n-1] <= target):
                res = dfs(target-coins[n-1], n, memo) + dfs(target, n-1, memo)
                memo[(target, n)] = res
                return res
            else:
                res = dfs(target, n-1, memo)
                memo[(target, n)] = res
                return res
        res = dfs(amount, len(coins), {})
        return res
    
        """"""
        2D DYNAMIC PROGRAMMING
        """"""
        dp = [[0]*(amount+1) for _ in range(len(coins)+1)]
        dp[0][0] = 1

        for i in range(1, len(coins)+1):
            for j in range(amount+1):
                if (coins[i-1]<=j):
                    dp[i][j] = dp[i][j-coins[i-1]] + dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j]
        return dp[len(coins)][amount]
    
        """"""
        1D DYNAMIC PROGRAMMING
        """"""
        dp = [0 for _ in range(amount+1)]
        dp[0] = 1
        for x in coins:
            for j in range(amount+1):
                if x <= j:
                    dp[j] += dp[j-x]
        return dp[amount]";"class Solucion:
    def cambio(self, cantidad, monedas):
        combinaciones = [0] * (cantidad + 1)
        combinaciones[0] = 1

        for moneda in monedas:
            for monto in range(moneda, cantidad + 1):
                combinaciones[monto] = combinaciones[monto] + combinaciones[monto - moneda]

        resultado_final = combinaciones[cantidad]
        return resultado_final"
"class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:
        def get_coordinates(x1,x2,y1,y2):
            return {0:[x1,y1],1:[x2,y1],2:[x2,y2],3:[x1,y2]}
        
        first = get_coordinates(ax1,ax2,ay1,ay2)
        second = get_coordinates(bx1,bx2,by1,by2)
        
        def left_overlap(a,b):
            if b[0][0]>=a[0][0] and b[0][0]<a[1][0] and b[1][0]>=a[1][0]:
                return abs(b[0][0]-a[1][0])
            if a[0][0]>=b[0][0] and a[0][0]<b[1][0] and a[1][0]>=b[1][0]:
                return abs(a[0][0]-b[1][0])
            if b[0][0]>=a[0][0] and b[0][0]<a[1][0] and b[1][0]<a[1][0]:
                return abs(b[1][0]-b[0][0])
            if a[0][0]>=b[0][0] and a[0][0]<b[1][0] and a[1][0]<b[1][0]:
                return abs(a[1][0]-a[0][0])
        
        def top_overlap(a,b):
            if b[0][1]>=a[0][1] and b[0][1]<a[2][1] and b[2][1]>=a[2][1]:
                return abs(b[0][1]-a[2][1])
            if a[0][1]>=b[0][1] and a[0][1]<b[2][1] and a[2][1]>=b[2][1]:
                return abs(a[0][1]-b[2][1])
            if b[0][1]>=a[0][1] and b[0][1]<a[2][1] and b[2][1]<a[2][1]:
                return abs(b[2][1]-b[0][1])
            if a[0][1]>=b[0][1] and a[0][1]<b[2][1] and a[2][1]<b[2][1]:
                return abs(a[2][1]-a[0][1])
        
        l=left_overlap(first,second)
        t=top_overlap(first, second)
        
        total_area = (first[1][0]-first[0][0])*(first[2][1]-first[0][1])
        total_area+=(second[1][0]-second[0][0])*(second[2][1]-second[0][1])
        if l is not None and t is not None:
            total_area -=l*t
        return total_area";"class Solucion:
    def calcular_area_total(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):
        area_del_primer_rectangulo = (ax2 - ax1) * (ay2 - ay1)
        area_del_segundo_rectangulo = (bx2 - bx1) * (by2 - by1)

        solapamiento_izquierda = 0
        if ax1 > bx1:
            solapamiento_izquierda = ax1
        else:
            solapamiento_izquierda = bx1

        solapamiento_abajo = 0
        if ay1 > by1:
            solapamiento_abajo = ay1
        else:
            solapamiento_abajo = by1

        solapamiento_derecha = 0
        if ax2 < bx2:
            solapamiento_derecha = ax2
        else:
            solapamiento_derecha = bx2

        solapamiento_arriba = 0
        if ay2 < by2:
            solapamiento_arriba = ay2
        else:
            solapamiento_arriba = by2

        ancho_del_solapamiento = solapamiento_derecha - solapamiento_izquierda
        alto_del_solapamiento = solapamiento_arriba - solapamiento_abajo

        area_del_solapamiento = 0
        if ancho_del_solapamiento > 0 and alto_del_solapamiento > 0:
            area_del_solapamiento = ancho_del_solapamiento * alto_del_solapamiento

        area_total = area_del_primer_rectangulo + area_del_segundo_rectangulo - area_del_solapamiento
        
        return area_total"
