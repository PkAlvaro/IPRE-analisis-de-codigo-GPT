Human_Code;IA_Code
"class Solution:
    def findSecretWord(self, words: List[str], master: 'Master') -> None:        
        k = 1 # for tracing the number of loops
        matches = 0
        blacklists = [[] for i in range(6)]
        
        while matches != 6:
            n = len(words)
            r = random.randint(0, n - 1)
            matches = master.guess(words[r])
            key = words[r]
            # print(k, n, r, matches, key)
            
            words.pop(r)
            
            if matches == 0:
                for i in range(6):
                    blacklists[i].append(key[i])
                # print(blacklists)
            
            elif matches > 0 and matches < 6:
                candidates = []
                for i in range(n - 1):
                    count = 0
                    for j in range(6):
                        if words[i][j] not in blacklists[j] and words[i][j] == key[j]:
                            count += 1
                    if count >= matches:
                        candidates.append(words[i])
                            
                words = candidates.copy()
                # print(words)
            
            k += 1";"import random

# """"""
# This is Master's API interface.
# You should not implement it, or speculate about its implementation
# """"""
# class Master:
#     def guess(self, word: str) -> int:

class Solution:
    def findSecretWord(self, words: list[str], master: 'Master') -> None:
        def match(w1, w2):
            return sum(c1 == c2 for c1, c2 in zip(w1, w2))

        candidates = words[:]
        
        for _ in range(10):
            if not candidates:
                return

            best_guess = min(
                words,
                key=lambda w: max(
                    list(
                        {
                            m: candidates.count(c)
                            for c in candidates
                            if (m := match(w, c))
                        }.values()
                    ) or [0]
                )
            )

            matches = master.guess(best_guess)
            if matches == 6:
                return
            
            candidates = [c for c in candidates if match(best_guess, c) == matches]"
"class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        # Dealing special case: 1.
        if n == 1:
            return True
        # If n is an odd, it is not a number that is power of three.
        # Also, eliminating those number did not have any factor of 3.
        elif n % 2 == 0 or n % 3 != 0:
            return False
        else:
            return power_of_three(n)

def power_of_three(n):
    # Base Case
    if n == 3:
        return True
    # If n is not devided by 3, it's not a power of three number.
    elif n % 3:
        return False
    elif n < 3:
        return False
    # Recursive
    else:
        return power_of_three(n / 3)";"class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n <= 0:
            return False
        while n % 3 == 0:
            n //= 3
        return n == 1"
"class Solution:
    def pushDominoes(self, dominoes: str) -> str:
        condensed = []
        
        index = 0
        currDir = dominoes[0]
        
        while index < len(dominoes) and dominoes[index] == currDir:
            index += 1
        
        count = index
                
        if index == len(dominoes):
            return dominoes
        elif currDir == '.' and dominoes[index] == 'L':
            currDir = dominoes[index]
            
            while index < len(dominoes) and dominoes[index] == currDir:
                index += 1
        
        condensed.append(currDir * index)
        count = 1
        
        if index == len(dominoes):
            return ''.join(condensed)
        
        currDir = dominoes[index]
        index += 1
        
        while index < len(dominoes):
            if dominoes[index] == currDir:
                count += 1
            else:
                if currDir == '.':
                    condensed.append([currDir, count])
                elif type(condensed[-1]) is not list:
                    condensed.append(currDir * count)
                else:
                    dotCount = condensed.pop()[1]
                    prevDir = condensed[-1][0]

                    if prevDir == currDir:
                        condensed.append(condensed.pop() + currDir * (dotCount + count))
                    elif prevDir == 'L':
                        condensed.append('.' * dotCount)
                        condensed.append(currDir * count)
                    else:
                        halfCount = dotCount // 2
                        hasExtraDot = halfCount*2 != dotCount
                        condensed.append(prevDir * halfCount)
                        if hasExtraDot:
                            condensed.append('.')
                        condensed.append(currDir * (halfCount + count))
                        
                currDir = dominoes[index]
                count = 1
                
            index += 1
        
        if condensed:
            if currDir == '.':            
                dotCount = count
                prevDir = condensed[-1][0]

                if prevDir == 'L':
                    condensed.append(currDir * dotCount)
                else:                
                    condensed.append(prevDir * dotCount)
            elif type(condensed[-1]) is list:
                dotCount = condensed.pop()[1]            
                
                if not condensed:
                    if currDir == 'L':
                        condensed.append(currDir * (dotCount + count))
                    else:
                        condensed.append('.' * dotCount)
                        condensed.append(currDir * count)
                else:
                    prevDir = condensed[-1][0]
                    
                    if prevDir == currDir:
                        condensed.append(condensed.pop() + currDir * (dotCount + count))
                    elif prevDir == 'L':
                        condensed.append('.' * dotCount)
                        condensed.append(currDir * count)
                    else:
                        halfCount = dotCount // 2
                        hasExtraDot = halfCount*2 != dotCount
                        condensed.append(prevDir * halfCount)
                        if hasExtraDot:
                            condensed.append('.')
                        condensed.append(currDir * (halfCount + count))
            else:
                condensed.append(currDir * count)
        else:
            condensed.append(currDir * count)
        
        return ''.join(condensed)";"class Solution:
    def pushDominoes(self, dominoes: str) -> str:
        n = len(dominoes)
        forces = [0] * n

        force = 0
        for i in range(n):
            if dominoes[i] == 'R':
                force = n
            elif dominoes[i] == 'L':
                force = 0
            else:
                force = max(0, force - 1)
            forces[i] += force

        force = 0
        for i in range(n - 1, -1, -1):
            if dominoes[i] == 'L':
                force = n
            elif dominoes[i] == 'R':
                force = 0
            else:
                force = max(0, force - 1)
            forces[i] -= force
        
        return """".join('R' if f > 0 else 'L' if f < 0 else '.' for f in forces)"
"class Solution:
    #Time-Complexity: O(n^2)
    #Space-Complexity: O(n)
    def integerBreak(self, n: int) -> int:
        #we know we can reduce n as 
        # n
    #   /  \
    #  1   n-1
    #     /  \
    #    1   n-2
    #     ...
    
        #Basically, we can keep reducing n like this in this tree structure above!
        #This is the pattern I recognized! I recognized for given n, there are 
        #potential sums of (1, n-1), (2, n-2), (3, n-3), ..., (n//2, n//2)!
        #For each pair, I can compare the direct number with the max product decomposition
        #and take the max of two!
        
        
        #Reason for comparison: for each of the sum factor of given n, either leave it
        #undecomposed or decompose it into further sum factors if the product of sum
        #factors produce ultimately a number that exceeds the orignal sum factor! This way
        #I am maximing product contribution for each and every sum factor!
        
        #For example, for 5, we decompose it into 2 and 3, since 2*3 > 5, so it will
        #maximize our product further!
        
        #However, for 3, we don't decompose since we can maximally decompose to
        #1 and 2 but 1*2 < 3!
        
        #Do that for both numbers of each pair and take the product!
        #Whatever is largest across the pairs will be answer for given input n!
    
        dp = [-1] * (n+1)
        #add dp-base!
        dp[1] = 1
    
        #this problem has only one state parameter: the given number to start decomposing           #from!
        #iterate through each subproblem or state!
        #Bottom-Up
        for i in range(2, n+1, 1):
            upper_bound = (i // 2) + 1
            #iterate through all possible pairs!
            for j in range(1, upper_bound, 1):
                #current pair (j, i-j), which we probably already solved its subproblems!
                first = max(j, dp[j])
                second = max(i-j, dp[i-j])
                #get product for current pair!
                sub_ans = first * second
                #compare current pair's product against built up answer maximum!
                dp[i] = max(dp[i], sub_ans)
    
        #then, once we are done, we can return dp[n]!
        return dp[n]";"class Solution:
    def integerBreak(self, n: int) -> int:
        if n <= 3:
            return n - 1
        
        quotient, remainder = divmod(n, 3)
        
        if remainder == 0:
            return 3**quotient
        elif remainder == 1:
            return 3**(quotient - 1) * 4
        else:  # remainder == 2
            return 3**quotient * 2"
"class Solution:
    def catMouseGame(self, graph: List[List[int]]) -> int:
        n = len(graph)
        
        @cache
        def fn(i, m, c): 
            """"""Return """"""
            if i == 2*n: return 0 # tie 
            if m == 0: return 1 # mouse wins
            if m == c: return 2 # cat wins 
            if i&amp,1: # cat's turn 
                tie = 0 
                for cc in graph[c]: 
                    if cc != 0: 
                        x = fn(i+1, m, cc)
                        if x == 2: return 2 
                        if x == 0: tie = 1
                if tie: return 0 
                return 1
            else: # mouse's turn 
                tie = 0 
                for mm in graph[m]: 
                    x = fn(i+1, mm, c)
                    if x == 1: return 1 
                    if x == 0: tie = 1
                if tie: return 0
                return 2 
        
        return fn(0, 1, 2)";"import collections

class Solution:
    def catMouseGame(self, graph: list[list[int]]) -> int:
        n = len(graph)
        
        DRAW, MOUSE_WIN, CAT_WIN = 0, 1, 2
        
        # State: (mouse_pos, cat_pos, turn)
        # turn=0: mouse, turn=1: cat
        color = [[[DRAW] * 2 for _ in range(n)] for _ in range(n)]
        
        out_degree = [[[0] * 2 for _ in range(n)] for _ in range(n)]

        for m in range(n):
            for c in range(n):
                out_degree[m][c][0] = len(graph[m])
                out_degree[m][c][1] = len(graph[c])
                if 0 in graph[c]:
                    out_degree[m][c][1] -= 1

        q = collections.deque()

        for i in range(1, n):
            # Mouse at hole
            color[0][i][0] = MOUSE_WIN
            color[0][i][1] = MOUSE_WIN
            q.append((0, i, 0))
            q.append((0, i, 1))
            
            # Cat catches mouse
            if i > 0:
                color[i][i][0] = CAT_WIN
                color[i][i][1] = CAT_WIN
                q.append((i, i, 0))
                q.append((i, i, 1))

        while q:
            m, c, t = q.popleft()
            winner = color[m][c][t]
            
            if t == 1: # Parent is mouse's turn
                # Find parent states (m_prev, c, 0)
                for m_prev in graph[m]:
                    if color[m_prev][c][0] == DRAW:
                        if winner == MOUSE_WIN:
                            color[m_prev][c][0] = MOUSE_WIN
                            q.append((m_prev, c, 0))
                        else: # winner == CAT_WIN
                            out_degree[m_prev][c][0] -= 1
                            if out_degree[m_prev][c][0] == 0:
                                color[m_prev][c][0] = CAT_WIN
                                q.append((m_prev, c, 0))
            else: # Parent is cat's turn
                # Find parent states (m, c_prev, 1)
                for c_prev in graph[c]:
                    if c_prev == 0:
                        continue
                    if color[m][c_prev][1] == DRAW:
                        if winner == CAT_WIN:
                            color[m][c_prev][1] = CAT_WIN
                            q.append((m, c_prev, 1))
                        else: # winner == MOUSE_WIN
                            out_degree[m][c_prev][1] -= 1
                            if out_degree[m][c_prev][1] == 0:
                                color[m][c_prev][1] = MOUSE_WIN
                                q.append((m, c_prev, 1))

        return color[1][2][0]"
"class Solution:
    def isPathCrossing(self, path: str) -> bool:
        #Store the directions(key) with their corresponding actions(values)
        directions = {'N': [0,1], 'E':[1,0], 'W':[-1,0], 'S':[0,-1]}
        
        #Keep the track of visited points
        visited = set()
        
        #Add the initial point from where you're starting
        visited.add((0,0))
        
        #Current trackers of x and y coordinates
        curr_x,curr_y = 0,0
        
        #Loop through all the path
        for i in path:
            curr_x += directions[i][0]
            curr_y += directions[i][1]
            
            #If visited for first time, add them to visited
            if (curr_x,curr_y) not in visited:
                visited.add((curr_x,curr_y))
            else:
                return True #Else return True
            
        return False #Return True if there is no re-visiting";"class Solution:
    def isPathCrossing(self, path: str) -> bool:
        x, y = 0, 0
        visited = {(0, 0)}
        
        moves = {
            'N': (0, 1),
            'S': (0, -1),
            'E': (1, 0),
            'W': (-1, 0)
        }
        
        for move in path:
            dx, dy = moves[move]
            x += dx
            y += dy
            if (x, y) in visited:
                return True
            visited.add((x, y))
            
        return False"
"class Solution:
    def winnerSquareGame(self, n: int) -> bool:
        @cache
        def doIWin(n, isAlice):
            if n == 0: return False # I lost, i cannot pick anything more :(
            sqr = 1
            while sqr*sqr <= n:
                if False == doIWin(n-sqr*sqr, 1 ^ isAlice):
                    # i forced my opponent to lose :)
                    return True
                
                sqr += 1
            
            
            # I did not find any way to make opponent lose..
            return False
        
        return doIWin(n, True)
        """"""
        No need of 'isAlice' :)
        Just makes the code cleaner?
        """"""

		@cache
        def doIWin(n):
            if n == 0: return False # I lost, i cannot pick anything more :(
            sqr = 1
            while sqr*sqr <= n:
                if False == doIWin(n-sqr*sqr):
                    # i forced my opponent to lose :)
                    return True
                
                sqr += 1
            
            
            # I did not find any way to make opponent lose..
            return False
        
        return doIWin(n)

		# final optimization.. travel backwards from sqrt to 1 :)
        @cache
        def doIWin(n):
            if n == 0: return False # I lost, i cannot pick anything more :(
            sqr = floor(sqrt(n))
            while sqr:
                if not doIWin(n-sqr*sqr):
                    # i forced my opponent to lose :)
                    return True
                
                sqr -= 1
            
            # I did not find any way to make opponent lose..
            return False
        
        return doIWin(n)";"import math

class Solution:
    def winnerSquareGame(self, n: int) -> bool:
        dp = [False] * (n + 1)
        for i in range(1, n + 1):
            for k in range(1, int(math.sqrt(i)) + 1):
                if not dp[i - k*k]:
                    dp[i] = True
                    break
        return dp[n]"
"class Solution:
    def knightDialer1(self, n: int) -> int:
        # observe pattern of knight moves and store in lookup table

        # 0 -> 4, 6
        # 1 -> 6, 8
        # 2 -> 7, 9
        # 3 -> 4, 8
        # 4 -> 3, 9, 0
        # 5 -> -
        # 6 -> 1, 7, 0
        # 7 -> 2, 6
        # 8 -> 1, 3
        # 9 -> 2, 4

        # approach #1: recursive with memo
        # helper function takes (curr, left),
        # returns number of possible moves based on (curr)ent value and moves (left)
        # if left is 1, return 1
        # otherwise, recursive call into next value based on lookup dict

        lut = { 0 : [4,6],
                1 : [6,8],
                2 : [7,9],
                3 : [4,8],
                4 : [0,3,9],
                5 : [],
                6 : [0,1,7],
                7 : [2,6],
                8 : [1,3],
                9 : [2,4] }

        def hlpr(curr: int, left: int) -> int:
            if left == 1: return 1
            if (curr, left) in memo: return memo[(curr, left)]

            res = 0
            for next in lut[curr]:
                res += hlpr(next, left-1)

            memo[(curr, left)] = res
            return res

        # setup and recursive call
        memo = {}
        res = 0
        for i in [0,1,2,3,4,5,6,7,8,9]:
            res += hlpr(i, n)
        return res % (10**9 + 7)

    def knightDialer2(self, n: int) -> int:
        # tabulate the solution above
        # two dimensional table
        # dp[i][j] is total moves starting from j, with i moves left
        # curr, which can be from 0-9 (cols)
        # left, which is strictly decreasing (rows)
        # O(N) time and space

        lut = { 0 : [4,6],
                1 : [6,8],
                2 : [7,9],
                3 : [4,8],
                4 : [0,3,9],
                5 : [],
                6 : [0,1,7],
                7 : [2,6],
                8 : [1,3],
                9 : [2,4] }

        dp = [[0 for _ in range(10)] for __ in range(n)]

        for i in range(10):
            dp[0][i] = 1

        for i in range(1,n):
            for j in range(10):
                tmp = 0
                for next in lut[j]:
                    tmp += dp[i-1][next]
                dp[i][j] += tmp

        return sum(dp[-1]) % (10**9 + 7)

    def knightDialer(self, n: int) -> int:
        # last trick, only need a single row of array rather than N rows
        # dp[i] represents total moves starting from i
        # make a copy of current dp row, and refer to that
        # using the actual dp row to store subproblem result
        # O(N) time, O(1) space

        lut = { 0 : [4,6],
                1 : [6,8],
                2 : [7,9],
                3 : [4,8],
                4 : [0,3,9],
                5 : [],
                6 : [0,1,7],
                7 : [2,6],
                8 : [1,3],
                9 : [2,4] }

        dp = [1 for _ in range(10)]

        for _ in range(1,n):
            last = dp[:]

            for j in range(10):
                tmp = 0
                for next in lut[j]:
                    tmp += last[next]
                dp[j] = tmp

        return sum(dp) % (10**9 + 7)";"class Solution:
    def knightDialer(self, n: int) -> int:
        MOD = 10**9 + 7
        jumps = [
            [4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9],
            [], [0, 1, 7], [2, 6], [1, 3], [2, 4]
        ]
        
        dp = [1] * 10
        
        for _ in range(n - 1):
            next_dp = [0] * 10
            for digit in range(10):
                if dp[digit] == 0:
                    continue
                for next_digit in jumps[digit]:
                    next_dp[next_digit] = (next_dp[next_digit] + dp[digit]) % MOD
            dp = next_dp
            
        return sum(dp) % MOD"
"class Solution:
    def stoneGameII(self, piles: List[int]) -> int:
        n = len(piles)
        dp = {} 
        def recursion(index,M):
            # if we reached to the end we cannot score any value
            if index == n:
                return 0
            # we search if we have solved the same case earlier
            if (index,M) in dp:
                return dp[(index,M)] 
            # total remaining score is the sum of array from index to the end
            total = sum(piles[index:])           
            # if we can take the complete array it is the best choice
            if index + 2*M >= n :return total
            # my_score is the score we are getting as the player who is playing
            my_score = 0
            for x in range(index,index+2*M):
                # opponent score will be calculated by next recursion
                opponent_score = recursion(x+1,max(M,x-index+1))
                # my_score is the remaining value of total - opponent_score
                my_score = max(my_score,total - opponent_score)          
            # this is memoization part
            dp[(index,M)] = my_score
            # return the score
            return my_score
        
        return recursion(0,1)";"import functools

class Solution:
    def stoneGameII(self, piles: list[int]) -> int:
        n = len(piles)
        suffix_sums = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_sums[i] = suffix_sums[i + 1] + piles[i]

        @functools.lru_cache(None)
        def solve(i: int, M: int) -> int:
            if i + 2 * M >= n:
                return suffix_sums[i]

            min_opponent_stones = float('inf')
            for X in range(1, 2 * M + 1):
                min_opponent_stones = min(min_opponent_stones, solve(i + X, max(M, X)))
            
            return suffix_sums[i] - min_opponent_stones

        return solve(0, 1)"
"class Solution:
    def countBits(self, n: int) -> List[int]:
        #knowing the number of 1-bits in bin. rep of lower values of i than the current i
        #can have to solve current subproblem for i, since if i is odd,
        #number of 1 bits for i = number of 1 bits for previous number(even) + 1
        #number of 1 bits for i if it is even and power of 2 = 1
        #number of 1 bits for i if it not power of 2 but even = number of 
        #largest powers of 2 even numbers I can use to sum up to i!
        #Ex. 6 = 4 + 2 -> used 2 powers of 2 = need 2 1-bits in bin. rep of 6!
        #Ex. 7 = 6 + 1 -> 6 uses 2 1-bits so 7 requires 2+1 = 3 1-bits in its bin. rep!
        
        #I showed with above examples that this problem demonstrates optimal substructure
        #property! -> Might be useful in bottom-up solve for lower values of state
        #parameter i and work your way in inc. order -> State parameter i corresponds
        #to each and every index of ans array length n+1!
        
        #also, we may need to refer to same number multiple times while
        #building up our solution -> Overlapping subproblem property satisfied!
        
        
        #Let me first attempt recursive approach!
        #I know I will face TLE so let's add dp memo for memoization!
        dp = [-1] * (n+1)
        #base cases
        if(n == 0):
            return [0]
        if(n == 1):
            return [0, 1]
        
        #add a memo base case
        if(dp[n] != -1):
            return dp[n]
        
        #for n>1, array with at least 3 elements!
        
        #check if n is even and is power of 2!
        #if it is power of 2, taking bitwise and with itself and one less in value
        #bin. rep should produce all 0-bits1
        if(n % 2 == 0 and (n &amp, n-1) == 0):
            #answer will be array from recursive call on n-1 plus the 1 1-bit required
            #for base 2 power even numbered n!
            dp[n] = self.countBits(n-1) + [1]
            return  self.countBits(n-1) + [1]
        #last index n is odd case!
        if(n%2 != 0):
            recurse = self.countBits(n-1)
            num_bits_prev_num = recurse[-1]
            dp[n] = recurse + [num_bits_prev_num + 1]
            return recurse + [num_bits_prev_num + 1]
        
        #last case: even number n not power of 2!
        else:
            #as long as we didn't reduce n!
            i = 2
            ans = 0
            while n:
                if((n - i) &amp, (n-i-1) == 0):
                    n -= (n-i)
                    i = 2
                    continue
                else:
                    i += 2
            dp[n] = self.countBits(n-1) + [ans]
            return self.countBits(n-1) + [ans]";"import collections

def countBits(n: int) -> list[int]:
    ans = [0] * (n + 1)
    for i in range(1, n + 1):
        ans[i] = ans[i >> 1] + (i & 1)
    return ans"
"class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        
        #Create a dictionary which will store the frequency of each of character 
        d={}  
        
        #iterate over all the characters in the string 's' 
        for element in s:
            if element in d:
                #increse the frequency count by 1 if it is already there in the dictionary 'd'
                d[element]+=1
            else:
                #initiate that element frequency by 1 in the 'd' if it is not there previously.
                d[element]=1
                
        #iterate over all the characters in the string 't'
        for element in t:
            if element in d:
        #decrease the frequency count by 1 so as to check the same frequency count of each character
                d[element]-=1
            else:
                #if the element is not there in the dictionary that means that particular element is not there in the string 's' which tends the result to False
                return False
        for key,value in d.items():
            if value!=0:
            #Return False if the any of element value is not 0 after cancelling their each occurence from both side 's' and 't'
                return False
        return True";"import collections

class Solution:
  def isAnagram(self, s: str, t: str) -> bool:
    return collections.Counter(s) == collections.Counter(t)"
"class Solution:
    def decodeString(self, s: str) -> str:
        #base case: single character that's not a number!
        if(len(s) == 1 and s.isdigit() == False and s[0] != '[' and s[0] != ']'):
            return s
        
        #otherwise, we need to intialize the ans variable which we will return at the end!
        ans = """"
        i = 0
        
        current_num = """"
        #iterate through each and every char until it goes out of bounds!
        while i < len(s):
            cur = s[i]
            #append stand alone characters!
            if(cur.isdigit() == False and cur != '[' and cur != ']'):
                ans += cur
                i += 1
                continue
            #otherwise, the other case we have to take account is if
            #current character is number, in which we have to decode
            #in recursive manner!
            if(cur.isdigit()):
                current_num += cur
                i += 1
                continue
            if(cur == '['):
                num = int(current_num)
                #we have to find index positions of all characters
                #between open and closed brackets -> recurse over
                #those characters in substring -> append to ans
                #the result num times!
                
                #to know when we reached the appropriate closing char,
                #we can use a stack!
                
                #push initial opening char!
                stack = ['[']
                #since i assume input is valid, there gaurantees
                #corresponding closing char!
                #start index = i + 2 since i+1th index is bracket char!
                start = i+1
                while stack:
                    if(s[start] == '['):
                        stack.append('[')
                    if(s[start] == ']'):
                        stack.pop()
                    start += 1
                #once we exit, we know range of chars to recurse over!
                #it will go from index i +2 to index start - 2!
                recurse = self.decodeString(s[i+1:start - 1])
                #add to answer num times the rec. call!
                for i in range(num):
                    ans += recurse
                #update i to index start since start points to first char after the closing bracket of
                #current decoded string!
                i = start
                current_num = """"
                continue
                
        return ans";"class Solution:
    def decodeString(self, s: str) -> str:
        stack = []
        current_num = 0
        current_string = ''
        for char in s:
            if char.isdigit():
                current_num = current_num * 10 + int(char)
            elif char == '[':
                stack.append(current_string)
                stack.append(current_num)
                current_string = ''
                current_num = 0
            elif char == ']':
                num = stack.pop()
                prev_string = stack.pop()
                current_string = prev_string + current_string * num
            else:
                current_string += char
        return current_string"
"class Solution:
    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:
        capital_profit = defaultdict(list)
        for p, c in zip(profits, capital):
            insort_left(capital_profit[c], p)
        sorted_capital = sorted(capital_profit.keys())
        if sorted_capital[-1] <= w and k == len(profits):
            return w + sum(profits)
        for _ in range(k):
            max_key, max_profit = -inf, -inf
            for key in sorted_capital:
                if key <= w:
                    if capital_profit[key][-1] > max_profit:
                        max_key, max_profit = key, capital_profit[key][-1]
                else:
                    break
            if max_profit > -inf:
                w += max_profit
                capital_profit[max_key].pop()
                if not capital_profit[max_key]:
                    capital_profit.pop(max_key)
                    sorted_capital.remove(max_key)
            else:
                break
        return w";"import heapq

class Solution:
    def findMaximizedCapital(self, k: int, w: int, profits: list[int], capital: list[int]) -> int:
        n = len(profits)
        projects = sorted(zip(capital, profits))
        
        available_projects_heap = []
        project_index = 0
        
        for _ in range(k):
            while project_index < n and projects[project_index][0] <= w:
                heapq.heappush(available_projects_heap, -projects[project_index][1])
                project_index += 1
            
            if not available_projects_heap:
                break
                
            w -= heapq.heappop(available_projects_heap)
            
        return w"
"class Solution:
    def candy(self, ratings: List[int]) -> int:
        # Analogy:
        # \   /    \
        #  \ / \  / \ /
        #   v   v    v  v
        #
        # Distribute candies such that it looks
        # like a bunch of troughs of varying heights aligned
        # side by side. Where the base of the troughs (v) are
        # the lowest rated children, and the heights of its
        # sides (\ or /) are the children with incrementally better
        # ratings
        
        # Problem is essentially looking for the next lowest ratings
        # and distributing candies in larger increments to the left
        # side and the right side IF their current rating is
        # greater than their previous rating
        
        # Use a priority queue to identify the lowest ratings
        heapq = [(ratings[i], i) for i in range(len(ratings))]
        heapify(heapq)
        
        # Array of candies parallel to the array of ratings of the child
        # where candies[i] represents the amount of candies the child at
        # ratings[i] will have
        candies = [1 for _ in range(len(ratings))]
        
        while(heapq):
            base = heappop(heapq) # Get next lowest rating
            
            # If the candy count has been modified, then it indicates
            # that this child isn't part of the lowest rating. We
            # only work with the lowest rating child (candy == 1), so skip
            if candies[base[1]] != 1:
                continue
            
            # Distribute candies to the left, when applicable
            curr = base[0]
            for i in range(base[1] - 1, -1, -1):
                # Give more candies when the current child has a greater
                # rating than the previous child AND when the current child
                # has fewer than or equal to the amount of candies than the
                # previous child
                #
                # The second condition is important since it will solve the
                # problem where the current child has already been
                # distributed candies, but may become overwritten in this new
                # distribution:
                # 
                # Distribute from lowest starting from left to right ========>
                # index:     0  1  2  3  4        0  1  2  3  4
                # ratings:  [1, 4, 3, 2, 1]  OR  [1, 2, 3, 4, 1]
                # candies:  [1, 2, 3, 2, 1]      [1, 2, 3, 4, 1]   
                #               ^                          ^
                # Solution: Let it overwrite WITH the larger amount of candies
                if ratings[i] > curr and candies[i] <= candies[i + 1]:
                    curr = ratings[i]
                    candies[i] = candies[i + 1] + 1
                else:
                    break
            
            # Distribute candies to the right, when applicable
            curr = base[0]
            for i in range(base[1] + 1, len(ratings)):
                # See line 41, same principle
                if ratings[i] > curr and candies[i] <= candies[i - 1]:
                    curr = ratings[i]
                    candies[i] = candies[i - 1] + 1
                else:
                    break
        
        return sum(candies)";"class Solution:
    def candy(self, ratings: list[int]) -> int:
        n = len(ratings)
        candies = [1] * n
        
        for i in range(1, n):
            if ratings[i] > ratings[i - 1]:
                candies[i] = candies[i - 1] + 1
                
        for i in range(n - 2, -1, -1):
            if ratings[i] > ratings[i + 1]:
                candies[i] = max(candies[i], candies[i + 1] + 1)
                
        return sum(candies)"
"class Solution:
    def convertToBase7(self, num: int) -> str:
        abs_num = abs(num)
        val = ''
        ans = ''
        while abs_num >= 7:# we want to add up every remainder until the dividend(num) equals to 7 or less than 7.
            val += str(abs_num % 7)
            abs_num = abs_num // 7
        val += str(abs_num % 7) # we add up the remainder first, then the quotient.
        val = val[::-1] # Revise its order.
        if num < 0: 
            ans += '-'
        ans += val
        return ans";"class Solution:
    def convertToBase7(self, num: int) -> str:
        if num == 0:
            return ""0""
        
        n = abs(num)
        res = """"
        while n > 0:
            res = str(n % 7) + res
            n //= 7
            
        return ""-"" + res if num < 0 else res"
"class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -> int:
        houses.sort()
        heaters.sort()
        total, size = len(houses), len(heaters)
		#dummy solution to check if heater with radius r, to cover all houses
        def valid_radius(r):
            house_offset = 0
            heater_offset = 0
            while house_offset < total:
                #case 1: current house is covered by current house, simply pass
                if abs(houses[house_offset] - heaters[heater_offset]) <= r:
                    house_offset += 1
                    continue
				#case 2 house cannot be covered, and locates on left side of heater, we can never find a heater to cover this house
                if houses[house_offset] < heaters[heater_offset]:
                    return False
                    break
				#case 3 go ahead to further heater, find the closest heater to cover the house or find no such heater valid
                while heater_offset < size and abs(houses[house_offset] - heaters[heater_offset]) > r:
                    heater_offset += 1
                if heater_offset >= size:return False
                if abs(houses[house_offset] - heaters[heater_offset]) <= r:
                    house_offset += 1
                    continue
                else:
                    return False
                    break
            return True
		#binary search to get radius
        low, high = 0, max(abs(heaters[0] - houses[0]), abs(heaters[0] - houses[-1]))
        mid = (low + high)//2
        while high - low > 1:
            if valid_radius(mid):
                high = mid
            else:low = mid
            mid = (low + high)//2

        return low if valid_radius(low) else high";"import bisect
from typing import List

class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -> int:
        heaters.sort()
        max_dist = 0
        n = len(heaters)

        for house in houses:
            i = bisect.bisect_left(heaters, house)
            
            dist1 = abs(heaters[i] - house) if i < n else float('inf')
            dist2 = abs(heaters[i - 1] - house) if i > 0 else float('inf')
            
            min_house_dist = min(dist1, dist2)
            max_dist = max(max_dist, min_house_dist)
            
        return max_dist"
"class Solution:
    def hIndex(self, citations: List[int]) -> int:
        """"""
        citations = [3,0,6,1,5]
        
        n : length of citations
        
        H - index defination: A scientist has an index h if h of their n 
        papers have at least h citations each, and the other n ? h papers 
        have no more than h citations each.
        
        [0, 0, 0, 0, 0, 0] we define a list of size n + 1
         0  1  2  3  4  5
        
        The above list will be used as a bucket which will keep the count
        of papers with i(index in the list) citations.
        
        citations[0] = 3 
        [0, 0, 0, 1, 0, 0]
         0  1  2  3  4  5
         
         citations[1] = 0
        [1, 0, 0, 1, 0, 0]
         0  1  2  3  4  5
         
         citations[2] = 6
        [1, 0, 0, 1, 0, 1] when cits for a paper is > 5 then put the value in n lst index
         0  1  2  3  4  5
         
         citations[3] = 1
        [1, 1, 0, 1, 0, 1]
         0  1  2  3  4  5
         
         citations[4] = 5
        [1, 1, 0, 1, 0, 2]
         0  1  2  3  4  5
         
         
         Find suffix sum of above list:
         [5, 4, 3, 3, 2, 2]  Find the larget index where index value(i) <= A[i]
          0  1  2  3  4  5
          
          which is 3
          ans : 3
        """"""
        
        n = len(citations)
        b = [0] * (n + 1)
        for i in range(n):
            b[min(citations[i], n)] += 1
        for i in range(n, -1, -1):
            if b[i] >= i:
                return i
            b[i - 1] += b[i]
        return -1";"class Solution:
    def hIndex(self, citations: list[int]) -> int:
        n = len(citations)
        counts = [0] * (n + 1)
        for c in citations:
            counts[min(c, n)] += 1
        
        papers = 0
        for h in range(n, -1, -1):
            papers += counts[h]
            if papers >= h:
                return h"
"class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        
        #Brute Force way of thinking
        #Generate all subarrays and as soon as we find the condition getting fulfilled, append it to our answer
        #Note - as per question, only 1 valid answer exists, so repetition will not be an issue
        #If at all there was repetition, it can be avoided by traversing as below
        #O(N^2) Time -- Accepted Solution
        

        n = len(nums)
        answer = list()
        for i in range(n):
            for j in range(i+1,n):
                if (nums[i] + nums[j] == target):
                    answer.append(i)
                    answer.append(j)
        return answer        

        
        #Let us try to optimize 
        
        #NOTE - We CANNOT SORT THIS array as we have to retrieve the indices and sorting it 
        #would change the original indices at which elements are present
        #If the given array would have already been sorted, this would have worked completely fine
        
        #if we fix one of the numbers as arr[i], so other would be arr[j] = (target - arr[i]) 
        #now, we simply have to see if this arr[j] exists in the given array or not
        #O(N) Time --- Accepted Solution (TAKEN HELP FROM DISCUSSION SECTION)
        
        #NOTE - Looking up an element in a dictionary is O(1) and not O(N) 
        
        n = len(nums)
        seen = {} #empty dictionary

        for index, value in enumerate(nums): 
            
            remaining = target - value 
            #here, value is nums[i]
            #we are looking for this remaining, which is nums[j] 
            #we have to find if remaining or nums[j] is present in the given array or not
            #this equation comes from the fact that as per question : 
            #nums[i] + nums[j] = target 
           
            if remaining in seen: 
                
                #if nums[j] is present in dictionary
                #just return index of nums[i] and nums[j] 
                return [index, seen[remaining]] 
                #index represents index of nums[i] and seen[remaining] will
                #hold index of nums[j]
            
            else: 
            #otherwise, add the value corresponding to its index in the dictionary
            #so, if it searched again, we can directly retrieve its index
                seen[value] = index";"class Solution:
    def twoSum(self, nums: list[int], target: int) -> list[int]:
        num_to_index = {}
        for i, num in enumerate(nums):
            complement = target - num
            if complement in num_to_index:
                return [num_to_index[complement], i]
            num_to_index[num] = i"
"class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        
        mp = {}
        count = 0
        
        # nested loop 1 
        for uno in nums1:
            for dos in nums2:
                # get = value for the key, value if you don't get it 
                # if uno+dos exists in hashmap, increment value 
                # else: increment with value 1 
                mp[uno + dos] = mp.get(uno + dos, 0) + 1
                
        # nested loop 2
        for tres in nums3:
            for quatro in nums4:
                # get(value for key, value if you don't get it)
                # getting hashmap value if the added number already exists in hashmap
                # if there is no complimentary value in the hashmap -> return 0 -> doesn't change count
                count += mp.get(-(tres + quatro), 0)
        # return mp
        return count";"import collections

class Solution:
    def fourSumCount(self, nums1: list[int], nums2: list[int], nums3: list[int], nums4: list[int]) -> int:
        ab_sums = collections.Counter(a + b for a in nums1 for b in nums2)
        count = 0
        for c in nums3:
            for d in nums4:
                if -(c + d) in ab_sums:
                    count += ab_sums[-(c + d)]
        return count"
"class Solution:
    def canWinNim(self, n: int) -> bool:        
        if n <= 3:
            return True
        new_size = n + 1
        memo = [False] * (new_size)
        
        for i in range(4): 
            memo[i] = True
        
        for i in range(4,new_size):
            for j in range(1,4):
                if memo[i] == True:
                    break
                if memo[i-j] == True:
                    memo[i] = False
                else:
                    memo[i] = True
        
        return memo[n]";"class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 != 0"
"class Solution:
    def sumGame(self, num: str) -> bool:
        n = len(num)
        q_cnt_1 = s1 = 0
        for i in range(n//2):    # get digit sum and question mark count for the first half of `num`
            if num[i] == '?':
                q_cnt_1 += 1
            else:    
                s1 += int(num[i])
        q_cnt_2 = s2 = 0				
        for i in range(n//2, n): # get digit sum and question mark count for the second half of `num`
            if num[i] == '?':
                q_cnt_2 += 1
            else:    
                s2 += int(num[i])
        s_diff = s1 - s2         # calculate sum difference and question mark difference
        q_diff = q_cnt_2 - q_cnt_1
        return not (q_diff % 2 == 0 and q_diff // 2 * 9 == s_diff) # When Bob can't win, Alice wins";"class Solution:
    def sumGame(self, num: str) -> bool:
        n = len(num)
        half = n // 2
        
        s1 = 0
        q1 = 0
        for i in range(half):
            if num[i] == '?':
                q1 += 1
            else:
                s1 += int(num[i])
                
        s2 = 0
        q2 = 0
        for i in range(half, n):
            if num[i] == '?':
                q2 += 1
            else:
                s2 += int(num[i])
                
        if (q1 + q2) % 2 != 0:
            return True
            
        return (s1 - s2) * 2 != (q2 - q1) * 9"
"class Solution:
#     Follow-up Solution DP Iterative, Time = O(N), Space = O(1), In-Place Algorithm
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        for lvl in range(len(triangle) - 2, -1, -1):
            for idx in range(len(triangle[lvl])):
                triangle[lvl][idx] += min(triangle[lvl + 1][idx], triangle[lvl + 1][idx + 1])
        return triangle[0][0]

#     DP Iterative, Time = O(N), Space = O(triangle)
#     def minimumTotal(self, triangle: List[List[int]]) -> int:
#         sum_cp = triangle
#         for lvl in range(len(triangle) - 2, -1, -1):
#             for idx in range(len(triangle[lvl])):
#                 sum_cp[lvl][idx] += min(sum_cp[lvl + 1][idx], sum_cp[lvl + 1][idx + 1])
#         return sum_cp[0][0]
        
#     DP Recursion, Time = O(N), Space = O(triangle)
#     def minimumTotal(self, triangle: List[List[int]]) -> int:
#         sum_dp = [[[False, 0] for j in range(len(triangle[i]))] for i in range(len(triangle))]
#         self.rec(triangle, sum_dp, 0, 0, len(triangle) - 1)
#         return sum_dp[0][0][1]
#     
#     def rec(self, triangle, sum_dp, lvl, idx, hgt):
#         if sum_dp[lvl][idx][0] == True:
#             return sum_dp[lvl][idx][1]
#         elif lvl == hgt:
#             sum_dp[lvl][idx][0] = True
#             sum_dp[lvl][idx][1] = triangle[lvl][idx]
#         else:
#             sum_dp[lvl][idx][0] = True
#             sum_dp[lvl][idx][1] = min(self.rec(triangle, sum_dp, lvl + 1, idx, hgt), self.rec(triangle, sum_dp, lvl + 1, idx + 1, hgt)) + triangle[lvl][idx]
#         return sum_dp[lvl][idx][1]
        
#     Simple Recursion, Time = O(2^N), Space = O(2^N), TLE
#     def minimumTotal(self, triangle: List[List[int]]) -> int:
#         return self.rec(triangle, 0, 0, len(triangle) - 1)
#         
#     def rec(self, triangle, lvl, idx, hgt):
#         if lvl == hgt:
#             return triangle[lvl][idx]
#         return min(self.rec(triangle, lvl + 1, idx, hgt), self.rec(triangle, lvl + 1, idx + 1, hgt)) + triangle[lvl][idx]";"class Solution:
    def minimumTotal(self, triangle: list[list[int]]) -> int:
        for i in range(len(triangle) - 2, -1, -1):
            for j in range(len(triangle[i])):
                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])
        return triangle[0][0]"
"class Solution:
    def racecar(self, target: int) -> int:
        q = [(0, 1)]
        steps = 0
        
        while q:
            num = len(q)
            for i in range(num):
                pos, speed = q.pop(0)
                if pos == target:
                    return steps
                q.append((pos+speed, speed*2))
                rev_speed = -1 if speed > 0 else 1
                if (pos+speed) < target and speed < 0 or (pos+speed) > target and speed > 0:
                    q.append((pos, rev_speed))
            steps += 1";"import collections

def racecar(target: int) -> int:
    q = collections.deque([(0, 1, 0)])  # (position, speed, steps)
    visited = {(0, 1)}

    while q:
        pos, speed, steps = q.popleft()

        if pos == target:
            return steps

        # 'A' instruction
        next_pos_a = pos + speed
        next_speed_a = speed * 2
        state_a = (next_pos_a, next_speed_a)
        
        # Heuristic bound to prune the search space
        if state_a not in visited and abs(next_pos_a) < abs(target) * 2:
            visited.add(state_a)
            q.append((next_pos_a, next_speed_a, steps + 1))

        # 'R' instruction
        next_speed_r = -1 if speed > 0 else 1
        state_r = (pos, next_speed_r)

        if state_r not in visited:
            visited.add(state_r)
            q.append((pos, next_speed_r, steps + 1))
    
    return -1"
"class Solution:
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
	
		# Recursive dfs. 
		# Accumulate the number as you traverse the tree and compare with targetSum
		# T: O(N)
		# S: O(N)
		
        return self.dfs(root, targetSum, 0)
        
    def dfs(self, root, targetSum, total):
        if not root:
            return False
        
        total += root.val
        #print(total)
        
        if not root.left and not root.right:
            return total == targetSum
        
        return self.dfs(root.left, targetSum, total) or self.dfs(root.right, targetSum, total) 
        
        
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        
        # Iterative DFS
		# Same logic
        # T: O(N)
        # S: O(N)
        
        if not root:
            return False
        
        stack = [root]
        total = root.val
        while stack:
            node = stack.pop()
            #print(node.val)
            if node.left:
                node.left.val += node.val
                stack.append(node.left)
                
            if node.right:
                node.right.val += node.val
                stack.append(node.right)
            
            if not node.right and not node.left:
                if node.val == targetSum:
                    return True
        return False
		
	def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        
        # Optimized recursive DFS
		# Instead of accumulation, we substract the value of node from the targetSum
        # T: O(N)
        # S: O(N)
        
        if not root:
            return False
        
        targetSum -= root.val
        if not root.left and not root.right:
            return targetSum == 0
        
        return self.hasPathSum(root.left, targetSum) or self.hasPathSum(root.right, targetSum)";"import collections

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        if not root:
            return False

        if not root.left and not root.right:
            return targetSum == root.val

        return self.hasPathSum(root.left, targetSum - root.val) or \
               self.hasPathSum(root.right, targetSum - root.val)"
"class Solution:
    
    def modpow(self, a: int, b: int, m: int) -> int:
        """""" Compute a^b mod m with fast exponentiation""""""
        if b == 0:
            return 1
        r = self.modpow(a, b//2, m)
        if b % 2 == 0:
            return (r * r) % m
        else:
            return (a * r * r) % m
    
    def superPow(self, a: int, b: List[int]) -> int:
        m = 1337
        r = 1  # this will contain the final result
        base = a  # this is the starting base
        for e in b[::-1]:  # note that I will traverse the list backward
            r = (r * self.modpow(base, e, m)) % m
            base = self.modpow(base, 10, m)  #  updating base
            if base == 1:  # this trick will save computation: if you find a base==1 no need to compute more
                return r
        return r";"class Solution:
    def superPow(self, a: int, b: list[int]) -> int:
        MOD = 1337
        
        res = 1
        a %= MOD
        
        for digit in b:
            res = (pow(res, 10, MOD) * pow(a, digit, MOD)) % MOD
            
        return res"
"class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        # * merge sort constant space (bottom up)

        cnt = 0
        node = head
        while node is not None:
            node = node.next
            cnt += 1
        
        if cnt < 2:
            return head
        
        dummy = ListNode(-1)
        dummy.next = head

        merge_size = 1
        # merging all sublists with size <merge_size>
        # this loop will go on for log n times
        while merge_size < cnt:
            pre = dummy
            end = None
            i = 0
            # this loop takes O(n) time
            while cnt - i > merge_size:
                # find two sublists
                list0 = pre.next
                node = pre

                for _ in range(merge_size):
                    node = node.next
                
                i += merge_size
                
                # mark the break point
                mid = node
                
                for _ in range(min(merge_size, cnt - i)):
                    node = node.next

                i += min(merge_size, cnt - i)
                
                # break up the sublist from the nodes after it
                end = None
                if node is not None:
                    end = node.next
                    node.next = None
                
                # break the sublist into two parts
                list1 = mid.next
                mid.next = None

                # break the sublist from the nodes before it (optional)
                pre.next = None

                # merge the two sublists (and concatenate the new sublist to the nodes before)
                # the following steps take linear time because we are essentially concatenating nodes to ''pre''
                while list0 is not None and list1 is not None:
                    if list0.val < list1.val:
                        pre.next = list0
                        list0 = list0.next
                    else:
                        pre.next = list1
                        list1 = list1.next
                    
                    pre = pre.next
                
                pre.next = list0 if list0 is not None else list1
                while pre.next is not None:
                    pre = pre.next
                
                # concatenate these nodes to the rest
                pre.next = end

            merge_size <<= 1

        return dummy.next";"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head

        # Find middle
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        # Split list
        mid = slow.next
        slow.next = None
        
        # Recursive sort
        left = self.sortList(head)
        right = self.sortList(mid)
        
        # Merge
        dummy = tail = ListNode()
        while left and right:
            if left.val < right.val:
                tail.next = left
                left = left.next
            else:
                tail.next = right
                right = right.next
            tail = tail.next
            
        tail.next = left or right
        return dummy.next"
"class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:
        # Calculate the max time for a pig to test buckets...
        # Note that, max time will not be (minutesToTest / minutesToDie)...
        # Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...
        max_time = minutesToTest / minutesToDie + 1
        # Initialize the required minimum number of pigs...
        req_pigs = 0
        # To find the minimum number of pigs, find the minimum req_pigs such that Math.pow(max_time, req_pigs) >= buckets...
        while (max_time) ** req_pigs < buckets:
            # Increment until it will be greater or equals to bucket...
            req_pigs += 1
        # Return the required minimum number of pigs...
        return req_pigs";"import math

class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:
        states = minutesToTest // minutesToDie + 1
        pigs = 0
        while states ** pigs < buckets:
            pigs += 1
        return pigs"
"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        lis=[]
        #First way to solve this question
        
        for val in range(1,n+1):
            #print(val%3, val%5)
            if (val%3==0 and val%5==0):
                lis.append(""FizzBuzz"")
            elif val%3==0:
                lis.append(""Fizz"")
            elif val%5==0:
                lis.append(""Buzz"")
            else:
                lis.append(str(val))
		return lis
        #Runtime: 88 ms, faster than 42.22% of Python3 online submissions for Fizz Buzz.
        #Memory Usage: 14.9 MB, less than 85.86% of Python3 online submissions for Fizz Buzz
        
        #Second way to solve this question
         
        for val in range(1,n+1):
            lis.append(""FizzBuzz"") if (val%3==0 and val%5==0) else (lis.append(""Fizz"") if val%3==0 else (lis.append(""Buzz"") if val%5==0 else lis.append(str(val)) ) )
        return lis,
         
        #Runtime: 87 ms, faster than 44.84% of Python3 online submissions for Fizz Buzz.
        #Memory Usage: 15.1 MB, less than 43.11% of Python3 online submissions for Fizz Buzz.
        
        #Third way to solve this solution
        
        # Learned this way to solve the question from https://leetcode.com/problems/fizz-buzz/discuss/2704645/Python-One-liner
        
        #Runtime: 96 ms, faster than 22.65% of Python3 online submissions for Fizz Buzz.
        #Memory Usage: 15.2 MB, less than 17.01% of Python3 online submissions for Fizz Buzz.
        return [ ""Fizz""*(val%3==0)+""Buzz""*(val%5==0) or f""{val}"" for val in range(1,n+1)]";"class Solution:
    def fizzBuzz(self, n: int) -> list[str]:
        answer = []
        for i in range(1, n + 1):
            if i % 15 == 0:
                answer.append(""FizzBuzz"")
            elif i % 3 == 0:
                answer.append(""Fizz"")
            elif i % 5 == 0:
                answer.append(""Buzz"")
            else:
                answer.append(str(i))
        return answer"
"class Solution:
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        """"""
        sort the start position.
        the car behind can only catch up no exceed.
        so if the car start late and speed is faster, it will catch up the car ahead of itself and they become a fleet.
        there is a target(or desitination),so use arrive time to measure. 
        
        start late but arrive ealier means the car is behind and will catch up before arriving the destination.
        
        position  10  8  5  3  0
        distance  2   4  7  9  12
        speed.    2   4  1  3  1
        time.     1   1  7  3  12
                      ^     ^
                      |     |
                     catch  catch up the previous car before target, join the fleet
		stack = [1] , [1],[1,7],[1,7][1,7,12] 			 
                                
        """"""
        stack = []
        for pos, v in sorted(zip(position, speed),reverse = True):

            dist = target - pos
            time = dist / v 
            
            if not stack:
                stack.append(time)
            elif time > stack[-1]:
                stack.append(time)

        return len(stack)";"class Solution:
    def carFleet(self, target: int, position: list[int], speed: list[int]) -> int:
        cars = sorted(zip(position, speed), reverse=True)
        fleets = 0
        slowest_time = 0.0
        
        for pos, spd in cars:
            time_to_reach_target = (target - pos) / spd
            if time_to_reach_target > slowest_time:
                fleets += 1
                slowest_time = time_to_reach_target
                
        return fleets"
"class MinStack:

    def __init__(self):
                
        self.Stack = []
        self.minVal = None
        

    def push(self, val: int) -> None:
        
        if not self.Stack or self.minVal == None:
            self.minVal = val
        
        
        if not self.Stack: 
            self.Stack.append(val)
        elif val < self.minVal: 
            self.Stack.append(2*val - self.minVal)
            self.minVal = val
        else: 
            self.Stack.append(val)
        

    def pop(self) -> None:
        
        if not self.Stack: 
            return
        elif self.Stack[-1] < self.minVal: 
            self.minVal = 2*self.minVal - self.Stack[-1]
            self.Stack.pop()
        else: 
            self.Stack.pop()
        

    def top(self) -> int:
        
        if self.Stack[-1] > self.minVal : 
            return self.Stack[-1]
        else: 
            return self.minVal
        

    def getMin(self) -> int:
        
        return self.minVal
        
        


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()";"class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]"
"class Node:
    def __init__(self, key, val):
        self.val = val
        self.key = key
        self.prev = None
        self.nxt_ = None

# use a DL
class DLinked:
    def __init__(self):
        self.head = None
        self.tail = None
    
    def remove(self, node):
        """""" return the deleted node key
        """"""
        # 3 basic postion cases
        prev = node.prev
        nxt_  = node.nxt_
        
        # if the removing node is the single node in the list
        if prev is None and nxt_ is None:
            # eariler termination
            self.head = None
            self.tail = None
            return node.key
        
        # head node and not single, happy 2.14's day !
        if prev is None:
            self.head = nxt_
            nxt_.prev  = None
        
        # tail node not single
        elif nxt_ is None:
            self.tail = prev
            prev.nxt_ = None
            
        else:
            # mid node
            prev.nxt_ = nxt_
            nxt_.prev = prev
        
        # either way you should return the old key        
        return node.key
    
    def add(self, node):
        """""" return the node ref if added
        """"""
        # when head is None
        if self.head is None:
            self.head = node
        
            if self.tail is None:
                self.tail = node
        else:
            node.nxt_ = self.head
            node.prev = None
            self.head.prev = node
            self.head = node
        
        return self.head
    
    
class LRUCache:
    def __init__(self, capacity):
        self.cap = capacity
        self.table = {}
        self.dlinked = DLinked()
    
    def get(self, key):
        # also check key first
        node = self.table.get(key, None)
        if node is not None:
            # update hit
            self.dlinked.remove(node)
            self.dlinked.add(node)
            return node.val
        else:
            return -1
    
    def put(self, key, val):
        # let Dlinked class to handle add / remove
        # let cache class to handle capacity cases
        # use forward logic to make thing clear
        
        # no need to check cap first, instead, we need to check key in table or not.
		# becase if key exist, there is nothing to deal with the capacity
        node = self.table.get(key, None)
        if node is not None:
            # update key hit
            self.dlinked.remove(node)
            node.val = val  # same key overwrite
            self.dlinked.add(node)
			# return as soon as possible to prevent logic twists
            return
        
        # if key not in table, then we need to add key, hence we need to check capacity
        
        if len(self.table) == self.cap:
            # cache full, kill the tail and add to head
			# seperating the operations by returning the old key
            old_key = self.dlinked.remove(self.dlinked.tail)
            del self.table[old_key]
            node = self.dlinked.add(Node(key, val)) 
            self.table[key] = node
        else:    
            # cache not full, add directly
            node = self.dlinked.add(Node(key, val))
            self.table[key] = node

        return";"import collections

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = collections.OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)"
"class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:
        # 1,2,3,4,5 -> player 1
        # 2,3,4,5 -> player 2, choose any of them, cannot win
        # Then 1 win
        candidate = [i for i in range(1, maxChoosableInteger + 1)]

        if sum(candidate) < desiredTotal:
            return False
        
        memo = dict()
        def dfs(candidate, remain):
            if candidate[-1] >= remain:
                return True
            
            if tuple(candidate) in memo:
                return memo[tuple(candidate)]
            
            for i in range(len(candidate)):
                if not dfs(candidate[:i] + candidate[i + 1:], remain - candidate[i]):
                    memo[tuple(candidate)] = True
                    return True
            
            memo[tuple(candidate)] = False
            return False
                
        return dfs(candidate, desiredTotal)";"class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:
        if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal:
            return False
        
        memo = {}

        def can_win_recursive(mask, total):
            if total <= 0:
                return False
            
            if mask in memo:
                return memo[mask]

            for i in range(maxChoosableInteger):
                if not (mask & (1 << i)):
                    if not can_win_recursive(mask | (1 << i), total - (i + 1)):
                        memo[mask] = True
                        return True
            
            memo[mask] = False
            return False

        return can_win_recursive(0, desiredTotal)"
"class Solution:
    # optimized prefix sum
    def gridGame(self, grid: List[List[int]]) -> int:
        n = len(grid[0])
        ans = math.inf
        topSum = sum(grid[0])
        bottomSum = 0

        for i in range(n):
            topSum -= grid[0][i]
            ans = min(ans, max(topSum, bottomSum))
            bottomSum += grid[1][i]

        return ans

    # neetcode's prefix sum method
    def gridGame(self, grid: List[List[int]]) -> int:
        res = float('inf') # max value
        prefixSum1 = [grid[0][0]]
        prefixSum2 = [grid[1][0]] # has the first value done so that we can iterate more smoothly
        length = len(grid[0])

        for i in range(1, length): # from 1 to end because we don't want to deal with an out of bounds error
            prefixSum1.append(grid[0][i] + prefixSum1[i-1]) # doing it this way bc it seems faster but you really just want to calculate the prefix sums of each row and save it to the index
            prefixSum2.append(grid[1][i] + prefixSum2[i-1])
        for i in range(length): # so here we want to calculate the turning point of the first robot
            # calculate the values excluding the current index
            top_row = prefixSum1[-1] - prefixSum1[i] # so total - the current index (which is the accumulated value of the left side, index inclusive)
            bottom_row = prefixSum2[i-1] if i > 0 else 0 # bounds checking here bc 0-1 is -1 and that is not the right place to be.
            current = max(top_row, bottom_row) # take the max values of this index that the second robot can grab
            res = min(res, current) # the first robot is a bad robot so we want to take the minimum values of all the maxes that we calculate and this here is O(1) space complexity instead of saving it all to an array. In taking the minimum, we take thus maximize robot 1's take and robot 2's take per the properties.
        return res



    # simple solution (runs out of time due to not storing the calculations)
    def gridGame(self, grid: List[List[int]]) -> int:

        # this is the simpler code but it doesn't work because of a time limit problem. simply having the prefix sum's already calculated makes this problem ultra efficient
        res = float('inf') # max
        length = len(grid[0])
        for i in range(length): # check each index of the array
            # take the sum of everything after the index on the top row and before the index on the bottom row
            top = sum(grid[0][i+1:])
            bot = sum(grid[1][:i])
            current = max(top, bot) # max of robot 2's take if robot 1 were to turn at this specific index
            res = min(res, current) # determines robot 2's real take that would maximize robot 1's take
        return res";"class Solution:
    def gridGame(self, grid: list[list[int]]) -> int:
        n = len(grid[0])
        top_sum = sum(grid[0])
        bottom_sum = 0
        result = float('inf')

        for i in range(n):
            top_sum -= grid[0][i]
            result = min(result, max(top_sum, bottom_sum))
            bottom_sum += grid[1][i]

        return result"
"class Solution:
    def canCross(self, stones: List[int]) -> bool:
        jump_mods = [-1,0,1]
        stone_ref = {}
        prev = 0
        
        # Make dictionary of the indexes of each stone
        for i,stone in enumerate(stones):
            stone_ref[stone] = i
            
            # if any stone is further away from the previous one than its index,
            # it is unreachable in all scenarios and we can return False early
            if stone-prev > i:
                return False
            
            prev = stone
        
        stack = [(0,0)]
        seen = set()    
        
        # DFS
        while stack:
            jump,stone = stack.pop()
            
            seen.add((jump,stone))
            
            # Return true if we reached our goal
            if stone == stones[-1]:
                return True
            
            # Go through each of the jump modifiers to see if any of them result in the following conditions:
            # 1) There is a stone that matches the current stone's value plus that modified jump value
            # 2) The index of that matching stone is greater than the index that the frog is currently on
            # 3) We have not visited that stone with the same jump value in the past
            for mod in jump_mods:
                if stone+jump+mod in stone_ref and stone_ref[stone+jump+mod] > stone_ref[stone]:
                    if (jump+mod,stone+jump+mod) not in seen:
                        stack.append((jump+mod,stone+jump+mod))
        return False";"import collections

class Solution:
    def canCross(self, stones: list[int]) -> bool:
        if not stones or stones[0] != 0 or (len(stones) > 1 and stones[1] != 1):
            return False
        if len(stones) == 1:
            return True

        last_stone = stones[-1]
        
        # dp[stone_position] = {set of jump sizes that can reach this stone}
        dp = {stone: set() for stone in stones}
        dp[1] = {1}

        for i in range(1, len(stones)):
            current_stone = stones[i]
            if not dp[current_stone]:
                continue
            
            for k in dp[current_stone]:
                for step in (k - 1, k, k + 1):
                    if step > 0:
                        next_stone = current_stone + step
                        if next_stone == last_stone:
                            return True
                        if next_stone in dp:
                            dp[next_stone].add(step)
                            
        return False"
"class Solution:
    def findNthDigit(self, n: int) -> int:
        """"""
        imagine the number you need to find have 4 digit
        so you need to go throught all num have 1 digit, 2 digit, 3 digit
        number have 1 digit:  10 ** 1 - 1 = 9 => 9 * 1 = 9 digit
        number have 2 digit:  10 ** 2 - 1 = 90 => 90 * 2 = 180 digit
        number have 3 digit:  10 ** 3 - 1 = 900 => 900 * 3 = 2700 digit
        ...
        just subtract until you find how many digit of the number you need to find
        when you got the number of digit 
        """"""
        if n < 10:
            return n
        
        number_of_digit = 0 # check how many digit of the number you need to find
        while n > 0:
            number_of_digit += 1
            n -= 9 * 10 ** ((number_of_digit - 1)) * number_of_digit
        n += 9 * 10 ** ((number_of_digit - 1)) * number_of_digit
        
        """""" 
        print(n , number_of_digit) if you dont understand 
        after subtract you will find number of digit
        all you need to do now is find exactly number by just a little bit of math
        """""" 
        tmp_num = 0
        
        if n % number_of_digit == 0:
            n //= number_of_digit 
            tmp_num += 10 ** ((number_of_digit - 1)) - 1
            return int(str(tmp_num + n)[-1])
        else:
            n /= number_of_digit
            digit = int((n * number_of_digit) % number_of_digit)
            tmp_num += 10 ** ((number_of_digit - 1)) - 1
            return int(str(int(tmp_num + n) + 1)[digit - 1])";"class Solution:
    def findNthDigit(self, n: int) -> int:
        n -= 1
        digits = 1
        first = 1
        count = 9
        while n // digits >= count:
            n -= digits * count
            digits += 1
            count *= 10
            first *= 10
        
        num = first + n // digits
        return int(str(num)[n % digits])"
"class Solution:
    def findMinStep(self, board: str, hand: str) -> int:
        
        # start from i and remove continues ball
        def remove_same(s, i):
            if i < 0:
                return s
            
            left = right = i
            while left > 0 and s[left-1] == s[i]:
                left -= 1
            while right+1 < len(s) and s[right+1] == s[i]:
                right += 1
            
            length = right - left + 1
            if length >= 3:
                new_s = s[:left] + s[right+1:]
                return remove_same(new_s, left-1)
            else:
                return s



        hand = """".join(sorted(hand))

        # board, hand and step
        q = collections.deque([(board, hand, 0)])
        visited = set([(board, hand)])

        while q:
            curr_board, curr_hand, step = q.popleft()
            for i in range(len(curr_board)+1):
                for j in range(len(curr_hand)):
                    # skip the continue balls in hand
                    if j > 0 and curr_hand[j] == curr_hand[j-1]:
                        continue
                    
                    # only insert at the begin of continue balls in board
                    if i > 0 and curr_board[i-1] == curr_hand[j]: # left side same color
                        continue
                    
                    pick = False
                    # 1. same color with right
                    # 2. left and right are same but pick is different
                    if i < len(curr_board) and curr_board[i] == curr_hand[j]:
                        pick = True
                    if 0<i<len(curr_board) and curr_board[i-1] == curr_board[i] and curr_board[i] != curr_hand[j]:
                        pick = True
                    
                    if pick:
                        new_board = remove_same(curr_board[:i] + curr_hand[j] + curr_board[i:], i)
                        new_hand = curr_hand[:j] + curr_hand[j+1:]
                        if not new_board:
                            return step + 1
                        if (new_board, new_hand) not in visited:
                            q.append((new_board, new_hand, step+1))
                            visited.add((new_board, new_hand))

        return -1";"import collections
import re

class Solution:
    def findMinStep(self, board: str, hand: str) -> int:
        hand_counts = collections.Counter(hand)
        board_counts = collections.Counter(board)
        for color, count in board_counts.items():
            if count + hand_counts[color] < 3:
                return -1

        memo = {}

        def cleanup(s: str) -> str:
            prev = None
            while s != prev:
                prev = s
                s = re.sub(r'(.)\1{2,}', '', s)
            return s

        def solve(current_board: str, current_hand: tuple) -> int:
            if not current_board:
                return 0

            state = (current_board, current_hand)
            if state in memo:
                return memo[state]

            res = float('inf')
            hand_map = {c: i for i, c in enumerate('WGRYB')}
            
            for i in range(len(current_board) + 1):
                for j in range(len(current_hand)):
                    if current_hand[j] > 0:
                        ball_char = 'WGRYB'[j]
                        
                        if i > 0 and current_board[i-1] == ball_char:
                            continue
                        
                        if i < len(current_board) and current_board[i] == ball_char:
                            pass
                        elif i > 0 and i < len(current_board) and current_board[i-1] == current_board[i] and current_board[i-1] != ball_char:
                             if current_hand[hand_map[current_board[i-1]]] >= 1:
                                pass
                             else:
                                continue
                        elif hand_counts[ball_char] < 2:
                             continue

                        new_hand_list = list(current_hand)
                        new_hand_list[j] -= 1
                        new_hand_tuple = tuple(new_hand_list)
                        
                        new_board = current_board[:i] + ball_char + current_board[i:]
                        cleaned_board = cleanup(new_board)
                        
                        sub_res = solve(cleaned_board, new_hand_tuple)
                        if sub_res != -1:
                            res = min(res, 1 + sub_res)

            memo[state] = res if res != float('inf') else -1
            return memo[state]

        initial_hand_list = [0] * 5
        hand_map = {c: i for i, c in enumerate('WGRYB')}
        for char in hand:
            initial_hand_list[hand_map[char]] += 1
        
        ans = solve(board, tuple(initial_hand_list))
        return ans"
"class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        '''
        The idea is similar to Unique Paths, https://leetcode.com/problems/unique-paths/
        in that, we get the minimum of the accumulated path totals from TOP + LEFT
		but here, we also then compare against accumulated path costs from BOTTOM + RIGHT
            
        Specifics of why 2 at a time and not all 4 is not fully clear but when done with 4
            runs infinitely / maxes out / keeps looping
        '''
        R, C = len(mat), len(mat[0])
        
        # Get the min of accumulated totals for NON-0's from TOP and LEFT
        # Out of bounds are rendered irrelevant by assigning infinity
        for r in range(R):
            for c in range(C):
                if mat[r][c] != 0:
                    top = float('inf') if r == 0 else mat[r - 1][c]
                    left = float('inf') if c == 0 else mat[r][c - 1]
                    mat[r][c] = 1 + min(top, left) # Note the +1 to account for the path-move
        
        # Do the same, but with BOTTOM and RIGHT and this time also compare against current value
        # Likewise, igore out of bounds by setting them as infinity
        for r in range(R-1, -1, -1):
            for c in range(C-1, -1, -1):
                if mat[r][c] != 0:
                    bottom = float('inf') if (r + 1) == R else mat[r + 1][c]
                    right = float('inf') if (c + 1) == C else mat[r][c + 1]
                    mat[r][c] = min(mat[r][c], 1 + bottom, 1 + right) # Note the pre-calculated one from last loop is fine but the others need +1 to pay for path move
                    
        # We got our minimums, let's return
        return mat";"import collections

class Solution:
    def updateMatrix(self, mat: list[list[int]]) -> list[list[int]]:
        m, n = len(mat), len(mat[0])
        q = collections.deque()
        
        for r in range(m):
            for c in range(n):
                if mat[r][c] == 0:
                    q.append((r, c))
                else:
                    mat[r][c] = -1

        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        distance = 0
        while q:
            distance += 1
            for _ in range(len(q)):
                r, c = q.popleft()
                for dr, dc in directions:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < m and 0 <= nc < n and mat[nr][nc] == -1:
                        mat[nr][nc] = distance
                        q.append((nr, nc))
        return mat"
"class Solution:
    def restoreString(self, s: str, indices: List[int]) -> str:
        res = [''] * len(s)
        for i in range(len(s)):
            res[indices[i]] = s[i]
        
        return ''.join(res)

class Solution:
    def restoreString(self, s: str, indices: List[int]) -> str:
        s = list(s)
        
        for i in range(len(indices)):
            while i != indices[i]:
                tmp = indices[i]
                indices[i] = indices[tmp]
                indices[tmp] = tmp
    
                s[i], s[tmp] = s[tmp], s[i]

        return ''.join(s)";"import collections

class Solution:
    def restoreString(self, s: str, indices: list[int]) -> str:
        res = [''] * len(s)
        for i, char in enumerate(s):
            res[indices[i]] = char
        return """".join(res)"
"class Solution:
    #Time-Complexity: O(n + n^2) -> O(n^2)
    #Space-Complexity: O(n + n + n) -> O(n)
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        
        q = collections.deque()
        number_of_rooms = len(rooms)
        #if we visited every room, our visited set will match wanted_set!
        wanted_set = set()
        for i in range(number_of_rooms):
            wanted_set.add(i)
        #visited will keep track of all distinct visited rooms which will be updated as bfs traversal                   progresess!
        visited = set()
        
        #before initiating bfs, we append to queue room 0 and mark room 0 as visited!
        visited.add(0)
        q.append(0)
        
        #as long as queue is non-emtpy, continue bfs!
        #all elements of queue are waited to be processed and are not already visited!
        #in worst case, our queue have to process all n rooms if we can simply hop from ith room to i+1th room
        #until we visit every single room!
        while q:
            cur_room = q.popleft()
            set_of_keys = rooms[cur_room]
            #For each room our current room can lead to, check that it is not already visited to avoid
            #revisiting node(stuck in cycle) and make sure it's not a self loop!
            #this inner for loop in worst case runs n-1 times, cause ith room may provide keys to 
            #all other rooms!
            for key in set_of_keys:
                if(key not in visited and key != cur_room):
                    q.append(key)
                    visited.add(key)
        #once our queue ends, see if visited == wanted_set
        if(visited == wanted_set):
            return True
        return False";"import collections

class Solution:
    def canVisitAllRooms(self, rooms: list[list[int]]) -> bool:
        n = len(rooms)
        visited = {0}
        queue = collections.deque([0])

        count = 1
        
        while queue:
            room_idx = queue.popleft()
            
            for key in rooms[room_idx]:
                if key not in visited:
                    visited.add(key)
                    queue.append(key)
                    count += 1
        
        return count == n"
"class Solution:
    def minPatches(self, nums: List[int], n: int) -> int:
        ans = prefix = k = 0 
        while prefix < n: 
            if k < len(nums) and nums[k] <= prefix + 1: 
                prefix += nums[k]
                k += 1
            else: 
                ans += 1
                prefix += prefix + 1
        return ans";"def minPatches(nums: list[int], n: int) -> int:
    miss = 1
    patches = 0
    i = 0
    while miss <= n:
        if i < len(nums) and nums[i] <= miss:
            miss += nums[i]
            i += 1
        else:
            miss += miss
            patches += 1
    return patches"
"class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        
        def mergeSort(arr, l, r):
            if l < r:
                m = l + (r-l)//2
                mergeSort(arr, l, m)
                mergeSort(arr, m+1, r)
                merge(arr, l, m, r)
        
        def merge(arr, l, m, r):
            ans = []
            i = l
            j = m+1
            while i <= m and j <= r:
                if int(arr[i]+arr[j]) > int(arr[j]+arr[i]):
                    ans.append(arr[i])
                    i += 1
                else:
                    ans.append(arr[j])
                    j += 1
            while i <= m:
                ans.append(arr[i])
                i+=1
            while j <= r:
                ans.append(arr[j])
                j+=1
            
            for i in range(len(ans)):
                arr[l+i] = ans[i]
        
        arr = [str(num) for num in nums]

        mergeSort(arr, 0, len(arr)-1)

        return ""0"" if arr and arr[0] == ""0"" else """".join(arr)";"import functools

class Solution:
    def largestNumber(self, nums: list[int]) -> str:
        class LargerNumKey(str):
            def __lt__(x, y):
                return x + y > y + x

        sorted_nums = sorted(map(str, nums), key=LargerNumKey)
        largest_num = """".join(sorted_nums)
        
        return ""0"" if largest_num[0] == '0' else largest_num"
"class Solution:
    # each state 6 len and 012345 permutation => (mn)! = 720 -> space = vis array of (mn)!
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        
        def getState(board):
            return ''.join(str(x) for row in board  for x in row)
        
        # print(getState(board))
        
        def setState(state):
            si = 0
            zx, zy = 0, 0
            for row in range(2):
                for i in range(3):
                    board[row][i] = int(state[si])
                    if board[row][i] == 0:
                        zx,zy = row, i
                    si += 1
                    
            # returns the position of zero ,)
            return zx, zy
        
        parent = dict() 
        def findPath(state):
            res = []
            while state in parent
                res.append(state)
                state = parent[state]
            return res
        
        # now template BFS...
        q = deque([getState(board)])
        dist = 0
        vis = set()
        while q: # level order traversal, expand one level at a time 
            # print(q)
            level_len = len(q)
            for _ in range(level_len):
                if q[0] == '123450':
                    return findPath(q[0])
                
                parent_state = q[0]
                
                zx, zy = setState(q.popleft())
                # now check all four neighbours.. after swap what happens :)
                for x, y in [[zx,zy+1], [zx+1,zy],[zx,zy-1],[zx-1,zy]]:
                    if 0<=x<2 and 0<=y<3:
                        board[zx][zy], board[x][y] = board[x][y], board[zx][zy]
                        
                        kid_state = getState(board)
                        
                        parent[kid_state] = parent_state
                        
                        if state not in vis:
                            vis.add(state)
                            q.append(state)
                        board[zx][zy], board[x][y] = board[x][y], board[zx][zy]
            dist += 1
        
        return -1";"import collections

class Solution:
    def slidingPuzzle(self, board: list[list[int]]) -> int:
        target_state = (1, 2, 3, 4, 5, 0)
        start_state = tuple(board[0] + board[1])
        
        if start_state == target_state:
            return 0

        q = collections.deque([(start_state, start_state.index(0), 0)])
        visited = {start_state}
        
        # Precomputed possible moves for the empty slot (0) at each index
        moves = {
            0: [1, 3],
            1: [0, 2, 4],
            2: [1, 5],
            3: [0, 4],
            4: [1, 3, 5],
            5: [2, 4]
        }
        
        while q:
            current_state, zero_idx, num_moves = q.popleft()
            
            if current_state == target_state:
                return num_moves
                
            for next_zero_idx in moves[zero_idx]:
                new_state_list = list(current_state)
                new_state_list[zero_idx], new_state_list[next_zero_idx] = new_state_list[next_zero_idx], new_state_list[zero_idx]
                new_state_tuple = tuple(new_state_list)
                
                if new_state_tuple not in visited:
                    visited.add(new_state_tuple)
                    q.append((new_state_tuple, next_zero_idx, num_moves + 1))
                    
        return -1"
"class Solution:
    def heightChecker(self, heights: List[int]) -> int:
        # O(N)
        sortedList = []
        count = 0
        
        # initialize 1 to 100 count dictionary
        oneToHundredDict = dict((k, 0) for k in range(1,101))
        
        # count the repeatations and updating the dictionary
        for i in range(0, len(heights)):
            oneToHundredDict[heights[i]] = oneToHundredDict[heights[i]] + 1
            
        # sorting the list
        for key,value in oneToHundredDict.items():
            if value > 0:
                # Reapting key by value times thereby sorting the list
                sortedList.extend(repeat(key, value))
        
        # compare
        for i in range(0,len(heights)):
            if sortedList[i] != heights[i]:
                count = count + 1
        
        return count";"class Solution:
    def heightChecker(self, heights: list[int]) -> int:
        expected = sorted(heights)
        return sum(h != e for h, e in zip(heights, expected))"
"class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        nums = [1] + nums + [1]
        size = len(nums)        
        
        t = [[-1 for p in range(0,size+1)]
            for q in range(0,size+1)]
        
        return self.solve(nums,1,size-1,t)
        
    def solve(self,arr,i,j,t):
        if i >= j:
            return 0
        
        if t[i][j] > 0:
            return t[i][j]
        
        ans = float('-inf')
        
        for k in range(i,j):
            if t[i][k] != -1:
                left = t[i][k]
            else:
                left = self.solve(arr,i,k,t)
                t[i][k] = left
                
            if t[k+1][j] != -1:
                right = t[k+1][j]
            else:
                right = self.solve(arr,k+1,j,t)
                t[k+1][j] = right
                
            temp = left + right + (arr[i-1]*arr[k]*arr[j])
            
            ans = max(ans,temp)
            
        t[i][j] = ans
        return t[i][j]";"import collections

class Solution:
    def maxCoins(self, nums: list[int]) -> int:
        nums = [1] + nums + [1]
        n = len(nums)
        dp = [[0] * n for _ in range(n)]

        for length in range(2, n):
            for left in range(n - length):
                right = left + length
                for k in range(left + 1, right):
                    coins = nums[left] * nums[k] * nums[right]
                    total = dp[left][k] + dp[k][right] + coins
                    if total > dp[left][right]:
                        dp[left][right] = total
        
        return dp[0][n - 1]"
"class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        
        # Setup counts for bulls and cows
        bulls = cows = 0
        
        # Copy secret and guess into lists that are easier to work with
        secretCopy = list(secret)
        guessCopy = list(guess)
        
        # In a for loop, check every pair of letters at the same index in both guess and secret for matching letters, AKA bulls
        for i in range(len(secret)):
            
            # If they match, bulls += 1 and pop() the letters from the copy lists via their .index()
            if secret[i] == guess[i]:
                bulls += 1
                secretCopy.pop(secretCopy.index(secret[i]))
                guessCopy.pop(guessCopy.index(guess[i]))
                
                
        # Count() the letters remaining in secret and guess lists
        secretCounter = Counter(secretCopy)
        guessCounter = Counter(guessCopy)
        
        # Counter1 - Counter2 gives us Counter1 with any matching values of Counter1 and Counter2 removed, leftover Counter2 values are trashed
        # secretCounter - guessCounter gives us the secretCounter except for any correctly guessed letters
        # Therefore, subtract this difference from the OG secretCounter to be left with a counter of only correctly guessed letters
        dif = secretCounter - (secretCounter - guessCounter)
        
        # The .total() of the dif Counter is the number of cows
        cows = dif.total()

        # return the formatted string with req. info
        return f'{bulls}A{cows}B'";"def getHint(secret: str, guess: str) -> str:
    bulls, cows = 0, 0
    counts = [0] * 10
    for s, g in zip(secret, guess):
        if s == g:
            bulls += 1
        else:
            s_digit = int(s)
            g_digit = int(g)
            if counts[s_digit] < 0:
                cows += 1
            if counts[g_digit] > 0:
                cows += 1
            counts[s_digit] += 1
            counts[g_digit] -= 1
    return f""{bulls}A{cows}B"""
"class Solution:
    def imageSmoother(self, img: List[List[int]]) -> List[List[int]]:
        
        #Pull the dimensions
        m_rows = len( img ),
        n_cols = len( img[ 0 ] ),
        
        #Kernel size is 3,
        k = 3,
        
        #Create a new image for each averaged total to be stored
        newImage = [ [ 0 for _ in range( n_cols ) ] for _ in range( m_rows ) ],
        
        #Start is the grid cordinate [ column , row ],
        start = [ 0, 0 ],
        
        #direction right tells us if we are true
        directionRight = [ True ],
        
        #Total keeps track of our total
        total = [ 0 ],
        
        #Initialize the kernel at [ 0 , 0 ],
        #Valid kernel will tell us how many valid squares
        #We are averaging
        total[ 0 ] , validKernel = self.initializeKernel( img, m_rows, n_cols, start ),
        
        #Previous direction will help us snake down the matrix
        #By snake down, we go right to left, then down, then left to right
        #As we find the total
        
        #This allows us to reuse our counts, and prevents overlapping calculations
        
        #When previous direction is True
        #It means we are going from right to left
        #When it is False, we are going from left to right
        prevDirection = True,

        #While our row value is at a valid index, process:
        while start[ 1 ] < m_rows:

            #Pull the x and y coordinate
            x = start[ 0 ],
            y = start[ 1 ],
            
            #Assign the average value
            newImage[ y ][ x ] = total[ 0 ] // validKernel,
            
            #Find the next coordinate by calling self.snake() to snake through the matri
            #Instead of scanning and going back to the beginning at the end,
            #Like when we read,
            #We continue our calculations in the other direction
            
            #next cord will go from
            #BEGIN [ 0, 0] , [ 1 , 0 ] , [ 2 ,  0] , END , [ 2, 1 ], [ 1 , 1 ], [ 0, 1 ] 
            # BEGIN [ 0, 2 ] [ 1, 2 ] [ 2, 2 ] END [ 2, 3 ]  ...
            nextCoord = self.snake(img, m_rows , n_cols, start, directionRight ),
            
            #nextCoord modifies the directionRight flag if it changes
            #to false, and thus begins going left
            
            #When we change directions, we want to go down a row
            if prevDirection != directionRight[ 0 ]:
                #We adjust the slice of the kernel by KEEPING
                #the overlapped elements
                
                #Adjust prev will remove from the total a slice of the kernel
                #That does not overlap
                
                #Since we are always going down, the below call to change slice
                #Will always remove the non overlapping top part of the kernel
                adjustPrev = self.changeSlice( img, m_rows, n_cols, [ x, y ] ,total, False, 0 ),
                validKernel -= adjustPrev,
                #We remove the count so our average will only consider the overlapped
                
                #Next we add the new slice that comes with our new coordinate
                #This will always be the bottom part of the kernel
                adjustCurr = self.changeSlice( img, m_rows, n_cols, [ x, y + 1 ] ,total, True, 1 ),
                validKernel += adjustCurr ,
                #and same thing, we add to the count the pieces of our new slice
                

            #If we are going in the same direction, 
            else: 
                #These values keep track of changeSlice
                #Minus condition and plus condition
                #Tell us which part of the kernel we are changing
                
                #If we are going right:
                #We remove the left slice of the old kernel
                #And add the right slice of the new kernel
                if directionRight[ 0 ]:
                    minusCondition = 3,
                    plusCondition = 2,
                    
                #If we are going left:
                #It is the opposide
                #We remove the right slice of the old kernel
                #And add the left slice of the new kernel
                else:
                    minusCondition = 2,
                    plusCondition = 3,
                    
                #Like with the above, We adjust the slices and update the validKernel count
                adjustPrev = self.changeSlice( img, m_rows, n_cols, [ x, y ], total, False, minusCondition ),
                validKernel -= adjustPrev,
                adjustCurr = self.changeSlice( img, m_rows, n_cols, nextCoord, total, True, plusCondition ),
                validKernel += adjustCurr,
                
                
            
           
            
            #At the end, we update the start value with our nextCoord
            #And we overWrite our prevDirection flag with our current direction
            start = nextCoord,
            prevDirection = directionRight[ 0 ],
        return newImage,
        
        
    #Is validCoord takes in the dimensions of the matrix
    #And returns if a current coordinate pair is not a valid index
    def isValidCoord( self, m, n, current ):
        x = current[ 0 ],
        y = current[ 1 ],
        
        if x < 0 or y < 0:
            return False,
        if x >= n or y >= m:
            return False,
        return True,
        
    #Intialize kernel will create the first instance of our kernel
    #at the top left of our matrix
    def initializeKernel( self, grid, m, n, start , k = 3):
        x = start[ 0 ],
        y = start[ 1 ],
        
        starting_total = 0,
        validCoord = 0,
        
        #It is generalized to take any slice of k
        #Since we are starting at the top left
        #We only need half of the kernel to begin with
        #Which is k // 2
        #The plus one comes from including the middle section of the kernel
        for i in range( ( k // 2) + 1 ):
            for j in range( (k // 2 ) + 1 ):
                #For each potential kernel location, 
                #We see if it is a valid coordinate
                #This is needed for when the kernel is larger than the matrix
                if self.isValidCoord( m , n , [ x + j, y + i ] ):
                    starting_total += grid[ y + i ][ x + j ],
                    validCoord += 1,

        #We return our starting total 
        #And our count, validCoord, which is used to divide the total to find
        #the average
        return starting_total, validCoord,

    
    #Change slice will tally slices of the kernel
    #The top or bottom row,
    #The left or right hand side of the column
    #Change slice will find the valid coordinates of the slice
    #And will either add them or subtract them from the total
    #Depending on the passed in paratmeters
    
    #It is the swiss-army-knife of this solution
    def changeSlice( self, grid, m , n, current, total, addition = True, condition = 0 ,k = 3 ):
        
        
        #Condition 0 tallies the top row
        #Condition 1 tallies the bottom row
        #Condition 2 tallies the right column
        #Condition 3 tallies the left column
        
        #If addition is True, we add to the total
        #If addition is False, we subtract from the total
        
        #We take the current center of the kernel
        x = current[ 0 ],
        y = current[ 1 ],
        
        #Adjust slice allows us to generalize to other sizes of k
        adjustSlice = ( k // 2 ),
        
        #We see how many valid coordinates are being modified
        #That is, how many are going into the addition or subtraction of the total
        validCoord = 0,
        
        #Going down or right from the top left of the kernel
        if condition == 0 or condition == 3:
            start = [ x - adjustSlice , y - adjustSlice ],
        #Going right from bottom left of the kernel
        elif condition == 1:
            start = [ x - adjustSlice , y + adjustSlice ],
        #Going down from top right of the kernel
        elif condition == 2:
            start = [ x + adjustSlice , y - adjustSlice ],
        else:
            raise ValueError,
        
        #For the size of the slice
        for i in range( k ):
            #Horizontal slice of k: condition 0 is top, 1 is bottom
            if condition == 0 or condition == 1:
                a = start[ 0 ] + i,
                b = start[ 1 ] ,
            #Vertical slice of k: 2 is righthand side, 3 is lefthand side
            else:
                a = start[ 0 ] ,
                b = start[ 1 ] + i,
                
            #Check to see if the generated coordinate is on the matrix
            if self.isValidCoord( m , n , [ a ,b ] ):
                #If it is, add to our subtotal count
                validCoord += 1,
            
                #If the addition flag is true:
                #Add the value to the total
                if addition:
                    total[ 0 ] += grid[ b ][ a ],  
                #If it is subtraction, remove the value from the total
                else:
                    total[ 0 ] -= grid[ b ][ a ],
                    
        #Return the number of coordinates that changed the total
        return validCoord,
                
        #Snake will, given the current coordinate, generate the next one
        #If directionRight is True, we are going right
        #If directionRight is False, we are going left
    def snake( self, grid, m, n, current , directionRight):
        
        #Pull the coordinates
        x = current[ 0 ],
        y = current[ 1 ],
        
        #Adjust the x value in accordance with the direction 
        if directionRight[ 0 ]:
            x = x + 1,
        else:
            x = x - 1,
        
        #If we are outside of a valid coordinate,
        if x == -1 or x == n:
            #Change direction
            directionRight[ 0 ] = not directionRight[ 0 ],
            
            #Return the original x, and increment y
            return [ current[ 0 ] , y + 1 ]
            
        #Otherwise, return the modified x, and the original y
        return [ x , y ],";"class Solution:
    def imageSmoother(self, img: list[list[int]]) -> list[list[int]]:
        m, n = len(img), len(img[0])
        res = [[0] * n for _ in range(m)]

        for r in range(m):
            for c in range(n):
                total = 0
                count = 0
                for i in range(r - 1, r + 2):
                    for j in range(c - 1, c + 2):
                        if 0 <= i < m and 0 <= j < n:
                            total += img[i][j]
                            count += 1
                res[r][c] = total // count
        
        return res"
"class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        #create a adjacent lists that have connections 
        dic = collections.defaultdict(set)
        email_to_name={}
        visited = set()
        ans = []
        for account in accounts:
            name = account[0]
            for email in account[1:]:
                dic[email].add(account[1])
                dic[account[1]].add(email)
                email_to_name[email] = name
        def dfs(intial_email,dic,visited):
            if intial_email in visited:
                return 
            stack = [intial_email]
            visited.add(intial_email)
            lst = []
            lst.append(intial_email)
            while stack:
                sub_email = stack.pop()
                if dic[sub_email]:
                    for other_email in dic[sub_email]:
                        if other_email not in visited:
                            lst.append(other_email)
                            stack.append(other_email)
                            visited.add(other_email)
                        else:
                            continue
            result = sorted(lst)
            return result
        for email in dic:
            result = dfs(email,dic,visited)
            if result:
                ans.append([email_to_name[email]]+result)
        return ans 

            

                    



        


        # dic_emails = {}
        # for account in accounts:
        #     for i in range(1,len(account)):
        #         if account[i] not in dic_emails:
        #             dic_emails[account[i]] =1
        #         else:
        #             dic_emails[account[i]] +=1
        # dic_email2 = {}
        # dic_email3 = []
        # for key,value in dic_emails.items():
        #     if value > 1:
        #         for account in accounts:
        #             if key in account and key not in dic_email2:
        #                 dic_email2[key] = []
        #                 dic_email2[key].append(account)
        #             elif key in account and key in dic_email2:
        #                 dic_email2[key].append(account)
        #             elif key not in account:
        #                 dic_email3.append(account)
        # total = []
        # for key,value in dic_email2.items():
        #     lst = []
        #     if len(value) > 1:
        #         for infor in value:
        #             for in_f in infor:
        #                 if in_f not in lst:
        #                     lst.append(in_f)
        #     total.append(lst[:1]+sorted(lst[1:]))
        # print(total)
        # print(dic_email3)
        # return sorted((total + dic_email3))";"import collections

def accountsMerge(accounts: list[list[str]]) -> list[list[str]]:
    email_to_name = {}
    graph = collections.defaultdict(set)
    for acc in accounts:
        name = acc[0]
        for email in acc[1:]:
            graph[acc[1]].add(email)
            graph[email].add(acc[1])
            email_to_name[email] = name

    visited = set()
    result = []
    for email in email_to_name:
        if email not in visited:
            component = []
            stack = [email]
            visited.add(email)
            while stack:
                node = stack.pop()
                component.append(node)
                for neighbor in graph[node]:
                    if neighbor not in visited:
                        visited.add(neighbor)
                        stack.append(neighbor)
            result.append([email_to_name[email]] + sorted(component))
    return result"
"class Solution:
		def isEvenOddTree(self, root: Optional[TreeNode]) -> bool:
			if root is None:
				return False

			level_order = self.level_order(root)

			# check level 0
			if level_order[0][0] % 2 == 0:
				return False

			# check level 1 ~ end
			for i, level in enumerate(level_order[1:], 2):
				if i % 2 == 0:
					# even and decreasing order
					previous_element = level[0]
					if previous_element % 2 != 0:
						return False

					for element in level[1:]:
						if element % 2 != 0 or previous_element < element:
							return False
						previous_element = element

				else:
					# odd and increasing order
					previous_element = level[0]
					if previous_element % 2 == 0:
						return False

					for element in level[1:]:
						if element % 2 == 0 or element < previous_element:
							return False
						previous_element = level

			return True

		def level_order(self, root: Optional[TreeNode]) -> List[List[int]]:
				queue = [root]
				level_order = []
				while queue:
					size = len(queue)
					level = []
					for _ in range(size):
						node = queue.pop(0)

						if node.left:
							queue.append(node.left)

						if node.right:
							queue.append(node.right)

						level.append(node.val)

					level_order.append(level)

				return level_order";"import collections

class Solution:
    def isEvenOddTree(self, root) -> bool:
        if not root:
            return True

        queue = collections.deque([root])
        level = 0

        while queue:
            level_size = len(queue)
            prev_val = float('-inf') if level % 2 == 0 else float('inf')

            for _ in range(level_size):
                node = queue.popleft()

                if level % 2 == 0:
                    if node.val % 2 == 0 or node.val <= prev_val:
                        return False
                else:
                    if node.val % 2 != 0 or node.val >= prev_val:
                        return False

                prev_val = node.val

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            level += 1

        return True"
"class Solution:
    def sumFourDivisors(self, nums: List[int]) -> int:
        res = 0
        for num in nums:
            divisor = set() 
            for i in range(1, floor(sqrt(num)) + 1):
                if num % i == 0:
                    divisor.add(num//i)
                    divisor.add(i)
                if len(divisor) > 4:    
                    break
                    
            if len(divisor) == 4:
                res += sum(divisor)
        return res";"import math

class Solution:
    def sumFourDivisors(self, nums: list[int]) -> int:
        total_sum = 0
        for n in nums:
            if n < 6:
                continue

            divisors = {1, n}
            limit = int(math.sqrt(n))
            
            for i in range(2, limit + 1):
                if n % i == 0:
                    divisors.add(i)
                    divisors.add(n // i)
                if len(divisors) > 4:
                    break
            
            if len(divisors) == 4:
                total_sum += sum(divisors)
                
        return total_sum"
"class Solution:
    def findRotateSteps(self, ring: str, key: str) -> int:
        char_pos = defaultdict(set)
        for i, c in enumerate(ring):
            char_pos[c].add(i)
        
        def minStep(fromm, to):
            if fromm == to:
                return 0
            minSteps = abs(fromm - to)
            minSteps = min(minSteps, abs(len(ring) - minSteps))
            return minSteps
        
        n = len(key)
        dp = [0] * len(ring)
        for p in char_pos[key[0]]:
            dp[p] = minStep(0, p)
        prev_char = key[0]
        for c in key[1:]:
            if prev_char == c:
                continue
            for next_pos in char_pos[c]:
                dp[next_pos] = min(dp[prev_pos] + minStep(prev_pos, next_pos) for prev_pos in char_pos[prev_char])
            prev_char = c
        return min(dp[p] for p in char_pos[prev_char]) + len(key)";"import collections

class Solution:
    def findRotateSteps(self, ring: str, key: str) -> int:
        n = len(ring)
        char_positions = collections.defaultdict(list)
        for i, char in enumerate(ring):
            char_positions[char].append(i)

        dp = {0: 0}

        for char_to_find in key:
            next_dp = collections.defaultdict(lambda: float('inf'))
            for next_pos in char_positions[char_to_find]:
                for prev_pos, prev_cost in dp.items():
                    dist = abs(next_pos - prev_pos)
                    rotation_cost = min(dist, n - dist)
                    total_cost = prev_cost + rotation_cost + 1
                    next_dp[next_pos] = min(next_dp[next_pos], total_cost)
            dp = next_dp

        return min(dp.values())"
"class Solution:
    def isValid(self, code: str) -> bool:
        if code[0] != '<' or code[-1] != '>': return False
        i, n = 0, len(code)
        stk = []
        while i < n:
            if code[i] == '<':
                if i != 0 and code[i: i + 9] == '<![CDATA[':
                    if not stk: return False
                    j = i + 9
                    while j + 3 <= n and code[j: j + 3] != ']]>': j += 1
                    if code[j: j + 3] == ']]>': i = j + 3
                    else: return False
                else:
                    start = i
                    isend = False
                    i += 1
                    if i >= n: return False
                    if code[i] == r'/':
                        isend = True
                        i += 1
                    if i >= n: return False
                    tag = ''
                    while i < n and code[i] != '>':
                        if not code[i].isupper(): return False
                        tag += code[i]
                        i += 1
                    if i >= n or len(tag) == 0 or len(tag) > 9: return False
                    if isend:
                        if not stk or stk[-1] != tag: return False
                        stk.pop(-1)
                    else:
                        if start != 0 and not stk: return False
                        stk.append(tag)
                    i += 1
            else:
                if not stk: return False
                while i < n and code[i] != '<': i += 1
        return not stk";"import re

class Solution:
    def isValid(self, code: str) -> bool:
        # Using a single regex to validate is difficult due to nested structures.
        # A simpler approach is to repeatedly remove valid innermost components.
        # The components are CDATA sections and valid tags with no tags inside.

        # First, remove all CDATA sections.
        code = re.sub(r'<!\[CDATA\[.*?\]\]>', 'c', code)

        # Now, repeatedly remove valid, non-nested tags.
        # A valid non-nested tag has a valid name and its content contains no '<'.
        # We loop until no more replacements can be made.
        prev_code = None
        while code != prev_code:
            prev_code = code
            code = re.sub(r'<([A-Z]{1,9})>[^<]*</\1>', 't', code)

        # After all valid tags are removed, the code should consist of a single 't'.
        # This 't' represents the original valid root tag.
        return code == 't'"
"class Solution:
    def toLowerCase(self, s: str) -> str:
        # Instead of using .lower(), let's implement with ASCII
        # ord() returns the ascii value of a passed character
        
        # Uncomment the line below to see the ASCII value of some important characters
        # print(ord('a'), ord('z'), ord('A'), ord('Z'))
        
        # Notice 'a'=97, and 'A'=65
        # This can be used to tell whether a character is upper/lower case, and can help us convert between them
        
        # First, make the string a list so we can change each char individually
        s = list(s)
        
        # Then, loop through the characters, and if their ascii value is <= 90 and >= 65, they must be upper case
        # Use the difference (97 - 65 = 32) to convert it from upper to lower, then use chr() to convert from ascii to char
        #   - ord('A') + 32 = 97 = ord('a')
        for i in range(len(s)):
            if ord(s[i]) <= 90 and ord(s[i]) >= 65:
                s[i] = chr(ord(s[i])+32)
        return ''.join(s)";"class Solution:
    def toLowerCase(self, s: str) -> str:
        return s.lower()"
"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        # self.selectionSort(nums)
        # self.bubbleSort(nums)
        # self.insertionSort(nums)
        # self.mergeSort(nums)       
        self.quickSort(nums)
        return nums
    
    ''' 
    Selection Sort (TLE)
    TC: O(n^2) ,  SC: O(1), in-place
    Not Stable
    Minimum swaps
    '''
    def selectionSort(self, nums):
        for i in range(len(nums)):
            min_idx=i
            for j in range(i, len(nums)):
                if nums[j]<nums[min_idx]:
                    min_idx=j
            nums[i], nums[min_idx] = nums[min_idx], nums[i]
            
    '''
    Bubble Sort (TLE)
    TC: best-O(n), worst-O(n^2)
    SC: O(1)
    Stable
    Use when array is almost sorted
    '''
    def bubbleSort(self, nums):
        for i in range(len(nums)):
            swapped = False
            for j in range(len(nums)-i-1):
                if nums[j]>nums[j+1]:
                    nums[j], nums[j+1] = nums[j+1], nums[j]
                    swapped = True
            
            if not swapped:
                break
                
    '''
    Insertion Sort (TLE)
    TC: best-O(n), worst-O(n^2)
    SC: O(1)
    Stable
    '''
    def insertionSort(self, nums):
        for i in range(1, len(nums)):
            key = nums[i]
            j=i-1
            while j>=0 and key<nums[j]:
                nums[j+1]=nums[j]
                j-=1
            nums[j+1]=key
    
    '''
    Merge Sort
    Recursive
    TC: O(nlogn)
    SC: O(n)
    Stable
    '''
    def mergeSort(self, nums):
        def merge(nums,L,R):
            i = j = k = 0
            while i < len(L) and j < len(R): 
                if L[i] < R[j]: 
                    nums[k] = L[i] 
                    i+=1
                else: 
                    nums[k] = R[j] 
                    j+=1
                k+=1
                
            while i < len(L): 
                nums[k] = L[i] 
                i+=1
                k+=1

            while j < len(R): 
                nums[k] = R[j] 
                j+=1
                k+=1
                
        if len(nums)>1:
                mid=len(nums)//2
                L=nums[:mid]
                R=nums[mid:]
                self.mergeSort(L)
                self.mergeSort(R)
                merge(nums,L,R)
        
    '''
    QuickSort
    Recursive
    TC: average-O(nlogn), worst-O(n^2)
    SC: average-O(logn), worst-O(n) recursion stack, in-place
    Not stable
    '''
    def quickSort(self, nums):
        # 3-way randomized
        def partition(l, r):
            pivot_idx = random.choice(range(l,r+1))
            pivot = nums[pivot_idx]
            # print(pivot)
            left, move, right = l,l,r
            while move<=right:
                if nums[move]<pivot:
                    nums[left], nums[move] = nums[move], nums[left]
                    move+=1
                    left+=1
                elif nums[move]>pivot:
                    nums[right], nums[move] = nums[move], nums[right]
                    right-=1
                else:
                    move+=1
            return left-1, move
        
        def quicksort(nums, low, high):
            if low<high:
                l,r = partition(low, high)
                quicksort(nums, low, l)
                quicksort(nums, r, high)
                
        quicksort(nums, 0, len(nums)-1)
        
        #---------------------------------------------------------------
        # def helper(head, tail):
        #     if head >= tail: return 
        #     l, r = head, tail
        #     m = (r - l) // 2 + l
        #     pivot = nums[m]
        #     while r >= l:
        #         while r >= l and nums[l] < pivot: l += 1
        #         while r >= l and nums[r] > pivot: r -= 1
        #         if r >= l:
        #             nums[l], nums[r] = nums[r], nums[l]
        #             l += 1
        #             r -= 1
        #     helper(head, r)
        #     helper(l, tail)

        # helper(0, len(nums)-1)";"class Solution:
    def sortArray(self, nums: list[int]) -> list[int]:
        
        def heapify(arr, n, i):
            largest = i
            left = 2 * i + 1
            right = 2 * i + 2

            if left < n and arr[left] > arr[largest]:
                largest = left

            if right < n and arr[right] > arr[largest]:
                largest = right

            if largest != i:
                arr[i], arr[largest] = arr[largest], arr[i]
                heapify(arr, n, largest)

        n = len(nums)

        for i in range(n // 2 - 1, -1, -1):
            heapify(nums, n, i)

        for i in range(n - 1, 0, -1):
            nums[i], nums[0] = nums[0], nums[i]
            heapify(nums, i, 0)
            
        return nums"
"class Solution:
    def calPoints(self, ops: List[str]) -> int:
        stack = [] # taking an empty stack. 
        prod = 2 # taking a variable to double a provided number. 
        prev_sum = 0 # taking a variable to have sum of previous elems of the stack. 
        
        for i in range(len(ops)): # Traversing through the provided list.
            if ops[i] is not ""C"" and ops[i] is not ""D"" and ops[i] is not ""+"": # if we are having other then a number then we`ll just add it to stack. 
                stack.append(int(ops[i])) # pushing elements to the stack and making it as int bcz originally it is provided as char.
            elif ops[i] is ""C"": # if its other then a number we`ll check what it is.
                stack.pop() # removing the previous record, we as coder refer it as a last element in the stack. 
            elif ops[i] is ""D"": # if its other then a number we`ll check what it is.
                prod*=int(stack[-1]) # Again making stack element as a integer for performing product operation. 
                stack.append(prod) # Pushing the product to the stack. 
                prod=2 # reseting variable. 
            elif ops[i] is ""+"": # if its other then a number we`ll check what it is.
                prev_sum = int(stack[-2]) + int(stack[-1]) # Again as we have list elem as char, to perform adding we have to change it to int. 
                stack.append(prev_sum) # Pushing the sum to the stack. 
                prev_sum=0 # reseting variable. 
        return sum(stack) # Returning the sum of all the scores on the record(sum of elements in the stack).";"class Solution:
    def calPoints(self, operations: list[str]) -> int:
        record = []
        for op in operations:
            if op == '+':
                record.append(record[-1] + record[-2])
            elif op == 'D':
                record.append(record[-1] * 2)
            elif op == 'C':
                record.pop()
            else:
                record.append(int(op))
        return sum(record)"
"class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        # Solution 1 using recursion
        while n % 4 == 0 and n > 0:
            return self.isPowerOfFour(n/4)
        return n == 1
        
        # Solution 2 iteration
        if n == 1:
            return True
        if n % 4:
            return False
        while n > 1:
            if n % 4:
                return False
            n //= 4
        return n == 1
        
        # Solution 3 using bit manipulation
        '''
        Once we write numbers in it's binary representation, from there we can observe:=>
        i. 000001 , power of 2 and 4
        ii. 000010, power of only 2
        iii. 000100 , power of 2 and 4
        iv. 001000, power of only 2
        v. 010000 , power of 2 and 4
        vi. 100000, power of only 2
        We can see if the set bit is at an odd position and is a power of 2, it's also power of 4.
        '''
        return n.bit_length() &amp, 1 and not(n &amp, (n-1))";"import math

class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        if n <= 0:
            return False
        return math.log(n, 4).is_integer()"
"class Solution:
    def oddEvenJumps(self, A: List[int]) -> int:
        
		# find next index of current index that is the least larger/smaller
        def getNextIndex(sortedIdx):
            stack = []
            result = [None] * len(sortedIdx)
        
            for i in sortedIdx:
                while stack and i > stack[-1]:
                    result[stack.pop()] = i
                stack.append(i)
            return result
        
        sortedIdx = sorted(range(len(A)), key= lambda x: A[x])
        oddIndexes = getNextIndex(sortedIdx)
        sortedIdx.sort(key=lambda x: -A[x])
        evenIndexes = getNextIndex(sortedIdx)
        
		# [odd, even], the 0th jump is even
        dp = [[0,1] for _ in range(len(A))]
        
        for i in range(len(A)):
            if oddIndexes[i] is not None:
                dp[oddIndexes[i]][0] += dp[i][1]
            if evenIndexes[i] is not None:
                dp[evenIndexes[i]][1] += dp[i][0]
				
        return dp[-1][0] + dp[-1][1]";"import collections

class Solution:
    def oddEvenJumps(self, arr: list[int]) -> int:
        n = len(arr)
        
        def get_next_indices(sorted_indices):
            result = [-1] * n
            stack = []
            for i in sorted_indices:
                while stack and stack[-1] < i:
                    result[stack.pop()] = i
                stack.append(i)
            return result

        sorted_asc = sorted(range(n), key=lambda i: (arr[i], i))
        next_higher = get_next_indices(sorted_asc)

        sorted_desc = sorted(range(n), key=lambda i: (-arr[i], i))
        next_lower = get_next_indices(sorted_desc)

        odd = [False] * n
        even = [False] * n
        odd[n - 1] = True
        even[n - 1] = True

        for i in range(n - 2, -1, -1):
            if next_higher[i] != -1:
                odd[i] = even[next_higher[i]]
            if next_lower[i] != -1:
                even[i] = odd[next_lower[i]]

        return sum(odd)"
"class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        
        visited = set()
        
        size = len(nums)
        
        max_subset_size = 0
        
        # check each index in input array
        for i in range(size):
            
            if nums[i] in visited:
                
                # current number has been visited
                continue
            
            # reset picking subset size to zero
            cur_subset_size = 0
            
            # keep picking if current nums[i] has not been visited 
            while nums[i] not in visited:
                
                # update current nums[i] as visited
                visited.add( nums[i] )
                
                # update subset size
                cur_subset_size += 1
                
                # i goes to next nesting index
                i = nums[i]
            
            # finished current element picking
            max_subset_size = max(max_subset_size, cur_subset_size)
            
        return max_subset_size";"def arrayNesting(nums: list[int]) -> int:
    max_len = 0
    for i in range(len(nums)):
        if nums[i] >= 0:
            count = 0
            j = i
            while nums[j] >= 0:
                next_j = nums[j]
                nums[j] = -1
                j = next_j
                count += 1
            max_len = max(max_len, count)
    return max_len"
"class Solution:
    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        self.cyclic(grid, k, len(grid), len(grid[0]))
        self.redact(grid, len(grid), len(grid[0]))
        return grid
    
    def cyclic(self, grid: List[List[int]], k: int, rows: int, cols: int):
        for r in range(rows):
            for c in range(cols):
                cell = grid[r][c]
                if cell > 1000:
                    continue
                destx, desty = self.calculate(k, r, c, rows, cols)
                while not (r == destx and c == desty):
                    self.swap(grid, r, c, destx, desty)
                    destx, desty = self.calculate(k, destx, desty, rows, cols)
                self.mark(grid, r, c)
                
    def calculate(self, k: int, currx: int, curry: int, rows: int, cols: int) -> Tuple[int, int]:
        desty = (curry + k) % cols
        destx = (currx + ((curry + k) // cols)) % rows
        return destx, desty
    
    def swap(self, m: List[List[int]], fromx: int, fromy: int, tox: int, toy: int):
        temp = m[tox][toy]
        m[tox][toy] = m[fromx][fromy] + 2001
        m[fromx][fromy] = temp
        
    def mark(self, m:List[List[int]], x: int, y: int):
        m[x][y] += 2001
        
    def redact(self, m: List[List[int]], rows: int, cols: int):
        for r in range(rows):
            for c in range(cols):
                m[r][c] -= 2001";"import collections

class Solution:
    def shiftGrid(self, grid: list[list[int]], k: int) -> list[list[int]]:
        m, n = len(grid), len(grid[0])
        k %= (m * n)

        flat_list = [item for row in grid for item in row]
        
        deq = collections.deque(flat_list)
        deq.rotate(k)
        
        result = []
        rotated_flat = list(deq)
        for i in range(0, m * n, n):
            result.append(rotated_flat[i:i + n])
            
        return result"
"class Solution:
    def soupServings(self, n: int) -> float:
        if n > 4275: return 1                                        # handle special case
        n = n // 25 + (n%25 > 0)                                     # count size of tabulation
        dp = [[0] * (n+1) for _ in range(n+1)]
        dp[n][n] = 1
        for i in range(n, 0, -1):                                    # starting from (n, n) for each soup
            for j in range(n, 0, -1):
                for a, b in [[4, 0], [3, 1], [2, 2], [1, 3]]:
                    dp[max(0, i-a)][max(0, j-b)] += dp[i][j] * 0.25  # traverse backwards from (n,n) to (0,0)
        ans = dp[0][0] / 2                                           # half the probability when `a` &amp, `b` both use up at the same time
        for j in range(1, n+1):                                      # plus when `a` use up first
            ans += dp[0][j]
        return ans";"class Solution:
    def soupServings(self, n: int) -> float:
        if n > 4799:
            return 1.0
        
        n = (n + 24) // 25
        memo = {}

        def solve(a, b):
            if (a, b) in memo:
                return memo[(a, b)]
            if a <= 0 and b <= 0:
                return 0.5
            if a <= 0:
                return 1.0
            if b <= 0:
                return 0.0
            
            ans = 0.25 * (solve(a - 4, b) + 
                          solve(a - 3, b - 1) + 
                          solve(a - 2, b - 2) + 
                          solve(a - 1, b - 3))
            memo[(a, b)] = ans
            return ans

        return solve(n, n)"
"class Solution:
    def findRelativeRanks(self, score: List[int]) -> List[str]:
        
        sorted_score = sorted(score, reverse=True)
        
        hashmap = {}
        
        if len(score) > 2:
            hashmap[sorted_score[0]] = ""Gold Medal""
            hashmap[sorted_score[1]] = ""Silver Medal""
            hashmap[sorted_score[2]] = ""Bronze Medal""
        
        elif len(score) == 1:
            return [""Gold Medal""]
        
        else:
            if score[0] > score[1]:
                return [""Gold Medal"", ""Silver Medal""]
            else:
                return [""Silver Medal"", ""Gold Medal""]
            
        rank = 4
        for index in range(3, len(sorted_score)):
            hashmap[sorted_score[index]] = str(rank)
            rank += 1
            
        
        return [hashmap[x] for x in score]";"import collections

class Solution:
    def findRelativeRanks(self, score: list[int]) -> list[str]:
        sorted_score = sorted(score, reverse=True)
        rank_map = {}
        for i, s in enumerate(sorted_score):
            if i == 0:
                rank_map[s] = ""Gold Medal""
            elif i == 1:
                rank_map[s] = ""Silver Medal""
            elif i == 2:
                rank_map[s] = ""Bronze Medal""
            else:
                rank_map[s] = str(i + 1)
        
        return [rank_map[s] for s in score]"
"class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:        
        # Define some CORNER Cases #
		if len(nums) == 0:
            # Nothing to do if no integers are given
			return nums
        elif len(nums) == 1:
            # Nothing to do if single integer is given
			return list(map(str, nums))
        else:
            # MAIN program begins only if 2(+) integers are provided.
			# 1st convert all integers to strings
			str_num_list = list(map(str, nums))
			# Initiate 2 lists - Slave list constitutes the 1st element of the above list, while Master is initiated as blank list.  
            slave_list = [str_num_list[0]] , master_list = [] 
			# Invoke a Lambda function to be used later.  
			# The function appends the slave element to the master list if slave list only has a single element. 
			# Otherwise, it clips the 1st and last element of the slave list, adds a ""->"" character in between them, and then appends this new element in the master list. 
            add_2_master_list = lambda mlist, slist : mlist.append(slist[0] + str(""->"") + slist[-1]) if len(slist) > 1 else mlist.append(slist[0])
            # Run a loop from 2nd element to last 
			for i in str_num_list[1:]:
				# Check if reducing 1 from i doesn't gives us last element of slave list 
				if int(i)-1 != int(slave_list[-1]):
                    # If yes, invoke that lambda function &amp, start appending elements to the master list based on elements present in slave list
					add_2_master_list(master_list, slave_list)
                    # Clear the slave_list to prepare for the next element
					slave_list.clear()
                # After every iteration, keep on appending the items in slave. Note : Slave must never be kept empty.
				slave_list.append(i)
            # Once all iterations are done, whatever items are there in the slave list have to be now added to the master list.
			# Hence again invoke the lambda function. 
			add_2_master_list(master_list, slave_list)
            # Return the master list
			return master_list";"class Solution:
    def summaryRanges(self, nums: list[int]) -> list[str]:
        if not nums:
            return []
        
        result = []
        i = 0
        while i < len(nums):
            start = nums[i]
            while i + 1 < len(nums) and nums[i+1] == nums[i] + 1:
                i += 1
            
            if start == nums[i]:
                result.append(str(start))
            else:
                result.append(f""{start}->{nums[i]}"")
            i += 1
            
        return result"
"class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        """"""
        Using a 2-pointer approach, compare two strings and determines if the first string is a subset of the second string.

        :param s:
            str: String of alpha characters
        :param t:
            str: String of alpha characters
        :return
            bool: True if first string is a contiguous subset of the second string
        """"""
        # Set variables equal to the length of each input string
        left_bound, right_bound = len(s), len(t)

        # Initialize index for each pointer
        p_left = p_right = 0

        while p_left < left_bound and p_right < right_bound:
            # Move both pointers if the equal each other
            if s[p_left] == t[p_right]:
                p_left += 1
            p_right += 1
        # Return when left pointer equals length of source string
        return p_left == left_bound";"class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        t_iter = iter(t)
        return all(c in t_iter for c in s)"
"class Solution:
    def brute_force(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N*N)
        Space Complexity: O(1)
        """"""
        for i in range(len(nums)):
            if i not in nums:
                return i
        return len(nums)
    
    def sorting(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(Nlog(N))
        Space Complexity: O(N)
        """"""
        nums.sort()
        
        for i, num in enumerate(nums):
            if i != num:
                return i
        return len(nums)
    
    def binary_search(self, nums: List[int]) -> int:
        """"""
        Time Complexity:
            O(Nlog(N)) if nums not sorted
            O(log(N)) if nums already sorted
        
        Space Complexity:
            O(N) if nums not sorted
            O(1) if nums sorted
        """"""
        nums.sort()
        left, right = 0, len(nums)
        mid = (left+right)//2
        while left < right:
            if nums[mid] == mid:
                left = mid+1
            else:
                right = mid - 1
            
            mid = (left + right)//2
        
        return mid + 1
    
    def hashing(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(N)
        """"""
        nums_set = set(nums)
        N = len(nums)
        for i in range(N):
            if i not in nums_set:
                return i
        
        return len(nums)
        
    def gauss_formula(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(1)
        """"""
        N = len(nums)
        return N*(N + 1)//2 - sum(nums)
    
    def xor(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(1)
        """"""
        result = len(nums)
        for i, v in enumerate(nums):
            result ^= i^v
        
        return result
    
    def cyclic_swapping(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(1)
        """"""
        current = 0
        N = len(nums)
        count = 0
        while current < N:
            count+= 1
            if nums[current] == N:
                current += 1
                continue
            
            if nums[current] == nums[nums[current]]:
                current += 1
            else:
                temp = nums[current]
                nums[current] = nums[nums[current]]
                nums[temp] = temp
        
        for i, v in enumerate(nums):
            if i != v:
                return i
        
        return N
    
    def value_inversion(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(1)
        
        Advantages:
            - Original Input array can be restored
        """"""
        
        for i, _ in enumerate(nums):
            nums[i] += 1
        
        for i, v in enumerate(nums):
            if abs(v) > len(nums):
                continue
        
            nums[abs(v)-1] = -abs(nums[abs(v)-1])
        
        for i, v in enumerate(nums):
            if v > 0:
                return i
        
        return len(nums)
                
    
    def missingNumber(self, nums: List[int]) -> int:
        # return self.brute_force(nums)
        # return self.sorting(nums)
        # return self.hashing(nums)
        # return self.gauss_formula(nums)
        # return self.xor(nums)
        # return self.cyclic_swapping(nums)
        # return self.binary_search(nums)
        return self.value_inversion(nums)";"class Solution:
    def missingNumber(self, nums: list[int]) -> int:
        n = len(nums)
        expected_sum = n * (n + 1) // 2
        actual_sum = sum(nums)
        return expected_sum - actual_sum"
"class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        
        @cache
        def fn(n, k):
            """"""Return min moves given n floors and k eggs.""""""
            if k == 1: return n
            if n == 0: return 0 
            lo, hi = 1, n + 1
            while lo < hi: 
                mid = lo + hi >> 1
                if fn(mid-1, k-1) < fn(n-mid, k): lo = mid + 1
                else: hi = mid 
            return 1 + max(fn(lo-1, k-1), fn(n-lo, k))
        
        return fn(n, k)";"def superEggDrop(k: int, n: int) -> int:
    dp = [0] * (k + 1)
    moves = 0
    while dp[k] < n:
        moves += 1
        for eggs in range(k, 0, -1):
            dp[eggs] = dp[eggs] + dp[eggs - 1] + 1
    return moves"
"class Solution:
    def removeKdigits(self, nums: str, k: int) -> str:
       
        # Base Case
        if len(nums) == k:
            return ""0""
        
        # Init
        m = len(nums)
        
        # Build a monotonic stack, by removing
        # greater element previous to current
        # index
        stack = []
        for i in range(m):
            if stack:
                curr = int(nums[i])
                while k and stack and int(stack[-1]) > curr:
                    stack.pop()
                    k -= 1
            stack.append(nums[i])
        
        # Pop remaining k elements,
        # as they will be greatest in the
        # monotonic stack so created
        while k and stack:
            stack.pop()
            k -= 1
        
        # Join all the element in the stack
        # and first convert it to int, to
        # remove the leading zeros, and
        # then convert to string before
        # returning
        return str(int("""".join(stack)))
        
        """"""
        def REC(s: int, k: int, n: int):
            if n < 0 or k==0 or s=="""":
                return -1 if s=="""" else int(s)
            else:
                return min(REC(s[:n] + s[n+1:], k-1, n-1), REC(s,k,n-1))
        """"""
        
        """"""
        def REC(s: int, k: int, n: int, t: Dict = dict()):
            if n < 0 or k==0 or s=="""":
                return -1 if s=="""" else int(s)
            else:
                key = s 
                if key not in t:
                    t[key] = min(REC(s[:n] + s[n+1:], k-1, n-1, t), REC(s,k,n-1,t))
            return t[key]
        
        val = REC(nums, k, m-1)
        
        return """" if val == -1 else str(val) 
        """"""";"class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        stack = []
        
        for digit in num:
            while k and stack and stack[-1] > digit:
                stack.pop()
                k -= 1
            stack.append(digit)
            
        if k:
            stack = stack[:-k]
            
        result = """".join(stack).lstrip('0')
        
        return result or ""0"""
"class Solution(object):
    def removeComments(self, source):
        """"""
        :type source: List[str]
        :rtype: List[str]
        """"""
        
        # initialize some variables to save lines and valid characters
        result = []
        current_line = """"
        
        # initialize some state variables
        in_block = False
        in_line = False
        skip_next = False
        
        for line in source:
            
            # in a new line we will never skip the first character
            skip_next = False
            
            # a new line can never be part of an inline comment
            in_line = False
            
            for index, character in enumerate(line):
                
                # ----------------------------------------------------------------
                # Guard clauses that will always skip the character, if we are in
                # a comment or notified the loop to skip the next
                # -----------------------------------------------------------------
                
                # guard clause whether we want to skip the current character
                if skip_next:
                    
                    # reset the boolean in case we skip
                    skip_next = False
                    continue
                
                # guard clause whether we are in an in line comment
                # this comment can only be ended by a new line so we do not need
                # to check the current character
                if in_line:
                    continue
                    
                # guard clause whether we are in a block comment
                if in_block:
                    
                    # since the block comment can be ended, we need to check whether we find
                    # our ending symbol
                    # line[index:index+2] slicing works also at the end of a line
                    # (even if index+2 is out of scope)
                    if line[index:index+2] == '*/':
                        
                        # in case we found the end of the block comment we switch the bool to false
                        # and we need to skip the next character
                        # Our current character (line[index]) is '*' and the next is '/' which we skip
                        in_block = False
                        skip_next = True
                        continue
                    else:
                        
                        # we are still in block comment and therefore can continue
                        continue
                
                
                # ----------------------------------------------------------------
                # After all guard clauses passed, we are not in a comment and
                # we need to check the current character whether it starts one
                # -----------------------------------------------------------------
                
                # check whether block comment begins
                # slicing of list works even if index+2 is out of scope
                if line[index:index+2] == '/*':
                    
                    # switch the comment boolean and 
                    # tell our loop we need to skip the next character
                    # since it will be a '*'
                    in_block = True
                    skip_next = True
                    continue
                
                # check whether in line comment starts
                # slicing works also at end of line
                if line[index:index+2] == '//':
                    
                    # we switch the boolean and  skip the next character as it will be
                    # '/'
                    in_line = True
                    skip_next = True
                    continue
                
                # ----------------------------------------------------------------
                # Now that all checks have passed we found
                # a character that is part of the code
                # -----------------------------------------------------------------
                
                
                # append our character to the current line
                current_line += character
            
            
            # we will append the current line to our result (finalize a line in the output)
            # a) if we are not in a block comment that hasn't ended
            # b) and the current line has characters in it
            if not in_block and current_line:
                
                # append the line and reset the current line
                result.append(current_line)
                current_line = """"
                
        return result";"import collections

class Solution:
  def removeComments(self, source: list[str]) -> list[str]:
    in_block = False
    result = []
    current_line = []

    for line in source:
      i = 0
      if not in_block:
        current_line = []
      
      while i < len(line):
        if in_block:
          if i + 1 < len(line) and line[i:i+2] == '*/':
            in_block = False
            i += 1
        elif i + 1 < len(line) and line[i:i+2] == '//':
          break
        elif i + 1 < len(line) and line[i:i+2] == '/*':
          in_block = True
          i += 1
        else:
          current_line.append(line[i])
        i += 1
      
      if current_line and not in_block:
        result.append("""".join(current_line))
        
    return result"
"class Solution:
    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
        a,b,c = sorted((a,b,c))
        ans = inf
        def hcf(a,b):
            if a %b == 0: return b
            return hcf(b , a % b)
        p,q,r= hcf(a,b),hcf(b,c),hcf(a,c)
        s = hcf(r,b)
        x1 = (a*b) // p
        x2 = (b*c) // q 
        x3 = (a*c) // r
        x4 = (a * b * c * s)// (p * q * r )
        low,high = a , a *n
        while low <= high:
            mid = (low + high)//2
            times = mid//a + mid//b + mid//c - mid//x1 - mid//x2 - mid//x3 + mid//x4
            if times < n : low = mid + 1
            elif times == n:
                ans = min(ans,mid)
                high = mid - 1
            else: high = mid - 1
        return ans";"import math

class Solution:
    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
        
        def lcm(x, y):
            return (x * y) // math.gcd(x, y)

        ab = lcm(a, b)
        ac = lcm(a, c)
        bc = lcm(b, c)
        abc = lcm(a, bc)

        low = 1
        high = 2 * 10**9

        while low < high:
            mid = low + (high - low) // 2
            
            count = (mid // a) + (mid // b) + (mid // c) - \
                    (mid // ab) - (mid // ac) - (mid // bc) + \
                    (mid // abc)
            
            if count < n:
                low = mid + 1
            else:
                high = mid
        
        return low"
"class Solution:
    def countAsterisks(self, s: str) -> int:
        count = 0
        if '|' not in s:
            count += s.count('*')
        while '|' in s:
            split_list = s.split('|', 2)
            count += split_list[0].count('*')
            s = split_list[2]
            if '|' not in split_list[2]:
                count += split_list[2].count('*')
        return count
    
# assert Solution().countAsterisks('""yo|uar|e**|b|e***au|tifu|l""') == 5
# assert Solution().countAsterisks('iamprogrammer') == 0
# assert Solution().countAsterisks('l|*e*et|c**o|*de|') == 2
# assert Solution().countAsterisks(""||*"") == 1
# assert Solution().countAsterisks(""|*|"") == 0
# assert Solution().countAsterisks(""||"") == 0
# assert Solution().countAsterisks(""*||"") == 1
# assert Solution().countAsterisks(""*"") == 1";"class Solution:
    def countAsterisks(self, s: str) -> int:
        return sum(part.count('*') for part in s.split('|')[::2])"
"class Solution:
    def duplicateZeros(self, arr: List[int]) -> None:
        """"""
        Do not return anything, modify arr in-place instead.
        """"""
        possible_duplicates = 0
        length = len(arr) - 1
        # going left to right 
        # and counting zeros to be considered for duplication
        # why considering whole length of array and not leaving last element?
        # Ans:=> in this case last element could be zero and if we don't iterate over the whole array we would end up duplicating it in the next iteration as we would miss not considering the last element for no-duplication
        for left in range(length + 1):
            # left goes beyond allowed elements, stop iteration
            if left > length - possible_duplicates:
                break
            
            # count zeros
            if arr[left] == 0:
                # edge case: don't include the last element which can not be duplicated due to no more space available in the array
                if left == length - possible_duplicates:
                    # move this zero to the end of the array
                    arr[length] = arr[left]  # or 0
                    length -= 1  # we don't have to consider placing this element to its correct position because we already did so
                    break  # break out of the loop, we have already visited and seen all the elements that could be part of resulting arr, we don't have to calculate this 0 too.
                possible_duplicates += 1
        
        last_index = length - possible_duplicates
        # going right to left and placing elements at their correct index
        # also, duplicating zeros
        for right in range(last_index, -1, -1):
            if arr[right] == 0:
                arr[right + possible_duplicates] = arr[right]  # or 0
                # decrement zero
                possible_duplicates -= 1
                arr[right + possible_duplicates] = arr[right]  # or 0, duplicating zero
            
            else:
                arr[right + possible_duplicates] = arr[right]";"def duplicateZeros(arr: list[int]) -> None:
    possible_dups = arr.count(0)
    length = len(arr)

    if possible_dups == 0:
        return

    for i in range(length - 1, -1, -1):
        if i + possible_dups < length:
            arr[i + possible_dups] = arr[i]

        if arr[i] == 0:
            possible_dups -= 1
            if i + possible_dups < length:
                arr[i + possible_dups] = 0"
"class Solution:
    def maximumGap(self, arr: List[int]) -> int:
        min1 = float('inf')
        max1 = float('-inf')
        n = len(arr)
        if (n < 2):
            return 0
        
        for i in range(0, n):
            min1 = min(min1, arr[i])
            max1 = max(max1, arr[i])
                
        if (max1 == min1):
            return 0
        gap = (max1 - min1) // (n-1)
        # print((max1-min1)/(n-1), min1, max1, n-1, max1-min1, 8/3)
        # print(gap)
        if ((max1 - min1) % (n-1) != 0):
            gap += 1 
        
        # print(gap, min1, max1)
        
        # new_arr = [0]*(n+1)
        # for i in range(0, n+1):
        #     new_arr[i]= [min1 + (i* gap), min1 + (i+1)*gap-1]
        # print(new_arr)
        min_bucket = [float('inf')] * (n)
        max_bucket = [float('-inf')] * (n)
        # print(min_bucket, max_bucket)
        for i in range(0, n):
            bucket_num = (arr[i] - min1) // gap
            # print(bucket_num)
            
            min_bucket[bucket_num] = min(arr[i], min_bucket[bucket_num])
            
            max_bucket[bucket_num] = max(arr[i], max_bucket[bucket_num])
            
            
        # print(min_bucket, max_bucket)
        
#         print(max_bucket[1])
        
#         if (max_bucket[1] == -inf):
#             print('es')
        
        prev = max_bucket[0]
        ans = float('-inf')
        for i in range(1, len(min_bucket)):
        # print(""Ok"", prev)
            if (prev == float('-inf') or min_bucket[i] == float('inf')): 
                # print(""EXE"")
                continue
            ans = max(ans, min_bucket[i] - prev)
            # print(""prev"",min_bucket[i], ans, prev)
            prev = max_bucket[i]

        return ans";"def maximumGap(nums: list[int]) -> int:
    n = len(nums)
    if n < 2:
        return 0

    min_val = min(nums)
    max_val = max(nums)

    if min_val == max_val:
        return 0

    bucket_size = max(1, (max_val - min_val) // (n - 1))
    bucket_count = (max_val - min_val) // bucket_size + 1

    buckets = [[float('inf'), float('-inf')] for _ in range(bucket_count)]

    for num in nums:
        idx = (num - min_val) // bucket_size
        buckets[idx][0] = min(buckets[idx][0], num)
        buckets[idx][1] = max(buckets[idx][1], num)

    max_gap = 0
    previous_max = min_val

    for i in range(bucket_count):
        if buckets[i][0] == float('inf'):
            continue
        max_gap = max(max_gap, buckets[i][0] - previous_max)
        previous_max = buckets[i][1]

    return max_gap"
"class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if amount == 0 or not coins: return 0
        
        # this dp will hold the number of coins
        # required for every amount from 0..amount
        dp = [float('inf')] * (amount+1)
        
        # to have a sum of zero
        # we don't need any coins i.e 0
        dp[0] = 0
        
        # brute force, we'll calculate
        # the coins needed for every amount
        # starting from 1 since we've calculated 0
        for a in range(1, amount+1):
            # for every amount, we'll
            # try to form coins with every
            # available coin
            for c in coins:
                # if the current amount is less
                # than the current coin, you can't
                # make that amount with this coin
                # so skip it. i.e. if a = 2 and coin = 5
                # you should not bother computing anything here
                if a-c >= 0:
                    # otherwise, you check the min
                    # of the num(coins) for current amount
                    # and the 1 plus the coins required
                    # by amount-c i.e. to make the amount 0
                    # for e.g. if amount = 7 and coin = 3,
                    # we can say the coins needed to make 7
                    # would be the coin of denomination 4 (+1) and
                    # the number of coins taken to reach 3
                    # => 1 + dp[3] so that we can easily reach the sum i.e 7
                    dp[a] = min(dp[a], dp[a-c]+1)
            
        # we need to return -1 if we weren't able to find
        # an answer i.e. no updates were made and the amount
        # still has the initial value we had set i.e float('inf')
        return dp[amount] if dp[amount] != float('inf') else -1";"import math

def coinChange(coins: list[int], amount: int) -> int:
    dp = [amount + 1] * (amount + 1)
    dp[0] = 0

    for a in range(1, amount + 1):
        for c in coins:
            if a - c >= 0:
                dp[a] = min(dp[a], 1 + dp[a - c])

    return dp[amount] if dp[amount] != amount + 1 else -1"
"class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """"""
        Do not return anything, modify board in-place instead.
        """"""
        life = []
        for i in range(len(board)):
            col = []
            for j in range(len(board[0])):
                col.append(board[i][j])
            life.append(col)
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == 1:
                    if self.check(board,i,j) == True:
                        life[i][j] = 0
                else:
                    if self.check(board,i,j) == True:
                        life[i][j] = 1
        for i in range(len(life)):
            for j in range(len(life[0])):
                board[i][j] = life[i][j]
                
    def check(self,board,i,j):
        count = 0
        if board[i][j]==1:
            #diagonal top left to bottom right
            if i !=0 and j !=0 :
                if board[i-1][j-1] == 1:
                    count+=1
            if i != len(board)-1 and j != len(board[0])-1:
                if board[i+1][j+1] == 1:
                    count+=1
            #diagonal top right to bottom left
            if i!=0 and j != len(board[0])-1:
                if board[i-1][j+1] ==1:
                    count+=1
            if i!= len(board)-1 and j!=0:
                if board[i+1][j-1] == 1:
                    count +=1
            #top and bottom vertically
            if i!=0 and board[i-1][j]==1:
                count+=1
            if i!= len(board)-1 and board[i+1][j]==1:
                count +=1
            #left and right horizontally
            if j!=0 and board[i][j-1] ==1:
                count+=1
            if j!= len(board[0])-1 and board[i][j+1]==1:
                count+=1
            if count ==2 or count == 3:
                return False
            else:
                return True
        else:
            if board[i][j]==0:
                #diagonal top left to bottom right
                if i !=0 and j !=0 :
                    if board[i-1][j-1] == 1:
                        count+=1
                if i != len(board)-1 and j != len(board[0])-1:
                    if board[i+1][j+1] == 1:
                        count+=1
                #diagonal top right to bottom left
                if i!=0 and j != len(board[0])-1:
                    if board[i-1][j+1] ==1:
                        count+=1
                if i!= len(board)-1 and j!= 0:
                    if board[i+1][j-1] ==1:
                        count +=1
                #top and bottom vertically
                if i!=0 and board[i-1][j]==1:
                    count+=1
                if i!= len(board)-1 and board[i+1][j]==1:
                    count +=1
                #left and right horizontally
                if j!=0 and board[i][j-1] ==1:
                    count+=1
                if j!= len(board[0])-1 and board[i][j+1]==1:
                    count+=1
                if count == 3:
                    return True
                else:
                    return False";"def gameOfLife(board: list[list[int]]) -> None:
    """"""
    Do not return anything, modify board in-place instead.
    """"""
    m, n = len(board), len(board[0])
    
    # -1: 1 -> 0 (was live, now dead)
    #  2: 0 -> 1 (was dead, now live)
    
    for r in range(m):
        for c in range(n):
            live_neighbors = 0
            for i in range(max(0, r-1), min(m, r+2)):
                for j in range(max(0, c-1), min(n, c+2)):
                    if (i, j) == (r, c):
                        continue
                    if abs(board[i][j]) == 1:
                        live_neighbors += 1
                        
            if board[r][c] == 1 and (live_neighbors < 2 or live_neighbors > 3):
                board[r][c] = -1
            elif board[r][c] == 0 and live_neighbors == 3:
                board[r][c] = 2

    for r in range(m):
        for c in range(n):
            if board[r][c] == 2:
                board[r][c] = 1
            elif board[r][c] == -1:
                board[r][c] = 0"
"class Solution:
	#Time-Complexity: O(logn * (n/2)) -> O(nlogn) -> while loop runs at most logn times since
	#we divide nums array size by half each iteration, and the for loop runs at most n/2 times!
	#Space-Complexity: O(logn * (n/2)) -> for each iteration of while loop, we allocate
	#copy array of size at worst (n/2) -> O(nlogn)
    def minMaxGame(self, nums: List[int]) -> int:
        
        #just simulate it?
        min_flag = True
        
        while len(nums) > 1:
            copy = []
            for i in range(0, len(nums)-1, 2):
                if(min_flag):
                    copy.append(min(nums[i], nums[i+1]))
                    min_flag = (not min_flag)
                    continue
                
                else:
                    copy.append(max(nums[i], nums[i+1]))
                    min_flag = (not min_flag)
                    continue
            
            nums = copy
            min_flag = True
        
        return nums[0]";"class Solution:
    def minMaxGame(self, nums: list[int]) -> int:
        n = len(nums)
        while n > 1:
            n //= 2
            for i in range(n):
                if i % 2 == 0:
                    nums[i] = min(nums[2 * i], nums[2 * i + 1])
                else:
                    nums[i] = max(nums[2 * i], nums[2 * i + 1])
        return nums[0]"
"class Solution:
    def rob(self, nums: List[int]) -> int:
        # How many money we can make we we reach last house
        # How many money we can make when we reach i house
        # iterate from left to right
        # when reach i'th  house the money we can make is from
        # (First) dp[i-2] which is the maimum value we can make when reach (i-2)'th house plus the curr nums[i]
        # (Second) get the money from dp[i-1] which is the maximum value we can make when reach (i-1)'th house. However, we can't add current num[i], since when we take the money from (i-1)'th house, we can not take the adjacent house
        # store the maximum between (First) and (Second)
        # check the base case dp[0] give nums[0] is ok, However, dp[1] =  max(dp[1-1],dp[1-2]+nums[1]), we don't have dp[-1], therefore we give a extra space at the frony.
        # dp = [0]*(n+1). Therefore, i in dp correspond to i-1 in nums, That is now the dp[1] = nums[0]
        
        # Method 1
        # Time: O(n), Space: O(n)
        
        n = len(nums) 
        dp = [0]*(n+1)
        dp[1] = nums[0]
        for i in range(2,n+1):
            dp[i] = max(dp[i-1],dp[i-2]+nums[i-1])
        return dp[-1]
        
        # Method 2
        # Since we only need dp[i-1], dp[i-2]. we can create variable and save space
        # Time: O(n), Space: O(1)
        first = 0
        second = 0
        for num in nums:
            first, second =  second, max(first + num, second)
        return second            
            
        # Method 3 same as method 2
        # Time: O(n), Space: O(1)
        first_value = 0 
        second_value = 0
        
        for num in nums:
            temp = max(num + first_value, second_value)
            first_value = second_value
            second_value = temp
        return second_value";"def rob(nums: list[int]) -> int:
    rob1, rob2 = 0, 0
    for n in nums:
        temp = max(n + rob1, rob2)
        rob1 = rob2
        rob2 = temp
    return rob2"
"class Solution:
    def minimizeXor(self, num1: int, num2: int) -> int:
        # determine number of 1's in binary representation
        # which is also equal to bin(num2[1:]).count(""1"")
        n2 = 0
        while num2:
            if num2 &amp, 1:    # last bit is 1
                n2 += 1     # increase count
            num2 >>= 1      # shift the binary number to the right

        # search for indices for 0's and 1's
        # n = 110 (binary form) => bits1{0: [0], 1: [1, 2]}
        bits1 = {0: [], 1: []}
        i = 0    # index from the right side
        while num1:
            if num1 &amp, 1:   # decide which list to append
                bits1[1].append(i)
            else:
                bits1[0].append(i)
            i += 1        # increase index
            num1 >>= 1    # shift the number to the right

        # list of positions - reversed for 1 (left to right)
        # straight for 0 (right to left)
        target_pos = bits1[1][::-1] + bits1[0]    # positions for 1
        # if we need more 1's to be placed into the target number
        if len(target_pos) < n2:
            next_pos = target_pos[0] + 1    # most left position
            # fill it in with consecutive positions
            target_pos += list(range(next_pos,
                                     next_pos + n2 - len(target_pos)))
        # cut the list to the required length n2
        target_pos = target_pos[:n2]
        # find the final number by shifting 1's to the target positions
        # e.g. target = 101 == 100 + 001 in binary
        return sum(1 << pos for pos in target_pos)";"import math

class Solution:
    def minimizeXor(self, num1: int, num2: int) -> int:
        c2 = num2.bit_count()
        x = 0
        
        # Greedily match set bits from num1, starting from MSB
        for i in range(30, -1, -1):
            if (num1 >> i) & 1:
                if c2 > 0:
                    x |= (1 << i)
                    c2 -= 1
        
        # If more bits are needed, fill them from LSB upwards
        if c2 > 0:
            for i in range(31):
                if not ((x >> i) & 1):
                    if c2 > 0:
                        x |= (1 << i)
                        c2 -= 1
                    else:
                        break
        
        return x"
"class Solution:
    def wordPattern(self, letters: str, words: str) -> bool:
        '''
		Renamed parameters to less confusing names.
		""patterns"" to ""letters"".
		""s"" to ""words"".
		
		Solution:
		
        Return False if the number of letters and words are not the same.
   
        Traverse the letters, one by one and return False if:
        
        A letter together with its corresponding word in words
        (same index as in letters) meets a condition when compared:
        
        With letters as keys in the dictonary and words as
        corresponding values:
        
        1. Return False if: 
           Current letter/key in loop already exists but
           isn't the same as the letter/word pair currently in comparison.
        
        2. Return False if:
           Current letter in loop is not yet a key but the corresponding
           word is a value in the dictionary already. 
           (Otherwise add the letter and word 
           as key/value pairs to the dict)
           
        Return True if the loop is complete, which means that all letters 
		have been compared with corresponding words without finding any of the
		above issues.
        '''
        
        words = words.split()
        
        if len(letters) != len(words):
            return False
			
		pairs = dict()
        
        for i, letter in enumerate(letters):
            if letter in pairs.keys():
                if pairs[letter] != words[i]:
                    return False
            elif words[i] not in pairs.values():
                pairs[letter] = words[i]
            else:
                return False
            
        return True";"import collections

class Solution:
  def wordPattern(self, pattern: str, s: str) -> bool:
    words = s.split()
    if len(pattern) != len(words):
      return False
    
    char_to_word = {}
    word_to_char = {}
    
    for char, word in zip(pattern, words):
      if char in char_to_word and char_to_word[char] != word:
        return False
      if word in word_to_char and word_to_char[word] != char:
        return False
      char_to_word[char] = word
      word_to_char[word] = char
      
    return True"
"class Solution:            # Suppose for example:
                           #    words1 = ['food', 'coffee', 'foofy']
                           #    words2 = ['foo', 'off']
                           #  
                           # Here's the plan:
                           #   1) Construct a dict in which the key is a char in
                           #      one or more words in words2, and the key's max
                           #      count in those words.
                           #            for 'foo': c2 = {'o': 2, 'f': 1}
                           #            for 'off': c2 = {'o': 1, 'f': 2}
                           #            so: d = {'o': 2, 'f': 2}
                           #
                           #   2) Use a counter for each word in words1 to determine 
                           #      whether the word has at least the quantity of each char
                           #      in d:
                           #            for 'food'  : c1 = {'o': 2, 'f': 1, 'd': 1}          (fails at 'f')
                           #            for 'coffee': c1 = {'f': 2, 'e': 2, 'o': 1, 'c': 1 } (fails at 'o')
                           #            for 'foofy ': c1 = {'f': 2, 'o': 2, 'y': 1}          (success)
                           #
                           #   3) return answer:
                           #            answer = ['foofy'] 
                           #
    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:
        d, ans = defaultdict(int), []

        for word in words2:                     #  <-- 1)
            c2 = Counter(word)
            for ch in c2:
                d[ch] = max(d[ch], c2[ch])

        for word in words1:                     #  <-- 2)
            c1 = Counter(word)

            for ch in d:
                if c1[ch] < d[ch]: break
            else:
                ans.append(word)                #  <-- else executes only if the for-loop
                                                #      completes without break

        return ans                              #  <-- 3)";"import collections

class Solution:
    def wordSubsets(self, words1: list[str], words2: list[str]) -> list[str]:
        max_b_counts = collections.Counter()
        for b in words2:
            max_b_counts |= collections.Counter(b)

        result = []
        for a in words1:
            count_a = collections.Counter(a)
            if all(count_a[char] >= count for char, count in max_b_counts.items()):
                result.append(a)
        
        return result"
"class Solution:
    def isHappy(self, n: int) -> bool:   
        # Maintain the additions we have done, so we know when the loop goes infinite
        duplicate = {}
        
        # Use recursion: calculate sum of digits, add to duplicates map, and re-call the method
        def check(n: int) -> bool:
            if n == 1:
                # we return true -> since it is a happy number
                return True
            
            # Find the digits. Note: order in the list does not matter here. 
            res = []
            while n > 0:
                w = n%10
                res.append(w)
                n = n//10
        
            # Since we have the digits now, add the digits
            add = 0
            for num in res:
                add += num**2
            
            # Return False if sum in duplicate map, or re-call the method with new sum
            if add in duplicate:
                # Loop detected
                return False
            else:
                duplicate[add] = 0
                return check(add)
        
        # calling the main method
        return check(n)";"class Solution:
    def isHappy(self, n: int) -> bool:
        seen = set()
        while n != 1 and n not in seen:
            seen.add(n)
            n = sum(int(digit)**2 for digit in str(n))
        return n == 1"
"class Solution:
    def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:
        # Stack: go from back and use stack to get ans
        # Time: O(n)
        # Space: O(n)
        
        stack = [] # index
        ans = [-1] * len(cars)
        for i in range(len(cars)-1,-1,-1):
            # remove cars that are faster than current car since it will never collide
            while stack and cars[i][1] <= cars[stack[-1]][1]: 
                stack.pop()

            while stack: # if car left, we can compute collide time with current car. 
                collision_t = (cars[stack[-1]][0] - cars[i][0]) / (cars[i][1] - cars[stack[-1]][1])
                # if current car's collide time is greater than previous car's collide time 
                # (previous collided before current), then we have to find previous car's previous car
                # to compute collide time with that car, so we pop from stack and re-process
                # Otherwise, we add that collide time to answer and break
                if ans[stack[-1]] == -1 or collision_t <= ans[stack[-1]]:
                    ans[i] = collision_t
                    break
                stack.pop()
            stack.append(i)
        return ans";"import collections

class Solution:
    def getCollisionTimes(self, cars: list[list[int]]) -> list[float]:
        n = len(cars)
        answer = [-1.0] * n
        stack = []

        for i in range(n - 1, -1, -1):
            p_i, s_i = cars[i]
            
            while stack:
                j = stack[-1]
                p_j, s_j = cars[j]
                
                if s_i <= s_j:
                    stack.pop()
                    continue
                
                collision_time = (p_j - p_i) / (s_i - s_j)
                
                if answer[j] != -1 and collision_time >= answer[j]:
                    stack.pop()
                    continue
                
                answer[i] = collision_time
                break
            
            stack.append(i)
            
        return answer"
"class Solution:
    def closestRoom(self, rooms: List[List[int]], queries: List[List[int]]) -> List[int]:
        ans = [0] * len(queries)
        
        # sort queries to handle largest size queries first
        q = deque(sorted([(size, room, i) for i, (room, size) in enumerate(queries)], key=lambda a: (-a[0], a[1], a[2])))

        # sort rooms by descending size
        rooms = deque(sorted(rooms, key=lambda x: -x[1]))

        # current available room ids
        cands = []
        
        
        while q:
            size, room, i = q.popleft()
            # add room ids to candidates as long as top of room size meet the requirements
            while rooms and rooms[0][1] >= size:
                bisect.insort(cands, rooms.popleft()[0])
                    
            # if no room size available, return -1
            if not cands: ans[i] = -1
                
            # else use bisect to find optimal room ids
            else:
                loc = bisect.bisect_left(cands, room)
                if loc == 0: ans[i] = cands[loc]
                elif loc == len(cands): ans[i] = cands[-1]
                else: ans[i] = cands[loc - 1] if room - cands[loc - 1] <= cands[loc] - room else cands[loc]
        
        return ans";"import bisect

class Solution:
    def closestRoom(self, rooms: list[list[int]], queries: list[list[int]]) -> list[int]:
        rooms.sort(key=lambda x: x[1], reverse=True)
        
        indexed_queries = sorted(
            [(queries[i][1], queries[i][0], i) for i in range(len(queries))], 
            reverse=True
        )
        
        ans = [-1] * len(queries)
        available_ids = []
        room_ptr = 0
        
        for min_size, preferred, original_idx in indexed_queries:
            
            while room_ptr < len(rooms) and rooms[room_ptr][1] >= min_size:
                bisect.insort_left(available_ids, rooms[room_ptr][0])
                room_ptr += 1
            
            if not available_ids:
                continue

            i = bisect.bisect_left(available_ids, preferred)
            
            best_id = -1
            min_diff = float('inf')

            # Check candidate to the right
            if i < len(available_ids):
                cand_id = available_ids[i]
                diff = abs(cand_id - preferred)
                if diff < min_diff:
                    min_diff = diff
                    best_id = cand_id

            # Check candidate to the left
            if i > 0:
                cand_id = available_ids[i-1]
                diff = abs(cand_id - preferred)
                if diff < min_diff:
                    min_diff = diff
                    best_id = cand_id
                elif diff == min_diff:
                    best_id = min(best_id, cand_id)

            ans[original_idx] = best_id
            
        return ans"
"class Solution:
    def stoneGameV(self, stoneValue: List[int]) -> int:
        def getPartialSum():
            for i in range(n):
                partial_sum[i][i] = stoneValue[i]
            for i in range(n):
                for j in range(i+1, n):
                    partial_sum[i][j] = partial_sum[i][j-1]+stoneValue[j]
                               
        # (O(n) search)    
        def preCalCutIdx():
            # based on the fact that cut index is increasing with k for 
            # partial_sum[start][k]
            for i in range(n-1):
                cp = i
                cut_index[i][i+1] = i
                for j in range(i+2, n):
                    while cp < j-1 and partial_sum[i][cp] < partial_sum[cp+1][j]:
                        cp += 1  
                    cut_index[i][j] = cp
		
			
        @lru_cache(None)
        def dfs(start, end):
            if start >= end:
                return 0
            max_score = 0
            # find first cut s.t. left sum >= right sum 
            cut = cut_index[start][end]
            # we can't find cut s.t. left sum >= right sum
            if cut == -1:
                cut = end-1
            sum1 = partial_sum[start][cut]
            sum2 = partial_sum[cut+1][end]
            if sum1 < sum2:
                # calcuate left[start][cut] if not yet
                dfs(start, cut)
                # the remaining will be the left part for sure, no 
                # matter where the cut is. 
                max_score = left[start][cut]
            elif sum1 == sum2:
                dfs(start, cut)
                dfs(cut+1, end)
                # if real cut in the range of [cut+1, end], remaining will be the right part
                # if real cut in the range of [0, cut], remaing will be the left part
                # if real cut is cut, either can be the remaining. 
                max_score = max(left[start][cut], right[cut+1][end])
            else:
                dfs(cut+1, end)
                # we are selecting the cut in the range of [cut, end] having 
                # the max score. For cut in that range, the remaining is 
                # the right part of the cut for sure. 
                max_score = right[cut+1][end]
                if cut > start:
                    dfs(start, cut-1)
                    # we are selecting the cut in the range of [0, cut] having 
                    # the max score. The remaining is the left part for sure. 
                    max_score = max(max_score, left[start][cut-1])
            dfs(start, end-1)
            dfs(start+1, end)
            # updating left and right arrays. 
            left[start][end] = max(left[start][end-1], partial_sum[start][end]+max_score)
            right[start][end] = max(right[start+1][end], partial_sum[start][end]+max_score)
            return max_score
            
        n = len(stoneValue)
        partial_sum = [[0]*n for _ in range(n)]
        cut_index = [[-1]*n for _ in range(n)]
        # left[i][j]: cut in the range of [i, j], max score of left part
        # right[i][j]: cut in the range of [i, j], max score of right part
        left = [[0]*n for _ in range(n)]
        right = [[0]*n for _ in range(n)]
        for i in range(n):
            left[i][i] = stoneValue[i]
            right[i][i] = stoneValue[i]
        getPartialSum()
        # for partial_sum[i][j], find cut index between i and j 
        # s.t partial_sum[i][cut_index] >= partial_sum[cut_index+1][j] or 
        # cut_index = j-1 if not exist. 
        preCalCutIdx()
        return dfs(0, n-1)";"class Solution:
    def stoneGameV(self, stoneValue: list[int]) -> int:
        n = len(stoneValue)
        if n <= 1:
            return 0

        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i + 1] = prefix[i] + stoneValue[i]

        dp = [[0] * n for _ in range(n)]

        for length in range(2, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                max_score = 0
                for k in range(i, j):
                    left_sum = prefix[k + 1] - prefix[i]
                    right_sum = prefix[j + 1] - prefix[k + 1]
                    
                    current_score = 0
                    if left_sum < right_sum:
                        current_score = left_sum + dp[i][k]
                    elif right_sum < left_sum:
                        current_score = right_sum + dp[k + 1][j]
                    else:
                        current_score = left_sum + max(dp[i][k], dp[k + 1][j])
                    
                    if current_score > max_score:
                        max_score = current_score
                dp[i][j] = max_score
        
        return dp[0][n - 1]"
"class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:  # Time: O(n) and Space: O(1)

        # Find Middle: find middle and divide the list in to two
        slow, fast = head, head.next  # head(slow) -> 1 -> 2(fast) -> ...
        while fast and fast.next:     # while fast exists and there is next element to travel keep moving
            slow = slow.next          # fast moving twice as much as slow, will lead slow to point in the middle 
            fast = fast.next.next     # Even(4): slow = 2, fast = 4 &amp, Odd(5): slow = 3, fast = None 

        # Reverse: reverse the second list
        second = slow.next       # in Odd case lets say 1-> 2(slow) -> 3 -> 4(fast): second = 3(2.next) 
        prev = slow.next = None  # Created Two separate nodes 1->2 &amp, 3->4 
        while second:
            tmp = second.next   # tmp = 4
            second.next = prev  # 3 -> None
            prev = second       # prev = 3
            second = tmp        # second = 4
        # So, in the next iteration 
            # tmp = None 
            # 4.next = prev(3) and our linked is reversed
			# prev = 4 
			# second = None

        # Merge: merge the first with the reversed second  
        first, second = head, prev  # first will point to starting of the 1st Node and second to 2nd Node
        while second:
            tmp1, tmp2 = first.next, second.next  # tmp1 = 2, tmp2 = 3
            first.next = second                   # 1 -> 4
            second.next = tmp1                    # 4.next = 2 i.e. 1 -> 4 -> 2 
            first, second = tmp1, tmp2            # first = 2, second = 3
        # So, in the next iteration 
            # tmp1 = tmp2 = None
            # 2 -> 3 i.e. 1 -> 4 -> 2 -> 3
            # 1 -> 4 -> 2 -> 3 -> None
			# first = second = None";"class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        if not head or not head.next:
            return

        # 1. Find the middle of the list
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        # 2. Reverse the second half of the list
        second_half_head = slow.next
        slow.next = None  # Split the list into two halves
        prev = None
        current = second_half_head
        while current:
            next_node = current.next
            current.next = prev
            prev = current
            current = next_node
        
        # 'prev' is now the head of the reversed second half

        # 3. Merge the two halves
        first_half_head = head
        second_half_head = prev
        while second_half_head:
            temp1, temp2 = first_half_head.next, second_half_head.next
            first_half_head.next = second_half_head
            second_half_head.next = temp1
            first_half_head, second_half_head = temp1, temp2"
"class Solution:
    def countPrimes(self, n: int) -> int:
        # Prerequisite:
        # What is prime number. What are they just the starting. 
        
        truth = [True]*n # making a list of lenght n. And keep all the values as True.
        if n<2: # as 0 &amp, 1 are not prime numbers. 
            return 0
        truth[0], truth[1] = False, False #as we added True in the truth list. So will make false for ) &amp, 1 as they are not prime numbers.
        
        i=2 # As we know 0 &amp, 1 are not prime.
        while i*i<n: # why we are doing it as i*i here is bcz lets say 5*2 = 10 is divisble by 2 as well as 5 so if 10 is already removed why to traverse a value which is already travered once. so in case of n=5 - 5<5. CONCLUSION : i<sqrt(n)
#why we are running the loop till n is bcz question says "" prime numbers that are strictly less than n"".
            if truth[i] == True:
                for j in range(i*i,n,i): # if we have mutiple of a number in the range of n, we have to remove them as they can be prime. i.e 2 is prime, but its multiple in n = 10 are 4,6,8 they cant be prime. So we will make them false(means not a prime).
                    truth[j]=False
            i += 1 # increasing our iterator.
        return truth.count(True) # will count true value";"class Solution:
    def countPrimes(self, n: int) -> int:
        if n <= 2:
            return 0
        is_prime = [True] * n
        is_prime[0] = is_prime[1] = False
        for i in range(2, int(n**0.5) + 1):
            if is_prime[i]:
                for multiple in range(i * i, n, i):
                    is_prime[multiple] = False
        return sum(is_prime)"
"class Solution:
    def isPowerOfTwo(self, x: int) -> bool:
        
        # TC = O(1), SC = O(1)
        
        # a power of 2 has only kth bit set in its binary representation 
        # and ( power of 2 ) - 1 -> has all bits set except the kth bit
        # so taking bitwise of these two numbers would always give 0
        
        return (x!=0) and (x &amp, (x-1)) == 0
		
		# Example 1:
        # if x = 0 ans = False 
        # if x = 1 ans = True and 1 &amp, 0 == 0 -> True so True and True = True
        #   00000
        # &amp, 00001
        # ---------
        #   00000
        # ---------
		
		# Example 2:
		# if x = 16 , then x - 1 = 15, so x &amp, x-1 == 0 will check:
		# 16 =     10000       
		# 15 =  &amp,  01111
		# --------------------
		#          00000
		# --------------------";"class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (n & (n - 1) == 0)"
"class Solution:
    def reverseBits(self, n: int) -> int:
        
    # Short Version
        out = str(bin(n))[::-1][:-2]
        while len(out) < 32:
            out += '0'
        return int(out, 2)
    
    # Long, step-by-step version
    # First, let's see the binary of the original number
        #print(bin(n))
        
    # Then, let's turn the number into binary, and a string and save it to a variable
        #out = str(bin(n))
        #print(out)
        
    # Next, this is fancy python for: iterate through the list from end to start in increments of -1 (backwards)
    # returning each element. This effectively reverses the string from the step above.
        #out = out[::-1]
        #print(out)

    # Now, since we turned the binary representation into a string, we have a ""0b"" at the end (since we reversed order)
    # We can remove it with python indexing [:-2]
        #out = out[:-2]
    
    # The input binary may have had leading zeros that would have been truncated
    #   i.e. 000101 -> 101
    # When reversed, those zeros are important
    #   101000 =/= 101 
    # Since we know the input number is always 32 bits, we can just add trailing zeros until we reach a length of 32
        #while len(out) < 32:
        #    out += '0'
        #print(out)
    
    # Finally, we can convert back to base-10 and return!
        #out = int(out, 2)
        #return out";"class Solution:
    def reverseBits(self, n: int) -> int:
        res = 0
        for _ in range(32):
            res = (res << 1) | (n & 1)
            n >>= 1
        return res"
"class Solution:
    def readBinaryWatch(self, turnedOn: int) -> List[str]:
        ans = set()
        m_so_far = 0
        h_so_far = 0
        #hashmap tells the possible hr and min values we can recurse on!
        hashmap = {}
        hashmap[""hr""] = [1, 2, 4, 8]
        hashmap[""min""] = [1, 2, 4, 8, 16, 32]
        
        #Paramters:
        #1. LEDS -> tell number of LEDS turned on so far!
        #2. hr_set -> set of all hour values that are already used and not available!
        #3. min_set -> similar idea as hr_set!
        def helper(LEDS, hr_set, min_set):
            nonlocal m_so_far, h_so_far, ans, turnedOn, hashmap
            #check if m_so_far or h_so_far is out of range -> invalid time!
            if(m_so_far > 59 or h_so_far > 11):
                return
            
            #base case: LEDS == input: number of turnedOn!
            #we used all LEDs and current time is valid! So we need to record it!
            if(LEDS == turnedOn):
                m_string = """"
                #if minute is single digit, we need a leading zero!
                if(0<= m_so_far <= 9):
                    m_string = m_string + ""0"" + str(m_so_far)
                else:
                    m_string = str(m_so_far)
                #no leading zero for hour!
                res = str(h_so_far) + "":"" + m_string
                ans.add(res)
                return
            
            #otherwise, we can recurse over all 4 hour values nad 6 minutes values and
            #use them only if they are not already in set! 
            for hour in hashmap[""hr""]:
                if(hour in hr_set):
                    continue
                hr_set.add(hour)
                #update the hour count and add to set before recursing!
                h_so_far += hour
                
                helper(LEDS + 1, hr_set, min_set)
                #once rec. call returns, update the count of hours as well as state of hr!
                h_so_far -= hour
                hr_set.remove(hour)
            
            for minute in hashmap[""min""]:
                if(minute in min_set):
                    continue
                
                min_set.add(minute)
                m_so_far += minute
                
                helper(LEDS + 1, hr_set, min_set)
                m_so_far -= minute
                min_set.remove(minute)
        
        helper(0, set(), set())
        return list(ans)";"from typing import List

class Solution:
    def readBinaryWatch(self, turnedOn: int) -> List[str]:
        return [f""{h}:{m:02d}"" for h in range(12) for m in range(60) if bin(h).count('1') + bin(m).count('1') == turnedOn]"
"class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        swaps, i = 0, 0
        while swaps < len(nums): # we only make the necessary amount of swaps for each entry
            start, num = i, nums[i] # start index and current number to swap
            while True:
                temp = nums[(i+k) % len(nums)] # save the value at the final location of the current value
                nums[(i+k) % len(nums)] = num # store current value at final location
                num = temp # value at final location will now be placed at its final location next iteration
                swaps += 1 # update number of swaps
                i = (i+k) % len(nums) # update index
                if start == i: break # if we have swapped all entries in the group then break
            i += 1 # if we have to loop again, when len(nums) % k == 0, then we move to the next index";"import collections

class Solution:
    def rotate(self, nums: list[int], k: int) -> None:
        n = len(nums)
        if n == 0:
            return
        
        k %= n
        if k == 0:
            return

        # In-place reversal algorithm with O(1) extra space.
        def reverse(l: int, r: int) -> None:
            while l < r:
                nums[l], nums[r] = nums[r], nums[l]
                l += 1
                r -= 1
        
        reverse(0, n - 1)
        reverse(0, k - 1)
        reverse(k, n - 1)"
"class Solution:
    def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:
        if not p1 != p2 != p3 != p4: return False            # 4 points have to be different
        dis = lambda x, y: (y[1]-x[1])**2 + (y[0]-x[0])**2   # lambda function to calc distance**2
        points = [p1, p2, p3, p4]
        d = collections.defaultdict(list)
        for i in range(4):                                   # calculate distance between each points to other 3
            for j in range(i+1, 4):
                distance = dis(points[i], points[j])
                d[tuple(points[i])].append(distance)
                d[tuple(points[j])].append(distance)
        for point, distances in d.items():                   # check neighbour edges equality &amp, Pythagoras theorem
            distances.sort()
            if not (distances[0] == distances[1] and sum(distances[:2]) == distances[2]): return False
        return True";"import collections

class Solution:
    def validSquare(self, p1: list[int], p2: list[int], p3: list[int], p4: list[int]) -> bool:
        
        def dist_sq(a, b):
            return (a[0] - b[0])**2 + (a[1] - b[1])**2

        dists = sorted([
            dist_sq(p1, p2),
            dist_sq(p1, p3),
            dist_sq(p1, p4),
            dist_sq(p2, p3),
            dist_sq(p2, p4),
            dist_sq(p3, p4)
        ])

        return (dists[0] > 0 and
                dists[0] == dists[1] and
                dists[0] == dists[2] and
                dists[0] == dists[3] and
                dists[4] == dists[5] and
                dists[4] == 2 * dists[0])"
"class Solution:
    def minJumps(self, arr: List[int]) -> int:
        
        n = len(arr)
        visited = set()
        
        
        if n <= 1:
            return 0
        
        same_value = dict()
        
        for i, v in enumerate(arr):
            if v not in same_value.keys():
                same_value[v]= [i]
            else:
                same_value[v].append(i)
                
        stack = list()
        level = 0
        
        stack.append((0,0))
        total = -1
        
        
        while stack:
            level,node = stack.pop(0)
        
            visited.add(node)
            
            if node == n-1:
                return level
            else:
                for a in same_value[arr[node]] :
                    if a != node and a not in visited:
                        stack.append((level+1,a))
                
                same_value[arr[node]].clear()
                
                if node+1 < n and node+1 not in visited:
                    stack.append((level+1,node+1))
                 
                if node-1 >=0 and node-1 not in visited:
                    stack.append((level+1,node-1))
                    

                                 
        return level";"import collections

class Solution:
    def minJumps(self, arr: list[int]) -> int:
        n = len(arr)
        if n <= 1:
            return 0

        graph = collections.defaultdict(list)
        for i, num in enumerate(arr):
            graph[num].append(i)

        queue = collections.deque([(0, 0)])  # (index, steps)
        visited = {0}

        while queue:
            idx, steps = queue.popleft()

            if idx == n - 1:
                return steps

            # Jump to neighbors with the same value
            for neighbor in graph[arr[idx]]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append((neighbor, steps + 1))
            
            graph[arr[idx]].clear()

            # Jump to i + 1
            next_idx = idx + 1
            if next_idx < n and next_idx not in visited:
                visited.add(next_idx)
                queue.append((next_idx, steps + 1))

            # Jump to i - 1
            prev_idx = idx - 1
            if prev_idx >= 0 and prev_idx not in visited:
                visited.add(prev_idx)
                queue.append((prev_idx, steps + 1))
        
        return -1"
"class Solution:
    def findWords(self, words: List[str]) -> List[str]:
        l=[""qwertyuiop"",""asdfghjkl"",""zxcvbnm""] #This list contains alphabets which are in one row of keyboard , total three rows, hence three strings
        l1=[]
		'''
		i.)We now check if all the letter in word is present in a row or not
        ii.)For instance: ""Hello""---> 'H' is in second row, hence y will be incremented by 1 and 'e' is in first row , so x will be incremented by 1
		iii.)At the end , x=2, y=z and z=0 , with none of them equal to length of word, hence we dont append it to the result
		'''
		for word in words:
            x,y,z=0,0,0
            for letter in word.lower():                        
                if letter not in l[1] and letter not in l[2]:  
				    x+=1                                                       
                elif letter not in l[0] and letter not in l[2]: # To accout for casing of words, we have used word.lower()
                    y+=1
                elif letter not in l[0] and letter not in l[1]:
                    z+=1
            if x==len(word) or y==len(word) or z==len(word):
                l1.append(word)
        return l1";"class Solution:
    def findWords(self, words: list[str]) -> list[str]:
        row1 = set(""qwertyuiop"")
        row2 = set(""asdfghjkl"")
        row3 = set(""zxcvbnm"")
        
        result = []
        for word in words:
            word_lower_set = set(word.lower())
            if word_lower_set.issubset(row1) or \
               word_lower_set.issubset(row2) or \
               word_lower_set.issubset(row3):
                result.append(word)
        return result"
"class Solution {
    public int[] findErrorNums(int[] nums) {
        var st = new HashSet<Integer>(),
        int dup = Arrays.stream(nums).boxed().filter(i -> !st.add(i)).toList().get(0), n = nums.length, s = (n * (n + 1)) / 2, ts = Arrays.stream(nums).sum(),
        return new int[]{dup, s - (ts - dup)},
    }
}




python :

class Solution:
    def findErrorNums(self, nums: list[int]) -> list[int]:
        n, a, b = len(nums), sum(nums), sum(set(nums))
        s = n*(n+1)//2
        return [a-b, s-b]



C++:

vector<int> findErrorNums(vector<int>&amp, nums) {
    //sum of elements on nums
    int initialSum = accumulate(nums.begin(), nums.end(), 0),

    //put the element of nums into set to remove the duplicate number
    set<int> s,
    for(auto &amp,i: nums){
        s.insert(i),
    }

    //sum of elements of the set
    int sum = accumulate(s.begin(), s.end(), 0),

    //difference of initialSum and sum will give us the repeated number
    int repeatedNum = initialSum - sum,

    //sum of all the natural numbers from 1 to n
    int n = nums.size() + 1,

    //subtracting the sum of elements in set i.e. sum from the sum of the natural numbers will give us the missing number
    int missingNum = n * (n-1)/2 - sum,

    return {repeatedNum, missingNum},
}";"class Solution:
    def findErrorNums(self, nums: list[int]) -> list[int]:
        n = len(nums)
        expected_sum = n * (n + 1) // 2
        actual_sum = sum(nums)
        set_sum = sum(set(nums))
        
        duplicate = actual_sum - set_sum
        missing = expected_sum - set_sum
        
        return [duplicate, missing]"
"class Solution:
    def divisorGame(self, n: int) -> bool:
        #here, the state will have single parameter: current number on chalkboard!
        #Depending on current number on chalkboard, the player to make the first move
        #can either win or lose!
        
        #I will take bottom-up approach and use a dp table filling it from the most
        #trivial base case of n=1 up to original n!
        #size n+1 for indices from 0 to n, where we don't use index 0!
        dp = [None] * (n+1)
        #player who plays when 1 on board loses!
        dp[1] = False
        
        #iterate through state's parameters in inc. order to fill our dp table!
        for i in range(2, n+1, 1):
            #iterate through each and every number btw 1 and i//2 
            #we know that any number greater than i//2  can never be a factor of i!
            can_win = False
            for a in range(1, (i//2) + 1, 1):
                if(i % a == 0):
                    #if player playing at i-a number on board will lose, then
                    #current player that played first when i was on board can win
                    #since he will choose the most optimal path for him!
                    if(dp[i - a] == False):
                        can_win = True
                        break
            #once we tried all possible numbers btw 0 and i that are factors of i,
            #we check boolean flag!
            if(can_win):
                dp[i] = True
            else:
                dp[i] = False
        #since dp[n] equals True if Alice starts first and can win or False otherewise!
        return dp[n]";"class Solution:
    def divisorGame(self, n: int) -> bool:
        return n % 2 == 0"
"class Solution:
    # O(n) time,
    # O(n) space,
    # Approach: greedy, hashset
    def predictPartyVictory(self, senate: str) -> str:
        n = len(senate)
        count = Counter(senate)
        
        skip_r = 0
        skip_d = 0
        removed_r = set()
        removed_d = set()
        while count['D'] > 0 and count['R'] > 0:
            for i in range(n):
                s = senate[i]
                if s == 'R':
                    if skip_r <= 0 and i not in removed_r:
                        count['D'] -=1
                        skip_d +=1
                    else:
                        if i not in removed_r:
                            skip_r -=1
                            removed_r.add(i)
                else:
                    if skip_d <= 0 and i not in removed_d:
                        count['R'] -=1
                        skip_r +=1
                    else:
                        if i not in removed_d:
                            skip_d -=1
                            removed_d.add(i)
                        
        if count['D'] > 0:
            return 'Dire'
        else:
            return 'Radiant'";"import collections

class Solution:
    def predictPartyVictory(self, senate: str) -> str:
        n = len(senate)
        radiant_q = collections.deque()
        dire_q = collections.deque()

        for i, s in enumerate(senate):
            if s == 'R':
                radiant_q.append(i)
            else:
                dire_q.append(i)

        while radiant_q and dire_q:
            r_idx = radiant_q.popleft()
            d_idx = dire_q.popleft()

            if r_idx < d_idx:
                radiant_q.append(r_idx + n)
            else:
                dire_q.append(d_idx + n)

        return ""Radiant"" if radiant_q else ""Dire"""
"class Solution:
    def calculateMinimumHP(self, li: List[List[int]]) -> int:
        """"""
        Bottom Up Approach (Faster than 97% Submissions)
        Array:
            -2  -3  3
            -5 -10  1
            10  30 -5
        Working:
                      2
                      5  
               0   0  6
               
                    4+1  2
               6+0  11   5
               0.    0   6
        
               3+4    5      2
                6     11     5
                0     0      6
              
              7  5  2
              6 11  5
              0  0. 6
        """"""
        n,m = len(li), len(li[0])
        dp = [[None for i in range(m)] for i in range(n)]
        
        if li[-1][-1] >= 0:
            dp[-1][-1] = 0
        else:
            dp[-1][-1] = abs(li[-1][-1]) + 1
        
        #Populate last Column Values
        j = m-1
        for i in range(n-2,-1, -1):
            reqHealth = dp[i+1][j]
            if li[i][j] >= 0:
                cHealth = li[i][j]
                print(cHealth, reqHealth)
                if cHealth >= reqHealth:
                    dp[i][j] = 0
                else:
                    dp[i][j] = reqHealth - cHealth
            else:
                mandatoryHealthToSurvive = abs(li[i][j])+1
                cHealth = 1
                if cHealth >= reqHealth:
                    dp[i][j] = mandatoryHealthToSurvive
                else:
                    dp[i][j] = mandatoryHealthToSurvive + reqHealth - cHealth
        
        #Populate last Row Value
        i = n-1
        for j in range(m-2,-1,-1):
            reqHealth = dp[i][j+1]
            if li[i][j] >= 0:
                cHealth = li[i][j]
                if cHealth >= reqHealth:
                    dp[i][j] = 0
                else:
                    dp[i][j] = reqHealth - cHealth
            else:
                mandatoryHealthToSurvive = abs(li[i][j])+1
                cHealth = 1
                if cHealth >= reqHealth:
                    dp[i][j] = mandatoryHealthToSurvive
                else:
                    dp[i][j] = mandatoryHealthToSurvive + reqHealth - cHealth
          
        #Dp
        for i in range(n-2, -1, -1):
            for j in range(m-2, -1, -1):
                reqHealth = min(dp[i+1][j], dp[i][j+1])
                if li[i][j] >= 0:
                    cHealth = li[i][j]
                    if cHealth >= reqHealth:
                        dp[i][j] = 0
                    else:
                        dp[i][j] = reqHealth - cHealth
                else:
                    mandatoryHealthToSurvive = abs(li[i][j])+1
                    cHealth = 1
                    if cHealth >= reqHealth:
                        dp[i][j] = mandatoryHealthToSurvive
                    else:
                        dp[i][j] = mandatoryHealthToSurvive + reqHealth - cHealth
        for i in dp:
            print(i)
        return max(1, dp[0][0])";"import math

class Solution:
    def calculateMinimumHP(self, dungeon: list[list[int]]) -> int:
        m, n = len(dungeon), len(dungeon[0])
        dp = [[math.inf] * (n + 1) for _ in range(m + 1)]
        dp[m][n - 1] = 1
        dp[m - 1][n] = 1

        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                needed = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]
                dp[i][j] = max(1, needed)

        return dp[0][0]"
"class Solution:
    def removeBoxes(self, boxes: List[int]) -> int:

        @cache
        def dp(l, r, count = 0):
            if l > r: return 0
            // Initial count for the letter at boxes[l]
            count += 1
            ptr = l + 1
            while ptr <= r and boxes[l] == boxes[ptr]:
                ptr += 1
                count += 1
            points = (count ** 2) + dp(ptr, r)
            for i in range(ptr + 1, r + 1):
                if boxes[l] == boxes[i]:
                    points = max(points, dp(i, r, count) + dp(ptr, i - 1))
            return points

        return dp(0, len(boxes) - 1)";"from functools import lru_cache

class Solution:
  def removeBoxes(self, boxes: list[int]) -> int:
    if not boxes:
        return 0

    groups = []
    i = 0
    while i < len(boxes):
        j = i
        while j + 1 < len(boxes) and boxes[j + 1] == boxes[i]:
            j += 1
        groups.append((boxes[i], j - i + 1))
        i = j + 1
    
    colors = [g[0] for g in groups]
    counts = [g[1] for g in groups]
    m = len(groups)

    @lru_cache(None)
    def dp(l, r, k):
        if l > r:
            return 0
        
        current_count = counts[l] + k
        res = current_count**2 + dp(l + 1, r, 0)
        
        for p in range(l + 1, r + 1):
            if colors[p] == colors[l]:
                res = max(res, dp(l + 1, p - 1, 0) + dp(p, r, k + counts[l]))
        
        return res

    return dp(0, m - 1, 0)"
"class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n-1, -1, -1):
            for j in range(i, n):
                if(i == j):
                    dp[i][j] = nums[i]
                else:
                    dp[i][j] = nums[i] + self.getMax(dp, i+1,j, min(i+k, n-1, j))
        
        return dp[0][-1]
    
    def getMax(self, dp, startIndex, j, endIndex):
        x = -float(""inf"")
        for index in range(startIndex, endIndex+1):
            x = max(x, dp[index][j])
        return x";"import collections

class Solution:
    def maxResult(self, nums: list[int], k: int) -> int:
        n = len(nums)
        deq = collections.deque([0])
        for i in range(1, n):
            if deq[0] < i - k:
                deq.popleft()
            nums[i] += nums[deq[0]]
            while deq and nums[deq[-1]] <= nums[i]:
                deq.pop()
            deq.append(i)
        return nums[-1]"
"class Solution(object):
    def pathSum(self, root, targetSum):
        """"""
        :type root: TreeNode
        :type targetSum: int
        :rtype: int
        """"""
        self.targetSum=targetSum
        self.hashmap={0:1}
        self.prefix=0
        self.result=0
        
        self.helper(root)
        
        return self.result
    def helper(self, root):
        
        if root is None:
            return
        
        self.prefix+=root.val
        if self.prefix-self.targetSum in self.hashmap:
            self.result+=self.hashmap[self.prefix-self.targetSum]
        
        if self.prefix in self.hashmap:
            self.hashmap[self.prefix]+=1
        else:
            self.hashmap[self.prefix]=1
            
        self.helper(root.left)
        self.helper(root.right)
        
        self.hashmap[self.prefix]-=1
        self.prefix-=root.val";"class Solution:
    def pathSum(self, root, targetSum: int) -> int:
        count = 0
        prefix_sum_map = {0: 1}

        def dfs(node, current_sum):
            nonlocal count
            if not node:
                return

            current_sum += node.val
            
            # Check if (current_sum - targetSum) exists in the prefix_sum_map
            count += prefix_sum_map.get(current_sum - targetSum, 0)
            
            # Add current_sum to the map
            prefix_sum_map[current_sum] = prefix_sum_map.get(current_sum, 0) + 1
            
            # Recurse for children
            dfs(node.left, current_sum)
            dfs(node.right, current_sum)
            
            # Backtrack: remove current_sum from the map when moving up
            prefix_sum_map[current_sum] -= 1

        dfs(root, 0)
        return count"
"class Solution:
    def maximumSwap(self, num: int) -> int:
        # larger digit to swap, digit position of this digit
        high_digit = high_pos = 0
        
        # smaller digit to swap, digit position of this digit
        low_digit = low_pos = 0
        
        # greatest digit seen so far, digit postion of this digit
        cur_high_digit, cur_high_pos = -1, 0
        
        # current digit position
        pos = 1
        
        res = num
        while num: # iterate through digits from right to left
            digit = num % 10
            
            # if digit is greatest digit yet
            if digit > cur_high_digit:
                cur_high_digit, cur_high_pos = digit, pos
            
            # if digit is less than greatest digit yet
            elif digit < cur_high_digit:
                # set the digits to swap as the greatest digit yet, and this digit
                high_digit, high_pos = cur_high_digit, cur_high_pos
                low_digit, low_pos = digit, pos
            
            pos *= 10
            num //= 10
        
        # swap the digits
        res += high_digit*(low_pos - high_pos) + low_digit*(high_pos - low_pos)
        return res";"def maximum_swap(num: int) -> int:
    s = list(str(num))
    n = len(s)
    last_indices = {s[i]: i for i in range(n)}
    
    for i in range(n):
        for d in range(9, int(s[i]), -1):
            digit_char = str(d)
            if digit_char in last_indices and last_indices[digit_char] > i:
                j = last_indices[digit_char]
                s[i], s[j] = s[j], s[i]
                return int("""".join(s))
    
    return num"
"class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:

        @cache
        def dp(x1, y1, x2):
            y2 = x1+y1-x2

            if not(0 <= x1 < len(grid) and 0 <= y1 < len(grid[0]) and 0 <= x2 < len(grid) and 0 <= y2 < len(grid[0])):
                return -float('inf')

            if grid[x1][y1] == -1 or grid [x2][y2] == -1 :
                return -float('inf')

            if x1 == len(grid)-1 and x2 == len(grid)-1 and y1 == len(grid[0])-1 and y1 == len(grid[0])-1 :
                if grid[x1][y1] == 1 :
                    return 1 
                else :
                    return 0 

            if x1 == x2 and y1 == y2 :
                if grid[x1][y1] == 1 :
                    return 1+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                else:
                    return max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
            else :
                if grid[x1][y1] == 1 and grid[x2][y2] == 1:
                    return 2+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                elif grid[x1][y1] == 1:
                    return 1+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                elif grid[x2][y2] == 1:
                    return 1+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                else:
                    return max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
        
        if dp(0,0,0) == -float('inf'):
            return 0
        else :
            return dp(0,0,0)";"import collections

class Solution:
    def cherryPickup(self, grid: list[list[int]]) -> int:
        n = len(grid)
        dp = [[-1] * n for _ in range(n)]
        dp[0][0] = grid[0][0]

        for k in range(1, 2 * n - 1):
            new_dp = [[-1] * n for _ in range(n)]
            for r1 in range(n):
                for r2 in range(n):
                    c1 = k - r1
                    c2 = k - r2

                    if not (0 <= c1 < n and 0 <= c2 < n and
                            grid[r1][c1] != -1 and grid[r2][c2] != -1):
                        continue

                    cherries = grid[r1][c1]
                    if r1 != r2:
                        cherries += grid[r2][c2]

                    prev_max = -1
                    if dp[r1][r2] != -1:
                        prev_max = max(prev_max, dp[r1][r2])
                    if r1 > 0 and dp[r1 - 1][r2] != -1:
                        prev_max = max(prev_max, dp[r1 - 1][r2])
                    if r2 > 0 and dp[r1][r2 - 1] != -1:
                        prev_max = max(prev_max, dp[r1][r2 - 1])
                    if r1 > 0 and r2 > 0 and dp[r1 - 1][r2 - 1] != -1:
                        prev_max = max(prev_max, dp[r1 - 1][r2 - 1])
                    
                    if prev_max != -1:
                        new_dp[r1][r2] = cherries + prev_max
            
            dp = new_dp
        
        return max(0, dp[n - 1][n - 1])"
"class Solution:
    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:
        if s[-1] == ""1"": # If last one equal to ""1"", then just return False.
            return False
        if minJump <= len(s)-1 <= maxJump: # If the first jump can reach the end point, then return True.
            return True
        # Initialize th max index of s, the current and previous start point, end point.
        Len, start, end, pre_start, pre_end = len(s), minJump, maxJump, -1, -1
        
        while True:
            if pre_start == start and pre_end == end: # If we can't go any further(we'll never reach the last index), return False.
                return False
            pre_start, pre_end = start, end # Update previous values.
            # Search next round ""0""s
            for i in range(pre_start, pre_end+1):
                # If s[i] equals ""0"", then we can jump
                # and make sure that at least one ""0"" in the range if we jump from index i.
                if s[i] == ""0"" and ""0"" in s[i + minJump:i + maxJump + 1]:
                    if start <= pre_end: # Update start point to a minimum value that greater than previous end point.
                        start = i + minJump
                    end = i + maxJump # Update end point to the maximum of this round.
                    if start <= Len-1 <= end: # If the start and end points contain the last index, return True.
                        return True";"import collections

class Solution:
    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:
        n = len(s)
        if s[-1] == '1':
            return False
        
        dp = [False] * n
        dp[0] = True
        pre = 0
        
        for i in range(1, n):
            if i >= minJump:
                pre += 1 if dp[i - minJump] else 0
            if i > maxJump:
                pre -= 1 if dp[i - maxJump - 1] else 0
            
            if pre > 0 and s[i] == '0':
                dp[i] = True
        
        return dp[n-1]"
"class Solution:
    def stoneGameVI(self, alice: List[int], bob: List[int]) -> int:
        n = len(alice)
        arr = [alice[i] + bob[i] for i in range(n)]
        s = sum(bob)
        res = 0
        k = (n+1)//2
        arr.sort(reverse=True)
        for i in range(0, n, 2):
            res += arr[i]
        
        
        if res > s:
            return 1
        elif res == s:
            return 0 
        else:
            return -1";"class Solution:
    def stoneGameVI(self, aliceValues: list[int], bobValues: list[int]) -> int:
        stones = sorted(zip(aliceValues, bobValues), key=sum, reverse=True)
        
        alice_score = sum(s[0] for s in stones[::2])
        bob_score = sum(s[1] for s in stones[1::2])
        
        if alice_score > bob_score:
            return 1
        elif bob_score > alice_score:
            return -1
        else:
            return 0"
"class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        
        # Sorting method
        # Time: O(nlogn) Space: O(1)
        
        # Here, we'll simply sort the list and then check if the next element == current element
        # if yes, then we'll continue
        # else we'll return the element
        
        if len(nums) == 1:
            return nums[0]
        nums.sort()
        for i in range(1,len(nums),2):
            if nums[i] != nums[i-1]:
                return nums[i-1]
        return nums[len(nums)-1]
    
    
        # Using Dictionary
        # Time: O(n) Space:O(n)
        
        # Here, we'll simply traverse through the list and 
        # insert the element and it's count as (key,value) pair
        # then we'll start iterating through the dictionary 
        # and if we find any element having count 1
        # we'll return the element
        
        res = {}
        for el in nums:
            if el in res:
                res[el] += 1
            else:
                res[el] = 1
        for key in res.keys():
            if res[key] == 1:
                return key
        
        
        # XOR method
        # Time: O(n) Space: O(1)
        
        # If you know how XOR operation works then it's pretty straight forward for you.
        
        for i in range(1,len(nums)):
            nums[0] ^= nums[i]
        return nums[0]";"import operator
from functools import reduce

class Solution:
    def singleNumber(self, nums: list[int]) -> int:
        return reduce(operator.xor, nums)"
"class Solution:
    #n = len(arr)
    #Time-Complexity: O(n), in worst case we visit each and every index position and finds out
    #there's no indices with integer 0 !
    #Space-Complexity: O(n + n), by same argument as T.C! -> O(n)
    def canReach(self, arr: List[int], start: int) -> bool:
        #We can model this as a general directed graph problem!
        #If we are at node i(at position index i), we can either
        #jump to two descendants: arr[i] + i or arr[i] - i!
        
        #We will only add to queue index positions not already visited
        #and in-bounds!
        visited = set()
        q = collections.deque()
        q.append(start)
        visited.add(start)
        #as long as queue is not empty, keep bfs going!
        while q:
            cur_index = q.popleft()
            #check if at current index has value 0! If so, immediately
            #break and return True
            if(arr[cur_index] == 0):
                return True
            #otherwise, process the two descendants and only add to queue
            #if it's not already visited and is in-bounds!
            neighbor1 = arr[cur_index] + cur_index
            neighbor2 = cur_index - arr[cur_index]
            if(neighbor1 not in visited and 0<=neighbor1 < len(arr)):
                q.append(neighbor1)
                visited.add(neighbor1)
            if(neighbor2 not in visited and 0<=neighbor2 < len(arr)):
                q.append(neighbor2)
                visited.add(neighbor2)
        
        #once bfs is over, we tried every possible path from start!
        #could not reach index position with value of 0!
        return False";"import collections

class Solution:
    def canReach(self, arr: list[int], start: int) -> bool:
        n = len(arr)
        q = collections.deque([start])
        visited = {start}

        while q:
            curr = q.popleft()

            if arr[curr] == 0:
                return True

            # Jump forward
            forward_jump = curr + arr[curr]
            if forward_jump < n and forward_jump not in visited:
                visited.add(forward_jump)
                q.append(forward_jump)

            # Jump backward
            backward_jump = curr - arr[curr]
            if backward_jump >= 0 and backward_jump not in visited:
                visited.add(backward_jump)
                q.append(backward_jump)

        return False"
"# Binary Search Tree Solution -> If exact matching of intervals found then return False
#                                Else you can add this interval to that particular node's left or right
class Node:
    def __init__(self, s, e):
        self.s = s
        self.e = e
        self.left = None
        self.right = None
class MyCalendar:
    def __init__(self):
        self.head = None
        
    def insert(self, s, e, node):
        if s >= node.e:
            if node.right: return self.insert(s, e, node.right)
            else: 
                nn = Node(s, e)
                node.right = nn
                return True
        elif e <= node.s:
            if node.left: return self.insert(s, e, node.left)
            else:
                nn = Node(s, e)
                node.left = nn
                return True
        else: return False
        
    def book(self, s: int, e: int) -> bool:
        if self.head == None:
            nn = Node(s, e)
            self.head = nn
            return True
        return self.insert(s, e, self.head)";"import bisect

class MyCalendar:

    def __init__(self):
        self.calendar = []

    def book(self, start: int, end: int) -> bool:
        if not self.calendar:
            self.calendar.append((start, end))
            return True

        # Find insertion point
        idx = bisect.bisect_right(self.calendar, (start, end))
        
        # Check for overlap with the previous event
        if idx > 0 and self.calendar[idx - 1][1] > start:
            return False
        
        # Check for overlap with the next event
        if idx < len(self.calendar) and self.calendar[idx][0] < end:
            return False
            
        self.calendar.insert(idx, (start, end))
        return True"
"class Solution:
    def reformatDate(self, date: str) -> str:
        
        month_dict = {
            'Jan':'01', 'Feb':'02', 'Mar':'03', 'Apr':'04', 'May':'05', 'Jun':'06',
            'Jul':'07', 'Aug':'08', 'Sep':'09', 'Oct':'10', 'Nov':'11', 'Dec':'12',
        }
        
        date_list = date.split()
        
        #defining empty string
        date_string = ''
        
        #year
        date_string = date_string + date_list[2] + '-' 
        
        #month
        date_string = date_string + month_dict[date_list[1]] + '-'
        
        #day
        date_day = [x for x in date_list[0] if not x.isalpha()]
        date_day_digits = ''.join(date_day)
        if len(date_day_digits) == 1:
            date_string = date_string+'0'+date_day_digits
        else:
            date_string = date_string+date_day_digits
        
        
        return date_string
        # date_String = date_string + date_list[]";"import collections

class Solution:
  def reformatDate(self, date: str) -> str:
    months = {
        ""Jan"": ""01"", ""Feb"": ""02"", ""Mar"": ""03"", ""Apr"": ""04"", 
        ""May"": ""05"", ""Jun"": ""06"", ""Jul"": ""07"", ""Aug"": ""08"", 
        ""Sep"": ""09"", ""Oct"": ""10"", ""Nov"": ""11"", ""Dec"": ""12""
    }
    parts = date.split()
    
    day = f""{int(parts[0][:-2]):02d}""
    month = months[parts[1]]
    year = parts[2]
    
    return f""{year}-{month}-{day}"""
"class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        trie=Trie()
        out=[]
        words=sentence.split("" "")
        for word in dictionary:
            trie.insert(word)
        for word in words:
            out.append(trie.transfer(word))
        return "" "".join(out)
        

class TrieNode(object):
        def __init__(self):
            self.children = {}
            self.isWord = False
class Trie:

    def __init__(self):
        self.root = TrieNode()
    def insert(self, word: str) -> None:
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.isWord = True
    def transfer(self, successor: str) -> bool:
        node = self.root
        out=""""
        for char in successor:
            if node.isWord:
                return out
            if char not in node.children:
                return successor
            out+=char
            node = node.children[char]
        return successor";"class Solution:
    def replaceWords(self, dictionary: list[str], sentence: str) -> str:
        root_set = set(dictionary)

        def find_root(word):
            for i in range(1, len(word) + 1):
                prefix = word[:i]
                if prefix in root_set:
                    return prefix
            return word

        return "" "".join(map(find_root, sentence.split("" "")))"
"class Solution:
    def containVirus(self, mat: List[List[int]]) -> int:
        m,n = len(mat),len(mat[0])

        def dfs(i,j,visited,nextInfected):  # return no. of walls require to quarantined dfs area
            if 0<=i<m and 0<=j<n and (i,j) not in visited:
                if mat[i][j]==2: # Already quarantined cell
                    return 0
                if mat[i][j]==0:
                    nextInfected.add((i,j)) # add cell which will be infected next day
                    return 1   # require one wall to quarantined cell from one side
                    
                else:
                    visited.add((i,j))
                    return dfs(i-1,j,visited,nextInfected) + dfs(i+1,j,visited,nextInfected) + dfs(i,j-1,visited,nextInfected) + dfs(i,j+1,visited,nextInfected)  # traverse all four direction
            else:
                return 0
				
        ans = 0 
        while True:   # this loop running ""how many days we should installing the walls"" times
            # For every day check which area infect more cells
            visited = set()  # Using in dfs
            All_nextinfect  = set()
            stop , walls = set(),0   # here stop store the indices of maximum no. of cells in which we stop spreading of virus this day
            
            for i in range(m):
                for j in range(n):
                    if mat[i][j]==1 and (i,j) not in visited:
                        nextInfected = set()
                        a = dfs(i,j,visited,nextInfected)
                        
                        if len(stop)<len(nextInfected):
                            All_nextinfect  = All_nextinfect | stop # leave previous saved area from virus
                            stop = nextInfected  # pick new area which we want to save
                            walls = a  # require walls
                            p,q = i,j  # starting position(indices) of this area
                        else:
                            All_nextinfect  = All_nextinfect | nextInfected   
                            
            if not stop : # if our job is done i.e. No cell will be infect Later
                break
            ans += walls  # add new walls installed this day
            
            # change each cell value to 2 which will be covered by quarantined area
            def fun(p,q):
                if 0<=p<m and 0<=q<n and mat[p][q]==1:
                    mat[p][q]=2
                    fun(p+1,q)
                    fun(p-1,q)
                    fun(p,q-1)
                    fun(p,q+1)
            fun(p,q) # start dfs from start point of quarantined area
            
            for a,b in All_nextinfect: # set new infected cell value = 1 for iterating next day
                mat[a][b] = 1

        return ans   # Final answer";"import collections

class Solution:
    def containVirus(self, isInfected: list[list[int]]) -> int:
        rows, cols = len(isInfected), len(isInfected[0])
        total_walls = 0

        while True:
            regions = []
            visited = set()

            for r in range(rows):
                for c in range(cols):
                    if isInfected[r][c] == 1 and (r, c) not in visited:
                        region_cells = set()
                        frontiers = set()
                        walls_needed = 0
                        q = collections.deque([(r, c)])
                        visited.add((r, c))
                        region_cells.add((r, c))

                        while q:
                            curr_r, curr_c = q.popleft()
                            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                                nr, nc = curr_r + dr, curr_c + dc
                                if 0 <= nr < rows and 0 <= nc < cols:
                                    if isInfected[nr][nc] == 1 and (nr, nc) not in visited:
                                        visited.add((nr, nc))
                                        q.append((nr, nc))
                                        region_cells.add((nr, nc))
                                    elif isInfected[nr][nc] == 0:
                                        frontiers.add((nr, nc))
                                        walls_needed += 1
                        
                        if frontiers:
                            regions.append((len(frontiers), walls_needed, region_cells, frontiers))

            if not regions:
                break
            
            regions.sort(key=lambda x: x[0], reverse=True)
            
            region_to_quarantine = regions.pop(0)
            
            _, walls_to_build, cells_to_contain, _ = region_to_quarantine
            total_walls += walls_to_build
            
            for r_cell, c_cell in cells_to_contain:
                isInfected[r_cell][c_cell] = -1

            for _, _, _, frontiers_to_infect in regions:
                for r_frontier, c_frontier in frontiers_to_infect:
                    isInfected[r_frontier][c_frontier] = 1

        return total_walls"
"class Solution:
    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:
        #Let len(richer) = n and let len(quiet) = m!
        #Time: O(n + m + m + m*m + m +  m) -> O(m^2 + n)
        #Space: O(m*m + m + m + m*m + m) -> O(m^2)
        #step 1: build adjacency list representation and update indegrees of every node initially!
        adj = [[] for _ in range(len(quiet))]
        indegrees = [0] * len(quiet)
        #we want edges to go from richer to poorer so that ancestors of every node are all people
        #who have more money than the node person!
        for rel in richer:
            richer, poorer = rel[0], rel[1]
            adj[richer].append(poorer)
            indegrees[poorer] += 1
        
        queue = deque()
        ancestors = []
        for i in range(len(quiet)):
            new = set()
            new.add(i)
            ancestors.append(new)
        #step 2: fill in the queue all nodes that have indegrees of 0!

        #step 3: proceeding with Kahn's algorithm and recording list of all ancestors to every node!
        while queue:
            cur = queue.pop()
            for neighbor in adj[cur]:
                ancestors[neighbor].add(cur)
                ancestors[neighbor].update(ancestors[cur])
                indegrees[neighbor] -= 1
                if(indegrees[neighbor] == 0):
                    queue.append(neighbor)
        
        ancestors = [list(s) for s in ancestors]
        output = []
        #step 4:for each person, find the least quiet person who also has more money than the current               #person we're iterating on!
        for a in range(len(ancestors)):
            cur_ancestors = ancestors[a]
            if(len(cur_ancestors) == 1):
                output.append(a)
                continue
            minimum = cur_ancestors[0]
            for ancestor in cur_ancestors:
                #check if current person with more money than person a has lower quiet level!
                if(quiet[ancestor] < quiet[minimum]):
                    minimum = ancestor
            output.append(minimum)
        return output";"import collections

class Solution:
    def loudAndRich(self, richer: list[list[int]], quiet: list[int]) -> list[int]:
        n = len(quiet)
        adj = [[] for _ in range(n)]
        for u, v in richer:
            adj[v].append(u)

        answer = [None] * n

        def dfs(node):
            if answer[node] is None:
                answer[node] = node
                for neighbor in adj[node]:
                    candidate = dfs(neighbor)
                    if quiet[candidate] < quiet[answer[node]]:
                        answer[node] = candidate
            return answer[node]

        return [dfs(i) for i in range(n)]"
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        
        # Using the ITERATIVE APPROACH with O(logn)
        
        '''
        Step-by-step Binary Search Algorithm: We basically ignore half of the elements just after one comparison.

        1. Compare x with the middle element.
        2. If x matches with the middle element, we return the mid index.
        3. Else If x is greater than the mid element, then x can only lie in the right half subarray after the mid element. So we recur for the right half.
        4. Else (x is smaller) recur for the left half.    
        
        '''
        
        # Two containers
        low_value  = 0              # Index of first element    
        high_value = len(nums) - 1  # Index of last element
        
        while low_value <= high_value:                  # check if the �high_value� is higher than the �low_value�
            middle_value = (low_value + high_value)//2  # middle index of our list which will be the floor of the average of �high_value� plus �low_value�
            
            if nums[middle_value] == target:    # check if the middle element and the target are equal 
                return middle_value             # If they are equal, the position of the item will be returned
            
            if target < nums[middle_value]:     # check if the middle element is less than the item to be searched
                
                high_value = middle_value - 1   # the new position will shift to the right once.
                
            else:                               # check if the value of the last index is greater than or equal to the value of the first index
                                                
                low_value = middle_value + 1    #  the new position will shift to the left once
                     
        return -1  # If the target is not in the list, it will return a statement";"class Solution:
    def search(self, nums: list[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        
        while left <= right:
            mid = left + (right - left) // 2
            
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
                
        return -1"
"class Solution:
    def stoneGameVII(self, stones: List[int]) -> int:
        dp = [[0 for _ in range(len(stones))] for _ in range(len(stones))]     # dp table n x n
        run_sum = [0]                            # running sum -> sum [i..j] = run_sum[j] - run_sum[i]
        s = 0
        
		## Calculation of running sum
        for i in stones:
            s += i
            run_sum.append(s)
		
        n = len(stones) 
        
        for k in range(1, n):               # no. of stones left
            for i in range(0, n - k):   # from each starting point
                remove_i_stone = (run_sum[i+k+1] - run_sum[i+1])    # score after removing i th stone
                remove_j_stone = (run_sum[i+k] - run_sum[i])             # score after removing j th stone
                
                if (n-(k+1))%2 == 0:        # alice's move 
                    dp[i][i+k] = max(remove_i_stone + dp[i+1][i+k],
                                    remove_j_stone + dp[i][i+k-1])
                else:                       # bob's move
                    dp[i][i+k] = min(-remove_i_stone + dp[i+1][i+k],
                                    - remove_j_stone + dp[i][i+k-1])
                    
        return dp[0][n - 1]";"class Solution:
    def stoneGameVII(self, stones: list[int]) -> int:
        n = len(stones)
        prefix_sum = [0] * (n + 1)
        for i in range(n):
            prefix_sum[i + 1] = prefix_sum[i] + stones[i]

        def get_sum(i, j):
            return prefix_sum[j + 1] - prefix_sum[i]

        dp = [[0] * n for _ in range(n)]

        for length in range(2, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                
                if (n - length) % 2 == 0:  # Alice's turn
                    take_left = get_sum(i + 1, j) + dp[i + 1][j]
                    take_right = get_sum(i, j - 1) + dp[i][j - 1]
                    dp[i][j] = max(take_left, take_right)
                else:  # Bob's turn
                    take_left = -get_sum(i + 1, j) + dp[i + 1][j]
                    take_right = -get_sum(i, j - 1) + dp[i][j - 1]
                    dp[i][j] = min(take_left, take_right)
                    
        return dp[0][n - 1]"
"# Linked List Solution
class MyHashSet(object):
    
    def __init__(self):
        self.keyRange = 769
        self.bucketArray = [LinkedList() for i in range(self.keyRange)]
        
    def _hash(self, key):
        return key % self.keyRange
    
    def add(self, key):
        bucketIndex = self._hash(key)
        self.bucketArray[bucketIndex].append(key)
        
    def remove(self, key):
        bucketIndex = self._hash(key)
        self.bucketArray[bucketIndex].deleteNodeKeyAll(key)
        # while self.bucketArray[bucketIndex].search(key):
        #     self.bucketArray[bucketIndex].deleteNodeKeyOne(key)
        
    def contains(self, key):
        bucketIndex = self._hash(key)
        return self.bucketArray[bucketIndex].search(key)
    
# ---------------------------------------------------------
## Define a linked list

class Node:
    
    def __init__(self, val, next = None):
        self.val = val
        self.next = next
        
class LinkedList:
    
    def __init__(self):
        self.head = None

# ---------------------------------------------------------
## Insert a new node

### Insert the new node at the front of the linked list
    def push(self, new_val):
        new_node = Node(new_val)
        new_node.next = self.head
        self.head = new_node
        
### Insert the new node at the end of the linked list
    def append(self, new_val):
        new_node = Node(new_val)
        if self.head is None:
            self.head = new_node
            return
        # Traverse till the end of the linked list
        last = self.head
        while last.next:
            last = last.next
        last.next = new_node

### Insert the new node after a given node
    def insertAfter(self, new_val, prev_node):
        if prev_node is None:
            print(""Please enter the node which is the previous node of the inserted node."")
            return
        new_node = Node(new_val)
        new_node.next = prev_node.next
        prev_node.next = new_node
        
# ---------------------------------------------------------
## Delete a node

### Delete a node by value
# Iterative Method
    def deleteNodeKeyOne(self, key): # delete a single node
        temp = self.head
        if temp is None:
            return
        if temp.val == key:
            self.head = temp.next
            temp = None
            return
        while temp is not None:
            if temp.val == key:
                break
            prev = temp
            temp = temp.next
        if temp is None:
            return
        prev.next = temp.next
        temp = None
        
    def deleteNodeKeyAll(self, key): # delete all the nodes with value key
        temp = self.head
        if temp is None:
            return
        while temp.val == key:
            deletedNode = temp
            self.head = temp.next
            temp = self.head
            deletedNode = None
            if temp is None:
                return
        nxt = temp.next
        while nxt is not None:
            if nxt.val == key:
                deletedNode = nxt
                temp.next = nxt.next
                deletedNode = None
            temp = nxt
            nxt = nxt.next

### Delete a node by position and return the value of the deleted node
    def deleteNodePosition(self, position):
        if self.head is None:
            return
        if position == 0:
            temp = self.head
            self.head = self.head.next
            temp = None
            return
        idx = 0
        current = self.head
        prev = self.head
        nxt = self.head
        while current is not None:
            if idx == position:
                nxt = current.next
                break
            prev = current
            current = current.next
            idx += 1
        prev.next = nxt
        current = None
        
# ---------------------------------------------------------
# Print a linked list
    def printList(self):
        temp = self.head
        while temp:
            print ("" %d"" %(temp.val))
            temp = temp.next

# ---------------------------------------------------------
## Search an element in a linked list
    def search(self, x):
        current = self.head
        while current is not None:
            if current.val == x:
                return True
            current = current.next
        return False";"class MyHashSet:
    def __init__(self):
        self.key_range = 769
        self.bucket_array = [[] for _ in range(self.key_range)]

    def _hash(self, key):
        return key % self.key_range

    def add(self, key: int) -> None:
        bucket_index = self._hash(key)
        bucket = self.bucket_array[bucket_index]
        if key not in bucket:
            bucket.append(key)

    def remove(self, key: int) -> None:
        bucket_index = self._hash(key)
        bucket = self.bucket_array[bucket_index]
        if key in bucket:
            bucket.remove(key)

    def contains(self, key: int) -> bool:
        bucket_index = self._hash(key)
        return key in self.bucket_array[bucket_index]"
"class Solution:
    def reachNumber(self, target: int) -> int:
        def gaussSum(n):
            return n*(n+1)//2
        
        def binaryFind(lower, upper):
            t = abs(target)
            sums, n = -1, -1
            while lower <= upper:
                mid = (lower+upper)//2
                if gaussSum(mid) >= t:
                    sums, n = gaussSum(mid), mid
                    upper = mid-1
                else:
                    lower = mid+1
            return sums, n
        
                    
        lower, upper = 0, 10**5
        # find min n s.t. 1+2+...+n>=abs(target)
        sums, n = binaryFind(lower, upper)
        while sums%2 != abs(target)%2:
            sums += n+1
            n += 1
        return n";"class Solution:
    def reachNumber(self, target: int) -> int:
        target = abs(target)
        k = 0
        current_sum = 0
        while current_sum < target:
            k += 1
            current_sum += k
    
        while (current_sum - target) % 2 != 0:
            k += 1
            current_sum += k
            
        return k"
"class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        sortedList = sorted(nums)
        n = len(nums)
        if n%2==0:
            small = sortedList[:((n//2))][::-1]
            large = (sortedList[(n//2):])[::-1]
            for i in range(1,n,2):
                nums[i] = large[i//2]
            for i in range(0,n,2):
                nums[i] = small[i//2]
        else:
            small = sortedList[:1+((n//2))][::-1]
            large = (sortedList[1+(n//2):])[::-1]
            for i in range(1,n,2):
                nums[i] = large[i//2]
            for i in range(0,n,2):
                nums[i] = small[i//2]";"class Solution:
    def wiggleSort(self, nums: list[int]) -> None:
        n = len(nums)
        s_nums = sorted(nums)
        mid = (n + 1) // 2
        small_half = s_nums[:mid]
        large_half = s_nums[mid:]
        nums[0::2] = small_half[::-1]
        nums[1::2] = large_half[::-1]"
"class Solution:
    def rotatedDigits(self, N: int) -> int:
        smallSet = {0,1,8}
        bigSet = {2,5,6,9}
        smallNum = [0,0,1,1,1,2,3,3,3,4][N % 10]
        bigNum = [1,2,3,3,3,4,5,5,6,7][N % 10]
        N = N // 10
        smInc, bgInc = 4, 7
        while N:
            x = N % 10
            N = N // 10
            sm, bg = 0, 0
            for i in range(x):
                if i in smallSet:
                    sm += smInc
                    bg += bgInc
                elif i in bigSet:
                    sm += bgInc
                    bg += bgInc
            if x in smallSet:
                smallNum += sm
                bigNum += bg
            elif x in bigSet:
                smallNum = bigNum + sm
                bigNum += bg
            else:
                smallNum = sm
                bigNum = bg
            smInc, bgInc = 4*bgInc + 3*smInc, bgInc * 7
        return smallNum";"class Solution:
    def rotatedDigits(self, n: int) -> int:
        count = 0
        for i in range(1, n + 1):
            s = str(i)
            if any(d in '347' for d in s):
                continue
            if any(d in '2569' for d in s):
                count += 1
        return count"
"class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:

		""Edge Case checking""
        
        if endWord not in wordList:
            return []
        
        size = len(beginWord)
        
        
        ""create llokup got all the possible wordpatters""
        
        lookup = defaultdict(list)                                  
        
        for word in wordList:                                     
            for i in range(size):
                lookup[word[:i] + ""*"" + word[i+1:]].append(word)    
        
        cur_len = 9999
        
        ans = []      
        
        ""enter the first element in the queue""
        
        queue =  collections.deque([[beginWord, 1,[beginWord]]])
        
        visited = {beginWord: True}
        
        while(queue):
            
            currWord, pathLength,words_till_now = queue.popleft()
            
            """"""
            instead of marking an elemnt vistied , when we insert it in the queue,
            we mark it as visited only when we pop and element
            this way , same word can be used by other curWords
            <ex :>
            ""red""
            ""tax""
            [""ted"",""tex"",""red"",""tax"",""tad"",""den"",""rex"",""pee""]                        
            and we make sure that element can not be used again           
            """"""
            visited[currWord] = True
            
            """"""
            run a for loop for all values for all the possible patterns for the popped word
            """"""
            
            for i in range(size):
                
                possibleWordPattern = currWord[:i] + ""*"" + currWord[i+1:]
                
                for word in lookup[possibleWordPattern]:            
                    
                    if(currWord == word):
                        continue
                    
                    """"""
                    if the word for the possibleWordPattern key matches with the end word we add it to the 
                    ans list
                    """"""
                        
                    if(word == endWord):                                                    
                        
                        if cur_len == pathLength + 1:
                                                    
                            ans.append(words_till_now+[word])
                        elif cur_len > pathLength + 1:
                            
                            ans = [words_till_now+[word]]
                            
                            cur_len = pathLength + 1
                    
                    if(word not in visited):                        
                        queue.append([word, pathLength + 1,words_till_now+[word]])
        
        return ans";"import collections

class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:
        wordSet = set(wordList)
        if endWord not in wordSet:
            return []
        
        level = {beginWord}
        parents = collections.defaultdict(list)

        while level:
            wordSet -= level
            next_level = collections.defaultdict(list)
            for word in level:
                for i in range(len(word)):
                    p1, p2 = word[:i], word[i+1:]
                    for c in 'abcdefghijklmnopqrstuvwxyz':
                        next_word = p1 + c + p2
                        if next_word in wordSet:
                            next_level[next_word].append(word)
            
            parents.update(next_level)
            
            if endWord in next_level:
                res = []
                path = [endWord]
                def dfs(word):
                    if word == beginWord:
                        res.append(path[::-1])
                        return
                    
                    for p in parents[word]:
                        path.append(p)
                        dfs(p)
                        path.pop()
                
                dfs(endWord)
                return res
            
            if not next_level:
                break
            
            level = next_level

        return []"
"class Solution:
    def numDecodings(self, s: str) -> int:
        non_zero = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
        first_incl, second_incl = 1, 0
        first_excl, second_excl = 0, 0
        
        if s[0] in non_zero:
            second_incl = 1
        if s[0] == '*':
            second_incl = 9
            
        for i in range(1, len(s)):
            new_incl, new_excl = 0, 0
            if s[i] == '*':
                new_incl = 9 * (second_incl + second_excl)
                
                if s[i-1] == '1':
                    # number is of type (1, *)
                    new_excl = 9 * (first_incl + first_excl)
                    
                elif s[i-1] == '2':
                    # number is of type (2, *)
                    new_excl = 6 * (first_incl + first_excl)
                    
                elif s[i-1] == '*':
                    # number is of type (*, *)
                    new_excl = 15 * (first_incl + first_excl)
            else:
                if s[i] in non_zero:
                    new_incl = second_incl + second_excl
                        
                if s[i-1] == '*':
                    # number is of type (*,digit)
                    if int(s[i]) <= 6:
                        new_excl = 2 * (first_excl + first_incl)
                    else:
                        new_excl = first_incl + first_excl
                        
                else:
                    # number is of type (digit,digit)
                    val = int(s[i-1:i+1])
                    if 10 <= val <= 26:
                        new_excl = first_incl + first_excl
                    else:
                        new_excl = 0
            first_incl, first_excl = second_incl, second_excl
            second_incl, second_excl = new_incl, new_excl
        return (second_incl + second_excl) % (10**9 + 7)";"class Solution:
    def numDecodings(self, s: str) -> int:
        if s[0] == '0':
            return 0
        
        MOD = 10**9 + 7
        n = len(s)
        
        prev2 = 1
        prev1 = 9 if s[0] == '*' else 1
        
        for i in range(1, n):
            current = 0
            
            if s[i] == '*':
                current = (9 * prev1) % MOD
            elif s[i] > '0':
                current = prev1
            
            if s[i-1] == '1':
                if s[i] == '*':
                    current = (current + 9 * prev2) % MOD
                else:
                    current = (current + prev2) % MOD
            elif s[i-1] == '2':
                if s[i] == '*':
                    current = (current + 6 * prev2) % MOD
                elif s[i] <= '6':
                    current = (current + prev2) % MOD
            elif s[i-1] == '*':
                if s[i] == '*':
                    current = (current + 15 * prev2) % MOD
                elif s[i] <= '6':
                    current = (current + 2 * prev2) % MOD
                else:
                    current = (current + prev2) % MOD
            
            prev2 = prev1
            prev1 = current
            
        return prev1"
"class Solution:
    def isThree(self, n):
        
        answers =  [4, 9, 25, 49, 121, 169, 289, 361, 529, 841, 961, 1369, 1681, 1849, 2209, 2809, 3481, 3721, 4489, 5041, 5329, 6241, 6889, 7921, 9409]
        
        while True:
            size = len(answers)
            if size == 1:
                return answers[0] == n
            elif size == 0:
                return False
            mp = size // 2
            
            if answers[mp] == n:
                return True
            elif answers[mp] > n:
                answers = answers[:mp]
            else:
                answers = answers[mp + 1:]";"import math

class Solution:
    def isThree(self, n: int) -> bool:
        if n < 4:
            return False
        
        s = int(math.sqrt(n))
        
        if s * s != n:
            return False
        
        for i in range(2, int(math.sqrt(s)) + 1):
            if s % i == 0:
                return False
                
        return True"
"class Solution:
    def nthUglyNumber(self, n: int) -> int:
        lst=[1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45, 48, 50, 54, 60, 64, 72, 75, 80, 81, 90, 96, 100, 108, 120, 125, 128, 135, 144, 150, 160, 162, 180, 192, 200, 216, 225, 240, 243, 250, 256, 270, 288, 300, 320, 324, 360, 375, 384, 400, 405, 432, 450, 480, 486, 500, 512, 540, 576, 600, 625, 640, 648, 675, 720, 729, 750, 768, 800, 810, 864, 900, 960, 972, 1000, 1024, 1080, 1125, 1152, 1200, 1215, 1250, 1280, 1296, 1350, 1440, 1458, 1500, 1536, 1600, 1620, 1728, 1800, 1875, 1920, 1944, 2000, 2025, 2048, 2160, 2187, 2250, 2304, 2400, 2430, 2500, 2560, 2592, 2700, 2880, 2916, 3000, 3072, 3125, 3200, 3240, 3375, 3456, 3600, 3645, 3750, 3840, 3888, 4000, 4050, 4096, 4320, 4374, 4500, 4608, 4800, 4860, 5000, 5120, 5184, 5400, 5625, 5760, 5832, 6000, 6075, 6144, 6250, 6400, 6480, 6561, 6750, 6912, 7200, 7290, 7500, 7680, 7776, 8000, 8100, 8192, 8640, 8748, 9000, 9216, 9375, 9600, 9720, 10000, 10125, 10240, 10368, 10800, 10935, 11250, 11520, 11664, 12000, 12150, 12288, 12500, 12800, 12960, 13122, 13500, 13824, 14400, 14580, 15000, 15360, 15552, 15625, 16000, 16200, 16384, 16875, 17280, 17496, 18000, 18225, 18432, 18750, 19200, 19440, 19683, 20000, 20250, 20480, 20736, 21600, 21870, 22500, 23040, 23328, 24000, 24300, 24576, 25000, 25600, 25920, 26244, 27000, 27648, 28125, 28800, 29160, 30000, 30375, 30720, 31104, 31250, 32000, 32400, 32768, 32805, 33750, 34560, 34992, 36000, 36450, 36864, 37500, 38400, 38880, 39366, 40000, 40500, 40960, 41472, 43200, 43740, 45000, 46080, 46656, 46875, 48000, 48600, 49152, 50000, 50625, 51200, 51840, 52488, 54000, 54675, 55296, 56250, 57600, 58320, 59049, 60000, 60750, 61440, 62208, 62500, 64000, 64800, 65536, 65610, 67500, 69120, 69984, 72000, 72900, 73728, 75000, 76800, 77760, 78125, 78732, 80000, 81000, 81920, 82944, 84375, 86400, 87480, 90000, 91125, 92160, 93312, 93750, 96000, 97200, 98304, 98415, 100000, 101250, 102400, 103680, 104976, 108000, 109350, 110592, 112500, 115200, 116640, 118098, 120000, 121500, 122880, 124416, 125000, 128000, 129600, 131072, 131220, 135000, 138240, 139968, 140625, 144000, 145800, 147456, 150000, 151875, 153600, 155520, 156250, 157464, 160000, 162000, 163840, 164025, 165888, 168750, 172800, 174960, 177147, 180000, 182250, 184320, 186624, 187500, 192000, 194400, 196608, 196830, 200000, 202500, 204800, 207360, 209952, 216000, 218700, 221184, 225000, 230400, 233280, 234375, 236196, 240000, 243000, 245760, 248832, 250000, 253125, 256000, 259200, 262144, 262440, 270000, 273375, 276480, 279936, 281250, 288000, 291600, 294912, 295245, 300000, 303750, 307200, 311040, 312500, 314928, 320000, 324000, 327680, 328050, 331776, 337500, 345600, 349920, 354294, 360000, 364500, 368640, 373248, 375000, 384000, 388800, 390625, 393216, 393660, 400000, 405000, 409600, 414720, 419904, 421875, 432000, 437400, 442368, 450000, 455625, 460800, 466560, 468750, 472392, 480000, 486000, 491520, 492075, 497664, 500000, 506250, 512000, 518400, 524288, 524880, 531441, 540000, 546750, 552960, 559872, 562500, 576000, 583200, 589824, 590490, 600000, 607500, 614400, 622080, 625000, 629856, 640000, 648000, 655360, 656100, 663552, 675000, 691200, 699840, 703125, 708588, 720000, 729000, 737280, 746496, 750000, 759375, 768000, 777600, 781250, 786432, 787320, 800000, 810000, 819200, 820125, 829440, 839808, 843750, 864000, 874800, 884736, 885735, 900000, 911250, 921600, 933120, 937500, 944784, 960000, 972000, 983040, 984150, 995328, 1000000, 1012500, 1024000, 1036800, 1048576, 1049760, 1062882, 1080000, 1093500, 1105920, 1119744, 1125000, 1152000, 1166400, 1171875, 1179648, 1180980, 1200000, 1215000, 1228800, 1244160, 1250000, 1259712, 1265625, 1280000, 1296000, 1310720, 1312200, 1327104, 1350000, 1366875, 1382400, 1399680, 1406250, 1417176, 1440000, 1458000, 1474560, 1476225, 1492992, 1500000, 1518750, 1536000, 1555200, 1562500, 1572864, 1574640, 1594323, 1600000, 1620000, 1638400, 1640250, 1658880, 1679616, 1687500, 1728000, 1749600, 1769472, 1771470, 1800000, 1822500, 1843200, 1866240, 1875000, 1889568, 1920000, 1944000, 1953125, 1966080, 1968300, 1990656, 2000000, 2025000, 2048000, 2073600, 2097152, 2099520, 2109375, 2125764, 2160000, 2187000, 2211840, 2239488, 2250000, 2278125, 2304000, 2332800, 2343750, 2359296, 2361960, 2400000, 2430000, 2457600, 2460375, 2488320, 2500000, 2519424, 2531250, 2560000, 2592000, 2621440, 2624400, 2654208, 2657205, 2700000, 2733750, 2764800, 2799360, 2812500, 2834352, 2880000, 2916000, 2949120, 2952450, 2985984, 3000000, 3037500, 3072000, 3110400, 3125000, 3145728, 3149280, 3188646, 3200000, 3240000, 3276800, 3280500, 3317760, 3359232, 3375000, 3456000, 3499200, 3515625, 3538944, 3542940, 3600000, 3645000, 3686400, 3732480, 3750000, 3779136, 3796875, 3840000, 3888000, 3906250, 3932160, 3936600, 3981312, 4000000, 4050000, 4096000, 4100625, 4147200, 4194304, 4199040, 4218750, 4251528, 4320000, 4374000, 4423680, 4428675, 4478976, 4500000, 4556250, 4608000, 4665600, 4687500, 4718592, 4723920, 4782969, 4800000, 4860000, 4915200, 4920750, 4976640, 5000000, 5038848, 5062500, 5120000, 5184000, 5242880, 5248800, 5308416, 5314410, 5400000, 5467500, 5529600, 5598720, 5625000, 5668704, 5760000, 5832000, 5859375, 5898240, 5904900, 5971968, 6000000, 6075000, 6144000, 6220800, 6250000, 6291456, 6298560, 6328125, 6377292, 6400000, 6480000, 6553600, 6561000, 6635520, 6718464, 6750000, 6834375, 6912000, 6998400, 7031250, 7077888, 7085880, 7200000, 7290000, 7372800, 7381125, 7464960, 7500000, 7558272, 7593750, 7680000, 7776000, 7812500, 7864320, 7873200, 7962624, 7971615, 8000000, 8100000, 8192000, 8201250, 8294400, 8388608, 8398080, 8437500, 8503056, 8640000, 8748000, 8847360, 8857350, 8957952, 9000000, 9112500, 9216000, 9331200, 9375000, 9437184, 9447840, 9565938, 9600000, 9720000, 9765625, 9830400, 9841500, 9953280, 10000000, 10077696, 10125000, 10240000, 10368000, 10485760, 10497600, 10546875, 10616832, 10628820, 10800000, 10935000, 11059200, 11197440, 11250000, 11337408, 11390625, 11520000, 11664000, 11718750, 11796480, 11809800, 11943936, 12000000, 12150000, 12288000, 12301875, 12441600, 12500000, 12582912, 12597120, 12656250, 12754584, 12800000, 12960000, 13107200, 13122000, 13271040, 13286025, 13436928, 13500000, 13668750, 13824000, 13996800, 14062500, 14155776, 14171760, 14348907, 14400000, 14580000, 14745600, 14762250, 14929920, 15000000, 15116544, 15187500, 15360000, 15552000, 15625000, 15728640, 15746400, 15925248, 15943230, 16000000, 16200000, 16384000, 16402500, 16588800, 16777216, 16796160, 16875000, 17006112, 17280000, 17496000, 17578125, 17694720, 17714700, 17915904, 18000000, 18225000, 18432000, 18662400, 18750000, 18874368, 18895680, 18984375, 19131876, 19200000, 19440000, 19531250, 19660800, 19683000, 19906560, 20000000, 20155392, 20250000, 20480000, 20503125, 20736000, 20971520, 20995200, 21093750, 21233664, 21257640, 21600000, 21870000, 22118400, 22143375, 22394880, 22500000, 22674816, 22781250, 23040000, 23328000, 23437500, 23592960, 23619600, 23887872, 23914845, 24000000, 24300000, 24576000, 24603750, 24883200, 25000000, 25165824, 25194240, 25312500, 25509168, 25600000, 25920000, 26214400, 26244000, 26542080, 26572050, 26873856, 27000000, 27337500, 27648000, 27993600, 28125000, 28311552, 28343520, 28697814, 28800000, 29160000, 29296875, 29491200, 29524500, 29859840, 30000000, 30233088, 30375000, 30720000, 31104000, 31250000, 31457280, 31492800, 31640625, 31850496, 31886460, 32000000, 32400000, 32768000, 32805000, 33177600, 33554432, 33592320, 33750000, 34012224, 34171875, 34560000, 34992000, 35156250, 35389440, 35429400, 35831808, 36000000, 36450000, 36864000, 36905625, 37324800, 37500000, 37748736, 37791360, 37968750, 38263752, 38400000, 38880000, 39062500, 39321600, 39366000, 39813120, 39858075, 40000000, 40310784, 40500000, 40960000, 41006250, 41472000, 41943040, 41990400, 42187500, 42467328, 42515280, 43046721, 43200000, 43740000, 44236800, 44286750, 44789760, 45000000, 45349632, 45562500, 46080000, 46656000, 46875000, 47185920, 47239200, 47775744, 47829690, 48000000, 48600000, 48828125, 49152000, 49207500, 49766400, 50000000, 50331648, 50388480, 50625000, 51018336, 51200000, 51840000, 52428800, 52488000, 52734375, 53084160, 53144100, 53747712, 54000000, 54675000, 55296000, 55987200, 56250000, 56623104, 56687040, 56953125, 57395628, 57600000, 58320000, 58593750, 58982400, 59049000, 59719680, 60000000, 60466176, 60750000, 61440000, 61509375, 62208000, 62500000, 62914560, 62985600, 63281250, 63700992, 63772920, 64000000, 64800000, 65536000, 65610000, 66355200, 66430125, 67108864, 67184640, 67500000, 68024448, 68343750, 69120000, 69984000, 70312500, 70778880, 70858800, 71663616, 71744535, 72000000, 72900000, 73728000, 73811250, 74649600, 75000000, 75497472, 75582720, 75937500, 76527504, 76800000, 77760000, 78125000, 78643200, 78732000, 79626240, 79716150, 80000000, 80621568, 81000000, 81920000, 82012500, 82944000, 83886080, 83980800, 84375000, 84934656, 85030560, 86093442, 86400000, 87480000, 87890625, 88473600, 88573500, 89579520, 90000000, 90699264, 91125000, 92160000, 93312000, 93750000, 94371840, 94478400, 94921875, 95551488, 95659380, 96000000, 97200000, 97656250, 98304000, 98415000, 99532800, 100000000, 100663296, 100776960, 101250000, 102036672, 102400000, 102515625, 103680000, 104857600, 104976000, 105468750, 106168320, 106288200, 107495424, 108000000, 109350000, 110592000, 110716875, 111974400, 112500000, 113246208, 113374080, 113906250, 114791256, 115200000, 116640000, 117187500, 117964800, 118098000, 119439360, 119574225, 120000000, 120932352, 121500000, 122880000, 123018750, 124416000, 125000000, 125829120, 125971200, 126562500, 127401984, 127545840, 128000000, 129140163, 129600000, 131072000, 131220000, 132710400, 132860250, 134217728, 134369280, 135000000, 136048896, 136687500, 138240000, 139968000, 140625000, 141557760, 141717600, 143327232, 143489070, 144000000, 145800000, 146484375, 147456000, 147622500, 149299200, 150000000, 150994944, 151165440, 151875000, 153055008, 153600000, 155520000, 156250000, 157286400, 157464000, 158203125, 159252480, 159432300, 160000000, 161243136, 162000000, 163840000, 164025000, 165888000, 167772160, 167961600, 168750000, 169869312, 170061120, 170859375, 172186884, 172800000, 174960000, 175781250, 176947200, 177147000, 179159040, 180000000, 181398528, 182250000, 184320000, 184528125, 186624000, 187500000, 188743680, 188956800, 189843750, 191102976, 191318760, 192000000, 194400000, 195312500, 196608000, 196830000, 199065600, 199290375, 200000000, 201326592, 201553920, 202500000, 204073344, 204800000, 205031250, 207360000, 209715200, 209952000, 210937500, 212336640, 212576400, 214990848, 215233605, 216000000, 218700000, 221184000, 221433750, 223948800, 225000000, 226492416, 226748160, 227812500, 229582512, 230400000, 233280000, 234375000, 235929600, 236196000, 238878720, 239148450, 240000000, 241864704, 243000000, 244140625, 245760000, 246037500, 248832000, 250000000, 251658240, 251942400, 253125000, 254803968, 255091680, 256000000, 258280326, 259200000, 262144000, 262440000, 263671875, 265420800, 265720500, 268435456, 268738560, 270000000, 272097792, 273375000, 276480000, 279936000, 281250000, 283115520, 283435200, 284765625, 286654464, 286978140, 288000000, 291600000, 292968750, 294912000, 295245000, 298598400, 300000000, 301989888, 302330880, 303750000, 306110016, 307200000, 307546875, 311040000, 312500000, 314572800, 314928000, 316406250, 318504960, 318864600, 320000000, 322486272, 324000000, 327680000, 328050000, 331776000, 332150625, 335544320, 335923200, 337500000, 339738624, 340122240, 341718750, 344373768, 345600000, 349920000, 351562500, 353894400, 354294000, 358318080, 358722675, 360000000, 362797056, 364500000, 368640000, 369056250, 373248000, 375000000, 377487360, 377913600, 379687500, 382205952, 382637520, 384000000, 387420489, 388800000, 390625000, 393216000, 393660000, 398131200, 398580750, 400000000, 402653184, 403107840, 405000000, 408146688, 409600000, 410062500, 414720000, 419430400, 419904000, 421875000, 424673280, 425152800, 429981696, 430467210, 432000000, 437400000, 439453125, 442368000, 442867500, 447897600, 450000000, 452984832, 453496320, 455625000, 459165024, 460800000, 466560000, 468750000, 471859200, 472392000, 474609375, 477757440, 478296900, 480000000, 483729408, 486000000, 488281250, 491520000, 492075000, 497664000, 500000000, 503316480, 503884800, 506250000, 509607936, 510183360, 512000000, 512578125, 516560652, 518400000, 524288000, 524880000, 527343750, 530841600, 531441000, 536870912, 537477120, 540000000, 544195584, 546750000, 552960000, 553584375, 559872000, 562500000, 566231040, 566870400, 569531250, 573308928, 573956280, 576000000, 583200000, 585937500, 589824000, 590490000, 597196800, 597871125, 600000000, 603979776, 604661760, 607500000, 612220032, 614400000, 615093750, 622080000, 625000000, 629145600, 629856000, 632812500, 637009920, 637729200, 640000000, 644972544, 645700815, 648000000, 655360000, 656100000, 663552000, 664301250, 671088640, 671846400, 675000000, 679477248, 680244480, 683437500, 688747536, 691200000, 699840000, 703125000, 707788800, 708588000, 716636160, 717445350, 720000000, 725594112, 729000000, 732421875, 737280000, 738112500, 746496000, 750000000, 754974720, 755827200, 759375000, 764411904, 765275040, 768000000, 774840978, 777600000, 781250000, 786432000, 787320000, 791015625, 796262400, 797161500, 800000000, 805306368, 806215680, 810000000, 816293376, 819200000, 820125000, 829440000, 838860800, 839808000, 843750000, 849346560, 850305600, 854296875, 859963392, 860934420, 864000000, 874800000, 878906250, 884736000, 885735000, 895795200, 900000000, 905969664, 906992640, 911250000, 918330048, 921600000, 922640625, 933120000, 937500000, 943718400, 944784000, 949218750, 955514880, 956593800, 960000000, 967458816, 972000000, 976562500, 983040000, 984150000, 995328000, 996451875, 1000000000, 1006632960, 1007769600, 1012500000, 1019215872, 1020366720, 1024000000, 1025156250, 1033121304, 1036800000, 1048576000, 1049760000, 1054687500, 1061683200, 1062882000, 1073741824, 1074954240, 1076168025, 1080000000, 1088391168, 1093500000, 1105920000, 1107168750, 1119744000, 1125000000, 1132462080, 1133740800, 1139062500, 1146617856, 1147912560, 1152000000, 1162261467, 1166400000, 1171875000, 1179648000, 1180980000, 1194393600, 1195742250, 1200000000, 1207959552, 1209323520, 1215000000, 1220703125, 1224440064, 1228800000, 1230187500, 1244160000, 1250000000, 1258291200, 1259712000, 1265625000, 1274019840, 1275458400, 1280000000, 1289945088, 1291401630, 1296000000, 1310720000, 1312200000, 1318359375, 1327104000, 1328602500, 1342177280, 1343692800, 1350000000, 1358954496, 1360488960, 1366875000, 1377495072, 1382400000, 1399680000, 1406250000, 1415577600, 1417176000, 1423828125, 1433272320, 1434890700, 1440000000, 1451188224, 1458000000, 1464843750, 1474560000, 1476225000, 1492992000, 1500000000, 1509949440, 1511654400, 1518750000, 1528823808, 1530550080, 1536000000, 1537734375, 1549681956, 1555200000, 1562500000, 1572864000, 1574640000, 1582031250, 1592524800, 1594323000, 1600000000, 1610612736, 1612431360, 1620000000, 1632586752, 1638400000, 1640250000, 1658880000, 1660753125, 1677721600, 1679616000, 1687500000, 1698693120, 1700611200, 1708593750, 1719926784, 1721868840, 1728000000, 1749600000, 1757812500, 1769472000, 1771470000, 1791590400, 1793613375, 1800000000, 1811939328, 1813985280, 1822500000, 1836660096, 1843200000, 1845281250, 1866240000, 1875000000, 1887436800, 1889568000, 1898437500, 1911029760, 1913187600, 1920000000, 1934917632, 1937102445, 1944000000, 1953125000, 1966080000, 1968300000, 1990656000, 1992903750, 2000000000, 2013265920, 2015539200, 2025000000, 2038431744, 2040733440, 2048000000, 2050312500, 2066242608, 2073600000, 2097152000, 2099520000, 2109375000, 2123366400]
        return lst[n-1]";"class Solution:
    def nthUglyNumber(self, n: int) -> int:
        ugly = [0] * n
        ugly[0] = 1
        p2 = p3 = p5 = 0

        for i in range(1, n):
            next_ugly_2 = ugly[p2] * 2
            next_ugly_3 = ugly[p3] * 3
            next_ugly_5 = ugly[p5] * 5

            ugly[i] = min(next_ugly_2, next_ugly_3, next_ugly_5)

            if ugly[i] == next_ugly_2:
                p2 += 1
            if ugly[i] == next_ugly_3:
                p3 += 1
            if ugly[i] == next_ugly_5:
                p5 += 1
        
        return ugly[-1]"
"class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        def isSameCase(l, r, word, isUpper):
            while l <= r:
                if word[l].isupper() != isUpper or word[r].isupper() != isUpper:
                    return False
                l += 1
                r -= 1
            return True
        
        if len(word) == 1: # Base Case
            return True
        
        if word[0].isupper() and word[1].isupper(): #Case 1 ""USA""
            return isSameCase(1, len(word) - 1, word, True)
        elif word[0].islower() and word[1].islower(): #Case 2 ""leetcode""
            return isSameCase(1, len(word) - 1, word, False)
        elif word[0].isupper() and word[1].islower(): # Case 3 ""Google""
            return isSameCase(1, len(word) - 1, word, False)
        else:
            return False";"class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        return word.isupper() or word.islower() or word.istitle()"
"class Solution:
    
    def reversePairs(self, arr: List[int]) -> int:
        count = 0
        if len(arr) > 1:
            mid = len(arr)//2
            L = arr[:mid]
            R = arr[mid:]
            count = self.reversePairs(L) 
            count += self.reversePairs(R)
            count += self.merge(L,R,arr)
        return count
    
    def merge(self,L,R,arr):
		#finding count for the condition
        count = 0
        i,j = 0,0
        while i < len(L):
            while j < len(R):
                if L[i] > 2*R[j]:
                    j += 1
                else:
                    break
            
            if j > 0:
                count += j
            i += 1

		#merging the sorted arrays
        i,j,k = 0,0,0        
        while i < len(L) and j < len(R):    
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1   
            else:
                arr[k] = R[j]
                j += 1
            k += 1

        while i < len(L):
            arr[k] = L[i]
            k += 1
            i += 1   
        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1
                
        return count";"import collections

class Solution:
    def reversePairs(self, nums: list[int]) -> int:
        
        def merge_sort_and_count(start: int, end: int) -> int:
            if start >= end:
                return 0

            mid = (start + end) // 2
            
            count = merge_sort_and_count(start, mid) + merge_sort_and_count(mid + 1, end)
            
            j = mid + 1
            for i in range(start, mid + 1):
                while j <= end and nums[i] > 2 * nums[j]:
                    j += 1
                count += j - (mid + 1)

            # Merge step
            temp = []
            l, r = start, mid + 1
            while l <= mid and r <= end:
                if nums[l] <= nums[r]:
                    temp.append(nums[l])
                    l += 1
                else:
                    temp.append(nums[r])
                    r += 1
            
            while l <= mid:
                temp.append(nums[l])
                l += 1
            
            while r <= end:
                temp.append(nums[r])
                r += 1
            
            for i in range(len(temp)):
                nums[start + i] = temp[i]
            
            return count

        if not nums:
            return 0
        return merge_sort_and_count(0, len(nums) - 1)"
"class Solution:
    def stoneGameIX(self, stones: List[int]) -> bool:
        stones = [v % 3 for v in stones]
        
        d = defaultdict(int)
        for v in stones:
            d[v] += 1
        
        while d[1] >= 2 and d[2] >= 2:
            d[2] -= 1
            d[1] -= 1
        
        if d[0] % 2 == 0: # number of 0s will not influent the result
            if (d[1] == 1 and d[2] >= 1) or (d[2] == 1 and d[1] >= 1):
                return True
        else:
            if (d[1] == 0 and d[2] >= 3) or (d[2] == 0 and d[1] >= 3):
                return True
            if (d[1] == 1 and d[2] >= 4) or (d[2] == 1 and d[1] >= 4):
                return True

        return False";"import sys

# It's necessary to increase the recursion limit for this problem.
sys.setrecursionlimit(200000)

from functools import lru_cache

class Solution:
    def stoneGameIX(self, stones: list[int]) -> bool:
        counts = [0, 0, 0]
        for stone in stones:
            counts[stone % 3] += 1
        
        c0, c1, c2 = counts[0], counts[1], counts[2]

        @lru_cache(None)
        def can_win(rem, n0, n1, n2):
            total_stones = n0 + n1 + n2
            if total_stones == 0:
                return False

            # Alice's turn, rem=0
            if rem == 0:
                win = False
                if n1 > 0 and not can_win(1, n0, n1 - 1, n2):
                    win = True
                if not win and n2 > 0 and not can_win(2, n0, n1, n2 - 1):
                    win = True
                return win
            
            # Bob's turn or subsequent Alice's turn
            # Player must not form a sum of 3
            # If rem is 1, cannot take stone_val=2
            # If rem is 2, cannot take stone_val=1
            
            # Try taking a stone of value 0
            win_by_0 = False
            if n0 > 0:
                if not can_win(rem, n0 - 1, n1, n2):
                    win_by_0 = True
            
            if win_by_0:
                return True

            # Try taking a stone of value 1
            win_by_1 = False
            if rem == 2 and n1 > 0:
                if not can_win((rem + 1) % 3, n0, n1 - 1, n2):
                    win_by_1 = True
            
            if win_by_1:
                return True

            # Try taking a stone of value 2
            win_by_2 = False
            if rem == 1 and n2 > 0:
                if not can_win((rem + 2) % 3, n0, n1, n2 - 1):
                    win_by_2 = True
            
            if win_by_2:
                return True
                
            return False

        # Simplified logic derived from the game theory
        if c1 == 0 and c2 == 0:
            return False
        
        if c0 % 2 == 0: # Alice can effectively ignore c0 stones
            if c1 > 0 and c2 > 0:
                return True
            else:
                return False
        else: # Alice is forced to 'use' one c0
            if abs(c1 - c2) > 2:
                return True
            else:
                return False"
"class Solution:
    def rotateString(self, s: str, goal: str) -> bool:
        if len(s) != len(goal):
            return False
        
        txt = s + s
        n, m = len(txt), len(goal) 

        lps = self.build_lps(goal)
       
        i, j = 0, 0

        while i < n:
            if txt[i] == goal[j] :
                i, j = i + 1, j + 1
                
                if j == m:
                    return True
            else: 
                if j == 0:
                   i += 1 
                else:
                    j = lps[j-1]
                    
                    
        return False

    
    def build_lps(self, pattern):
        lps = [0] * len(pattern) 
        prev_lps, i = 0, 1

        while i < len(pattern):
            if pattern[i] == pattern[prev_lps]:
                lps[i] = prev_lps + 1
                prev_lps, i = prev_lps + 1, i + 1
            else:
                if prev_lps == 0:
                    lps[i] = 0
                    i += 1
                else:
                    prev_lps = lps[prev_lps - 1]

        return lps";"class Solution:
    def rotateString(self, s: str, goal: str) -> bool:
        if len(s) != len(goal):
            return False
        if not s and not goal:
            return True
        s_concat = s + s
        return goal in s_concat"
"class Solution:
    def wordBreak(self, s: str, wordDict):
        output = []
        def backtracking(restString, candidate):
            # When the restString is empty, it means all substring/prefix of s are found in dictionary.
            # Add candidate to output answer.
            if restString == """":
                output.append(candidate)
                return
            
            # Process demonstration of the following for loop:
            # candidate = """"  <= 'cat'sanddog
            # candidate = ""cat""  <= 'sand'dog
            # candidate = ""cat sand""  <= dog
            # candidate = ""cat sand dog""  <= ''

            # candidate = """"  <= 'cats'anddog
            # candidate = ""cats""  <= 'and'dog
            # candidate = ""cats and""  <= dog
            # candidate = ""cats and dog""  <= ''

            # In the for loop range needs to add one, otherwise you will miss one char when you use restString[:i].
            # This for loop will keep checking if any prefix of restString was in dictionary.
            for i in range(len(restString)+1):
                if restString[:i] in wordDict:
                    # This if block can avoid the extra space in the from of candidate answer.
                    if candidate == """":
                        backtracking(restString[i:], restString[:i])
                    else:
                        backtracking(restString[i:], candidate+"" ""+restString[:i])
                    
        backtracking(s, """")
        return output

""""""
Input: s = ""catsanddog"", wordDict = [""cat"",""cats"",""and"",""sand"",""dog""]
Output: [""cats and dog"",""cat sand dog""]
""""""

if __name__ == ""__main__"":
    s = ""catsanddog"" 
    wordDict = [""cat"",""cats"",""and"",""sand"",""dog""]
    solution = Solution()
    print(f""s = {s}"")
    print(f""wordDict = {wordDict}"")
    print(f""wordBreak = {solution.wordBreak(s, wordDict)}"")";"import collections
from typing import List

class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        word_set = set(wordDict)
        memo = {}

        def _word_break_helper(sub: str) -> List[str]:
            if sub in memo:
                return memo[sub]

            if not sub:
                return [""""] 

            res = []
            for i in range(1, len(sub) + 1):
                prefix = sub[:i]
                if prefix in word_set:
                    suffix_results = _word_break_helper(sub[i:])
                    for suffix in suffix_results:
                        if suffix:
                            res.append(prefix + "" "" + suffix)
                        else:
                            res.append(prefix)
            
            memo[sub] = res
            return res

        return _word_break_helper(s)"
"class Solution:
    def bagOfTokensScore(self, tokens: List[int], power: int) -> int:
        # Establish score to return
        score = 0
        
        # Why use Collections.deque instead of the list 
        # as-is? One word - optimization! Deque has been 
        # written in such a way where popping items off
        # the front of the list using popleft occurs in O(1)
        # time, while running tokens.pop(0) runs in O(n) time.
        # Since we care a lot about runtime, deque's
        # the way to go here
        d = deque(sorted(tokens))
        while d:
            # Since we've sorted the list in ascending 
            # order, we don't need to compare the power to 
            # all values - if it's smaller than the smallest, 
            # it'll be smaller than everything
            if power < d[0]:
                # Pop the tail of the list (play token face-down)
                if score > 0 and len(d) > 1:
                    power += d.pop()
                    score -= 1
                # It's possible power will be smaller than 
                # all scores but either our score's too low
                # to play anything face-down OR there's only
                # one piece left, making the play redundnat.
                # In either of these cases, we're done
                else:
                    return score
            else:
                #Pop the head (play token face-up)
                power -= d.popleft()
                score += 1
        # Game over - time to return our score!
        return score";"import collections

class Solution:
    def bagOfTokensScore(self, tokens: list[int], power: int) -> int:
        tokens.sort()
        score = 0
        max_score = 0
        left, right = 0, len(tokens) - 1

        while left <= right:
            if power >= tokens[left]:
                power -= tokens[left]
                score += 1
                left += 1
                max_score = max(max_score, score)
            elif score > 0 and left < right:
                power += tokens[right]
                score -= 1
                right -= 1
            else:
                break
        
        return max_score"
"class Solution:
    def buddyStrings(self, s: str, goal: str) -> bool:
        n1=len(s)
        n2=len(goal)
        if n1!=n2: #if length is not equal we cannot make them the same with interchange
            return False
        d=defaultdict(list)
        mx =0 #max count of individual
        cnt=defaultdict(int)
        for i in range(n1):
            cnt[s[i]]+=1
            if cnt[s[i]]>mx:
                mx=cnt[s[i]] # maximum times acharacter occurs in s 
            
            d[i]=[s[i],goal[i]] #store value of both strings at an index
        count=0
        dif=[]
       
        for k in d:
            
            
            a=d[k][0] #letter at index k of s
            b=d[k][1] #letter at index k of s
            if a!=b:
                count+=1 
                dif.append(k)
            if count>2: # only one interchange is allowed 
                return False 
        
        if count==1:
            return False #one index at has unmatched value , can never be interchanged
        if count==0:
            if mx >=2: #s='aa' goal='aa'
                
                return True
            return False #s='ab' goal='ab'
        
        if d[dif[0]][0]==d[dif[1]][1] and d[dif[1]][0]==d[dif[0]][1]: #if 2 values are at wrong index check if there interchange would make the strings same 
            return True 
        return False";"class Solution:
    def buddyStrings(self, s: str, goal: str) -> bool:
        if len(s) != len(goal):
            return False

        if s == goal:
            return len(set(s)) < len(s)

        diffs = []
        for i in range(len(s)):
            if s[i] != goal[i]:
                diffs.append(i)

        if len(diffs) != 2:
            return False
        
        i, j = diffs[0], diffs[1]
        
        return s[i] == goal[j] and s[j] == goal[i]"
"class Solution:
    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:
        """"""LeetCode 835

        Not hard in terms of figuring out a method, but very complicated in
        implementation. First turn both images into bitmaps. Then brute force
        it by traversing all possible overlap states. At each state, compute
        the number of overlapped positions.

        The difficulty lies in accurately finding out the correct bitmap from
        both images at each overlapped state to perform the AND operation.

        O(N^4), 645 ms, faster than 81.87%
        """"""
        n = len(img1)
        bitmap1 = [sum(v << (n - i - 1) for i, v in enumerate(row)) for row in img1]
        bitmap2 = [sum(v << (n - i - 1) for i, v in enumerate(row)) for row in img2]
        res = 0
        for i in range(2 * n - 1):
            for j in range(2 * n - 1):
                cur = 0
                if i <= n - 1:
                    if j <= n - 1:
                        for ii in range(n - i - 1, n):
                            ol = ((bitmap1[ii] &amp, ((1 << (j + 1)) - 1)) << (n - j - 1)) &amp, (bitmap2[ii - (n - i - 1)])
                            cur += bin(ol).count('1')
                    else:
                        for ii in range(n - i - 1, n):
                            ol = (bitmap1[ii] >> (j - n + 1)) &amp, (bitmap2[ii - (n - i - 1)])
                            cur += bin(ol).count('1')
                else:
                    if j <= n - 1:
                        for ii in range(2 * n - i - 1):
                            ol = ((bitmap1[ii] &amp, ((1 << (j + 1)) - 1)) << (n - j - 1)) &amp, (bitmap2[ii + i - n + 1])
                            cur += bin(ol).count('1')
                    else:
                        for ii in range(2 * n - i - 1):
                            ol = (bitmap1[ii] >> (j - n + 1)) &amp, (bitmap2[ii + i - n + 1])
                            cur += bin(ol).count('1')
                res = max(res, cur)
        return res";"import collections

class Solution:
    def largestOverlap(self, img1: list[list[int]], img2: list[list[int]]) -> int:
        n = len(img1)
        
        ones1 = []
        for r in range(n):
            for c in range(n):
                if img1[r][c] == 1:
                    ones1.append((r, c))
        
        ones2 = []
        for r in range(n):
            for c in range(n):
                if img2[r][c] == 1:
                    ones2.append((r, c))

        if not ones1 or not ones2:
            return 0

        vector_counts = collections.defaultdict(int)
        max_overlap = 0

        for r1, c1 in ones1:
            for r2, c2 in ones2:
                vector = (r2 - r1, c2 - c1)
                vector_counts[vector] += 1
                max_overlap = max(max_overlap, vector_counts[vector])
        
        return max_overlap"
"class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
	
        def helper(full, empty, drank):
		    # Base case, make sure we can continue (we have enough to cash in)
            if full + empty < numExchange:
                return drank+full
			# If we have any full bottles we'll make them empty
            if full:
                empty += full
            # Exchange empties for fulls
            new = empty // numExchange
			# Don't forget there might be remainders!
            remaining_empt = empty - (new*numExchange)
            return helper(new, remaining_empt, drank + full)
            
        return helper(numBottles, 0, 0)";"class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
        total_drank = numBottles
        empty_bottles = numBottles

        while empty_bottles >= numExchange:
            newly_filled = empty_bottles // numExchange
            total_drank += newly_filled
            empty_bottles = (empty_bottles % numExchange) + newly_filled
            
        return total_drank"
"class Solution:
    def bulbSwitch(self, n: int) -> int:
        bulb_on = 0
        v = 2
        while n >= 1:
            bulb_on += 1
            n -= v + 1
            v += 2
        return bulb_on";"import math

class Solution:
    def bulbSwitch(self, n: int) -> int:
        return int(math.sqrt(n))"
"class Solution:
    def orderlyQueue(self, s: str, k: int) -> str:
        # case1 : ? s ??????????? return ??? s ??
        if len(set(s)) == 1: return s
        # case2 : ? k ?? 1???? return ?????????(????????????)
        if k != 1: return """".join(sorted(s))
        # case3 : ? k ? 1????????????????
        Len = len(s)
        Min = ""{""
        Min_idxs = dict() # ???????? index ????key = index, val = smallest char
        for i in range(Len):
            if Min > s[i]: # ??????????????? {index:char}??????? == 1
                Min = s[i]
                Min_idxs = {i:s[i]}
            elif Min == s[i]: # ????????????? index:char??????? > 1
                Min_idxs[i] = s[i]
                
        step = 1 # ????? index ?????????????
        # ??????? 1 (????????????????????)?????????????????
        while len(Min_idxs) != 1 and step < Len:

            Min = ""{""
            for idx in Min_idxs:
                comp_idx = (idx+step)%Len # ? index ?? s ????? s[0] ?????
                if Min > s[comp_idx]: # ???? index ? step ????????
                    Min = s[comp_idx]
                Min_idxs[idx] = s[comp_idx] # ??? k,v ?? value ????? step ???
            
            # ? value ???????? key ????
            del_list = [k for k, v in Min_idxs.items() if v != Min]
            # ?? value ???????? k,v ?
            for idx in del_list:
                Min_idxs.pop(idx)
            # ????? step ???
            step += 1

        split_idx = list(Min_idxs.keys())[0] # ??????

        return s[split_idx:] + s[:split_idx] # ????? return";"def solve(s: str, k: int) -> str:
    if k > 1:
        return """".join(sorted(s))
    
    return min(s[i:] + s[:i] for i in range(len(s)))"
"class Solution:
    def leastBricks(self, wall: List[List[int]]) -> int:
        
        """"""
        
        Line can be drawn at one unit distance.
        
        Idea here is to create map of points where each row would like to have line
        Such that no brick is cut.
        
        Post this, check max row fine with particualr point.
        
        Ex For this row, [1,2,2,1]
        
        we can draw line without cutting any brick 
        at 1 or 1+2, or 1+2+2
        
        
        
        """"""
        
        
        lenMap  = collections.defaultdict(int)
        
        for w in wall:
            s = 0 
            for i in w[:-1]:
                s = s + i
                lenMap[s] = lenMap[s] + 1
        
        
        fine = 0
        if lenMap.values():
            fine = max(lenMap.values())
        
        return (len(wall) - fine)";"import collections

class Solution:
    def leastBricks(self, wall: list[list[int]]) -> int:
        edge_counts = collections.defaultdict(int)
        
        for row in wall:
            position = 0
            for brick in row[:-1]:
                position += brick
                edge_counts[position] += 1
                
        return len(wall) - max(edge_counts.values() or [0])"
"class Solution:
    # O(logn) time,
    # O(1) space,
    # Approach: binary search,
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        
        def findLowerBoundIndexToNum(lo, hi, num):
            while True:
                mid = (lo+hi)//2
                curr = citations[mid]
                
                if curr == num and (mid == 0 or citations[mid-1] < num):
                    return mid
                elif curr == num:
                    hi = mid-1
                elif curr > num:
                    if mid == 0 or citations[mid-1] < num:
                        return mid
                    hi = mid-1
                else:
                    if lo >= hi:
                        if citations[hi] >= num:
                            return hi
                        else:
                            return n
                    lo = mid+1
        
        def valid(hindex):
            index = findLowerBoundIndexToNum(0, n-1, hindex)
            citation_num = n - index
            return citation_num >= hindex
        
        
        def findMaxHindex(lo, hi):
            while True:
                mid = (lo+hi)//2
                validCitation = valid(mid)
                
                if validCitation and (mid == n or not valid(mid+1)):
                    return mid
                elif not validCitation:
                    hi = mid-1
                else:
                    if lo >= hi:
                        return hi
                    lo = mid+1
                
        return findMaxHindex(0, n)";"class Solution:
    def hIndex(self, citations: list[int]) -> int:
        n = len(citations)
        low, high = 0, n - 1
        ans = 0
        while low <= high:
            mid = low + (high - low) // 2
            if citations[mid] >= n - mid:
                ans = n - mid
                high = mid - 1
            else:
                low = mid + 1
        return ans"
"class Solution:
    def addDigits(self, num: int) -> int:

        num = [int(i) for i in str(num)]

        if len(num) == 1:
          return num[0]

        while(len(num) != 1): 
          sum = 0
          for i in range(len(num)):
            sum += num[i]
          num = sum
          num = [int(i) for i in str(num)]
        return num[0]";"class Solution:
    def addDigits(self, num: int) -> int:
        if num == 0:
            return 0
        return 1 + (num - 1) % 9"
"class Solution:

    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        # Step 0: Special case of an empty route
        if source == target: return 0

        # Step 1: Create a dict of [stop -> busses stopping at this stop]
        stop2bus = dict()
        for i in range(len(routes)):
            for stop in routes[i]:
                if stop not in stop2bus: stop2bus[stop] = set()
                stop2bus[stop].add(i)

        # Step 2: BFS over the bus stops
        bfs_queue = [(source,0)] # Tuple of (bus stop, number of busses taken to get to the stop)
        visited = {source} # Set of visited bus stops to avoid cycles
        
        while len(bfs_queue) > 0: # BFS
            stop, numBusses = bfs_queue.pop(0)
            if stop==target: return numBusses # If we arrived at the target, stop here!
            if stop in stop2bus:
                for bus in stop2bus[stop]: # Check all busses at this stop
                    for neighbour in routes[bus]: # Check all stops of each bus
                        if neighbour not in visited:
                            # Add all new stops to the neighbours
                            bfs_queue.append((neighbour,numBusses+1))
                            visited.add(neighbour)
                    routes[bus]=[]
            
        return -1 # If we finished the BFS and did not reach the target, it is unreachable";"import collections

class Solution:
    def numBusesToDestination(self, routes: list[list[int]], source: int, target: int) -> int:
        if source == target:
            return 0

        stop_to_routes_map = collections.defaultdict(set)
        for i, route in enumerate(routes):
            for stop in route:
                stop_to_routes_map[stop].add(i)

        q = collections.deque()
        visited_routes = set()
        
        # Start BFS from routes that include the source stop
        for route_idx in stop_to_routes_map[source]:
            q.append((route_idx, 1))
            visited_routes.add(route_idx)
        
        # Pre-convert routes to sets for efficient 'in' checks
        routes_as_sets = [set(r) for r in routes]

        while q:
            current_route_idx, num_buses = q.popleft()

            if target in routes_as_sets[current_route_idx]:
                return num_buses

            # Explore all stops on the current route to find transfers
            for stop in routes[current_route_idx]:
                # For each stop, find all other routes that pass through it
                for next_route_idx in stop_to_routes_map[stop]:
                    if next_route_idx not in visited_routes:
                        visited_routes.add(next_route_idx)
                        q.append((next_route_idx, num_buses + 1))

        return -1"
"class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        n = len(piles)
        memo = [[0] * n for i in range(n)]
        
        def dp(i, j):
            if (i > j): return 0
            if (memo[i][j] != 0):
                return memo[i][j]
            
            player_turn = (n - (j - i)) % 2
            if (player_turn == 1):
                # increasing player1's score when player1 picks a max pile
                memo[i][j] = max(piles[i] + dp(i+1, j), piles[j] + dp(i, j-1))
            else:
                # decreasing player1's score when player2 picks a pile and player2 is assumed to pick the larger pile leading to a min score for player1
                memo[i][j] = min(-piles[i] + dp(i+1, j), -piles[j] + dp(i, j-1))
            return memo[i][j]
                
        return dp(0, n-1) > 0";"def stoneGame(piles: list[int]) -> bool:
    return True"
"class Solution:
    #Time-Complexity: O(rows*cols)
    #Space-Complexity: O(rows*cols + rows*cols) -> O(rows*cols)
    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:
        #this is a standard bfs problem!
        #we will add to queue pixels that share same color as the starting pixel point 
        #that have not already been visited!
        #For each element we dequeue from queue, we will overwrite that entry with the new
        #color!
        #our answer will return image parameter that is modified in-place!
        rows, cols = len(image), len(image[0])
        visited = set()
        q = collections.deque()
        orig_color = image[sr][sc]
        q.append([sr, sc])
        visited.add((sr, sc))
        four_directions = [[1,0],[-1,0], [0,1], [0,-1]]
        #initiate bfs!
        while q:
            cr, cc = q.popleft()
            image[cr][cc] = color
            #iterate through each of four directional neighbors!
            for direction in four_directions:
                r_change, c_change = direction
                if(cr + r_change in range(rows) and
                   cc + c_change in range(cols) and 
                   image[cr+r_change][cc+c_change] == orig_color and
                   (cr+r_change, cc+c_change) not in visited):
                    q.append([cr+r_change, cc+c_change])
                    visited.add((cr+r_change, cc+c_change))
        #once bfs ends, return grid changed in place!
        return image";"class Solution:
    def floodFill(self, image: list[list[int]], sr: int, sc: int, color: int) -> list[list[int]]:
        rows, cols = len(image), len(image[0])
        original_color = image[sr][sc]

        if original_color == color:
            return image

        def dfs(r, c):
            if not (0 <= r < rows and 0 <= c < cols and image[r][c] == original_color):
                return

            image[r][c] = color
            
            dfs(r + 1, c)
            dfs(r - 1, c)
            dfs(r, c + 1)
            dfs(r, c - 1)

        dfs(sr, sc)
        return image"
"class Solution:
    def toGoatLatin(self, sentence: str) -> str:
        new = sentence.split() # Breaks up the input into individual sentences
        count = 1 # Starting at 1 since we only have one ""a"" to begin with.
        
        for x in range(len(new)):
            if new[x][0].casefold() in 'aeiou': # Checks if the first value of x is a vowel. The casefold, can be replaced with lower, lowers the case. Can also just be removed and have ""in 'aeiouAEIOU'
                new[x] = new[x] + 'ma' + 'a'*count # Brings it together with the count multiplying number of ""a""'s as needed.
                count += 1
            elif new[x].casefold() not in 'aeiou': # Same comment as above.
                new[x] = new[x][1:] + new[x][0] + 'ma' + 'a'*count # Just moves the first value to the end then does the a.
                count += 1
        
        return "" "".join(x for x in new) # Converts the list back into a string.";"class Solution:
    def toGoatLatin(self, sentence: str) -> str:
        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}
        words = sentence.split()
        result = []
        
        for i, word in enumerate(words, 1):
            if word[0] in vowels:
                new_word = word + ""ma""
            else:
                new_word = word[1:] + word[0] + ""ma""
            
            new_word += 'a' * i
            result.append(new_word)
            
        return "" "".join(result)"
"class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        # Break words into pieces
        # Empty word can be found in the dictionary
        # can the whole s be also represented in the dictionary?
        
        # BUILDING THE INTUITION HERE
        """"""
        1. can I generate all substrings and check if the strings in the 
        dictionary are present in the substring.
        2. This will not work, why? Because strings in the mother set 
        may have been used already to create another string
        
        SOLUTION
        --------------------------
        1. Go through the dictionary of words and find the string which is the 
        potential begining of the string
        2. segment the length of that string from the string.
        3. Check if the remaining string can also be segmented in words from 
        the dictionary.
        4. if there are no more strings to segment then we can return True.
        5. This is a recurrence problem and can be solved with the recurrence 
        solution.
        
        6. The recurrence function should go through the word dictionary 
        and the one which qualifies will now segment the rest of the string 
        and check for the rest of the segment of the string.
        
        FOR THE RECURRENCE RELATION
        
        1. With every word in the dictionary, get the length of the word.
        2. Check if a segment of the string is equal to that word.
        3. if True, call the function of the rest of the segment of the string.
        
        Base Case:
        1. If all strings are segmented, which means we have the empty ("""") string
        so we can then return True
        
        2. Else we return False
        
        """"""
        """""" RECURRENCE SOLUTION """"""
        def sectionBreak(string):
            if len(string) == 0:
                return True

            for word in wordDict:
                prefix = string[:len(word)]

                if prefix == word and sectionBreak(string[len(word):]):
                    return True
            return False
        
        return sectionBreak(s)
        
        """"""
        MOMOIZATION
        """"""
        def sectionBreak(string, memo):
            if len(string) == 0:
                return True
            elif string in memo:
                return memo[string]

            for word in wordDict:
                prefix = string[:len(word)]

                if prefix == word and sectionBreak(string[len(word):], memo):
                    memo[string] = True
                    return True
            memo[string] = False
            return False
        
        return sectionBreak(s, {})

        """"""
        The dynammic programming approach 
        1. The empty substring can be segmented to any of the words in the dictionary.
        2. Let the index of the words represents the sufix of words in the dictionary.
        3. If suffix of a word is in the dictionary then and the suffix of the previous 
        word is also in the dictionary, then it stands to prove that, the substring of 
        the string up to the current suffix can also be segmented
        """"""
    
        # Initialize a dp table with the length of the string + 1
        # Plus 1 is to compensate for the empty string
        # You can either iterate from the back if you want to use the prefix instead of suffix pointers.
        
        wordSet = set(wordDict) # put words in a hashSet to optimize lookup to O(1)
        dp = [False for _ in range(len(s)+1)]
        dp[0] = True
        
        for i in range(1, len(s)+1):
            for j in range(i-1, -1, -1):
                if dp[j] and s[j:i] in wordSet:
                    dp[i] = True
                    break  # break from the loop if a segment is found
        return dp[-1]";"from typing import List

def wordBreak(s: str, wordDict: List[str]) -> bool:
    word_set = set(wordDict)
    dp = [False] * (len(s) + 1)
    dp[0] = True

    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in word_set:
                dp[i] = True
                break
    return dp[len(s)]"
"class Solution:
    def binaryGap(self, n: int) -> int:
        
        #Bit mask
        mask = 1,
        
        #Max streak and streak default to zero
        maxStreak = 0,
        streak = 0,
        
        #Burn through all of the rightmost zeroes
        #Keep bitshifting n to the right
        #As long as the rightmost bit is not 1 ( which means its even)
        while n > 0 and n % 2 != 1:
            n = n >> 1,
        
        #Then we can begin finding our distances
        while n > 0:
            #Each iteration, we see if the rightmost bit is 1
            isOne = ( mask &amp, n ) == 1,
            
            #If it is, we update our max
            if isOne:
                maxStreak = max( maxStreak, streak ),
                
                #And then increment the streak
                streak = 1,
                
            #If it is a zero, we increment the streak
            else:  
                streak += 1,
                
            #Each time, we bitshift right
            n = n >> 1,
        
        #Note, we will always end at a valid 1 as leading zeros are not
        #processed and we stop when n == 0
        return maxStreak,";"class Solution:
    def binaryGap(self, n: int) -> int:
        last_pos = -1
        max_dist = 0
        current_pos = 0
        while n > 0:
            if n & 1:
                if last_pos != -1:
                    max_dist = max(max_dist, current_pos - last_pos)
                last_pos = current_pos
            n >>= 1
            current_pos += 1
        return max_dist"
"class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        
        """"""
        Let suppose we can divide the array in to two subsets S1 and S2.
        Such that, the difference of those subset is target value.
        sum(S1) + sum(S2) = total     --- (1)
        sum(S1) - sum(S2) = target    --- (2)
        _____________________________________
        2*sum(S1) = total + target    --- (1) + (2)
        
        Hence, sum(S1) = total + target // 2
        """"""
        
        # Total of array
        total = sum(nums)
        
        # Base Case:
        # If total is less than target it is not possible to find any subsets
        # If total + target is odd, no subset exists
        if (total < target) or ((total + target) % 2):
            return 0
        
        # Get the value of sum of subset S1
        sum_s1 = (total + target) // 2
        
        # Recurrsion with memoization
        def countSubsetSum(n: int, w : int, t: Dict):
            if n == 0:
                t[(n,w)] = (0 if w else 1)
            else:
                if (n,w) not in t:
                    if nums[n-1] <= w:
                        t[(n,w)] = countSubsetSum(n-1, w-nums[n-1], t) + countSubsetSum(n-1, w, t) 
                    else:
                        t[(n,w)] = countSubsetSum(n-1, w, t)
            return t[(n,w)]
            
        return countSubsetSum(len(nums), sum_s1, dict())";"class Solution:
    def findTargetSumWays(self, nums: list[int], target: int) -> int:
        total_sum = sum(nums)
        
        if abs(target) > total_sum or (total_sum + target) % 2 != 0:
            return 0
            
        subset_sum = (total_sum + target) // 2
        
        dp = [0] * (subset_sum + 1)
        dp[0] = 1
        
        for num in nums:
            for j in range(subset_sum, num - 1, -1):
                dp[j] += dp[j - num]
                
        return dp[subset_sum]"
"class Solution:
    #Time-Complexity: O(16rows*cols), in worst case our bfs algorithm needs to         process, and each iteration of while loop in worst case will run for loop
    #2 times, with each going through each of eight directions for total of 16!
    #-> O(rows*cols)
    #Space-Complexity: O(2rows*cols)->O(rows*cols)
    #each and every entry of grid that could be updated!
    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:
        #click is going to be start position of our bfs!
        
        #first thing we got to check is if click position clicks a unrevealed mine directly -> Immediate
        #Game Over!
        rows, cols = len(board), len(board[0])
        sr, sc = click
        if(board[sr][sc] == 'M'):
            board[sr][sc] = 'X'
            return board
        
        #otherwise, we need to inititate bfs starting from click position using a queue data structure!
        q = collections.deque()
        #need a visited hashset so we don't revisit empty cell again! Since we may need to bfs
        #continuously from a cell with no adjacent mines in terms of its neighbors!
        visited = set()
        q.append(click)
        visited.add((sr, sc))
        eight_directions = [[1, 0], [-1, 0], [0, 1], [0,-1], [-1, -1], [-1, 1], [1, -1], [1, 1]]
        # as long as queue is non-empty initiate bfs!
        while q:
            #cr = current row, cc = current column!
            cr, cc = q.popleft()
            #for each new empty cell we are processing, the number of adjacent mines starts as 0!
            number_of_mines = 0
            #we have to loop through each of the 8 directional neighbors and check how many of them
            #are in-bounds, unrevealed mine cell!
            for direction in eight_directions:
                r_change, c_change = direction
                if(cr + r_change in range(rows) and 
                   cc + c_change in range(cols) and 
                   board[cr+r_change][cc+c_change] == 'M'):
                    number_of_mines += 1
            #once we iterated through all possible eight neighbors, check if current empty cell
            #has no adjacent mines or even at least 1!
            if(number_of_mines == 0):
                #then, check each of eight directional neighbors: in-bounds, unrevealed empty cell, and
                #and it's not already visited!
                for direction2 in eight_directions:
                    r_change2, c_change2 = direction2
                    if(cr + r_change2 in range(rows) and
                       cc + c_change2 in range(cols) and
                       board[cr+r_change2][cc+c_change2] == 'E' and
                       (cr+r_change2, cc+c_change2) not in visited):
                        q.append([cr+r_change2, cc+c_change2])
                        visited.add((cr+r_change2, cc+c_change2))
                #current empty cell 
                board[cr][cc] = 'B'
            else:
                #otherwise, we need to stop bfs from current cell and label current cell
                #by number of adjacent land mines! digits 1-8 at most!
                board[cr][cc] = str(number_of_mines)
        #once bfs is done, our game board is updated! Simply return it!
        return board";"import collections

class Solution:
    def updateBoard(self, board: list[list[str]], click: list[int]) -> list[list[str]]:
        m, n = len(board), len(board[0])
        r, c = click

        if board[r][c] == 'M':
            board[r][c] = 'X'
            return board

        q = collections.deque([(r, c)])
        visited = set([(r, c)])

        while q:
            row, col = q.popleft()

            mine_count = 0
            neighbors = []
            for dr in range(-1, 2):
                for dc in range(-1, 2):
                    if dr == 0 and dc == 0:
                        continue
                    nr, nc = row + dr, col + dc
                    if 0 <= nr < m and 0 <= nc < n:
                        neighbors.append((nr, nc))
                        if board[nr][nc] == 'M':
                            mine_count += 1
            
            if mine_count > 0:
                board[row][col] = str(mine_count)
            else:
                board[row][col] = 'B'
                for nr, nc in neighbors:
                    if board[nr][nc] == 'E' and (nr, nc) not in visited:
                        q.append((nr, nc))
                        visited.add((nr, nc))
                        
        return board"
"class Solution:
    def isUgly(self, n):
        # Base Cases: 
        # For a number to be ""Ugly"" the first
        # prerequisite is that it is positive
        if n <= 0: return False
        if n == 1: return True

        # Initializing desired set for O(1) lookups later
        # Not a huge improvement, but it's non-zero improvement
        desired = {2,3,5}
        primes = (i for i in [2,3,5,7])

        current_prime = next(primes)
        while True:
            # As soon as our current prime exceeds 2,3,5 we know our n
            # has prime factors not included in the ""Ugly"" grouping
            if current_prime not in desired: return False
            
            # We want to divide n by said prime as many times as we can
            # If the prime doesn't divide evenly into n then we go to the
            # next prime. We would only do this shift 3 times, and once 
            # we have, we've gone into the realm of non-Ugly numbers
            while n % current_prime == 0:
                div= n/current_prime
                if div == 1: return True
                n = div
            current_prime = next(primes)";"class Solution:
    def isUgly(self, n: int) -> bool:
        if n <= 0:
            return False
        
        for p in [2, 3, 5]:
            while n % p == 0:
                n //= p
                
        return n == 1"
"class Solution:
    def deserialize(self, s: str) -> NestedInteger:
        stack = []
        integerStr = ''
        
        for c in s:
            if c == '[':
                stack.append(NestedInteger())
            elif c == ']':
                if len(integerStr)>0:
                    stack[-1].add(NestedInteger(int(integerStr)))
                integerStr = ''
                poppedList = stack.pop()
                if len(stack)==0:
                    return poppedList
                stack[-1].add(poppedList)
            elif c == ',':
                if len(integerStr)>0:
                    stack[-1].add(NestedInteger(int(integerStr)))
                integerStr = ''
            else:
                integerStr += c
                
        return NestedInteger(int(s))";"# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
class NestedInteger:
   def __init__(self, value=None):
       """"""
       If value is an integer, initializes a NestedInteger with that integer.
       Otherwise, initializes an empty nested list.
       """"""
       if value is None:
           self._list = []
           self._integer = None
       else:
           self._integer = value
           self._list = None

   def isInteger(self) -> bool:
       """"""
       @return True if this NestedInteger holds a single integer, rather than a nested list.
       """"""
       return self._integer is not None

   def add(self, elem: 'NestedInteger'):
       """"""
       Set this NestedInteger to hold a nested list and adds a NestedInteger elem to it.
       """"""
       if self.isInteger():
           self._list = [NestedInteger(self._integer)]
           self._integer = None
       
       if self._list is None:
           self._list = []

       self._list.append(elem)

   def setInteger(self, value: int):
       """"""
       Set this NestedInteger to hold a single integer value.
       """"""
       self._integer = value
       self._list = None

   def getInteger(self) -> int:
       """"""
       @return the single integer that this NestedInteger holds, if it holds a single integer
       Return None if this NestedInteger holds a nested list
       """"""
       return self._integer

   def getList(self) -> ['NestedInteger']:
       """"""
       @return the nested list that this NestedInteger holds, if it holds a nested list
       Return None if this NestedInteger holds a single integer
       """"""
       return self._list

class Solution:
    def deserialize(self, s: str) -> NestedInteger:
        if not s:
            return NestedInteger()
        if s[0] != '[':
            return NestedInteger(int(s))

        stack = []
        num_start = -1

        for i, char in enumerate(s):
            if char == '[':
                new_list = NestedInteger()
                if stack:
                    stack[-1].add(new_list)
                stack.append(new_list)
                num_start = -1
            elif char == '-' or char.isdigit():
                if num_start < 0:
                    num_start = i
            elif char == ',' or char == ']':
                if num_start >= 0:
                    num = int(s[num_start:i])
                    num_ni = NestedInteger(num)
                    stack[-1].add(num_ni)
                    num_start = -1
                if char == ']' and len(stack) > 1:
                    stack.pop()
        
        return stack[0]"
"class Solution:
    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:
        prev_key, prev_ts = ('',0) ## this tuple will contain the previous key press and when that was released (prev_ts)
        slowest_key, max_duration = ('',0) ## this tuple will contain the slowest key and for how long it was pressed for
        for key,release_ts in zip(keysPressed,releaseTimes): ## convert keyPressed and releaseTimes into tuples and example the tuple one-by-one
            cur_duration = release_ts - prev_ts ## get the duration for which the key was pressed
            if prev_ts == 0: ## initial case, first key press
                prev_ts = release_ts
                max_duration=release_ts
            if cur_duration > max_duration: ## subsequent keys, check if current duration is more than max we have seen so far
                slowest_key, max_duration = key, cur_duration ## assign the max tuple with the new max and corresponding key
            elif cur_duration == max_duration: ## if current key press duration and max are the same, 
                if key > slowest_key: ## check which one is higher lexically, if current key is higher then update the slowest key to current key
                    slowest_key = key
            prev_key, prev_ts = key, release_ts ## set current key and release_ts to prev for next iteration
        return slowest_key";"class Solution:
    def slowestKey(self, releaseTimes: list[int], keysPressed: str) -> str:
        max_duration = releaseTimes[0]
        result_key = keysPressed[0]
        
        for i in range(1, len(keysPressed)):
            duration = releaseTimes[i] - releaseTimes[i - 1]
            
            if duration > max_duration:
                max_duration = duration
                result_key = keysPressed[i]
            elif duration == max_duration:
                if keysPressed[i] > result_key:
                    result_key = keysPressed[i]
                    
        return result_key"
"class Solution:
    # O(n * m^2) time, n --> len(wordList), m --> len(wordList[i])
    # O(n*m) space,
    # Approach: BFS, hashtable, string
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        
        vstd = set()
        pattern_map = {}
        
        def buildPattern() -> None:
            addWordPattern(beginWord)
            for word in wordList:
                addWordPattern(word)
                
        
        def addWordPattern(word: str) -> None:
            patterns = getPatterns(word)
            
            for pattern in patterns:
                if pattern not in pattern_map.keys():
                    pattern_map[pattern] = []
                pattern_map[pattern].append(word)
        
        
        def getPatterns(word: str) -> List[str]:
            patterns = []
            for i in range(len(word)):
                pattern = word[:i] + '#' + word[i+1:]
                patterns.append(pattern)
                
            return patterns
        
        
        def getNeighbours(root_word: str) -> List[str]:
            neighbours = []
            patterns = getPatterns(root_word)
            
            for pattern in patterns:
                words = pattern_map[pattern]
                for word in words:
                    if word != root_word:
                        neighbours.append(word)
                
            return neighbours
        
        
        def bfs(root_word:str) -> int:
            qu = deque()
            qu.append(root_word)
            depth = 0
            
            while qu:
                n = len(qu)
                depth +=1
                for i in range(n):
                    root_word = qu.popleft()
                    if root_word in vstd:   continue
                    
                    if root_word == endWord:
                        return depth
                    
                    vstd.add(root_word)
                    neighbours = getNeighbours(root_word)
                    for nb in neighbours:
                        qu.append(nb)
                    
            return 0
            
        buildPattern()
        ans = bfs(beginWord)
        return ans";"import collections

class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: list[str]) -> int:
        if endWord not in wordList:
            return 0

        wordSet = set(wordList)
        queue = collections.deque([(beginWord, 1)])
        visited = {beginWord}

        while queue:
            word, length = queue.popleft()

            if word == endWord:
                return length

            for i in range(len(word)):
                for char_code in range(ord('a'), ord('z') + 1):
                    next_word = word[:i] + chr(char_code) + word[i+1:]
                    if next_word in wordSet and next_word not in visited:
                        visited.add(next_word)
                        queue.append((next_word, length + 1))
        
        return 0"
"class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        drop = {}   # passengers drop location list        
        nxt = trips[0][2]   # next/earliest drop point
        
        # swap-> numPassengersi and fromi in the trips, then
        # sort(asc) trips as per pickup location
        for p in trips:
            p[0], p[1]  = p[1], p[0]
        heapq.heapify(trips)
        
			seats = capacity    #available seats
        while trips:
            # current stop, num of passenger, dest/to
            (curr, psg, dest) = heapq.heappop(trips)
            # drop passengers
            while nxt <= curr:
                if drop:
                    seats += drop[nxt]
                    del drop[nxt]
                    if drop:
                        nxt = min(drop)                
                    else:
                        nxt = dest                            
            # pick passengers/psg        
            seats -= psg            
            if seats < 0:                
                return False
            #number of passengers to drop at location dest
            if dest in drop:
                drop[dest] += psg
            else:                
                drop[dest] = psg
            nxt = min(nxt, dest)            
            
        return True";"import collections

class Solution:
    def carPooling(self, trips: list[list[int]], capacity: int) -> bool:
        timeline = [0] * 1001
        for num_passengers, start, end in trips:
            timeline[start] += num_passengers
            timeline[end] -= num_passengers

        current_passengers = 0
        for passenger_change in timeline:
            current_passengers += passenger_change
            if current_passengers > capacity:
                return False
        
        return True"
"class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        
        dict_1 = from_str_to_dict(ransomNote)
        dict_2 = from_str_to_dict(magazine)
        
        return check_compatibility(dict_1, dict_2)
    
# Define helper method that checks if to dictionaries have keys in common, and 
# if the ransomNote needs more letters then what the magazine can provide.

def check_compatibility(dict_1, dict_2):
    
    # Check for common keys.
    for key in list(dict_1.keys()):
        
        if not key in dict_2:
            
            return False
        
        # Check for valid quantity.
        if dict_1[key] > dict_2[key]:
            
            return False
        
    return True

# Convert a string into a dictionary.

def from_str_to_dict(string: str):
    
    dic = {}
    
    for i in string:
        
        if i in dic:
            
            dic[i] += 1
            
        else:
            
            dic[i] = 1
            
    return dic        

# Runtime: 134 ms, faster than 24.02% of Python3 online submissions for Ransom Note.
# Memory Usage: 14.1 MB, less than 93.55% of Python3 online submissions for Ransom Note.

# If you like my work and found it helpful, then I'll appreciate a like. Thanks!";"import collections

class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        if len(ransomNote) > len(magazine):
            return False
        
        magazine_counts = collections.Counter(magazine)
        
        for char in ransomNote:
            if magazine_counts[char] > 0:
                magazine_counts[char] -= 1
            else:
                return False
        
        return True"
"class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        self.targetSum, self.ans = targetSum, []            # variable initialization
        self.get_path_sum(root, 0, [])                      # calling function get path sum
        return self.ans                                     # return answer
        
    def get_path_sum(self, root, psum, path):
        if not root: return None                            # if not root return None
        if not root.left and not root.right:                # if curr node is leaf
            if root.val + psum == self.targetSum:           # if path sum from root to leaf = target sum
                path.append(root.val)                       # append node value to path
                self.ans.append([e for e in path])          # add path to ans list
                path.pop(-1)                                # remove node value from path
                return,                                     # return
        path.append(root.val)                               # append node value to path
        self.get_path_sum(root.left, psum + root.val, path) # left traversal
        self.get_path_sum(root.right, psum + root.val, path)# right traversal
        path.pop(-1)                                        # remove node value from path";"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def pathSum(self, root, targetSum):
        result = []
        
        def dfs(node, remaining_sum, path):
            if not node:
                return

            path.append(node.val)
            
            if not node.left and not node.right and remaining_sum == node.val:
                result.append(list(path))
            else:
                dfs(node.left, remaining_sum - node.val, path)
                dfs(node.right, remaining_sum - node.val, path)
            
            path.pop()

        dfs(root, targetSum, [])
        return result"
"class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        # To adhere to the problem's constraints, we should probably hardcode this!
        tables_of_addition = {str(x): {str(i): str(x+i) for i in range(10)} for x in range(0, 10)}
        # Corner case
        for i in range(10, 20): tables_of_addition[""1""][str(i)] = str(1+i)
        
        # Ensuring that the 2 numbers are the same size.
        num1 = num1.zfill(max(len(num1), len(num2)))
        num2 = num2.zfill(max(len(num1), len(num2)))

        p = len(num1)-1
        
        carry, results = ""0"", """"
        while p > -1:
            curr_res = tables_of_addition[num1[p]][num2[p]]
            
            # Carry is a bit tricky since current result can be in the range 0, 18 (inclusive)
            curr_res_with_carry = tables_of_addition[str(carry)][curr_res] if str(carry) == ""1"" else curr_res
            carry = ""0""
            
            # We know that the maximum addition (between 9 &amp, 9) is 2 digits and will equal 18
            if len(curr_res_with_carry) > 1:
                carry = curr_res_with_carry[0]
                results = curr_res_with_carry[1]+results
            else:
                results = curr_res_with_carry[0]+results
            p-=1
        
        return results if carry == ""0"" else carry + results";"def addStrings(num1: str, num2: str) -> str:
    res = []
    carry = 0
    i, j = len(num1) - 1, len(num2) - 1

    while i >= 0 or j >= 0 or carry:
        digit1 = int(num1[i]) if i >= 0 else 0
        digit2 = int(num2[j]) if j >= 0 else 0
        
        total = digit1 + digit2 + carry
        res.append(str(total % 10))
        carry = total // 10
        
        i -= 1
        j -= 1
        
    return ''.join(res[::-1])"
"class Solution:
    def maxJumps(self, nums: List[int], d: int) -> int:
        N = len(nums)
        seen = set() # seen for lookup, to memoize
        dp = [1]*N   # stores the values of jump we can make from Ith index in DP.                                    #  minimum being 1 jump (i.e its self)
        
        def recursion(indx):
            # if we have indx in seen return its value  dp[indx].
            if indx in seen:
                return dp[indx]
            # base case if indx is out of range we cant jump. return 0
            if indx<0 or indx >= N:
                return 0
            
        # tempR : all the jumps we can make to the right side of indx
        # tempL : all the jumps we can make to the left side of indx
            tempR,tempL= 0,0
            curr = nums[indx] # height of current indx so we only jump allowed jump 
                    # i.e nums[i] < curr <- allowed  if curr =< nums[i] break(jump not allowed)
            
            #max jump we can make to the right Side are stored in tempR, 
            for i in range(indx+1, min(indx+d+1,N) ):
                if nums[i] < curr:
                    tempR = max(tempR, recursion(i)) # store max jumps in right
                else:
                    break
            for i in range(indx-1, max(-1,indx-d-1) , -1): 
                if nums[i] < curr:
                    tempL = max(tempL, recursion(i)) # store max jumps in  left
                else:
                    break
            # update dp[indx] by (1 + maxjumps( right, left))   ( 1 becoz it can jump on itself)
            dp[indx] = max(tempR,tempL) + 1 
            seen.add(indx) # as Indx calculated, can use its value next time, so added to seen
            return dp[indx]
        
        
        # for all indices we check how many jumps we can make
        for i in range(N): 
            if i not in seen: # if ith index is not in seen then we have comupted its jumps.
                recursion(i)
        return max(dp)  # returns the max jumps";"import functools

class Solution:
    def maxJumps(self, arr: list[int], d: int) -> int:
        n = len(arr)

        @functools.lru_cache(None)
        def dp(i):
            res = 1
            
            for j in range(i + 1, min(n, i + d + 1)):
                if arr[j] >= arr[i]:
                    break
                res = max(res, 1 + dp(j))

            for j in range(i - 1, max(-1, i - d - 1), -1):
                if arr[j] >= arr[i]:
                    break
                res = max(res, 1 + dp(j))
            
            return res

        return max(dp(i) for i in range(n))"
"class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if node is None: return None #if we have an empty graph
        visited = [] #will store all visited nodes
        cloneNodes = {} #will store cloned nodes. In each k:v pair k is the val attribute of 
                        #the old node and v is the corresponding cloned node
        adj = {} #the adjacency list for the graph. In each k:v pair k is the val attribute
                 #of a node and v is a list of the val attributes of its neighbors.
        stack = [node] #stack of nodes to be visited. Each time we visit a node, we will add
                       #its neighbors in the stack.
        while stack != []:
            curr = stack.pop() #take a node out of the stack
            if curr.val not in visited: #if node was already visited we do nothing
                visited.append(curr.val)
                cloneNodes[curr.val] = Node(curr.val) #create new node with the same val and 
                                                      #no neighbors
                adj[curr.val] = []
                for nd in curr.neighbors:
                    stack.append(nd) #add neighbors in the stack
                    adj[curr.val].append(nd.val) #save neighbors in adjacency dictionary
        for k, v in adj.items():
            #update neighbors of cloned nodes to match the neighbors of old ones
            cloneNodes[k].neighbors = [cloneNodes[i] for i in v]
        return cloneNodes[node.val] #return clone of initial node";"class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        oldToNew = {}

        def dfs(original_node):
            if original_node in oldToNew:
                return oldToNew[original_node]
            
            copy = Node(original_node.val)
            oldToNew[original_node] = copy
            for neighbor in original_node.neighbors:
                copy.neighbors.append(dfs(neighbor))
            return copy

        return dfs(node) if node else None"
"class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        n=len(nums)
        
        # Brute Force: O(n^3) --> TLE
		# for i in range(n):
        #     for j in range(i+1, n):
        #         for k in range(j+1, n):
        #             if nums[i]<nums[k] and nums[k]<nums[j]:
        #                 return True
        
        # Optimised using BS: O(nlogn) --> TLE 
        # for i in range(n):
        #     j=i+1
        #     k=n-1
        #     while j<k:
        #         if nums[i]<nums[j] and nums[i]<nums[k]:
        #             if nums[j]<nums[k]:
        #                 k-=1
        #             elif nums[k]==nums[j]:
        #                 j+=1
        #             else:
        #                 return True
        #         elif nums[i]<nums[j]:
        #             k-=1
        #         else:
        #             j+=1
        
        # Optimised using Monotonic stack: O(n)
        st=[]
        mini=nums[0]
        for num in nums:
            while st and st[-1][0]<=num:
                st.pop()
            if st and st[-1][1]<num:
                return True
            st.append([num, mini])
            mini=min(mini, num)
        return False";"import math

class Solution:
    def find132pattern(self, nums: list[int]) -> bool:
        n = len(nums)
        if n < 3:
            return False
        
        stack = []
        s2 = -math.inf
        
        for i in range(n - 1, -1, -1):
            if nums[i] < s2:
                return True
            while stack and nums[i] > stack[-1]:
                s2 = stack.pop()
            stack.append(nums[i])
            
        return False"
"class Solution:
    def new21Game(self, n: int, k: int, maxPts: int) -> float:
        if n >= k - 1 + maxPts: return 1 #the last possible stop-point is k-1, if we roll a maxPts and it will end within n, that means anyway it will end within n with prob 1, there is no need to continue
        dp = [0] * (n + 1) #dp[i] is the probability we reach point i. As we care what's the probability within n, at most we need dp to calculate from 1 to n
        dp[0], curSum = 1, 0 #dp[0] is the probability we reach 0. As we start with 0, we have a probability of 1 reaching 0
        for i in range(1, n + 1):
            if i - 1 < k: # when the previous point hasn't reached k, that means we can still continue to roll, and we'll add that point. Otherwise, when i - 1 already reaches k, then the game stops and we cannot reach status i from  i - 1 (we cannot pick any more number)
                curSum += dp[i - 1]
            if i - 1 >= maxPts: # we can only reach point i from point i - 1, i - 2, ..., i - maxPts. and hence when we calculate point i, we need to make sure the previous points outside of the range drops out
                curSum -= dp[i - 1 - maxPts]
            dp[i] = curSum / maxPts
        return sum(dp[k:]) # we calculate all the probabilities that we land in point k, point k + 1, until point n";"class Solution:
    def new21Game(self, n: int, k: int, maxPts: int) -> float:
        if k == 0 or n >= k + maxPts - 1:
            return 1.0

        dp = [0.0] * (n + 1)
        dp[0] = 1.0
        window_sum = 1.0
        ans = 0.0

        for i in range(1, n + 1):
            dp[i] = window_sum / maxPts
            
            if i < k:
                window_sum += dp[i]
            else:
                ans += dp[i]

            if i >= maxPts:
                window_sum -= dp[i - maxPts]
                
        return ans"
"class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        return self.moveZerosOptimal(nums)
		return self.moveZerosOptimalTwo(nums)
        # return self.moveZeroesByPopAndAppend(nums)

#     O(n) || O(1)
# runtime: 291ms 32.26%
    def moveZerosOptimal(self, nums):
        if not nums:return nums

        nextPtr = 0

        for num in nums:
            if num != 0:
                nums[nextPtr] = num
                nextPtr += 1
        
        for i in range(nextPtr, len(nums)):
            nums[i] = 0

        return nums
    
	# O(n) || O(1)
	def moveZerosOptimalTwo(self, nums):
		if not nums:
			return nums
			
		left = 0
		for right in range(len(nums)):
			if nums[right]:
				nums[left], nums[right] = nums[right], nums[left]
				left += 1
		return nums
    
# O(n) || O(1) space: but its a bad practice,
# appending a element is an O(1) operation but when you pop(O(1)) 
# all the elements to its right move to fill the space. O(n)
# runtime: 1698ms 5.69%
    def moveZeroesByPopAndAppend(self, nums):
        if not nums:
            return nums

        for i in nums:
            if i == 0:
                nums.remove(i)
                nums.append(i)

        return nums";"def moveZeroes(nums: list[int]) -> None:
    """"""
    Do not return anything, modify nums in-place instead.
    """"""
    last_non_zero_found_at = 0
    for i in range(len(nums)):
        if nums[i] != 0:
            nums[last_non_zero_found_at], nums[i] = nums[i], nums[last_non_zero_found_at]
            last_non_zero_found_at += 1"
"class Solution:
        #greedy algorithm
        def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
                #if the gas at all stations is less than the cost at all stations then gas will not be sufficient to travel the circuit once
                if sum(gas) < sum(cost):
                        #so return - 1
                        return - 1
                #if the gas is sufficient 
                #we have to find from which index we should start
                total = 0 
                #res is a variable which is created to store the index from which we are going to start
                res = 0 
                #iterate of the indexes of gas
                for i in range(len(gas)):
                        #add the difference of gas and cost at each station
                        total += (gas[i]  - cost[i])
                        #if the difference is less than 0 
                        if total < 0:
                                #then we have to check the positive difference
                                #so reset total to 0 
                                total = 0
                                #increse the res value to next index
                                res = i + 1
                #after finishing the for-loop 
                #we the return the index where first positive difference is occured
                return res";"class Solution:
    def canCompleteCircuit(self, gas: list[int], cost: list[int]) -> int:
        if sum(gas) < sum(cost):
            return -1

        start_node = 0
        tank = 0
        for i in range(len(gas)):
            tank += gas[i] - cost[i]
            if tank < 0:
                start_node = i + 1
                tank = 0
        
        return start_node"
"class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        
        # Init
        m = len(matrix)
        n = len(matrix[0])
        max_len = 0
        
        # Convert matrix value of string to int
        for row in range(m):
            for col in range(n):
                matrix[row][col] = int(matrix[row][col])
        
        # Scan first row
        for col in range(n):
            max_len = max(max_len, matrix[0][col])
            
        # Scan first column
        for row in range(m):
            max_len = max(max_len, matrix[row][0])
        
        # For each row starting from second row
        for i in range(1,m):
            
            # For each col starting from second column
            for j in range(1,n):
                
                # If the current element is non-zero
                if matrix[i][j]:
                    
                    # If all three of it's adjacent elements are non-zero
                    # Three elements are:
                    # a) element in the previous row ""[i-1][j]""
                    # b) element in the previous column ""[i][j-1]""
                    # c) element in previous diagonal ""[i-1][j-1]""
                    if matrix[i-1][j] and matrix[i][j-1] and matrix[i-1][j-1]:
                        
                        # Get the minimum of all three adjacent elements and add one to it
                        # This updates length of the element w.r.t how many adjacent ones
                        # are available in the original matrix
                        matrix[i][j] = min(matrix[i-1][j], matrix[i][j-1], matrix[i-1][j-1]) + 1
                    
                    # Calc max len w.r.t the updated length of the current element
                    max_len = max(max_len, matrix[i][j])
                        
                    
        return max_len**2 # Area of a square of length ""l"" is l*l = l^2";"import collections

class Solution:
    def maximalSquare(self, matrix: list[list[str]]) -> int:
        if not matrix or not matrix[0]:
            return 0

        rows, cols = len(matrix), len(matrix[0])
        dp = [[0] * (cols + 1) for _ in range(rows + 1)]
        max_side = 0

        for r in range(rows):
            for c in range(cols):
                if matrix[r][c] == '1':
                    dp[r + 1][c + 1] = min(dp[r][c], dp[r + 1][c], dp[r][c + 1]) + 1
                    max_side = max(max_side, dp[r + 1][c + 1])
        
        return max_side * max_side"
"class Solution2:
    def _get_all_divisors(self, num: int):
        for divisor in range(1, int(num ** 0.5) + 1):
            if num % divisor == 0:
                yield divisor
                other_divisor = num // divisor
                if divisor != other_divisor:
                    yield other_divisor

    def checkPerfectNumber(self, num: int) -> bool:
        sum_of_divisors = sum(self._get_all_divisors(num)) - num
        return sum_of_divisors == num";"class Solution:
    def checkPerfectNumber(self, num: int) -> bool:
        if num <= 1:
            return False
        
        divisor_sum = 1
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                divisor_sum += i
                if i * i != num:
                    divisor_sum += num // i
        
        return divisor_sum == num"
"class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        words_out = []
        for w_x in words:
            inx_words = []
            inx_count = []
            for xx in range(len(w_x)):
                inx_words.append(self.index_all(board, w_x[xx]))
                inx_count.append(len(inx_words[xx]))
            if inx_count.count(0) > 0:
                pass
            else:
                board_2 = []
                for x in range(len(board)):
                    for y in range(len(board[0])):
                        try:
                            b2 = [f'{board[x][y]}{board[x][y + 1]}']
                        except IndexError:
                            b2 = [0]
                        try:
                            b2 += [f'{board[x][y]}{board[x + 1][y]}']
                        except IndexError:
                            b2 += [0]
                        b2 += [f'{board[x][y]}{board[x][y - 1]}', f'{board[x][y]}{board[x - 1][y]}']
                        if x == 0 and y == 0:
                            board_2 += b2[:2]
                        elif x == 0 and y != 0:
                            board_2 += b2[:3]
                        elif x != 0 and y == 0:
                            board_2 += [b2[0], b2[1], b2[3]]
                        else:
                            board_2 += b2

                break_c = False
                for x in range(len(w_x) - 1):
                    words_2 = w_x[x] + w_x[x + 1]
                    if board_2.count(words_2) == 0:
                        break_c = True
                        break

                if break_c:
                    continue

                w_x0 = w_x[:]
                if inx_count[-1] <= inx_count[0]:
                    w_x = w_x[::-1]
                    inx_words = inx_words[::-1]

                inx = [0 for i in range(len(w_x))]
                while inx[0] < len(inx_words[0]):
                    inx_s1 = inx_words[0][inx[0]]
                    i = 1
                    path = [inx_s1]
                    inx_words0 = [aa[:] for aa in inx_words]
                    while i < len(w_x):
                        try:
                            for ix in range(i, len(w_x)):
                                if inx_words0[ix].count(inx_s1) > 0:
                                    inx_words0[ix].remove(inx_s1)
                            inx_s2 = inx_words0[i][inx[i]]
                            inx_s12 = [[inx_s1[0] + 1, inx_s1[1]], [inx_s1[0] - 1, inx_s1[1]],
                                       [inx_s1[0], inx_s1[1] + 1], [inx_s1[0], inx_s1[1] - 1]]

                            if inx_s12.count(inx_s2) == 0:
                                inx[i] += 1
                                break
                            inx_s1 = inx_s2
                            path.append(inx_s1)
                            i += 1
                        except IndexError:
                            inx[i - 1] += 1
                            inx[i:] = [0] * (len(w_x) - i)
                            break

                    if i == len(w_x):
                        inx[i - 1] += 1
                        if len(w_x) == len(set(map(tuple, path))):
                            words_out.append(w_x0)
                            break
        return words_out

    def index_all(self, my_list, v):
        inx_s = []
        for i, x in enumerate(my_list):
            inx_c = [i for i, m in enumerate(x) if m == v]
            for xx in inx_c:
                inx_s.append([i, xx])
        return inx_s";"import collections

class Solution:
    def findWords(self, board: list[list[str]], words: list[str]) -> list[str]:
        if not board or not board[0]:
            return []

        # Use a defaultdict to build the Trie
        TrieNode = lambda: collections.defaultdict(TrieNode)
        trie = TrieNode()

        for word in words:
            node = trie
            for char in word:
                node = node[char]
            node['#'] = word # Mark end of word and store the word

        m, n = len(board), len(board[0])
        result = []

        def dfs(i, j, parent_node):
            char = board[i][j]
            current_node = parent_node.get(char)

            if not current_node:
                return

            # Check if a word is found
            if '#' in current_node:
                result.append(current_node.pop('#')) # Add and remove to avoid duplicates

            # Mark cell as visited
            board[i][j] = '!'

            # Explore neighbors
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ni, nj = i + dx, j + dy
                if 0 <= ni < m and 0 <= nj < n and board[ni][nj] != '!':
                    dfs(ni, nj, current_node)

            # Backtrack
            board[i][j] = char

            # Prune the Trie
            if not current_node:
                parent_node.pop(char)

        for i in range(m):
            for j in range(n):
                if board[i][j] in trie:
                    dfs(i, j, trie)

        return result"
"class Solution:
    def minimumBoxes(self, m: int) -> int:
        def cbrt(x):
            return x**(1. / 3)

        # Find the first tetrahedral number greater than
        # or equal to m.
        x = cbrt(sqrt(3)*sqrt(243*(m**2) - 1) + 27*m)
        n = ceil(x/cbrt(9) + 1/(cbrt(3)*x) - 1)
        
        # If m is the nth tetrahedral number, return the
        # nth triangular number (the base).
        t_n =n*(n+1)*(n+2) // 6 
        if m == t_n:
            return n*(n+1)//2

        # Otherwise, we must adjust the answer.
        ans = n*(n+1)//2
        j = t_n + 1
        while m < j:
            j -= n
            ans -= 1
            n -= 1

        return ans + 1";"import math

class Solution:
    def minimumBoxes(self, n: int) -> int:
        current_level_floor = 0
        total_floor = 0
        total_boxes = 0

        while total_boxes < n:
            current_level_floor += 1
            total_floor += current_level_floor
            total_boxes += total_floor

        if total_boxes == n:
            return total_floor

        total_boxes -= total_floor
        total_floor -= current_level_floor

        remaining = n - total_boxes
        
        extra_floor_boxes = 0
        while remaining > 0:
            extra_floor_boxes += 1
            remaining -= extra_floor_boxes
            
        return total_floor + extra_floor_boxes"
"class Solution:
    def magicalString(self, n: int) -> int:
        ref = ""122112""
        actual = """"
        start = 0
        one = True
        
        while(len(ref) < n):
            for i in range(start, len(ref)):
                if(one):
                    actual += int(ref[i]) * ""1""
                    one = False
                else:
                    actual += int(ref[i]) * ""2""
                    one = True
                    
            if(len(actual) > len(ref)):
                start = len(ref)
                ref = actual
        
        return ref[:n].count(""1"")";"class Solution:
    def magicalString(self, n: int) -> int:
        if n == 0:
            return 0
        if n <= 3:
            return 1
        
        s = [1, 2, 2]
        head = 2
        
        while len(s) < n:
            num_to_add = 3 - s[-1]
            count = s[head]
            s.extend([num_to_add] * count)
            head += 1
            
        return s[:n].count(1)"
"class Solution:
    def reverseString(self, s: List[str]) -> None:
        """"""
        Do not return anything, modify s in-place instead.
        """"""
        return self.reverseStringOptimal(s)
    
#     O(n) || O(1)
# runtime: 342 19.09%
    def reverseStringOptimal(self, string):
        if not string: return string
        left, right = 0, len(string) - 1

        while left < right:
            string[left], string[right] = string[right], string[left]
            left += 1
            right -= 1

        return string
    
    
#     O(n) || O(n)
# brute force
    def reverseStringWithNewList(self, string):
        if not string:
            return string

        newList = [0] * len(string)

        j = 0
        for i in reversed(range(len(string))):
            newList[i] = string[j]
            j += 1

        return newList

# below are just 'some' python built in
    def reverseStringWithListCompression(self, string):
        if not string: return string
        return [string[i] for i in reversed(range(len(string)))]

    
    def reversedStringWithReverse(self, string):
        string.reverse() 
        return string or string[::-1]";"class Solution:
    def reverseString(self, s: list[str]) -> None:
        """"""
        Do not return anything, modify s in-place instead.
        """"""
        left, right = 0, len(s) - 1
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1"
"class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        freq = [0] * 26
        for task in tasks: freq[ord(task) - ord('A')] += 1
        
        # highest freq, how many letters have it
        highest_freq, no_high_tasks = self.highest_freq1(freq, len(tasks))
        
        parts = highest_freq - 1
        empty_slots = (n - no_high_tasks + 1) * parts
        idle = max(0, empty_slots - ( len(tasks) - no_high_tasks * highest_freq))
        
        return len(tasks) + idle


    def highest_freq1(self, freq, total_tasks):
        '''
        sort in O(Nlog(N)) using heap, find the max frequency and 
        the no. of tasks that have it
        '''
        heapq.heapify(freq)
        max_so_far, high_tasks = -math.inf, 0
        
        while freq:
            occ = heapq.heappop(freq)
            if max_so_far < occ:
                max_so_far = occ
                high_tasks = 0
            if occ == max_so_far: high_tasks += 1
        
        return max_so_far, high_tasks
    
    
    def highest_freq2(self, freq, total_tasks):
        '''
        Sort in O(Nlog(N)) using Timsort and find the no. of tasks with max freq
        '''
        freq = sorted(freq, reverse=True)
        highest_freq, no_high_tasks = freq[0], 0
        
        for f in freq:
            if f == highest_freq: no_high_tasks += 1
        
        return highest_freq, no_high_tasks
    
    
    def highest_freq3(self, freq, total_tasks):
        '''
        Sort in O(N) using bucket sort and return the highest non-empty bucket
        and the number of elements in it
        '''
        buckets = [[] for _ in range(total_tasks + 1)]
        
        for i in range(len(freq)):
            f = freq[i]
            buckets[f].append(i)
        
        highest_freq = -1
        for i in range(len(buckets) - 1, 0, -1):
            if buckets[i]:
                highest_freq = i
                break
        
        return highest_freq, len(buckets[highest_freq])";"import collections
from typing import List

class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        freq_counter = collections.Counter(tasks)
        if not freq_counter:
            return 0

        frequencies = list(freq_counter.values())
        max_freq = max(frequencies)
        
        num_tasks_with_max_freq = frequencies.count(max_freq)
        
        time = (max_freq - 1) * (n + 1) + num_tasks_with_max_freq
        
        return max(time, len(tasks))"
"class Solution:
    def countPoints(self, rings: str) -> int:
        r = []
        g = []
        b = []
        ring_nums = set()
        count = 0
        for i in range(0, len(rings)):
            if rings[i] == 'R':
                r.append(int(rings[i+1]))
                if rings[i+1] not in ring_nums:
                    ring_nums.add(int(rings[i+1]))
            elif rings[i] == 'G':
                g.append(int(rings[i+1]))
                if rings[i+1] not in ring_nums:
                    ring_nums.add(int(rings[i+1]))
            elif rings[i] == 'B':
                b.append(int(rings[i+1]))
                if rings[i+1] not in ring_nums:
                    ring_nums.add(int(rings[i+1]))
        for i in ring_nums:
            if i in r and i in g and i in b:
                count += 1
        return count";"class Solution:
    def countPoints(self, rings: str) -> int:
        rods = [set() for _ in range(10)]
        for i in range(0, len(rings), 2):
            color = rings[i]
            rod_index = int(rings[i+1])
            rods[rod_index].add(color)
        
        count = 0
        for rod_set in rods:
            if len(rod_set) == 3:
                count += 1
        
        return count"
"class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        
        """"""
        Input: Array of integers
        constraints:
        1. Infinite number of each coin
        output: integer
        
        1. Do I have duplicate integers in the array
        2. Choose a single coin and add it up till it hits the targetj
        or greater than the target.
        
        Input variables are going to be the target, and the coins
        Base Case:
        if target hits zero, then return 1
        elif target is less than zero return 0
        Can we have a target less than zero
        Can the target be zero itself
        """"""
        if amount <= 0 and not coins:
            return 0
        if not coins:
            return 0
        memo = {}
        def dfs(target, n, memo):
            if (target, n) in memo:
                return memo[(target, n)]
            if target == 0:
                return 1
            if target < 0 or n == 0:
                return 0
            
            if (coins[n-1] <= target):
                res = dfs(target-coins[n-1], n, memo) + dfs(target, n-1, memo)
                memo[(target, n)] = res
                return res
            else:
                res = dfs(target, n-1, memo)
                memo[(target, n)] = res
                return res
        res = dfs(amount, len(coins), {})
        return res
    
        """"""
        2D DYNAMIC PROGRAMMING
        """"""
        dp = [[0]*(amount+1) for _ in range(len(coins)+1)]
        dp[0][0] = 1

        for i in range(1, len(coins)+1):
            for j in range(amount+1):
                if (coins[i-1]<=j):
                    dp[i][j] = dp[i][j-coins[i-1]] + dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j]
        return dp[len(coins)][amount]
    
        """"""
        1D DYNAMIC PROGRAMMING
        """"""
        dp = [0 for _ in range(amount+1)]
        dp[0] = 1
        for x in coins:
            for j in range(amount+1):
                if x <= j:
                    dp[j] += dp[j-x]
        return dp[amount]";"from typing import List

class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [0] * (amount + 1)
        dp[0] = 1

        for coin in coins:
            for i in range(coin, amount + 1):
                dp[i] += dp[i - coin]
        
        return dp[amount]"
"class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:
        def get_coordinates(x1,x2,y1,y2):
            return {0:[x1,y1],1:[x2,y1],2:[x2,y2],3:[x1,y2]}
        
        first = get_coordinates(ax1,ax2,ay1,ay2)
        second = get_coordinates(bx1,bx2,by1,by2)
        
        def left_overlap(a,b):
            if b[0][0]>=a[0][0] and b[0][0]<a[1][0] and b[1][0]>=a[1][0]:
                return abs(b[0][0]-a[1][0])
            if a[0][0]>=b[0][0] and a[0][0]<b[1][0] and a[1][0]>=b[1][0]:
                return abs(a[0][0]-b[1][0])
            if b[0][0]>=a[0][0] and b[0][0]<a[1][0] and b[1][0]<a[1][0]:
                return abs(b[1][0]-b[0][0])
            if a[0][0]>=b[0][0] and a[0][0]<b[1][0] and a[1][0]<b[1][0]:
                return abs(a[1][0]-a[0][0])
        
        def top_overlap(a,b):
            if b[0][1]>=a[0][1] and b[0][1]<a[2][1] and b[2][1]>=a[2][1]:
                return abs(b[0][1]-a[2][1])
            if a[0][1]>=b[0][1] and a[0][1]<b[2][1] and a[2][1]>=b[2][1]:
                return abs(a[0][1]-b[2][1])
            if b[0][1]>=a[0][1] and b[0][1]<a[2][1] and b[2][1]<a[2][1]:
                return abs(b[2][1]-b[0][1])
            if a[0][1]>=b[0][1] and a[0][1]<b[2][1] and a[2][1]<b[2][1]:
                return abs(a[2][1]-a[0][1])
        
        l=left_overlap(first,second)
        t=top_overlap(first, second)
        
        total_area = (first[1][0]-first[0][0])*(first[2][1]-first[0][1])
        total_area+=(second[1][0]-second[0][0])*(second[2][1]-second[0][1])
        if l is not None and t is not None:
            total_area -=l*t
        return total_area";"class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:
        area_of_a = (ax2 - ax1) * (ay2 - ay1)
        area_of_b = (bx2 - bx1) * (by2 - by1)

        overlap_width = max(0, min(ax2, bx2) - max(ax1, bx1))
        overlap_height = max(0, min(ay2, by2) - max(ay1, by1))
        
        overlap_area = overlap_width * overlap_height
        
        total_area = area_of_a + area_of_b - overlap_area
        return total_area"
