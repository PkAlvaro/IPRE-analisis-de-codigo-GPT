Human_Code;IA_Code
"class Solution:
    def findSecretWord(self, words: List[str], master: 'Master') -> None:        
        k = 1 # for tracing the number of loops
        matches = 0
        blacklists = [[] for i in range(6)]
        
        while matches != 6:
            n = len(words)
            r = random.randint(0, n - 1)
            matches = master.guess(words[r])
            key = words[r]
            # print(k, n, r, matches, key)
            
            words.pop(r)
            
            if matches == 0:
                for i in range(6):
                    blacklists[i].append(key[i])
                # print(blacklists)
            
            elif matches > 0 and matches < 6:
                candidates = []
                for i in range(n - 1):
                    count = 0
                    for j in range(6):
                        if words[i][j] not in blacklists[j] and words[i][j] == key[j]:
                            count += 1
                    if count >= matches:
                        candidates.append(words[i])
                            
                words = candidates.copy()
                # print(words)
            
            k += 1";"class Solucion:
    def encontrar_secreto(self, palabras, maestro):
        intentos_permitidos = maestro.allowedGuesses
        intentos_realizados = 0
        posibles_palabras = list(palabras)
        
        while intentos_realizados < intentos_permitidos and len(posibles_palabras) > 0:
            palabra_actual = posibles_palabras[0]
            coincidencias = maestro.guess(palabra_actual)
            intentos_realizados += 1
            
            if coincidencias == 6:
                return
            
            nuevas_posibles = []
            for palabra in posibles_palabras:
                contador = 0
                for a, b in zip(palabra, palabra_actual):
                    if a == b:
                        contador += 1
                if contador == coincidencias:
                    nuevas_posibles.append(palabra)
            
            posibles_palabras = nuevas_posibles"
"class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        # Dealing special case: 1.
        if n == 1:
            return True
        # If n is an odd, it is not a number that is power of three.
        # Also, eliminating those number did not have any factor of 3.
        elif n % 2 == 0 or n % 3 != 0:
            return False
        else:
            return power_of_three(n)

def power_of_three(n):
    # Base Case
    if n == 3:
        return True
    # If n is not devided by 3, it's not a power of three number.
    elif n % 3:
        return False
    elif n < 3:
        return False
    # Recursive
    else:
        return power_of_three(n / 3)";"n = int(input(""Ingresa un número: ""))

if n <= 0:
    print(False)
else:
    while n % 3 == 0:
        n = n // 3
    if n == 1:
        print(True)
    else:
        print(False)"
"class Solution:
    def pushDominoes(self, dominoes: str) -> str:
        condensed = []
        
        index = 0
        currDir = dominoes[0]
        
        while index < len(dominoes) and dominoes[index] == currDir:
            index += 1
        
        count = index
                
        if index == len(dominoes):
            return dominoes
        elif currDir == '.' and dominoes[index] == 'L':
            currDir = dominoes[index]
            
            while index < len(dominoes) and dominoes[index] == currDir:
                index += 1
        
        condensed.append(currDir * index)
        count = 1
        
        if index == len(dominoes):
            return ''.join(condensed)
        
        currDir = dominoes[index]
        index += 1
        
        while index < len(dominoes):
            if dominoes[index] == currDir:
                count += 1
            else:
                if currDir == '.':
                    condensed.append([currDir, count])
                elif type(condensed[-1]) is not list:
                    condensed.append(currDir * count)
                else:
                    dotCount = condensed.pop()[1]
                    prevDir = condensed[-1][0]

                    if prevDir == currDir:
                        condensed.append(condensed.pop() + currDir * (dotCount + count))
                    elif prevDir == 'L':
                        condensed.append('.' * dotCount)
                        condensed.append(currDir * count)
                    else:
                        halfCount = dotCount // 2
                        hasExtraDot = halfCount*2 != dotCount
                        condensed.append(prevDir * halfCount)
                        if hasExtraDot:
                            condensed.append('.')
                        condensed.append(currDir * (halfCount + count))
                        
                currDir = dominoes[index]
                count = 1
                
            index += 1
        
        if condensed:
            if currDir == '.':            
                dotCount = count
                prevDir = condensed[-1][0]

                if prevDir == 'L':
                    condensed.append(currDir * dotCount)
                else:                
                    condensed.append(prevDir * dotCount)
            elif type(condensed[-1]) is list:
                dotCount = condensed.pop()[1]            
                
                if not condensed:
                    if currDir == 'L':
                        condensed.append(currDir * (dotCount + count))
                    else:
                        condensed.append('.' * dotCount)
                        condensed.append(currDir * count)
                else:
                    prevDir = condensed[-1][0]
                    
                    if prevDir == currDir:
                        condensed.append(condensed.pop() + currDir * (dotCount + count))
                    elif prevDir == 'L':
                        condensed.append('.' * dotCount)
                        condensed.append(currDir * count)
                    else:
                        halfCount = dotCount // 2
                        hasExtraDot = halfCount*2 != dotCount
                        condensed.append(prevDir * halfCount)
                        if hasExtraDot:
                            condensed.append('.')
                        condensed.append(currDir * (halfCount + count))
            else:
                condensed.append(currDir * count)
        else:
            condensed.append(currDir * count)
        
        return ''.join(condensed)";"dominoes = input(""Ingresa el estado inicial de los dominós: "")
n = len(dominoes)
fuerzas = [0] * n
resultado = list(dominoes)

fuerza = 0
for i in range(n):
    if dominoes[i] == 'R':
        fuerza = n
    elif dominoes[i] == 'L':
        fuerza = 0
    else:
        fuerza = max(fuerza - 1, 0)
    fuerzas[i] += fuerza

fuerza = 0
for i in range(n - 1, -1, -1):
    if dominoes[i] == 'L':
        fuerza = n
    elif dominoes[i] == 'R':
        fuerza = 0
    else:
        fuerza = max(fuerza - 1, 0)
    fuerzas[i] -= fuerza

for i in range(n):
    if fuerzas[i] > 0:
        resultado[i] = 'R'
    elif fuerzas[i] < 0:
        resultado[i] = 'L'
    else:
        resultado[i] = '.'

print(''.join(resultado))"
"class Solution:
    #Time-Complexity: O(n^2)
    #Space-Complexity: O(n)
    def integerBreak(self, n: int) -> int:
        #we know we can reduce n as 
        # n
    #   /  \
    #  1   n-1
    #     /  \
    #    1   n-2
    #     ...
    
        #Basically, we can keep reducing n like this in this tree structure above!
        #This is the pattern I recognized! I recognized for given n, there are 
        #potential sums of (1, n-1), (2, n-2), (3, n-3), ..., (n//2, n//2)!
        #For each pair, I can compare the direct number with the max product decomposition
        #and take the max of two!
        
        
        #Reason for comparison: for each of the sum factor of given n, either leave it
        #undecomposed or decompose it into further sum factors if the product of sum
        #factors produce ultimately a number that exceeds the orignal sum factor! This way
        #I am maximing product contribution for each and every sum factor!
        
        #For example, for 5, we decompose it into 2 and 3, since 2*3 > 5, so it will
        #maximize our product further!
        
        #However, for 3, we don't decompose since we can maximally decompose to
        #1 and 2 but 1*2 < 3!
        
        #Do that for both numbers of each pair and take the product!
        #Whatever is largest across the pairs will be answer for given input n!
    
        dp = [-1] * (n+1)
        #add dp-base!
        dp[1] = 1
    
        #this problem has only one state parameter: the given number to start decomposing           #from!
        #iterate through each subproblem or state!
        #Bottom-Up
        for i in range(2, n+1, 1):
            upper_bound = (i // 2) + 1
            #iterate through all possible pairs!
            for j in range(1, upper_bound, 1):
                #current pair (j, i-j), which we probably already solved its subproblems!
                first = max(j, dp[j])
                second = max(i-j, dp[i-j])
                #get product for current pair!
                sub_ans = first * second
                #compare current pair's product against built up answer maximum!
                dp[i] = max(dp[i], sub_ans)
    
        #then, once we are done, we can return dp[n]!
        return dp[n]";"n = int(input(""Ingresa un número entero: ""))

if n == 2:
    resultado = 1
elif n == 3:
    resultado = 2
else:
    producto = 1
    while n > 4:
        producto *= 3
        n -= 3
    resultado = producto * n

print(""El producto máximo es:"", resultado)"
"class Solution:
    def catMouseGame(self, graph: List[List[int]]) -> int:
        n = len(graph)
        
        @cache
        def fn(i, m, c): 
            """"""Return """"""
            if i == 2*n: return 0 # tie 
            if m == 0: return 1 # mouse wins
            if m == c: return 2 # cat wins 
            if i&amp,1: # cat's turn 
                tie = 0 
                for cc in graph[c]: 
                    if cc != 0: 
                        x = fn(i+1, m, cc)
                        if x == 2: return 2 
                        if x == 0: tie = 1
                if tie: return 0 
                return 1
            else: # mouse's turn 
                tie = 0 
                for mm in graph[m]: 
                    x = fn(i+1, mm, c)
                    if x == 1: return 1 
                    if x == 0: tie = 1
                if tie: return 0
                return 2 
        
        return fn(0, 1, 2)";"def juego_raton_gato(grafo):
    tamaño = len(grafo)
    cola = []
    ganador = [[[0 for _ in range(tamaño)] for __ in range(tamaño)] for ___ in range(2)]
    
    for i in range(tamaño):
        for t in range(2):
            ganador[t][i][i] = 2
            ganador[t][0][i] = 1
            cola.append((t, i, i))
            cola.append((t, 0, i))
    
    movimientos = []
    for m in range(tamaño):
        for c in range(tamaño):
            if c != 0:
                movimientos.append((1, m, c))
    
    while cola:
        turno, raton, gato = cola.pop(0)
        for movimiento in movimientos:
            if turno == 1:
                nuevo_raton = movimiento[1]
                nuevo_gato = movimiento[2]
                if raton in grafo[nuevo_raton]:
                    if ganador[0][nuevo_raton][nuevo_gato] == 0:
                        if ganador[turno][raton][gato] == 1:
                            ganador[0][nuevo_raton][nuevo_gato] = 1
                            cola.append((0, nuevo_raton, nuevo_gato))
                        else:
                            contador = 0
                            for vecino in grafo[nuevo_raton]:
                                if ganador[1][vecino][nuevo_gato] != 2:
                                    contador += 1
                            if contador == 0:
                                ganador[0][nuevo_raton][nuevo_gato] = 2
                                cola.append((0, nuevo_raton, nuevo_gato))
            else:
                nuevo_raton = movimiento[1]
                nuevo_gato = movimiento[2]
                if gato in grafo[nuevo_gato] and nuevo_gato != 0:
                    if ganador[1][nuevo_raton][nuevo_gato] == 0:
                        if ganador[turno][raton][gato] == 2:
                            ganador[1][nuevo_raton][nuevo_gato] = 2
                            cola.append((1, nuevo_raton, nuevo_gato))
                        else:
                            contador = 0
                            for vecino in grafo[nuevo_gato]:
                                if vecino != 0:
                                    if ganador[0][nuevo_raton][vecino] != 1:
                                        contador += 1
                            if contador == 0:
                                ganador[1][nuevo_raton][nuevo_gato] = 1
                                cola.append((1, nuevo_raton, nuevo_gato))
    
    return ganador[0][1][2]"
"class Solution:
    def isPathCrossing(self, path: str) -> bool:
        #Store the directions(key) with their corresponding actions(values)
        directions = {'N': [0,1], 'E':[1,0], 'W':[-1,0], 'S':[0,-1]}
        
        #Keep the track of visited points
        visited = set()
        
        #Add the initial point from where you're starting
        visited.add((0,0))
        
        #Current trackers of x and y coordinates
        curr_x,curr_y = 0,0
        
        #Loop through all the path
        for i in path:
            curr_x += directions[i][0]
            curr_y += directions[i][1]
            
            #If visited for first time, add them to visited
            if (curr_x,curr_y) not in visited:
                visited.add((curr_x,curr_y))
            else:
                return True #Else return True
            
        return False #Return True if there is no re-visiting";"def camino_se_cruza(camino):
    visitados = set()
    x = 0
    y = 0
    visitados.add((x, y))
    
    for direccion in camino:
        if direccion == 'N':
            y += 1
        elif direccion == 'S':
            y -= 1
        elif direccion == 'E':
            x += 1
        elif direccion == 'W':
            x -= 1
        
        if (x, y) in visitados:
            return True
        visitados.add((x, y))
    
    return False"
"class Solution:
    def winnerSquareGame(self, n: int) -> bool:
        @cache
        def doIWin(n, isAlice):
            if n == 0: return False # I lost, i cannot pick anything more :(
            sqr = 1
            while sqr*sqr <= n:
                if False == doIWin(n-sqr*sqr, 1 ^ isAlice):
                    # i forced my opponent to lose :)
                    return True
                
                sqr += 1
            
            
            # I did not find any way to make opponent lose..
            return False
        
        return doIWin(n, True)
        """"""
        No need of 'isAlice' :)
        Just makes the code cleaner?
        """"""

		@cache
        def doIWin(n):
            if n == 0: return False # I lost, i cannot pick anything more :(
            sqr = 1
            while sqr*sqr <= n:
                if False == doIWin(n-sqr*sqr):
                    # i forced my opponent to lose :)
                    return True
                
                sqr += 1
            
            
            # I did not find any way to make opponent lose..
            return False
        
        return doIWin(n)

		# final optimization.. travel backwards from sqrt to 1 :)
        @cache
        def doIWin(n):
            if n == 0: return False # I lost, i cannot pick anything more :(
            sqr = floor(sqrt(n))
            while sqr:
                if not doIWin(n-sqr*sqr):
                    # i forced my opponent to lose :)
                    return True
                
                sqr -= 1
            
            # I did not find any way to make opponent lose..
            return False
        
        return doIWin(n)";"def juego_piedras(n):
    if n == 0:
        return False
    gana = [False] * (n + 1)
    for i in range(1, n + 1):
        j = 1
        while j * j <= i:
            if not gana[i - j * j]:
                gana[i] = True
                break
            j += 1
    return gana[n]"
"class Solution:
    def knightDialer1(self, n: int) -> int:
        # observe pattern of knight moves and store in lookup table

        # 0 -> 4, 6
        # 1 -> 6, 8
        # 2 -> 7, 9
        # 3 -> 4, 8
        # 4 -> 3, 9, 0
        # 5 -> -
        # 6 -> 1, 7, 0
        # 7 -> 2, 6
        # 8 -> 1, 3
        # 9 -> 2, 4

        # approach #1: recursive with memo
        # helper function takes (curr, left),
        # returns number of possible moves based on (curr)ent value and moves (left)
        # if left is 1, return 1
        # otherwise, recursive call into next value based on lookup dict

        lut = { 0 : [4,6],
                1 : [6,8],
                2 : [7,9],
                3 : [4,8],
                4 : [0,3,9],
                5 : [],
                6 : [0,1,7],
                7 : [2,6],
                8 : [1,3],
                9 : [2,4] }

        def hlpr(curr: int, left: int) -> int:
            if left == 1: return 1
            if (curr, left) in memo: return memo[(curr, left)]

            res = 0
            for next in lut[curr]:
                res += hlpr(next, left-1)

            memo[(curr, left)] = res
            return res

        # setup and recursive call
        memo = {}
        res = 0
        for i in [0,1,2,3,4,5,6,7,8,9]:
            res += hlpr(i, n)
        return res % (10**9 + 7)

    def knightDialer2(self, n: int) -> int:
        # tabulate the solution above
        # two dimensional table
        # dp[i][j] is total moves starting from j, with i moves left
        # curr, which can be from 0-9 (cols)
        # left, which is strictly decreasing (rows)
        # O(N) time and space

        lut = { 0 : [4,6],
                1 : [6,8],
                2 : [7,9],
                3 : [4,8],
                4 : [0,3,9],
                5 : [],
                6 : [0,1,7],
                7 : [2,6],
                8 : [1,3],
                9 : [2,4] }

        dp = [[0 for _ in range(10)] for __ in range(n)]

        for i in range(10):
            dp[0][i] = 1

        for i in range(1,n):
            for j in range(10):
                tmp = 0
                for next in lut[j]:
                    tmp += dp[i-1][next]
                dp[i][j] += tmp

        return sum(dp[-1]) % (10**9 + 7)

    def knightDialer(self, n: int) -> int:
        # last trick, only need a single row of array rather than N rows
        # dp[i] represents total moves starting from i
        # make a copy of current dp row, and refer to that
        # using the actual dp row to store subproblem result
        # O(N) time, O(1) space

        lut = { 0 : [4,6],
                1 : [6,8],
                2 : [7,9],
                3 : [4,8],
                4 : [0,3,9],
                5 : [],
                6 : [0,1,7],
                7 : [2,6],
                8 : [1,3],
                9 : [2,4] }

        dp = [1 for _ in range(10)]

        for _ in range(1,n):
            last = dp[:]

            for j in range(10):
                tmp = 0
                for next in lut[j]:
                    tmp += last[next]
                dp[j] = tmp

        return sum(dp) % (10**9 + 7)";"mod = 10**9 + 7

def caballo_telefono(n):
    if n == 0:
        return 0
    if n == 1:
        return 10
    
    saltos = {
        0: [4, 6],
        1: [6, 8],
        2: [7, 9],
        3: [4, 8],
        4: [0, 3, 9],
        5: [],
        6: [0, 1, 7],
        7: [2, 6],
        8: [1, 3],
        9: [2, 4]
    }
    
    dp_actual = [1] * 10
    dp_actual[5] = 0
    
    for _ in range(n - 1):
        dp_siguiente = [0] * 10
        for numero in range(10):
            for siguiente in saltos[numero]:
                dp_siguiente[siguiente] = (dp_siguiente[siguiente] + dp_actual[numero]) % mod
        dp_actual = dp_siguiente
    
    total = 0
    for count in dp_actual:
        total = (total + count) % mod
    
    return total"
"class Solution:
    def stoneGameII(self, piles: List[int]) -> int:
        n = len(piles)
        dp = {} 
        def recursion(index,M):
            # if we reached to the end we cannot score any value
            if index == n:
                return 0
            # we search if we have solved the same case earlier
            if (index,M) in dp:
                return dp[(index,M)] 
            # total remaining score is the sum of array from index to the end
            total = sum(piles[index:])           
            # if we can take the complete array it is the best choice
            if index + 2*M >= n :return total
            # my_score is the score we are getting as the player who is playing
            my_score = 0
            for x in range(index,index+2*M):
                # opponent score will be calculated by next recursion
                opponent_score = recursion(x+1,max(M,x-index+1))
                # my_score is the remaining value of total - opponent_score
                my_score = max(my_score,total - opponent_score)          
            # this is memoization part
            dp[(index,M)] = my_score
            # return the score
            return my_score
        
        return recursion(0,1)";"def juego_de_pilas(pilas):
    n = len(pilas)
    dp = [[[ -1 for _ in range(n + 1)] for __ in range(n)] for ___ in range(n)]
    
    def dfs(indice, M, es_alice):
        if indice >= n:
            return 0
        if dp[indice][M][es_alice] != -1:
            return dp[indice][M][es_alice]
        
        max_piedras = 0 if es_alice else float('inf')
        total = 0
        
        for X in range(1, 2 * M + 1):
            if indice + X > n:
                break
            total += pilas[indice + X - 1]
            if es_alice:
                piedras = total + dfs(indice + X, max(M, X), not es_alice)
                if piedras > max_piedras:
                    max_piedras = piedras
            else:
                piedras = dfs(indice + X, max(M, X), not es_alice)
                if piedras < max_piedras:
                    max_piedras = piedras
        
        dp[indice][M][es_alice] = max_piedras
        return max_piedras
    
    return dfs(0, 1, True)"
"class Solution:
    def countBits(self, n: int) -> List[int]:
        #knowing the number of 1-bits in bin. rep of lower values of i than the current i
        #can have to solve current subproblem for i, since if i is odd,
        #number of 1 bits for i = number of 1 bits for previous number(even) + 1
        #number of 1 bits for i if it is even and power of 2 = 1
        #number of 1 bits for i if it not power of 2 but even = number of 
        #largest powers of 2 even numbers I can use to sum up to i!
        #Ex. 6 = 4 + 2 -> used 2 powers of 2 = need 2 1-bits in bin. rep of 6!
        #Ex. 7 = 6 + 1 -> 6 uses 2 1-bits so 7 requires 2+1 = 3 1-bits in its bin. rep!
        
        #I showed with above examples that this problem demonstrates optimal substructure
        #property! -> Might be useful in bottom-up solve for lower values of state
        #parameter i and work your way in inc. order -> State parameter i corresponds
        #to each and every index of ans array length n+1!
        
        #also, we may need to refer to same number multiple times while
        #building up our solution -> Overlapping subproblem property satisfied!
        
        
        #Let me first attempt recursive approach!
        #I know I will face TLE so let's add dp memo for memoization!
        dp = [-1] * (n+1)
        #base cases
        if(n == 0):
            return [0]
        if(n == 1):
            return [0, 1]
        
        #add a memo base case
        if(dp[n] != -1):
            return dp[n]
        
        #for n>1, array with at least 3 elements!
        
        #check if n is even and is power of 2!
        #if it is power of 2, taking bitwise and with itself and one less in value
        #bin. rep should produce all 0-bits1
        if(n % 2 == 0 and (n &amp, n-1) == 0):
            #answer will be array from recursive call on n-1 plus the 1 1-bit required
            #for base 2 power even numbered n!
            dp[n] = self.countBits(n-1) + [1]
            return  self.countBits(n-1) + [1]
        #last index n is odd case!
        if(n%2 != 0):
            recurse = self.countBits(n-1)
            num_bits_prev_num = recurse[-1]
            dp[n] = recurse + [num_bits_prev_num + 1]
            return recurse + [num_bits_prev_num + 1]
        
        #last case: even number n not power of 2!
        else:
            #as long as we didn't reduce n!
            i = 2
            ans = 0
            while n:
                if((n - i) &amp, (n-i-1) == 0):
                    n -= (n-i)
                    i = 2
                    continue
                else:
                    i += 2
            dp[n] = self.countBits(n-1) + [ans]
            return self.countBits(n-1) + [ans]";"n = int(input(""Ingrese el valor de n: ""))
respuesta = [0] * (n + 1)

for i in range(n + 1):
    num = i
    contador = 0
    while num > 0:
        if num % 2 == 1:
            contador += 1
        num = num // 2
    respuesta[i] = contador

print(respuesta)"
"class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        
        #Create a dictionary which will store the frequency of each of character 
        d={}  
        
        #iterate over all the characters in the string 's' 
        for element in s:
            if element in d:
                #increse the frequency count by 1 if it is already there in the dictionary 'd'
                d[element]+=1
            else:
                #initiate that element frequency by 1 in the 'd' if it is not there previously.
                d[element]=1
                
        #iterate over all the characters in the string 't'
        for element in t:
            if element in d:
        #decrease the frequency count by 1 so as to check the same frequency count of each character
                d[element]-=1
            else:
                #if the element is not there in the dictionary that means that particular element is not there in the string 's' which tends the result to False
                return False
        for key,value in d.items():
            if value!=0:
            #Return False if the any of element value is not 0 after cancelling their each occurence from both side 's' and 't'
                return False
        return True";"def es_anagrama(s, t):
    if len(s) != len(t):
        return False
    
    conteo_s = {}
    conteo_t = {}
    
    for letra in s:
        if letra in conteo_s:
            conteo_s[letra] += 1
        else:
            conteo_s[letra] = 1
    
    for letra in t:
        if letra in conteo_t:
            conteo_t[letra] += 1
        else:
            conteo_t[letra] = 1
    
    return conteo_s == conteo_t"
"class Solution:
    def decodeString(self, s: str) -> str:
        #base case: single character that's not a number!
        if(len(s) == 1 and s.isdigit() == False and s[0] != '[' and s[0] != ']'):
            return s
        
        #otherwise, we need to intialize the ans variable which we will return at the end!
        ans = """"
        i = 0
        
        current_num = """"
        #iterate through each and every char until it goes out of bounds!
        while i < len(s):
            cur = s[i]
            #append stand alone characters!
            if(cur.isdigit() == False and cur != '[' and cur != ']'):
                ans += cur
                i += 1
                continue
            #otherwise, the other case we have to take account is if
            #current character is number, in which we have to decode
            #in recursive manner!
            if(cur.isdigit()):
                current_num += cur
                i += 1
                continue
            if(cur == '['):
                num = int(current_num)
                #we have to find index positions of all characters
                #between open and closed brackets -> recurse over
                #those characters in substring -> append to ans
                #the result num times!
                
                #to know when we reached the appropriate closing char,
                #we can use a stack!
                
                #push initial opening char!
                stack = ['[']
                #since i assume input is valid, there gaurantees
                #corresponding closing char!
                #start index = i + 2 since i+1th index is bracket char!
                start = i+1
                while stack:
                    if(s[start] == '['):
                        stack.append('[')
                    if(s[start] == ']'):
                        stack.pop()
                    start += 1
                #once we exit, we know range of chars to recurse over!
                #it will go from index i +2 to index start - 2!
                recurse = self.decodeString(s[i+1:start - 1])
                #add to answer num times the rec. call!
                for i in range(num):
                    ans += recurse
                #update i to index start since start points to first char after the closing bracket of
                #current decoded string!
                i = start
                current_num = """"
                continue
                
        return ans";"def decodificar_cadena(cadena):
    pila = []
    cadena_actual = """"
    numero_actual = 0
    
    for caracter in cadena:
        if caracter.isdigit():
            numero_actual = numero_actual * 10 + int(caracter)
        elif caracter == '[':
            pila.append((cadena_actual, numero_actual))
            cadena_actual = """"
            numero_actual = 0
        elif caracter == ']':
            cadena_anterior, num = pila.pop()
            cadena_actual = cadena_anterior + cadena_actual * num
        else:
            cadena_actual += caracter
    
    return cadena_actual"
"class Solution:
    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:
        capital_profit = defaultdict(list)
        for p, c in zip(profits, capital):
            insort_left(capital_profit[c], p)
        sorted_capital = sorted(capital_profit.keys())
        if sorted_capital[-1] <= w and k == len(profits):
            return w + sum(profits)
        for _ in range(k):
            max_key, max_profit = -inf, -inf
            for key in sorted_capital:
                if key <= w:
                    if capital_profit[key][-1] > max_profit:
                        max_key, max_profit = key, capital_profit[key][-1]
                else:
                    break
            if max_profit > -inf:
                w += max_profit
                capital_profit[max_key].pop()
                if not capital_profit[max_key]:
                    capital_profit.pop(max_key)
                    sorted_capital.remove(max_key)
            else:
                break
        return w";"def encontrar_maximo_capital(k, w, beneficios, capitales):
    proyectos = list(zip(capitales, beneficios))
    proyectos.sort()
    indice = 0
    n = len(proyectos)
    heap = []
    import heapq
    
    for _ in range(k):
        while indice < n and proyectos[indice][0] <= w:
            heapq.heappush(heap, -proyectos[indice][1])
            indice += 1
        if not heap:
            break
        w += -heapq.heappop(heap)
    
    return w"
"class Solution:
    def candy(self, ratings: List[int]) -> int:
        # Analogy:
        # \   /    \
        #  \ / \  / \ /
        #   v   v    v  v
        #
        # Distribute candies such that it looks
        # like a bunch of troughs of varying heights aligned
        # side by side. Where the base of the troughs (v) are
        # the lowest rated children, and the heights of its
        # sides (\ or /) are the children with incrementally better
        # ratings
        
        # Problem is essentially looking for the next lowest ratings
        # and distributing candies in larger increments to the left
        # side and the right side IF their current rating is
        # greater than their previous rating
        
        # Use a priority queue to identify the lowest ratings
        heapq = [(ratings[i], i) for i in range(len(ratings))]
        heapify(heapq)
        
        # Array of candies parallel to the array of ratings of the child
        # where candies[i] represents the amount of candies the child at
        # ratings[i] will have
        candies = [1 for _ in range(len(ratings))]
        
        while(heapq):
            base = heappop(heapq) # Get next lowest rating
            
            # If the candy count has been modified, then it indicates
            # that this child isn't part of the lowest rating. We
            # only work with the lowest rating child (candy == 1), so skip
            if candies[base[1]] != 1:
                continue
            
            # Distribute candies to the left, when applicable
            curr = base[0]
            for i in range(base[1] - 1, -1, -1):
                # Give more candies when the current child has a greater
                # rating than the previous child AND when the current child
                # has fewer than or equal to the amount of candies than the
                # previous child
                #
                # The second condition is important since it will solve the
                # problem where the current child has already been
                # distributed candies, but may become overwritten in this new
                # distribution:
                # 
                # Distribute from lowest starting from left to right ========>
                # index:     0  1  2  3  4        0  1  2  3  4
                # ratings:  [1, 4, 3, 2, 1]  OR  [1, 2, 3, 4, 1]
                # candies:  [1, 2, 3, 2, 1]      [1, 2, 3, 4, 1]   
                #               ^                          ^
                # Solution: Let it overwrite WITH the larger amount of candies
                if ratings[i] > curr and candies[i] <= candies[i + 1]:
                    curr = ratings[i]
                    candies[i] = candies[i + 1] + 1
                else:
                    break
            
            # Distribute candies to the right, when applicable
            curr = base[0]
            for i in range(base[1] + 1, len(ratings)):
                # See line 41, same principle
                if ratings[i] > curr and candies[i] <= candies[i - 1]:
                    curr = ratings[i]
                    candies[i] = candies[i - 1] + 1
                else:
                    break
        
        return sum(candies)";"def caramelos(calificaciones):
    n = len(calificaciones)
    if n == 0:
        return 0
    
    caramelos = [1] * n
    
    for i in range(1, n):
        if calificaciones[i] > calificaciones[i - 1]:
            caramelos[i] = caramelos[i - 1] + 1
    
    for i in range(n - 2, -1, -1):
        if calificaciones[i] > calificaciones[i + 1]:
            if caramelos[i] <= caramelos[i + 1]:
                caramelos[i] = caramelos[i + 1] + 1
    
    return sum(caramelos)"
"class Solution:
    def convertToBase7(self, num: int) -> str:
        abs_num = abs(num)
        val = ''
        ans = ''
        while abs_num >= 7:# we want to add up every remainder until the dividend(num) equals to 7 or less than 7.
            val += str(abs_num % 7)
            abs_num = abs_num // 7
        val += str(abs_num % 7) # we add up the remainder first, then the quotient.
        val = val[::-1] # Revise its order.
        if num < 0: 
            ans += '-'
        ans += val
        return ans";"def a_base_7(numero):
    if numero == 0:
        return ""0""
    
    es_negativo = False
    if numero < 0:
        es_negativo = True
        numero = -numero
    
    resultado = """"
    while numero > 0:
        resto = numero % 7
        resultado = str(resto) + resultado
        numero = numero // 7
    
    if es_negativo:
        resultado = ""-"" + resultado
    
    return resultado"
"class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -> int:
        houses.sort()
        heaters.sort()
        total, size = len(houses), len(heaters)
		#dummy solution to check if heater with radius r, to cover all houses
        def valid_radius(r):
            house_offset = 0
            heater_offset = 0
            while house_offset < total:
                #case 1: current house is covered by current house, simply pass
                if abs(houses[house_offset] - heaters[heater_offset]) <= r:
                    house_offset += 1
                    continue
				#case 2 house cannot be covered, and locates on left side of heater, we can never find a heater to cover this house
                if houses[house_offset] < heaters[heater_offset]:
                    return False
                    break
				#case 3 go ahead to further heater, find the closest heater to cover the house or find no such heater valid
                while heater_offset < size and abs(houses[house_offset] - heaters[heater_offset]) > r:
                    heater_offset += 1
                if heater_offset >= size:return False
                if abs(houses[house_offset] - heaters[heater_offset]) <= r:
                    house_offset += 1
                    continue
                else:
                    return False
                    break
            return True
		#binary search to get radius
        low, high = 0, max(abs(heaters[0] - houses[0]), abs(heaters[0] - houses[-1]))
        mid = (low + high)//2
        while high - low > 1:
            if valid_radius(mid):
                high = mid
            else:low = mid
            mid = (low + high)//2

        return low if valid_radius(low) else high";"casas = [1, 2, 3]
calentadores = [2]

casas.sort()
calentadores.sort()

radio_minimo = 0
i = 0

for casa in casas:
    while i < len(calentadores) - 1 and abs(calentadores[i+1] - casa) <= abs(calentadores[i] - casa):
        i += 1
    distancia = abs(calentadores[i] - casa)
    if distancia > radio_minimo:
        radio_minimo = distancia

print(radio_minimo)"
"class Solution:
    def hIndex(self, citations: List[int]) -> int:
        """"""
        citations = [3,0,6,1,5]
        
        n : length of citations
        
        H - index defination: A scientist has an index h if h of their n 
        papers have at least h citations each, and the other n ? h papers 
        have no more than h citations each.
        
        [0, 0, 0, 0, 0, 0] we define a list of size n + 1
         0  1  2  3  4  5
        
        The above list will be used as a bucket which will keep the count
        of papers with i(index in the list) citations.
        
        citations[0] = 3 
        [0, 0, 0, 1, 0, 0]
         0  1  2  3  4  5
         
         citations[1] = 0
        [1, 0, 0, 1, 0, 0]
         0  1  2  3  4  5
         
         citations[2] = 6
        [1, 0, 0, 1, 0, 1] when cits for a paper is > 5 then put the value in n lst index
         0  1  2  3  4  5
         
         citations[3] = 1
        [1, 1, 0, 1, 0, 1]
         0  1  2  3  4  5
         
         citations[4] = 5
        [1, 1, 0, 1, 0, 2]
         0  1  2  3  4  5
         
         
         Find suffix sum of above list:
         [5, 4, 3, 3, 2, 2]  Find the larget index where index value(i) <= A[i]
          0  1  2  3  4  5
          
          which is 3
          ans : 3
        """"""
        
        n = len(citations)
        b = [0] * (n + 1)
        for i in range(n):
            b[min(citations[i], n)] += 1
        for i in range(n, -1, -1):
            if b[i] >= i:
                return i
            b[i - 1] += b[i]
        return -1";"citas = [3, 0, 6, 1, 5]
citas.sort(reverse=True)
h = 0
for i in range(len(citas)):
    if citas[i] >= i + 1:
        h = i + 1
    else:
        break
print(h)"
"class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        
        #Brute Force way of thinking
        #Generate all subarrays and as soon as we find the condition getting fulfilled, append it to our answer
        #Note - as per question, only 1 valid answer exists, so repetition will not be an issue
        #If at all there was repetition, it can be avoided by traversing as below
        #O(N^2) Time -- Accepted Solution
        

        n = len(nums)
        answer = list()
        for i in range(n):
            for j in range(i+1,n):
                if (nums[i] + nums[j] == target):
                    answer.append(i)
                    answer.append(j)
        return answer        

        
        #Let us try to optimize 
        
        #NOTE - We CANNOT SORT THIS array as we have to retrieve the indices and sorting it 
        #would change the original indices at which elements are present
        #If the given array would have already been sorted, this would have worked completely fine
        
        #if we fix one of the numbers as arr[i], so other would be arr[j] = (target - arr[i]) 
        #now, we simply have to see if this arr[j] exists in the given array or not
        #O(N) Time --- Accepted Solution (TAKEN HELP FROM DISCUSSION SECTION)
        
        #NOTE - Looking up an element in a dictionary is O(1) and not O(N) 
        
        n = len(nums)
        seen = {} #empty dictionary

        for index, value in enumerate(nums): 
            
            remaining = target - value 
            #here, value is nums[i]
            #we are looking for this remaining, which is nums[j] 
            #we have to find if remaining or nums[j] is present in the given array or not
            #this equation comes from the fact that as per question : 
            #nums[i] + nums[j] = target 
           
            if remaining in seen: 
                
                #if nums[j] is present in dictionary
                #just return index of nums[i] and nums[j] 
                return [index, seen[remaining]] 
                #index represents index of nums[i] and seen[remaining] will
                #hold index of nums[j]
            
            else: 
            #otherwise, add the value corresponding to its index in the dictionary
            #so, if it searched again, we can directly retrieve its index
                seen[value] = index";"def encontrar_indices(numeros, objetivo):
    for i in range(len(numeros)):
        for j in range(i + 1, len(numeros)):
            if numeros[i] + numeros[j] == objetivo:
                return [i, j]
    return []"
"class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        
        mp = {}
        count = 0
        
        # nested loop 1 
        for uno in nums1:
            for dos in nums2:
                # get = value for the key, value if you don't get it 
                # if uno+dos exists in hashmap, increment value 
                # else: increment with value 1 
                mp[uno + dos] = mp.get(uno + dos, 0) + 1
                
        # nested loop 2
        for tres in nums3:
            for quatro in nums4:
                # get(value for key, value if you don't get it)
                # getting hashmap value if the added number already exists in hashmap
                # if there is no complimentary value in the hashmap -> return 0 -> doesn't change count
                count += mp.get(-(tres + quatro), 0)
        # return mp
        return count";"nums1 = [1, 2]
nums2 = [-2, -1]
nums3 = [-1, 2]
nums4 = [0, 2]

contador = 0
n = len(nums1)

for i in range(n):
    for j in range(n):
        for k in range(n):
            for l in range(n):
                suma = nums1[i] + nums2[j] + nums3[k] + nums4[l]
                if suma == 0:
                    contador += 1

print(contador)"
"class Solution:
    def canWinNim(self, n: int) -> bool:        
        if n <= 3:
            return True
        new_size = n + 1
        memo = [False] * (new_size)
        
        for i in range(4): 
            memo[i] = True
        
        for i in range(4,new_size):
            for j in range(1,4):
                if memo[i] == True:
                    break
                if memo[i-j] == True:
                    memo[i] = False
                else:
                    memo[i] = True
        
        return memo[n]";"def puedes_ganar(n):
    if n % 4 == 0:
        return False
    else:
        return True

n = int(input(""Ingresa el número de piedras: ""))
resultado = puedes_ganar(n)
print(resultado)"
"class Solution:
    def sumGame(self, num: str) -> bool:
        n = len(num)
        q_cnt_1 = s1 = 0
        for i in range(n//2):    # get digit sum and question mark count for the first half of `num`
            if num[i] == '?':
                q_cnt_1 += 1
            else:    
                s1 += int(num[i])
        q_cnt_2 = s2 = 0				
        for i in range(n//2, n): # get digit sum and question mark count for the second half of `num`
            if num[i] == '?':
                q_cnt_2 += 1
            else:    
                s2 += int(num[i])
        s_diff = s1 - s2         # calculate sum difference and question mark difference
        q_diff = q_cnt_2 - q_cnt_1
        return not (q_diff % 2 == 0 and q_diff // 2 * 9 == s_diff) # When Bob can't win, Alice wins";"def juego_numeros(num):
    longitud = len(num)
    mitad = longitud // 2
    suma_izquierda = 0
    suma_derecha = 0
    interrogantes_izquierda = 0
    interrogantes_derecha = 0
    
    for i in range(mitad):
        if num[i] == '?':
            interrogantes_izquierda += 1
        else:
            suma_izquierda += int(num[i])
    
    for i in range(mitad, longitud):
        if num[i] == '?':
            interrogantes_derecha += 1
        else:
            suma_derecha += int(num[i])
    
    diferencia = suma_izquierda - suma_derecha
    interrogantes_total = interrogantes_izquierda + interrogantes_derecha
    
    if interrogantes_total == 0:
        return diferencia != 0
    
    if (interrogantes_izquierda + interrogantes_derecha) % 2 != 0:
        return True
    
    if diferencia == 0:
        return interrogantes_izquierda != interrogantes_derecha
    
    if abs(diferencia) != 9 * abs(interrogantes_izquierda - interrogantes_derecha) // 2:
        return True
    
    return False"
"class Solution:
#     Follow-up Solution DP Iterative, Time = O(N), Space = O(1), In-Place Algorithm
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        for lvl in range(len(triangle) - 2, -1, -1):
            for idx in range(len(triangle[lvl])):
                triangle[lvl][idx] += min(triangle[lvl + 1][idx], triangle[lvl + 1][idx + 1])
        return triangle[0][0]

#     DP Iterative, Time = O(N), Space = O(triangle)
#     def minimumTotal(self, triangle: List[List[int]]) -> int:
#         sum_cp = triangle
#         for lvl in range(len(triangle) - 2, -1, -1):
#             for idx in range(len(triangle[lvl])):
#                 sum_cp[lvl][idx] += min(sum_cp[lvl + 1][idx], sum_cp[lvl + 1][idx + 1])
#         return sum_cp[0][0]
        
#     DP Recursion, Time = O(N), Space = O(triangle)
#     def minimumTotal(self, triangle: List[List[int]]) -> int:
#         sum_dp = [[[False, 0] for j in range(len(triangle[i]))] for i in range(len(triangle))]
#         self.rec(triangle, sum_dp, 0, 0, len(triangle) - 1)
#         return sum_dp[0][0][1]
#     
#     def rec(self, triangle, sum_dp, lvl, idx, hgt):
#         if sum_dp[lvl][idx][0] == True:
#             return sum_dp[lvl][idx][1]
#         elif lvl == hgt:
#             sum_dp[lvl][idx][0] = True
#             sum_dp[lvl][idx][1] = triangle[lvl][idx]
#         else:
#             sum_dp[lvl][idx][0] = True
#             sum_dp[lvl][idx][1] = min(self.rec(triangle, sum_dp, lvl + 1, idx, hgt), self.rec(triangle, sum_dp, lvl + 1, idx + 1, hgt)) + triangle[lvl][idx]
#         return sum_dp[lvl][idx][1]
        
#     Simple Recursion, Time = O(2^N), Space = O(2^N), TLE
#     def minimumTotal(self, triangle: List[List[int]]) -> int:
#         return self.rec(triangle, 0, 0, len(triangle) - 1)
#         
#     def rec(self, triangle, lvl, idx, hgt):
#         if lvl == hgt:
#             return triangle[lvl][idx]
#         return min(self.rec(triangle, lvl + 1, idx, hgt), self.rec(triangle, lvl + 1, idx + 1, hgt)) + triangle[lvl][idx]";"def suma_minima_camino(triangulo):
    if not triangulo:
        return 0
    
    filas = len(triangulo)
    
    for fila in range(filas - 2, -1, -1):
        for i in range(len(triangulo[fila])):
            triangulo[fila][i] += min(triangulo[fila + 1][i], triangulo[fila + 1][i + 1])
    
    return triangulo[0][0]"
"class Solution:
    def racecar(self, target: int) -> int:
        q = [(0, 1)]
        steps = 0
        
        while q:
            num = len(q)
            for i in range(num):
                pos, speed = q.pop(0)
                if pos == target:
                    return steps
                q.append((pos+speed, speed*2))
                rev_speed = -1 if speed > 0 else 1
                if (pos+speed) < target and speed < 0 or (pos+speed) > target and speed > 0:
                    q.append((pos, rev_speed))
            steps += 1";"from collections import deque

def secuencia_instrucciones(objetivo):
    cola = deque()
    cola.append((0, 1))
    visitados = set()
    visitados.add((0, 1))
    pasos = 0

    while cola:
        for _ in range(len(cola)):
            posicion, velocidad = cola.popleft()

            if posicion == objetivo:
                return pasos

            # Instrucción 'A'
            nueva_pos = posicion + velocidad
            nueva_vel = velocidad * 2
            if (nueva_pos, nueva_vel) not in visitados:
                visitados.add((nueva_pos, nueva_vel))
                cola.append((nueva_pos, nueva_vel))

            # Instrucción 'R'
            if velocidad > 0:
                nueva_vel = -1
            else:
                nueva_vel = 1
            if (posicion, nueva_vel) not in visitados:
                visitados.add((posicion, nueva_vel))
                cola.append((posicion, nueva_vel))

        pasos += 1

    return -1"
"class Solution:
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
	
		# Recursive dfs. 
		# Accumulate the number as you traverse the tree and compare with targetSum
		# T: O(N)
		# S: O(N)
		
        return self.dfs(root, targetSum, 0)
        
    def dfs(self, root, targetSum, total):
        if not root:
            return False
        
        total += root.val
        #print(total)
        
        if not root.left and not root.right:
            return total == targetSum
        
        return self.dfs(root.left, targetSum, total) or self.dfs(root.right, targetSum, total) 
        
        
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        
        # Iterative DFS
		# Same logic
        # T: O(N)
        # S: O(N)
        
        if not root:
            return False
        
        stack = [root]
        total = root.val
        while stack:
            node = stack.pop()
            #print(node.val)
            if node.left:
                node.left.val += node.val
                stack.append(node.left)
                
            if node.right:
                node.right.val += node.val
                stack.append(node.right)
            
            if not node.right and not node.left:
                if node.val == targetSum:
                    return True
        return False
		
	def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        
        # Optimized recursive DFS
		# Instead of accumulation, we substract the value of node from the targetSum
        # T: O(N)
        # S: O(N)
        
        if not root:
            return False
        
        targetSum -= root.val
        if not root.left and not root.right:
            return targetSum == 0
        
        return self.hasPathSum(root.left, targetSum) or self.hasPathSum(root.right, targetSum)";"class Nodo:
    def __init__(self, valor=0, izquierda=None, derecha=None):
        self.valor = valor
        self.izquierda = izquierda
        self.derecha = derecha

def tiene_suma_ruta(raiz, suma_objetivo):
    if raiz is None:
        return False
    if raiz.izquierda is None and raiz.derecha is None:
        return raiz.valor == suma_objetivo
    suma_restante = suma_objetivo - raiz.valor
    return tiene_suma_ruta(raiz.izquierda, suma_restante) or tiene_suma_ruta(raiz.derecha, suma_restante)"
"class Solution:
    
    def modpow(self, a: int, b: int, m: int) -> int:
        """""" Compute a^b mod m with fast exponentiation""""""
        if b == 0:
            return 1
        r = self.modpow(a, b//2, m)
        if b % 2 == 0:
            return (r * r) % m
        else:
            return (a * r * r) % m
    
    def superPow(self, a: int, b: List[int]) -> int:
        m = 1337
        r = 1  # this will contain the final result
        base = a  # this is the starting base
        for e in b[::-1]:  # note that I will traverse the list backward
            r = (r * self.modpow(base, e, m)) % m
            base = self.modpow(base, 10, m)  #  updating base
            if base == 1:  # this trick will save computation: if you find a base==1 no need to compute more
                return r
        return r";"a = int(input(""Ingresa el valor de a: ""))
b_str = input(""Ingresa el valor de b como array (ej. [1,2,3]): "")
b_array = eval(b_str)

b = 0
for digito in b_array:
    b = b * 10 + digito

resultado = 1
for _ in range(b):
    resultado = (resultado * a) % 1337

print(resultado)"
"class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        # * merge sort constant space (bottom up)

        cnt = 0
        node = head
        while node is not None:
            node = node.next
            cnt += 1
        
        if cnt < 2:
            return head
        
        dummy = ListNode(-1)
        dummy.next = head

        merge_size = 1
        # merging all sublists with size <merge_size>
        # this loop will go on for log n times
        while merge_size < cnt:
            pre = dummy
            end = None
            i = 0
            # this loop takes O(n) time
            while cnt - i > merge_size:
                # find two sublists
                list0 = pre.next
                node = pre

                for _ in range(merge_size):
                    node = node.next
                
                i += merge_size
                
                # mark the break point
                mid = node
                
                for _ in range(min(merge_size, cnt - i)):
                    node = node.next

                i += min(merge_size, cnt - i)
                
                # break up the sublist from the nodes after it
                end = None
                if node is not None:
                    end = node.next
                    node.next = None
                
                # break the sublist into two parts
                list1 = mid.next
                mid.next = None

                # break the sublist from the nodes before it (optional)
                pre.next = None

                # merge the two sublists (and concatenate the new sublist to the nodes before)
                # the following steps take linear time because we are essentially concatenating nodes to ''pre''
                while list0 is not None and list1 is not None:
                    if list0.val < list1.val:
                        pre.next = list0
                        list0 = list0.next
                    else:
                        pre.next = list1
                        list1 = list1.next
                    
                    pre = pre.next
                
                pre.next = list0 if list0 is not None else list1
                while pre.next is not None:
                    pre = pre.next
                
                # concatenate these nodes to the rest
                pre.next = end

            merge_size <<= 1

        return dummy.next";"class Nodo:
    def __init__(self, valor=0, siguiente=None):
        self.valor = valor
        self.siguiente = siguiente

def ordenar_lista(cabeza):
    if cabeza is None or cabeza.siguiente is None:
        return cabeza
    
    lista = []
    actual = cabeza
    while actual is not None:
        lista.append(actual.valor)
        actual = actual.siguiente
    
    lista.sort()
    
    nueva_cabeza = Nodo(lista[0])
    actual = nueva_cabeza
    for valor in lista[1:]:
        actual.siguiente = Nodo(valor)
        actual = actual.siguiente
    
    return nueva_cabeza"
"class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:
        # Calculate the max time for a pig to test buckets...
        # Note that, max time will not be (minutesToTest / minutesToDie)...
        # Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...
        max_time = minutesToTest / minutesToDie + 1
        # Initialize the required minimum number of pigs...
        req_pigs = 0
        # To find the minimum number of pigs, find the minimum req_pigs such that Math.pow(max_time, req_pigs) >= buckets...
        while (max_time) ** req_pigs < buckets:
            # Increment until it will be greater or equals to bucket...
            req_pigs += 1
        # Return the required minimum number of pigs...
        return req_pigs";"buckets = int(input(""Ingresa el número de cubetas: ""))
minutos_para_morir = int(input(""Ingresa los minutos para morir: ""))
minutos_para_prueba = int(input(""Ingresa los minutos para la prueba: ""))

if buckets == 1:
    cerdos = 0
else:
    intentos = minutos_para_prueba // minutos_para_morir
    cerdos = 0
    while (intentos + 1) ** cerdos < buckets:
        cerdos += 1

print(cerdos)"
"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        lis=[]
        #First way to solve this question
        
        for val in range(1,n+1):
            #print(val%3, val%5)
            if (val%3==0 and val%5==0):
                lis.append(""FizzBuzz"")
            elif val%3==0:
                lis.append(""Fizz"")
            elif val%5==0:
                lis.append(""Buzz"")
            else:
                lis.append(str(val))
		return lis
        #Runtime: 88 ms, faster than 42.22% of Python3 online submissions for Fizz Buzz.
        #Memory Usage: 14.9 MB, less than 85.86% of Python3 online submissions for Fizz Buzz
        
        #Second way to solve this question
         
        for val in range(1,n+1):
            lis.append(""FizzBuzz"") if (val%3==0 and val%5==0) else (lis.append(""Fizz"") if val%3==0 else (lis.append(""Buzz"") if val%5==0 else lis.append(str(val)) ) )
        return lis,
         
        #Runtime: 87 ms, faster than 44.84% of Python3 online submissions for Fizz Buzz.
        #Memory Usage: 15.1 MB, less than 43.11% of Python3 online submissions for Fizz Buzz.
        
        #Third way to solve this solution
        
        # Learned this way to solve the question from https://leetcode.com/problems/fizz-buzz/discuss/2704645/Python-One-liner
        
        #Runtime: 96 ms, faster than 22.65% of Python3 online submissions for Fizz Buzz.
        #Memory Usage: 15.2 MB, less than 17.01% of Python3 online submissions for Fizz Buzz.
        return [ ""Fizz""*(val%3==0)+""Buzz""*(val%5==0) or f""{val}"" for val in range(1,n+1)]";"n = int(input(""Ingresa un número: ""))
respuesta = []

for i in range(1, n + 1):
    if i % 3 == 0 and i % 5 == 0:
        respuesta.append(""FizzBuzz"")
    elif i % 3 == 0:
        respuesta.append(""Fizz"")
    elif i % 5 == 0:
        respuesta.append(""Buzz"")
    else:
        respuesta.append(str(i))

print(respuesta)"
"class Solution:
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        """"""
        sort the start position.
        the car behind can only catch up no exceed.
        so if the car start late and speed is faster, it will catch up the car ahead of itself and they become a fleet.
        there is a target(or desitination),so use arrive time to measure. 
        
        start late but arrive ealier means the car is behind and will catch up before arriving the destination.
        
        position  10  8  5  3  0
        distance  2   4  7  9  12
        speed.    2   4  1  3  1
        time.     1   1  7  3  12
                      ^     ^
                      |     |
                     catch  catch up the previous car before target, join the fleet
		stack = [1] , [1],[1,7],[1,7][1,7,12] 			 
                                
        """"""
        stack = []
        for pos, v in sorted(zip(position, speed),reverse = True):

            dist = target - pos
            time = dist / v 
            
            if not stack:
                stack.append(time)
            elif time > stack[-1]:
                stack.append(time)

        return len(stack)";"objetivo = int(input(""Ingresa el objetivo en millas: ""))
n = int(input(""Ingresa el número de coches: ""))

posicion = []
velocidad = []

for i in range(n):
    pos = int(input(f""Ingresa la posición del coche {i+1}: ""))
    vel = int(input(f""Ingresa la velocidad del coche {i+1}: ""))
    posicion.append(pos)
    velocidad.append(vel)

pares = []
for i in range(n):
    pares.append((posicion[i], velocidad[i]))

pares.sort()

tiempos = []
for i in range(n):
    tiempo = (objetivo - pares[i][0]) / pares[i][1]
    tiempos.append(tiempo)

flotas = 0
max_tiempo = 0

for i in range(n-1, -1, -1):
    if tiempos[i] > max_tiempo:
        flotas += 1
        max_tiempo = tiempos[i]

print(""Número de flotas:"", flotas)"
"class MinStack:

    def __init__(self):
                
        self.Stack = []
        self.minVal = None
        

    def push(self, val: int) -> None:
        
        if not self.Stack or self.minVal == None:
            self.minVal = val
        
        
        if not self.Stack: 
            self.Stack.append(val)
        elif val < self.minVal: 
            self.Stack.append(2*val - self.minVal)
            self.minVal = val
        else: 
            self.Stack.append(val)
        

    def pop(self) -> None:
        
        if not self.Stack: 
            return
        elif self.Stack[-1] < self.minVal: 
            self.minVal = 2*self.minVal - self.Stack[-1]
            self.Stack.pop()
        else: 
            self.Stack.pop()
        

    def top(self) -> int:
        
        if self.Stack[-1] > self.minVal : 
            return self.Stack[-1]
        else: 
            return self.minVal
        

    def getMin(self) -> int:
        
        return self.minVal
        
        


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()";"class PilaMin:
    def __init__(self):
        self.pila = []
        self.pila_min = []

    def push(self, val):
        self.pila.append(val)
        if not self.pila_min or val <= self.pila_min[-1]:
            self.pila_min.append(val)

    def pop(self):
        if not self.pila:
            return
        val = self.pila.pop()
        if val == self.pila_min[-1]:
            self.pila_min.pop()

    def top(self):
        if not self.pila:
            return -1
        return self.pila[-1]

    def getMin(self):
        if not self.pila_min:
            return -1
        return self.pila_min[-1]"
"class Node:
    def __init__(self, key, val):
        self.val = val
        self.key = key
        self.prev = None
        self.nxt_ = None

# use a DL
class DLinked:
    def __init__(self):
        self.head = None
        self.tail = None
    
    def remove(self, node):
        """""" return the deleted node key
        """"""
        # 3 basic postion cases
        prev = node.prev
        nxt_  = node.nxt_
        
        # if the removing node is the single node in the list
        if prev is None and nxt_ is None:
            # eariler termination
            self.head = None
            self.tail = None
            return node.key
        
        # head node and not single, happy 2.14's day !
        if prev is None:
            self.head = nxt_
            nxt_.prev  = None
        
        # tail node not single
        elif nxt_ is None:
            self.tail = prev
            prev.nxt_ = None
            
        else:
            # mid node
            prev.nxt_ = nxt_
            nxt_.prev = prev
        
        # either way you should return the old key        
        return node.key
    
    def add(self, node):
        """""" return the node ref if added
        """"""
        # when head is None
        if self.head is None:
            self.head = node
        
            if self.tail is None:
                self.tail = node
        else:
            node.nxt_ = self.head
            node.prev = None
            self.head.prev = node
            self.head = node
        
        return self.head
    
    
class LRUCache:
    def __init__(self, capacity):
        self.cap = capacity
        self.table = {}
        self.dlinked = DLinked()
    
    def get(self, key):
        # also check key first
        node = self.table.get(key, None)
        if node is not None:
            # update hit
            self.dlinked.remove(node)
            self.dlinked.add(node)
            return node.val
        else:
            return -1
    
    def put(self, key, val):
        # let Dlinked class to handle add / remove
        # let cache class to handle capacity cases
        # use forward logic to make thing clear
        
        # no need to check cap first, instead, we need to check key in table or not.
		# becase if key exist, there is nothing to deal with the capacity
        node = self.table.get(key, None)
        if node is not None:
            # update key hit
            self.dlinked.remove(node)
            node.val = val  # same key overwrite
            self.dlinked.add(node)
			# return as soon as possible to prevent logic twists
            return
        
        # if key not in table, then we need to add key, hence we need to check capacity
        
        if len(self.table) == self.cap:
            # cache full, kill the tail and add to head
			# seperating the operations by returning the old key
            old_key = self.dlinked.remove(self.dlinked.tail)
            del self.table[old_key]
            node = self.dlinked.add(Node(key, val)) 
            self.table[key] = node
        else:    
            # cache not full, add directly
            node = self.dlinked.add(Node(key, val))
            self.table[key] = node

        return";"class Nodo:
    def __init__(self, clave, valor):
        self.clave = clave
        self.valor = valor
        self.siguiente = None
        self.anterior = None

class LRUCache:
    def __init__(self, capacidad):
        self.capacidad = capacidad
        self.diccionario = {}
        self.cabeza = Nodo(0, 0)
        self.cola = Nodo(0, 0)
        self.cabeza.siguiente = self.cola
        self.cola.anterior = self.cabeza

    def _agregar_nodo(self, nodo):
        siguiente = self.cabeza.siguiente
        self.cabeza.siguiente = nodo
        nodo.anterior = self.cabeza
        nodo.siguiente = siguiente
        siguiente.anterior = nodo

    def _eliminar_nodo(self, nodo):
        anterior = nodo.anterior
        siguiente = nodo.siguiente
        anterior.siguiente = siguiente
        siguiente.anterior = anterior

    def get(self, clave):
        if clave in self.diccionario:
            nodo = self.diccionario[clave]
            self._eliminar_nodo(nodo)
            self._agregar_nodo(nodo)
            return nodo.valor
        return -1

    def put(self, clave, valor):
        if clave in self.diccionario:
            nodo = self.diccionario[clave]
            self._eliminar_nodo(nodo)
        nuevo_nodo = Nodo(clave, valor)
        self.diccionario[clave] = nuevo_nodo
        self._agregar_nodo(nuevo_nodo)
        if len(self.diccionario) > self.capacidad:
            nodo = self.cola.anterior
            self._eliminar_nodo(nodo)
            del self.diccionario[nodo.clave]"
"class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:
        # 1,2,3,4,5 -> player 1
        # 2,3,4,5 -> player 2, choose any of them, cannot win
        # Then 1 win
        candidate = [i for i in range(1, maxChoosableInteger + 1)]

        if sum(candidate) < desiredTotal:
            return False
        
        memo = dict()
        def dfs(candidate, remain):
            if candidate[-1] >= remain:
                return True
            
            if tuple(candidate) in memo:
                return memo[tuple(candidate)]
            
            for i in range(len(candidate)):
                if not dfs(candidate[:i] + candidate[i + 1:], remain - candidate[i]):
                    memo[tuple(candidate)] = True
                    return True
            
            memo[tuple(candidate)] = False
            return False
                
        return dfs(candidate, desiredTotal)";"def puede_ganar(max_numero_elegible, total_deseado):
    if max_numero_elegible >= total_deseado:
        return True
    if (max_numero_elegible * (max_numero_elegible + 1)) // 2 < total_deseado:
        return False
    
    memo = {}
    
    def jugar(estado_disponible, total_actual):
        if total_actual >= total_deseado:
            return False
        clave = tuple(estado_disponible)
        if clave in memo:
            return memo[clave]
        
        resultado = False
        for numero in range(1, max_numero_elegible + 1):
            if not estado_disponible[numero - 1]:
                continue
            nuevo_estado = list(estado_disponible)
            nuevo_estado[numero - 1] = False
            if not jugar(nuevo_estado, total_actual + numero):
                resultado = True
                break
        memo[clave] = resultado
        return resultado
    
    estado_inicial = [True] * max_numero_elegible
    return jugar(estado_inicial, 0)"
"class Solution:
    # optimized prefix sum
    def gridGame(self, grid: List[List[int]]) -> int:
        n = len(grid[0])
        ans = math.inf
        topSum = sum(grid[0])
        bottomSum = 0

        for i in range(n):
            topSum -= grid[0][i]
            ans = min(ans, max(topSum, bottomSum))
            bottomSum += grid[1][i]

        return ans

    # neetcode's prefix sum method
    def gridGame(self, grid: List[List[int]]) -> int:
        res = float('inf') # max value
        prefixSum1 = [grid[0][0]]
        prefixSum2 = [grid[1][0]] # has the first value done so that we can iterate more smoothly
        length = len(grid[0])

        for i in range(1, length): # from 1 to end because we don't want to deal with an out of bounds error
            prefixSum1.append(grid[0][i] + prefixSum1[i-1]) # doing it this way bc it seems faster but you really just want to calculate the prefix sums of each row and save it to the index
            prefixSum2.append(grid[1][i] + prefixSum2[i-1])
        for i in range(length): # so here we want to calculate the turning point of the first robot
            # calculate the values excluding the current index
            top_row = prefixSum1[-1] - prefixSum1[i] # so total - the current index (which is the accumulated value of the left side, index inclusive)
            bottom_row = prefixSum2[i-1] if i > 0 else 0 # bounds checking here bc 0-1 is -1 and that is not the right place to be.
            current = max(top_row, bottom_row) # take the max values of this index that the second robot can grab
            res = min(res, current) # the first robot is a bad robot so we want to take the minimum values of all the maxes that we calculate and this here is O(1) space complexity instead of saving it all to an array. In taking the minimum, we take thus maximize robot 1's take and robot 2's take per the properties.
        return res



    # simple solution (runs out of time due to not storing the calculations)
    def gridGame(self, grid: List[List[int]]) -> int:

        # this is the simpler code but it doesn't work because of a time limit problem. simply having the prefix sum's already calculated makes this problem ultra efficient
        res = float('inf') # max
        length = len(grid[0])
        for i in range(length): # check each index of the array
            # take the sum of everything after the index on the top row and before the index on the bottom row
            top = sum(grid[0][i+1:])
            bot = sum(grid[1][:i])
            current = max(top, bot) # max of robot 2's take if robot 1 were to turn at this specific index
            res = min(res, current) # determines robot 2's real take that would maximize robot 1's take
        return res";"n = len(grid[0])
suma_arriba = [0] * n
suma_abajo = [0] * n

suma_arriba[0] = grid[0][0]
for i in range(1, n):
    suma_arriba[i] = suma_arriba[i-1] + grid[0][i]

suma_abajo[n-1] = grid[1][n-1]
for i in range(n-2, -1, -1):
    suma_abajo[i] = suma_abajo[i+1] + grid[1][i]

max_puntos = 0
for i in range(n):
    puntos = max(suma_arriba[i] + suma_abajo[i], suma_arriba[i] + suma_abajo[i])
    if puntos > max_puntos:
        max_puntos = puntos

print(max_puntos)"
"class Solution:
    def canCross(self, stones: List[int]) -> bool:
        jump_mods = [-1,0,1]
        stone_ref = {}
        prev = 0
        
        # Make dictionary of the indexes of each stone
        for i,stone in enumerate(stones):
            stone_ref[stone] = i
            
            # if any stone is further away from the previous one than its index,
            # it is unreachable in all scenarios and we can return False early
            if stone-prev > i:
                return False
            
            prev = stone
        
        stack = [(0,0)]
        seen = set()    
        
        # DFS
        while stack:
            jump,stone = stack.pop()
            
            seen.add((jump,stone))
            
            # Return true if we reached our goal
            if stone == stones[-1]:
                return True
            
            # Go through each of the jump modifiers to see if any of them result in the following conditions:
            # 1) There is a stone that matches the current stone's value plus that modified jump value
            # 2) The index of that matching stone is greater than the index that the frog is currently on
            # 3) We have not visited that stone with the same jump value in the past
            for mod in jump_mods:
                if stone+jump+mod in stone_ref and stone_ref[stone+jump+mod] > stone_ref[stone]:
                    if (jump+mod,stone+jump+mod) not in seen:
                        stack.append((jump+mod,stone+jump+mod))
        return False";"piedras = [0,1,3,5,6,8,12,17]
ultima_piedra = piedras[-1]
saltos_posibles = {0: {0}}

for piedra in piedras:
    if piedra in saltos_posibles:
        for salto in saltos_posibles[piedra]:
            for siguiente_salto in [salto - 1, salto, salto + 1]:
                if siguiente_salto > 0:
                    siguiente_piedra = piedra + siguiente_salto
                    if siguiente_piedra in piedras:
                        if siguiente_piedra not in saltos_posibles:
                            saltos_posibles[siguiente_piedra] = set()
                        saltos_posibles[siguiente_piedra].add(siguiente_salto)

if ultima_piedra in saltos_posibles and len(saltos_posibles[ultima_piedra]) > 0:
    print(True)
else:
    print(False)"
"class Solution:
    def findNthDigit(self, n: int) -> int:
        """"""
        imagine the number you need to find have 4 digit
        so you need to go throught all num have 1 digit, 2 digit, 3 digit
        number have 1 digit:  10 ** 1 - 1 = 9 => 9 * 1 = 9 digit
        number have 2 digit:  10 ** 2 - 1 = 90 => 90 * 2 = 180 digit
        number have 3 digit:  10 ** 3 - 1 = 900 => 900 * 3 = 2700 digit
        ...
        just subtract until you find how many digit of the number you need to find
        when you got the number of digit 
        """"""
        if n < 10:
            return n
        
        number_of_digit = 0 # check how many digit of the number you need to find
        while n > 0:
            number_of_digit += 1
            n -= 9 * 10 ** ((number_of_digit - 1)) * number_of_digit
        n += 9 * 10 ** ((number_of_digit - 1)) * number_of_digit
        
        """""" 
        print(n , number_of_digit) if you dont understand 
        after subtract you will find number of digit
        all you need to do now is find exactly number by just a little bit of math
        """""" 
        tmp_num = 0
        
        if n % number_of_digit == 0:
            n //= number_of_digit 
            tmp_num += 10 ** ((number_of_digit - 1)) - 1
            return int(str(tmp_num + n)[-1])
        else:
            n /= number_of_digit
            digit = int((n * number_of_digit) % number_of_digit)
            tmp_num += 10 ** ((number_of_digit - 1)) - 1
            return int(str(int(tmp_num + n) + 1)[digit - 1])";"def encontrar_digito(n):
    longitud = 1
    contador = 9
    inicio = 1
    
    while n > longitud * contador:
        n -= longitud * contador
        longitud += 1
        contador *= 10
        inicio *= 10
    
    numero = inicio + (n - 1) // longitud
    digito_str = str(numero)
    digito = digito_str[(n - 1) % longitud]
    
    return int(digito)"
"class Solution:
    def findMinStep(self, board: str, hand: str) -> int:
        
        # start from i and remove continues ball
        def remove_same(s, i):
            if i < 0:
                return s
            
            left = right = i
            while left > 0 and s[left-1] == s[i]:
                left -= 1
            while right+1 < len(s) and s[right+1] == s[i]:
                right += 1
            
            length = right - left + 1
            if length >= 3:
                new_s = s[:left] + s[right+1:]
                return remove_same(new_s, left-1)
            else:
                return s



        hand = """".join(sorted(hand))

        # board, hand and step
        q = collections.deque([(board, hand, 0)])
        visited = set([(board, hand)])

        while q:
            curr_board, curr_hand, step = q.popleft()
            for i in range(len(curr_board)+1):
                for j in range(len(curr_hand)):
                    # skip the continue balls in hand
                    if j > 0 and curr_hand[j] == curr_hand[j-1]:
                        continue
                    
                    # only insert at the begin of continue balls in board
                    if i > 0 and curr_board[i-1] == curr_hand[j]: # left side same color
                        continue
                    
                    pick = False
                    # 1. same color with right
                    # 2. left and right are same but pick is different
                    if i < len(curr_board) and curr_board[i] == curr_hand[j]:
                        pick = True
                    if 0<i<len(curr_board) and curr_board[i-1] == curr_board[i] and curr_board[i] != curr_hand[j]:
                        pick = True
                    
                    if pick:
                        new_board = remove_same(curr_board[:i] + curr_hand[j] + curr_board[i:], i)
                        new_hand = curr_hand[:j] + curr_hand[j+1:]
                        if not new_board:
                            return step + 1
                        if (new_board, new_hand) not in visited:
                            q.append((new_board, new_hand, step+1))
                            visited.add((new_board, new_hand))

        return -1";"from collections import deque

def encontrar_minimo_bolas(tablero, mano):
    colores = ['R', 'Y', 'B', 'G', 'W']
    mano_lista = list(mano)
    cola = deque()
    cola.append((tablero, mano_lista, 0))
    visitados = set()
    visitados.add((tablero, tuple(sorted(mano_lista))))
    
    while cola:
        estado_actual, mano_actual, pasos = cola.popleft()
        
        if not estado_actual:
            return pasos
        
        for i in range(len(estado_actual) + 1):
            for j in range(len(mano_actual)):
                if i > 0 and estado_actual[i-1] == mano_actual[j]:
                    continue
                
                nuevo_tablero = estado_actual[:i] + mano_actual[j] + estado_actual[i:]
                nueva_mano = mano_actual[:j] + mano_actual[j+1:]
                
                cambiado = True
                while cambiado:
                    cambiado = False
                    inicio = 0
                    for k in range(len(nuevo_tablero) + 1):
                        if k == len(nuevo_tablero) or nuevo_tablero[k] != nuevo_tablero[inicio]:
                            if k - inicio >= 3:
                                nuevo_tablero = nuevo_tablero[:inicio] + nuevo_tablero[k:]
                                cambiado = True
                                break
                            inicio = k
                
                estado_mano = tuple(sorted(nueva_mano))
                if (nuevo_tablero, estado_mano) not in visitados:
                    visitados.add((nuevo_tablero, estado_mano))
                    cola.append((nuevo_tablero, nueva_mano, pasos + 1))
    
    return -1"
"class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        '''
        The idea is similar to Unique Paths, https://leetcode.com/problems/unique-paths/
        in that, we get the minimum of the accumulated path totals from TOP + LEFT
		but here, we also then compare against accumulated path costs from BOTTOM + RIGHT
            
        Specifics of why 2 at a time and not all 4 is not fully clear but when done with 4
            runs infinitely / maxes out / keeps looping
        '''
        R, C = len(mat), len(mat[0])
        
        # Get the min of accumulated totals for NON-0's from TOP and LEFT
        # Out of bounds are rendered irrelevant by assigning infinity
        for r in range(R):
            for c in range(C):
                if mat[r][c] != 0:
                    top = float('inf') if r == 0 else mat[r - 1][c]
                    left = float('inf') if c == 0 else mat[r][c - 1]
                    mat[r][c] = 1 + min(top, left) # Note the +1 to account for the path-move
        
        # Do the same, but with BOTTOM and RIGHT and this time also compare against current value
        # Likewise, igore out of bounds by setting them as infinity
        for r in range(R-1, -1, -1):
            for c in range(C-1, -1, -1):
                if mat[r][c] != 0:
                    bottom = float('inf') if (r + 1) == R else mat[r + 1][c]
                    right = float('inf') if (c + 1) == C else mat[r][c + 1]
                    mat[r][c] = min(mat[r][c], 1 + bottom, 1 + right) # Note the pre-calculated one from last loop is fine but the others need +1 to pay for path move
                    
        # We got our minimums, let's return
        return mat";"from collections import deque

def actualizar_matriz(matriz):
    if not matriz:
        return matriz
    
    filas = len(matriz)
    columnas = len(matriz[0])
    cola = deque()
    
    for i in range(filas):
        for j in range(columnas):
            if matriz[i][j] == 0:
                cola.append((i, j))
            else:
                matriz[i][j] = float('inf')
    
    direcciones = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    while cola:
        x, y = cola.popleft()
        
        for dx, dy in direcciones:
            nx, ny = x + dx, y + dy
            
            if 0 <= nx < filas and 0 <= ny < columnas:
                if matriz[nx][ny] > matriz[x][y] + 1:
                    matriz[nx][ny] = matriz[x][y] + 1
                    cola.append((nx, ny))
    
    return matriz"
"class Solution:
    def restoreString(self, s: str, indices: List[int]) -> str:
        res = [''] * len(s)
        for i in range(len(s)):
            res[indices[i]] = s[i]
        
        return ''.join(res)

class Solution:
    def restoreString(self, s: str, indices: List[int]) -> str:
        s = list(s)
        
        for i in range(len(indices)):
            while i != indices[i]:
                tmp = indices[i]
                indices[i] = indices[tmp]
                indices[tmp] = tmp
    
                s[i], s[tmp] = s[tmp], s[i]

        return ''.join(s)";"cadena_mezclada = []
cadena_original = ""ejemplo""  # Esto es solo un ejemplo, se reemplazará con la entrada real
indices = [0, 1, 2, 3, 4, 5, 6]  # Esto es solo un ejemplo, se reemplazará con la entrada real

for i in range(len(cadena_original)):
    cadena_mezclada.append('')

for posicion in range(len(indices)):
    nueva_posicion = indices[posicion]
    caracter = cadena_original[posicion]
    cadena_mezclada[nueva_posicion] = caracter

resultado = ''.join(cadena_mezclada)"
"class Solution:
    #Time-Complexity: O(n + n^2) -> O(n^2)
    #Space-Complexity: O(n + n + n) -> O(n)
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        
        q = collections.deque()
        number_of_rooms = len(rooms)
        #if we visited every room, our visited set will match wanted_set!
        wanted_set = set()
        for i in range(number_of_rooms):
            wanted_set.add(i)
        #visited will keep track of all distinct visited rooms which will be updated as bfs traversal                   progresess!
        visited = set()
        
        #before initiating bfs, we append to queue room 0 and mark room 0 as visited!
        visited.add(0)
        q.append(0)
        
        #as long as queue is non-emtpy, continue bfs!
        #all elements of queue are waited to be processed and are not already visited!
        #in worst case, our queue have to process all n rooms if we can simply hop from ith room to i+1th room
        #until we visit every single room!
        while q:
            cur_room = q.popleft()
            set_of_keys = rooms[cur_room]
            #For each room our current room can lead to, check that it is not already visited to avoid
            #revisiting node(stuck in cycle) and make sure it's not a self loop!
            #this inner for loop in worst case runs n-1 times, cause ith room may provide keys to 
            #all other rooms!
            for key in set_of_keys:
                if(key not in visited and key != cur_room):
                    q.append(key)
                    visited.add(key)
        #once our queue ends, see if visited == wanted_set
        if(visited == wanted_set):
            return True
        return False";"def puede_visitar_todas_las_habitaciones(habitaciones):
    if not habitaciones:
        return True
    
    n = len(habitaciones)
    visitadas = [False] * n
    llaves = [0]
    visitadas[0] = True
    
    while llaves:
        habitacion_actual = llaves.pop()
        for llave in habitaciones[habitacion_actual]:
            if not visitadas[llave]:
                visitadas[llave] = True
                llaves.append(llave)
    
    return all(visitadas)"
"class Solution:
    def minPatches(self, nums: List[int], n: int) -> int:
        ans = prefix = k = 0 
        while prefix < n: 
            if k < len(nums) and nums[k] <= prefix + 1: 
                prefix += nums[k]
                k += 1
            else: 
                ans += 1
                prefix += prefix + 1
        return ans";"def parches_numeros(numeros, n):
    parches = 0
    alcanzable = 1
    i = 0
    tamano = len(numeros)
    
    while alcanzable <= n:
        if i < tamano and numeros[i] <= alcanzable:
            alcanzable += numeros[i]
            i += 1
        else:
            alcanzable += alcanzable
            parches += 1
    
    return parches"
"class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        
        def mergeSort(arr, l, r):
            if l < r:
                m = l + (r-l)//2
                mergeSort(arr, l, m)
                mergeSort(arr, m+1, r)
                merge(arr, l, m, r)
        
        def merge(arr, l, m, r):
            ans = []
            i = l
            j = m+1
            while i <= m and j <= r:
                if int(arr[i]+arr[j]) > int(arr[j]+arr[i]):
                    ans.append(arr[i])
                    i += 1
                else:
                    ans.append(arr[j])
                    j += 1
            while i <= m:
                ans.append(arr[i])
                i+=1
            while j <= r:
                ans.append(arr[j])
                j+=1
            
            for i in range(len(ans)):
                arr[l+i] = ans[i]
        
        arr = [str(num) for num in nums]

        mergeSort(arr, 0, len(arr)-1)

        return ""0"" if arr and arr[0] == ""0"" else """".join(arr)";"def numero_mas_grande(numeros):
    if not numeros:
        return ""0""
    
    numeros = list(map(str, numeros))
    
    for i in range(len(numeros)):
        for j in range(i + 1, len(numeros)):
            if numeros[j] + numeros[i] > numeros[i] + numeros[j]:
                numeros[i], numeros[j] = numeros[j], numeros[i]
    
    resultado = ''.join(numeros)
    
    if resultado[0] == '0':
        return ""0""
    
    return resultado"
"class Solution:
    # each state 6 len and 012345 permutation => (mn)! = 720 -> space = vis array of (mn)!
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        
        def getState(board):
            return ''.join(str(x) for row in board  for x in row)
        
        # print(getState(board))
        
        def setState(state):
            si = 0
            zx, zy = 0, 0
            for row in range(2):
                for i in range(3):
                    board[row][i] = int(state[si])
                    if board[row][i] == 0:
                        zx,zy = row, i
                    si += 1
                    
            # returns the position of zero ,)
            return zx, zy
        
        parent = dict() 
        def findPath(state):
            res = []
            while state in parent
                res.append(state)
                state = parent[state]
            return res
        
        # now template BFS...
        q = deque([getState(board)])
        dist = 0
        vis = set()
        while q: # level order traversal, expand one level at a time 
            # print(q)
            level_len = len(q)
            for _ in range(level_len):
                if q[0] == '123450':
                    return findPath(q[0])
                
                parent_state = q[0]
                
                zx, zy = setState(q.popleft())
                # now check all four neighbours.. after swap what happens :)
                for x, y in [[zx,zy+1], [zx+1,zy],[zx,zy-1],[zx-1,zy]]:
                    if 0<=x<2 and 0<=y<3:
                        board[zx][zy], board[x][y] = board[x][y], board[zx][zy]
                        
                        kid_state = getState(board)
                        
                        parent[kid_state] = parent_state
                        
                        if state not in vis:
                            vis.add(state)
                            q.append(state)
                        board[zx][zy], board[x][y] = board[x][y], board[zx][zy]
            dist += 1
        
        return -1";"from collections import deque

def deslizar_puzzle(tablero):
    objetivo = [[1, 2, 3], [4, 5, 0]]
    movimientos = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    filas = 2
    columnas = 3
    
    estado_inicial = tuple(tuple(fila) for fila in tablero)
    cola = deque()
    cola.append((estado_inicial, 0))
    visitados = set()
    visitados.add(estado_inicial)
    
    while cola:
        estado_actual, pasos = cola.popleft()
        
        if list(list(fila) for fila in estado_actual) == objetivo:
            return pasos
        
        for i in range(filas):
            for j in range(columnas):
                if estado_actual[i][j] == 0:
                    x, y = i, j
        
        for dx, dy in movimientos:
            nuevo_x = x + dx
            nuevo_y = y + dy
            
            if 0 <= nuevo_x < filas and 0 <= nuevo_y < columnas:
                nuevo_estado = [list(fila) for fila in estado_actual]
                nuevo_estado[x][y], nuevo_estado[nuevo_x][nuevo_y] = nuevo_estado[nuevo_x][nuevo_y], nuevo_estado[x][y]
                nuevo_estado_tupla = tuple(tuple(fila) for fila in nuevo_estado)
                
                if nuevo_estado_tupla not in visitados:
                    visitados.add(nuevo_estado_tupla)
                    cola.append((nuevo_estado_tupla, pasos + 1))
    
    return -1"
"class Solution:
    def heightChecker(self, heights: List[int]) -> int:
        # O(N)
        sortedList = []
        count = 0
        
        # initialize 1 to 100 count dictionary
        oneToHundredDict = dict((k, 0) for k in range(1,101))
        
        # count the repeatations and updating the dictionary
        for i in range(0, len(heights)):
            oneToHundredDict[heights[i]] = oneToHundredDict[heights[i]] + 1
            
        # sorting the list
        for key,value in oneToHundredDict.items():
            if value > 0:
                # Reapting key by value times thereby sorting the list
                sortedList.extend(repeat(key, value))
        
        # compare
        for i in range(0,len(heights)):
            if sortedList[i] != heights[i]:
                count = count + 1
        
        return count";"alturas = [3, 2, 5, 4, 1]  # Ejemplo de alturas actuales

esperado = sorted(alturas)
contador = 0

for i in range(len(alturas)):
    if alturas[i] != esperado[i]:
        contador += 1

print(contador)"
"class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        nums = [1] + nums + [1]
        size = len(nums)        
        
        t = [[-1 for p in range(0,size+1)]
            for q in range(0,size+1)]
        
        return self.solve(nums,1,size-1,t)
        
    def solve(self,arr,i,j,t):
        if i >= j:
            return 0
        
        if t[i][j] > 0:
            return t[i][j]
        
        ans = float('-inf')
        
        for k in range(i,j):
            if t[i][k] != -1:
                left = t[i][k]
            else:
                left = self.solve(arr,i,k,t)
                t[i][k] = left
                
            if t[k+1][j] != -1:
                right = t[k+1][j]
            else:
                right = self.solve(arr,k+1,j,t)
                t[k+1][j] = right
                
            temp = left + right + (arr[i-1]*arr[k]*arr[j])
            
            ans = max(ans,temp)
            
        t[i][j] = ans
        return t[i][j]";"def max_monedas(nums):
    n = len(nums)
    nums = [1] + nums + [1]
    dp = [[0] * (n + 2) for _ in range(n + 2)]
    
    for largo in range(1, n + 1):
        for izquierda in range(1, n - largo + 2):
            derecha = izquierda + largo - 1
            for i in range(izquierda, derecha + 1):
                ganancia = nums[izquierda - 1] * nums[i] * nums[derecha + 1]
                ganancia += dp[izquierda][i - 1] + dp[i + 1][derecha]
                if ganancia > dp[izquierda][derecha]:
                    dp[izquierda][derecha] = ganancia
                    
    return dp[1][n]"
"class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        
        # Setup counts for bulls and cows
        bulls = cows = 0
        
        # Copy secret and guess into lists that are easier to work with
        secretCopy = list(secret)
        guessCopy = list(guess)
        
        # In a for loop, check every pair of letters at the same index in both guess and secret for matching letters, AKA bulls
        for i in range(len(secret)):
            
            # If they match, bulls += 1 and pop() the letters from the copy lists via their .index()
            if secret[i] == guess[i]:
                bulls += 1
                secretCopy.pop(secretCopy.index(secret[i]))
                guessCopy.pop(guessCopy.index(guess[i]))
                
                
        # Count() the letters remaining in secret and guess lists
        secretCounter = Counter(secretCopy)
        guessCounter = Counter(guessCopy)
        
        # Counter1 - Counter2 gives us Counter1 with any matching values of Counter1 and Counter2 removed, leftover Counter2 values are trashed
        # secretCounter - guessCounter gives us the secretCounter except for any correctly guessed letters
        # Therefore, subtract this difference from the OG secretCounter to be left with a counter of only correctly guessed letters
        dif = secretCounter - (secretCounter - guessCounter)
        
        # The .total() of the dif Counter is the number of cows
        cows = dif.total()

        # return the formatted string with req. info
        return f'{bulls}A{cows}B'";"secreto = ""1807""
adivinanza = ""7810""

toros = 0
vacas = 0
lista_secreto = []
lista_adivinanza = []

for i in range(len(secreto)):
    if secreto[i] == adivinanza[i]:
        toros += 1
    else:
        lista_secreto.append(secreto[i])
        lista_adivinanza.append(adivinanza[i])

for num in lista_adivinanza:
    if num in lista_secreto:
        vacas += 1
        lista_secreto.remove(num)

print(f""{toros}A{vacas}B"")"
"class Solution:
    def imageSmoother(self, img: List[List[int]]) -> List[List[int]]:
        
        #Pull the dimensions
        m_rows = len( img ),
        n_cols = len( img[ 0 ] ),
        
        #Kernel size is 3,
        k = 3,
        
        #Create a new image for each averaged total to be stored
        newImage = [ [ 0 for _ in range( n_cols ) ] for _ in range( m_rows ) ],
        
        #Start is the grid cordinate [ column , row ],
        start = [ 0, 0 ],
        
        #direction right tells us if we are true
        directionRight = [ True ],
        
        #Total keeps track of our total
        total = [ 0 ],
        
        #Initialize the kernel at [ 0 , 0 ],
        #Valid kernel will tell us how many valid squares
        #We are averaging
        total[ 0 ] , validKernel = self.initializeKernel( img, m_rows, n_cols, start ),
        
        #Previous direction will help us snake down the matrix
        #By snake down, we go right to left, then down, then left to right
        #As we find the total
        
        #This allows us to reuse our counts, and prevents overlapping calculations
        
        #When previous direction is True
        #It means we are going from right to left
        #When it is False, we are going from left to right
        prevDirection = True,

        #While our row value is at a valid index, process:
        while start[ 1 ] < m_rows:

            #Pull the x and y coordinate
            x = start[ 0 ],
            y = start[ 1 ],
            
            #Assign the average value
            newImage[ y ][ x ] = total[ 0 ] // validKernel,
            
            #Find the next coordinate by calling self.snake() to snake through the matri
            #Instead of scanning and going back to the beginning at the end,
            #Like when we read,
            #We continue our calculations in the other direction
            
            #next cord will go from
            #BEGIN [ 0, 0] , [ 1 , 0 ] , [ 2 ,  0] , END , [ 2, 1 ], [ 1 , 1 ], [ 0, 1 ] 
            # BEGIN [ 0, 2 ] [ 1, 2 ] [ 2, 2 ] END [ 2, 3 ]  ...
            nextCoord = self.snake(img, m_rows , n_cols, start, directionRight ),
            
            #nextCoord modifies the directionRight flag if it changes
            #to false, and thus begins going left
            
            #When we change directions, we want to go down a row
            if prevDirection != directionRight[ 0 ]:
                #We adjust the slice of the kernel by KEEPING
                #the overlapped elements
                
                #Adjust prev will remove from the total a slice of the kernel
                #That does not overlap
                
                #Since we are always going down, the below call to change slice
                #Will always remove the non overlapping top part of the kernel
                adjustPrev = self.changeSlice( img, m_rows, n_cols, [ x, y ] ,total, False, 0 ),
                validKernel -= adjustPrev,
                #We remove the count so our average will only consider the overlapped
                
                #Next we add the new slice that comes with our new coordinate
                #This will always be the bottom part of the kernel
                adjustCurr = self.changeSlice( img, m_rows, n_cols, [ x, y + 1 ] ,total, True, 1 ),
                validKernel += adjustCurr ,
                #and same thing, we add to the count the pieces of our new slice
                

            #If we are going in the same direction, 
            else: 
                #These values keep track of changeSlice
                #Minus condition and plus condition
                #Tell us which part of the kernel we are changing
                
                #If we are going right:
                #We remove the left slice of the old kernel
                #And add the right slice of the new kernel
                if directionRight[ 0 ]:
                    minusCondition = 3,
                    plusCondition = 2,
                    
                #If we are going left:
                #It is the opposide
                #We remove the right slice of the old kernel
                #And add the left slice of the new kernel
                else:
                    minusCondition = 2,
                    plusCondition = 3,
                    
                #Like with the above, We adjust the slices and update the validKernel count
                adjustPrev = self.changeSlice( img, m_rows, n_cols, [ x, y ], total, False, minusCondition ),
                validKernel -= adjustPrev,
                adjustCurr = self.changeSlice( img, m_rows, n_cols, nextCoord, total, True, plusCondition ),
                validKernel += adjustCurr,
                
                
            
           
            
            #At the end, we update the start value with our nextCoord
            #And we overWrite our prevDirection flag with our current direction
            start = nextCoord,
            prevDirection = directionRight[ 0 ],
        return newImage,
        
        
    #Is validCoord takes in the dimensions of the matrix
    #And returns if a current coordinate pair is not a valid index
    def isValidCoord( self, m, n, current ):
        x = current[ 0 ],
        y = current[ 1 ],
        
        if x < 0 or y < 0:
            return False,
        if x >= n or y >= m:
            return False,
        return True,
        
    #Intialize kernel will create the first instance of our kernel
    #at the top left of our matrix
    def initializeKernel( self, grid, m, n, start , k = 3):
        x = start[ 0 ],
        y = start[ 1 ],
        
        starting_total = 0,
        validCoord = 0,
        
        #It is generalized to take any slice of k
        #Since we are starting at the top left
        #We only need half of the kernel to begin with
        #Which is k // 2
        #The plus one comes from including the middle section of the kernel
        for i in range( ( k // 2) + 1 ):
            for j in range( (k // 2 ) + 1 ):
                #For each potential kernel location, 
                #We see if it is a valid coordinate
                #This is needed for when the kernel is larger than the matrix
                if self.isValidCoord( m , n , [ x + j, y + i ] ):
                    starting_total += grid[ y + i ][ x + j ],
                    validCoord += 1,

        #We return our starting total 
        #And our count, validCoord, which is used to divide the total to find
        #the average
        return starting_total, validCoord,

    
    #Change slice will tally slices of the kernel
    #The top or bottom row,
    #The left or right hand side of the column
    #Change slice will find the valid coordinates of the slice
    #And will either add them or subtract them from the total
    #Depending on the passed in paratmeters
    
    #It is the swiss-army-knife of this solution
    def changeSlice( self, grid, m , n, current, total, addition = True, condition = 0 ,k = 3 ):
        
        
        #Condition 0 tallies the top row
        #Condition 1 tallies the bottom row
        #Condition 2 tallies the right column
        #Condition 3 tallies the left column
        
        #If addition is True, we add to the total
        #If addition is False, we subtract from the total
        
        #We take the current center of the kernel
        x = current[ 0 ],
        y = current[ 1 ],
        
        #Adjust slice allows us to generalize to other sizes of k
        adjustSlice = ( k // 2 ),
        
        #We see how many valid coordinates are being modified
        #That is, how many are going into the addition or subtraction of the total
        validCoord = 0,
        
        #Going down or right from the top left of the kernel
        if condition == 0 or condition == 3:
            start = [ x - adjustSlice , y - adjustSlice ],
        #Going right from bottom left of the kernel
        elif condition == 1:
            start = [ x - adjustSlice , y + adjustSlice ],
        #Going down from top right of the kernel
        elif condition == 2:
            start = [ x + adjustSlice , y - adjustSlice ],
        else:
            raise ValueError,
        
        #For the size of the slice
        for i in range( k ):
            #Horizontal slice of k: condition 0 is top, 1 is bottom
            if condition == 0 or condition == 1:
                a = start[ 0 ] + i,
                b = start[ 1 ] ,
            #Vertical slice of k: 2 is righthand side, 3 is lefthand side
            else:
                a = start[ 0 ] ,
                b = start[ 1 ] + i,
                
            #Check to see if the generated coordinate is on the matrix
            if self.isValidCoord( m , n , [ a ,b ] ):
                #If it is, add to our subtotal count
                validCoord += 1,
            
                #If the addition flag is true:
                #Add the value to the total
                if addition:
                    total[ 0 ] += grid[ b ][ a ],  
                #If it is subtraction, remove the value from the total
                else:
                    total[ 0 ] -= grid[ b ][ a ],
                    
        #Return the number of coordinates that changed the total
        return validCoord,
                
        #Snake will, given the current coordinate, generate the next one
        #If directionRight is True, we are going right
        #If directionRight is False, we are going left
    def snake( self, grid, m, n, current , directionRight):
        
        #Pull the coordinates
        x = current[ 0 ],
        y = current[ 1 ],
        
        #Adjust the x value in accordance with the direction 
        if directionRight[ 0 ]:
            x = x + 1,
        else:
            x = x - 1,
        
        #If we are outside of a valid coordinate,
        if x == -1 or x == n:
            #Change direction
            directionRight[ 0 ] = not directionRight[ 0 ],
            
            #Return the original x, and increment y
            return [ current[ 0 ] , y + 1 ]
            
        #Otherwise, return the modified x, and the original y
        return [ x , y ],";"filas = len(img)
columnas = len(img[0]) if filas > 0 else 0
resultado = [[0 for _ in range(columnas)] for _ in range(filas)]

for i in range(filas):
    for j in range(columnas):
        suma = 0
        contador = 0
        for x in [i-1, i, i+1]:
            for y in [j-1, j, j+1]:
                if 0 <= x < filas and 0 <= y < columnas:
                    suma += img[x][y]
                    contador += 1
        resultado[i][j] = suma // contador

print(resultado)"
"class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        #create a adjacent lists that have connections 
        dic = collections.defaultdict(set)
        email_to_name={}
        visited = set()
        ans = []
        for account in accounts:
            name = account[0]
            for email in account[1:]:
                dic[email].add(account[1])
                dic[account[1]].add(email)
                email_to_name[email] = name
        def dfs(intial_email,dic,visited):
            if intial_email in visited:
                return 
            stack = [intial_email]
            visited.add(intial_email)
            lst = []
            lst.append(intial_email)
            while stack:
                sub_email = stack.pop()
                if dic[sub_email]:
                    for other_email in dic[sub_email]:
                        if other_email not in visited:
                            lst.append(other_email)
                            stack.append(other_email)
                            visited.add(other_email)
                        else:
                            continue
            result = sorted(lst)
            return result
        for email in dic:
            result = dfs(email,dic,visited)
            if result:
                ans.append([email_to_name[email]]+result)
        return ans 

            

                    



        


        # dic_emails = {}
        # for account in accounts:
        #     for i in range(1,len(account)):
        #         if account[i] not in dic_emails:
        #             dic_emails[account[i]] =1
        #         else:
        #             dic_emails[account[i]] +=1
        # dic_email2 = {}
        # dic_email3 = []
        # for key,value in dic_emails.items():
        #     if value > 1:
        #         for account in accounts:
        #             if key in account and key not in dic_email2:
        #                 dic_email2[key] = []
        #                 dic_email2[key].append(account)
        #             elif key in account and key in dic_email2:
        #                 dic_email2[key].append(account)
        #             elif key not in account:
        #                 dic_email3.append(account)
        # total = []
        # for key,value in dic_email2.items():
        #     lst = []
        #     if len(value) > 1:
        #         for infor in value:
        #             for in_f in infor:
        #                 if in_f not in lst:
        #                     lst.append(in_f)
        #     total.append(lst[:1]+sorted(lst[1:]))
        # print(total)
        # print(dic_email3)
        # return sorted((total + dic_email3))";"cuentas = [[""John"", ""johnsmith@mail.com"", ""john_newyork@mail.com""], [""John"", ""johnsmith@mail.com"", ""john00@mail.com""], [""Mary"", ""mary@mail.com""], [""John"", ""johnnybravo@mail.com""]]

def fusionar_cuentas(cuentas):
    grafo = {}
    email_a_nombre = {}
    email_a_id = {}
    id_actual = 0

    for cuenta in cuentas:
        nombre = cuenta[0]
        emails = cuenta[1:]
        primer_email = emails[0]
        for email in emails:
            if email not in email_a_id:
                email_a_id[email] = id_actual
            email_a_nombre[email] = nombre
            if primer_email not in grafo:
                grafo[primer_email] = []
            if email not in grafo:
                grafo[email] = []
            grafo[primer_email].append(email)
            grafo[email].append(primer_email)
        id_actual += 1

    visitados = set()
    resultado = []

    for email in grafo:
        if email not in visitados:
            pila = [email]
            visitados.add(email)
            componente = []
            while pila:
                nodo = pila.pop()
                componente.append(nodo)
                for vecino in grafo[nodo]:
                    if vecino not in visitados:
                        visitados.add(vecino)
                        pila.append(vecino)
            componente_ordenada = sorted(componente)
            cuenta_fusionada = [email_a_nombre[email]] + componente_ordenada
            resultado.append(cuenta_fusionada)

    return resultado

print(fusionar_cuentas(cuentas))"
"class Solution:
		def isEvenOddTree(self, root: Optional[TreeNode]) -> bool:
			if root is None:
				return False

			level_order = self.level_order(root)

			# check level 0
			if level_order[0][0] % 2 == 0:
				return False

			# check level 1 ~ end
			for i, level in enumerate(level_order[1:], 2):
				if i % 2 == 0:
					# even and decreasing order
					previous_element = level[0]
					if previous_element % 2 != 0:
						return False

					for element in level[1:]:
						if element % 2 != 0 or previous_element < element:
							return False
						previous_element = element

				else:
					# odd and increasing order
					previous_element = level[0]
					if previous_element % 2 == 0:
						return False

					for element in level[1:]:
						if element % 2 == 0 or element < previous_element:
							return False
						previous_element = level

			return True

		def level_order(self, root: Optional[TreeNode]) -> List[List[int]]:
				queue = [root]
				level_order = []
				while queue:
					size = len(queue)
					level = []
					for _ in range(size):
						node = queue.pop(0)

						if node.left:
							queue.append(node.left)

						if node.right:
							queue.append(node.right)

						level.append(node.val)

					level_order.append(level)

				return level_order";"from collections import deque

def es_par_impar(raiz):
    if not raiz:
        return True
    
    cola = deque()
    cola.append(raiz)
    nivel = 0
    
    while cola:
        tamano = len(cola)
        previo = None
        
        for _ in range(tamano):
            nodo = cola.popleft()
            
            if nivel % 2 == 0:
                if nodo.val % 2 == 0:
                    return False
                if previo is not None and nodo.val <= previo:
                    return False
            else:
                if nodo.val % 2 != 0:
                    return False
                if previo is not None and nodo.val >= previo:
                    return False
            
            previo = nodo.val
            
            if nodo.izquierda:
                cola.append(nodo.izquierda)
            if nodo.derecha:
                cola.append(nodo.derecha)
        
        nivel += 1
    
    return True"
"class Solution:
    def sumFourDivisors(self, nums: List[int]) -> int:
        res = 0
        for num in nums:
            divisor = set() 
            for i in range(1, floor(sqrt(num)) + 1):
                if num % i == 0:
                    divisor.add(num//i)
                    divisor.add(i)
                if len(divisor) > 4:    
                    break
                    
            if len(divisor) == 4:
                res += sum(divisor)
        return res";"def suma_divisores_cuatro(nums):
    total = 0
    for num in nums:
        divisores = []
        for i in range(1, num + 1):
            if num % i == 0:
                divisores.append(i)
        if len(divisores) == 4:
            suma = 0
            for d in divisores:
                suma += d
            total += suma
    return total"
"class Solution:
    def findRotateSteps(self, ring: str, key: str) -> int:
        char_pos = defaultdict(set)
        for i, c in enumerate(ring):
            char_pos[c].add(i)
        
        def minStep(fromm, to):
            if fromm == to:
                return 0
            minSteps = abs(fromm - to)
            minSteps = min(minSteps, abs(len(ring) - minSteps))
            return minSteps
        
        n = len(key)
        dp = [0] * len(ring)
        for p in char_pos[key[0]]:
            dp[p] = minStep(0, p)
        prev_char = key[0]
        for c in key[1:]:
            if prev_char == c:
                continue
            for next_pos in char_pos[c]:
                dp[next_pos] = min(dp[prev_pos] + minStep(prev_pos, next_pos) for prev_pos in char_pos[prev_char])
            prev_char = c
        return min(dp[p] for p in char_pos[prev_char]) + len(key)";"def encontrar_pasos_minimos(anillo, clave):
    posiciones = {}
    for idx, letra in enumerate(anillo):
        if letra not in posiciones:
            posiciones[letra] = []
        posiciones[letra].append(idx)
    
    tam_anillo = len(anillo)
    memo = {}
    
    def dp(pos_actual, indice_clave):
        if indice_clave == len(clave):
            return 0
        if (pos_actual, indice_clave) in memo:
            return memo[(pos_actual, indice_clave)]
        
        letra_objetivo = clave[indice_clave]
        pasos_minimos = float('inf')
        
        for pos in posiciones[letra_objetivo]:
            pasos_horario = abs(pos - pos_actual)
            pasos_antihorario = tam_anillo - pasos_horario
            pasos = min(pasos_horario, pasos_antihorario) + 1
            pasos_totales = pasos + dp(pos, indice_clave + 1)
            if pasos_totales < pasos_minimos:
                pasos_minimos = pasos_totales
        
        memo[(pos_actual, indice_clave)] = pasos_minimos
        return pasos_minimos
    
    return dp(0, 0)"
"class Solution:
    def isValid(self, code: str) -> bool:
        if code[0] != '<' or code[-1] != '>': return False
        i, n = 0, len(code)
        stk = []
        while i < n:
            if code[i] == '<':
                if i != 0 and code[i: i + 9] == '<![CDATA[':
                    if not stk: return False
                    j = i + 9
                    while j + 3 <= n and code[j: j + 3] != ']]>': j += 1
                    if code[j: j + 3] == ']]>': i = j + 3
                    else: return False
                else:
                    start = i
                    isend = False
                    i += 1
                    if i >= n: return False
                    if code[i] == r'/':
                        isend = True
                        i += 1
                    if i >= n: return False
                    tag = ''
                    while i < n and code[i] != '>':
                        if not code[i].isupper(): return False
                        tag += code[i]
                        i += 1
                    if i >= n or len(tag) == 0 or len(tag) > 9: return False
                    if isend:
                        if not stk or stk[-1] != tag: return False
                        stk.pop(-1)
                    else:
                        if start != 0 and not stk: return False
                        stk.append(tag)
                    i += 1
            else:
                if not stk: return False
                while i < n and code[i] != '<': i += 1
        return not stk";"def es_valido(codigo):
    pila = []
    i = 0
    n = len(codigo)
    
    while i < n:
        if i + 8 < n and codigo[i:i+9] == '<![CDATA[':
            j = i + 9
            while j + 2 < n and codigo[j:j+3] != ']]>':
                j += 1
            if j + 2 >= n:
                return False
            i = j + 3
        elif codigo[i] == '<':
            if i + 1 >= n:
                return False
            es_cierre = codigo[i+1] == '/'
            if es_cierre:
                inicio = i + 2
            else:
                inicio = i + 1
            j = inicio
            while j < n and codigo[j] != '>':
                if not codigo[j].isupper():
                    return False
                j += 1
            if j >= n:
                return False
            etiqueta = codigo[inicio:j]
            if len(etiqueta) < 1 or len(etiqueta) > 9:
                return False
            if es_cierre:
                if not pila or pila[-1] != etiqueta:
                    return False
                pila.pop()
            else:
                pila.append(etiqueta)
            i = j + 1
        else:
            i += 1
    
    return len(pila) == 0"
"class Solution:
    def toLowerCase(self, s: str) -> str:
        # Instead of using .lower(), let's implement with ASCII
        # ord() returns the ascii value of a passed character
        
        # Uncomment the line below to see the ASCII value of some important characters
        # print(ord('a'), ord('z'), ord('A'), ord('Z'))
        
        # Notice 'a'=97, and 'A'=65
        # This can be used to tell whether a character is upper/lower case, and can help us convert between them
        
        # First, make the string a list so we can change each char individually
        s = list(s)
        
        # Then, loop through the characters, and if their ascii value is <= 90 and >= 65, they must be upper case
        # Use the difference (97 - 65 = 32) to convert it from upper to lower, then use chr() to convert from ascii to char
        #   - ord('A') + 32 = 97 = ord('a')
        for i in range(len(s)):
            if ord(s[i]) <= 90 and ord(s[i]) >= 65:
                s[i] = chr(ord(s[i])+32)
        return ''.join(s)";"cadena_resultado = """"
cadena_original = input(""Ingresa una cadena: "")
for caracter in cadena_original:
    if 'A' <= caracter <= 'Z':
        caracter = chr(ord(caracter) + 32)
    cadena_resultado += caracter
print(cadena_resultado)"
"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        # self.selectionSort(nums)
        # self.bubbleSort(nums)
        # self.insertionSort(nums)
        # self.mergeSort(nums)       
        self.quickSort(nums)
        return nums
    
    ''' 
    Selection Sort (TLE)
    TC: O(n^2) ,  SC: O(1), in-place
    Not Stable
    Minimum swaps
    '''
    def selectionSort(self, nums):
        for i in range(len(nums)):
            min_idx=i
            for j in range(i, len(nums)):
                if nums[j]<nums[min_idx]:
                    min_idx=j
            nums[i], nums[min_idx] = nums[min_idx], nums[i]
            
    '''
    Bubble Sort (TLE)
    TC: best-O(n), worst-O(n^2)
    SC: O(1)
    Stable
    Use when array is almost sorted
    '''
    def bubbleSort(self, nums):
        for i in range(len(nums)):
            swapped = False
            for j in range(len(nums)-i-1):
                if nums[j]>nums[j+1]:
                    nums[j], nums[j+1] = nums[j+1], nums[j]
                    swapped = True
            
            if not swapped:
                break
                
    '''
    Insertion Sort (TLE)
    TC: best-O(n), worst-O(n^2)
    SC: O(1)
    Stable
    '''
    def insertionSort(self, nums):
        for i in range(1, len(nums)):
            key = nums[i]
            j=i-1
            while j>=0 and key<nums[j]:
                nums[j+1]=nums[j]
                j-=1
            nums[j+1]=key
    
    '''
    Merge Sort
    Recursive
    TC: O(nlogn)
    SC: O(n)
    Stable
    '''
    def mergeSort(self, nums):
        def merge(nums,L,R):
            i = j = k = 0
            while i < len(L) and j < len(R): 
                if L[i] < R[j]: 
                    nums[k] = L[i] 
                    i+=1
                else: 
                    nums[k] = R[j] 
                    j+=1
                k+=1
                
            while i < len(L): 
                nums[k] = L[i] 
                i+=1
                k+=1

            while j < len(R): 
                nums[k] = R[j] 
                j+=1
                k+=1
                
        if len(nums)>1:
                mid=len(nums)//2
                L=nums[:mid]
                R=nums[mid:]
                self.mergeSort(L)
                self.mergeSort(R)
                merge(nums,L,R)
        
    '''
    QuickSort
    Recursive
    TC: average-O(nlogn), worst-O(n^2)
    SC: average-O(logn), worst-O(n) recursion stack, in-place
    Not stable
    '''
    def quickSort(self, nums):
        # 3-way randomized
        def partition(l, r):
            pivot_idx = random.choice(range(l,r+1))
            pivot = nums[pivot_idx]
            # print(pivot)
            left, move, right = l,l,r
            while move<=right:
                if nums[move]<pivot:
                    nums[left], nums[move] = nums[move], nums[left]
                    move+=1
                    left+=1
                elif nums[move]>pivot:
                    nums[right], nums[move] = nums[move], nums[right]
                    right-=1
                else:
                    move+=1
            return left-1, move
        
        def quicksort(nums, low, high):
            if low<high:
                l,r = partition(low, high)
                quicksort(nums, low, l)
                quicksort(nums, r, high)
                
        quicksort(nums, 0, len(nums)-1)
        
        #---------------------------------------------------------------
        # def helper(head, tail):
        #     if head >= tail: return 
        #     l, r = head, tail
        #     m = (r - l) // 2 + l
        #     pivot = nums[m]
        #     while r >= l:
        #         while r >= l and nums[l] < pivot: l += 1
        #         while r >= l and nums[r] > pivot: r -= 1
        #         if r >= l:
        #             nums[l], nums[r] = nums[r], nums[l]
        #             l += 1
        #             r -= 1
        #     helper(head, r)
        #     helper(l, tail)

        # helper(0, len(nums)-1)";"def ordenar_arreglo(numeros):
    if len(numeros) <= 1:
        return numeros
    
    medio = len(numeros) // 2
    izquierda = numeros[:medio]
    derecha = numeros[medio:]
    
    izquierda = ordenar_arreglo(izquierda)
    derecha = ordenar_arreglo(derecha)
    
    i = j = k = 0
    
    while i < len(izquierda) and j < len(derecha):
        if izquierda[i] < derecha[j]:
            numeros[k] = izquierda[i]
            i += 1
        else:
            numeros[k] = derecha[j]
            j += 1
        k += 1
    
    while i < len(izquierda):
        numeros[k] = izquierda[i]
        i += 1
        k += 1
    
    while j < len(derecha):
        numeros[k] = derecha[j]
        j += 1
        k += 1
    
    return numeros"
"class Solution:
    def calPoints(self, ops: List[str]) -> int:
        stack = [] # taking an empty stack. 
        prod = 2 # taking a variable to double a provided number. 
        prev_sum = 0 # taking a variable to have sum of previous elems of the stack. 
        
        for i in range(len(ops)): # Traversing through the provided list.
            if ops[i] is not ""C"" and ops[i] is not ""D"" and ops[i] is not ""+"": # if we are having other then a number then we`ll just add it to stack. 
                stack.append(int(ops[i])) # pushing elements to the stack and making it as int bcz originally it is provided as char.
            elif ops[i] is ""C"": # if its other then a number we`ll check what it is.
                stack.pop() # removing the previous record, we as coder refer it as a last element in the stack. 
            elif ops[i] is ""D"": # if its other then a number we`ll check what it is.
                prod*=int(stack[-1]) # Again making stack element as a integer for performing product operation. 
                stack.append(prod) # Pushing the product to the stack. 
                prod=2 # reseting variable. 
            elif ops[i] is ""+"": # if its other then a number we`ll check what it is.
                prev_sum = int(stack[-2]) + int(stack[-1]) # Again as we have list elem as char, to perform adding we have to change it to int. 
                stack.append(prev_sum) # Pushing the sum to the stack. 
                prev_sum=0 # reseting variable. 
        return sum(stack) # Returning the sum of all the scores on the record(sum of elements in the stack).";"operaciones = [""5"",""2"",""C"",""D"",""+""]
registro = []

for op in operaciones:
    if op == '+':
        nuevo = registro[-1] + registro[-2]
        registro.append(nuevo)
    elif op == 'D':
        nuevo = registro[-1] * 2
        registro.append(nuevo)
    elif op == 'C':
        registro.pop()
    else:
        registro.append(int(op))

suma_total = 0
for puntaje in registro:
    suma_total += puntaje

print(suma_total)"
"class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        # Solution 1 using recursion
        while n % 4 == 0 and n > 0:
            return self.isPowerOfFour(n/4)
        return n == 1
        
        # Solution 2 iteration
        if n == 1:
            return True
        if n % 4:
            return False
        while n > 1:
            if n % 4:
                return False
            n //= 4
        return n == 1
        
        # Solution 3 using bit manipulation
        '''
        Once we write numbers in it's binary representation, from there we can observe:=>
        i. 000001 , power of 2 and 4
        ii. 000010, power of only 2
        iii. 000100 , power of 2 and 4
        iv. 001000, power of only 2
        v. 010000 , power of 2 and 4
        vi. 100000, power of only 2
        We can see if the set bit is at an odd position and is a power of 2, it's also power of 4.
        '''
        return n.bit_length() &amp, 1 and not(n &amp, (n-1))";"def es_potencia_de_cuatro(n):
    if n <= 0:
        return False
    while n % 4 == 0:
        n = n // 4
    return n == 1"
"class Solution:
    def oddEvenJumps(self, A: List[int]) -> int:
        
		# find next index of current index that is the least larger/smaller
        def getNextIndex(sortedIdx):
            stack = []
            result = [None] * len(sortedIdx)
        
            for i in sortedIdx:
                while stack and i > stack[-1]:
                    result[stack.pop()] = i
                stack.append(i)
            return result
        
        sortedIdx = sorted(range(len(A)), key= lambda x: A[x])
        oddIndexes = getNextIndex(sortedIdx)
        sortedIdx.sort(key=lambda x: -A[x])
        evenIndexes = getNextIndex(sortedIdx)
        
		# [odd, even], the 0th jump is even
        dp = [[0,1] for _ in range(len(A))]
        
        for i in range(len(A)):
            if oddIndexes[i] is not None:
                dp[oddIndexes[i]][0] += dp[i][1]
            if evenIndexes[i] is not None:
                dp[evenIndexes[i]][1] += dp[i][0]
				
        return dp[-1][0] + dp[-1][1]";"def saltos_impares_pares(arr):
    n = len(arr)
    if n == 0:
        return 0
    buenos = 0
    
    for i in range(n):
        saltos = 1
        actual = i
        puede_llegar = False
        
        while True:
            if actual == n - 1:
                puede_llegar = True
                break
                
            if saltos % 2 == 1:
                candidato = -1
                menor_valor = float('inf')
                for j in range(actual + 1, n):
                    if arr[actual] <= arr[j] and arr[j] < menor_valor:
                        menor_valor = arr[j]
                        candidato = j
                    elif arr[actual] <= arr[j] and arr[j] == menor_valor:
                        if j < candidato or candidato == -1:
                            candidato = j
                if candidato == -1:
                    break
                actual = candidato
            else:
                candidato = -1
                mayor_valor = -float('inf')
                for j in range(actual + 1, n):
                    if arr[actual] >= arr[j] and arr[j] > mayor_valor:
                        mayor_valor = arr[j]
                        candidato = j
                    elif arr[actual] >= arr[j] and arr[j] == mayor_valor:
                        if j < candidato or candidato == -1:
                            candidato = j
                if candidato == -1:
                    break
                actual = candidato
                
            saltos += 1
            
        if puede_llegar:
            buenos += 1
            
    return buenos"
"class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        
        visited = set()
        
        size = len(nums)
        
        max_subset_size = 0
        
        # check each index in input array
        for i in range(size):
            
            if nums[i] in visited:
                
                # current number has been visited
                continue
            
            # reset picking subset size to zero
            cur_subset_size = 0
            
            # keep picking if current nums[i] has not been visited 
            while nums[i] not in visited:
                
                # update current nums[i] as visited
                visited.add( nums[i] )
                
                # update subset size
                cur_subset_size += 1
                
                # i goes to next nesting index
                i = nums[i]
            
            # finished current element picking
            max_subset_size = max(max_subset_size, cur_subset_size)
            
        return max_subset_size";"def longitud_conjunto_mas_largo(numeros):
    max_longitud = 0
    n = len(numeros)
    visitados = [False] * n
    
    for i in range(n):
        if not visitados[i]:
            actual = i
            longitud_actual = 0
            while not visitados[actual]:
                visitados[actual] = True
                actual = numeros[actual]
                longitud_actual += 1
            if longitud_actual > max_longitud:
                max_longitud = longitud_actual
                
    return max_longitud"
"class Solution:
    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        self.cyclic(grid, k, len(grid), len(grid[0]))
        self.redact(grid, len(grid), len(grid[0]))
        return grid
    
    def cyclic(self, grid: List[List[int]], k: int, rows: int, cols: int):
        for r in range(rows):
            for c in range(cols):
                cell = grid[r][c]
                if cell > 1000:
                    continue
                destx, desty = self.calculate(k, r, c, rows, cols)
                while not (r == destx and c == desty):
                    self.swap(grid, r, c, destx, desty)
                    destx, desty = self.calculate(k, destx, desty, rows, cols)
                self.mark(grid, r, c)
                
    def calculate(self, k: int, currx: int, curry: int, rows: int, cols: int) -> Tuple[int, int]:
        desty = (curry + k) % cols
        destx = (currx + ((curry + k) // cols)) % rows
        return destx, desty
    
    def swap(self, m: List[List[int]], fromx: int, fromy: int, tox: int, toy: int):
        temp = m[tox][toy]
        m[tox][toy] = m[fromx][fromy] + 2001
        m[fromx][fromy] = temp
        
    def mark(self, m:List[List[int]], x: int, y: int):
        m[x][y] += 2001
        
    def redact(self, m: List[List[int]], rows: int, cols: int):
        for r in range(rows):
            for c in range(cols):
                m[r][c] -= 2001";"def desplazar_cuadricula(cuadricula, k):
    m = len(cuadricula)
    n = len(cuadricula[0]) if m > 0 else 0
    
    if m == 0 or n == 0:
        return cuadricula
    
    total_elementos = m * n
    k = k % total_elementos
    
    elementos = []
    for fila in cuadricula:
        elementos.extend(fila)
    
    elementos_desplazados = elementos[-k:] + elementos[:-k]
    
    nueva_cuadricula = []
    indice = 0
    for i in range(m):
        nueva_fila = []
        for j in range(n):
            nueva_fila.append(elementos_desplazados[indice])
            indice += 1
        nueva_cuadricula.append(nueva_fila)
    
    return nueva_cuadricula"
"class Solution:
    def soupServings(self, n: int) -> float:
        if n > 4275: return 1                                        # handle special case
        n = n // 25 + (n%25 > 0)                                     # count size of tabulation
        dp = [[0] * (n+1) for _ in range(n+1)]
        dp[n][n] = 1
        for i in range(n, 0, -1):                                    # starting from (n, n) for each soup
            for j in range(n, 0, -1):
                for a, b in [[4, 0], [3, 1], [2, 2], [1, 3]]:
                    dp[max(0, i-a)][max(0, j-b)] += dp[i][j] * 0.25  # traverse backwards from (n,n) to (0,0)
        ans = dp[0][0] / 2                                           # half the probability when `a` &amp, `b` both use up at the same time
        for j in range(1, n+1):                                      # plus when `a` use up first
            ans += dp[0][j]
        return ans";"def probabilidad_sopa(ml):
    if ml == 0:
        return 0.0
    memo = {}

    def calcular_prob(a, b):
        if (a, b) in memo:
            return memo[(a, b)]
        if a <= 0 and b <= 0:
            return 0.5
        if a <= 0:
            return 1.0
        if b <= 0:
            return 0.0
        prob = 0.0
        prob += 0.25 * calcular_prob(a - 100, b)
        prob += 0.25 * calcular_prob(a - 75, b - 25)
        prob += 0.25 * calcular_prob(a - 50, b - 50)
        prob += 0.25 * calcular_prob(a - 25, b - 75)
        memo[(a, b)] = prob
        return prob

    return calcular_prob(ml, ml)"
"class Solution:
    def findRelativeRanks(self, score: List[int]) -> List[str]:
        
        sorted_score = sorted(score, reverse=True)
        
        hashmap = {}
        
        if len(score) > 2:
            hashmap[sorted_score[0]] = ""Gold Medal""
            hashmap[sorted_score[1]] = ""Silver Medal""
            hashmap[sorted_score[2]] = ""Bronze Medal""
        
        elif len(score) == 1:
            return [""Gold Medal""]
        
        else:
            if score[0] > score[1]:
                return [""Gold Medal"", ""Silver Medal""]
            else:
                return [""Silver Medal"", ""Gold Medal""]
            
        rank = 4
        for index in range(3, len(sorted_score)):
            hashmap[sorted_score[index]] = str(rank)
            rank += 1
            
        
        return [hashmap[x] for x in score]";"puntuaciones = [10, 3, 8, 9, 4]
n = len(puntuaciones)
puntuaciones_con_indices = []
for i in range(n):
    puntuaciones_con_indices.append((puntuaciones[i], i))

puntuaciones_con_indices.sort(reverse=True, key=lambda x: x[0])

respuesta = [0] * n
for posicion in range(n):
    indice_original = puntuaciones_con_indices[posicion][1]
    if posicion == 0:
        respuesta[indice_original] = ""Gold Medal""
    elif posicion == 1:
        respuesta[indice_original] = ""Silver Medal""
    elif posicion == 2:
        respuesta[indice_original] = ""Bronze Medal""
    else:
        respuesta[indice_original] = str(posicion + 1)

print(respuesta)"
"class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:        
        # Define some CORNER Cases #
		if len(nums) == 0:
            # Nothing to do if no integers are given
			return nums
        elif len(nums) == 1:
            # Nothing to do if single integer is given
			return list(map(str, nums))
        else:
            # MAIN program begins only if 2(+) integers are provided.
			# 1st convert all integers to strings
			str_num_list = list(map(str, nums))
			# Initiate 2 lists - Slave list constitutes the 1st element of the above list, while Master is initiated as blank list.  
            slave_list = [str_num_list[0]] , master_list = [] 
			# Invoke a Lambda function to be used later.  
			# The function appends the slave element to the master list if slave list only has a single element. 
			# Otherwise, it clips the 1st and last element of the slave list, adds a ""->"" character in between them, and then appends this new element in the master list. 
            add_2_master_list = lambda mlist, slist : mlist.append(slist[0] + str(""->"") + slist[-1]) if len(slist) > 1 else mlist.append(slist[0])
            # Run a loop from 2nd element to last 
			for i in str_num_list[1:]:
				# Check if reducing 1 from i doesn't gives us last element of slave list 
				if int(i)-1 != int(slave_list[-1]):
                    # If yes, invoke that lambda function &amp, start appending elements to the master list based on elements present in slave list
					add_2_master_list(master_list, slave_list)
                    # Clear the slave_list to prepare for the next element
					slave_list.clear()
                # After every iteration, keep on appending the items in slave. Note : Slave must never be kept empty.
				slave_list.append(i)
            # Once all iterations are done, whatever items are there in the slave list have to be now added to the master list.
			# Hence again invoke the lambda function. 
			add_2_master_list(master_list, slave_list)
            # Return the master list
			return master_list";"nums = [0, 1, 2, 4, 5, 7]
resultado = []
inicio = nums[0]

for i in range(1, len(nums)):
    if nums[i] != nums[i-1] + 1:
        if inicio != nums[i-1]:
            rango = str(inicio) + ""->"" + str(nums[i-1])
        else:
            rango = str(inicio)
        resultado.append(rango)
        inicio = nums[i]

if inicio != nums[-1]:
    rango = str(inicio) + ""->"" + str(nums[-1])
else:
    rango = str(inicio)
resultado.append(rango)

print(resultado)"
"class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        """"""
        Using a 2-pointer approach, compare two strings and determines if the first string is a subset of the second string.

        :param s:
            str: String of alpha characters
        :param t:
            str: String of alpha characters
        :return
            bool: True if first string is a contiguous subset of the second string
        """"""
        # Set variables equal to the length of each input string
        left_bound, right_bound = len(s), len(t)

        # Initialize index for each pointer
        p_left = p_right = 0

        while p_left < left_bound and p_right < right_bound:
            # Move both pointers if the equal each other
            if s[p_left] == t[p_right]:
                p_left += 1
            p_right += 1
        # Return when left pointer equals length of source string
        return p_left == left_bound";"def es_subsecuencia(s, t):
    i = 0
    j = 0
    while i < len(s) and j < len(t):
        if s[i] == t[j]:
            i += 1
        j += 1
    return i == len(s)"
"class Solution:
    def brute_force(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N*N)
        Space Complexity: O(1)
        """"""
        for i in range(len(nums)):
            if i not in nums:
                return i
        return len(nums)
    
    def sorting(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(Nlog(N))
        Space Complexity: O(N)
        """"""
        nums.sort()
        
        for i, num in enumerate(nums):
            if i != num:
                return i
        return len(nums)
    
    def binary_search(self, nums: List[int]) -> int:
        """"""
        Time Complexity:
            O(Nlog(N)) if nums not sorted
            O(log(N)) if nums already sorted
        
        Space Complexity:
            O(N) if nums not sorted
            O(1) if nums sorted
        """"""
        nums.sort()
        left, right = 0, len(nums)
        mid = (left+right)//2
        while left < right:
            if nums[mid] == mid:
                left = mid+1
            else:
                right = mid - 1
            
            mid = (left + right)//2
        
        return mid + 1
    
    def hashing(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(N)
        """"""
        nums_set = set(nums)
        N = len(nums)
        for i in range(N):
            if i not in nums_set:
                return i
        
        return len(nums)
        
    def gauss_formula(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(1)
        """"""
        N = len(nums)
        return N*(N + 1)//2 - sum(nums)
    
    def xor(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(1)
        """"""
        result = len(nums)
        for i, v in enumerate(nums):
            result ^= i^v
        
        return result
    
    def cyclic_swapping(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(1)
        """"""
        current = 0
        N = len(nums)
        count = 0
        while current < N:
            count+= 1
            if nums[current] == N:
                current += 1
                continue
            
            if nums[current] == nums[nums[current]]:
                current += 1
            else:
                temp = nums[current]
                nums[current] = nums[nums[current]]
                nums[temp] = temp
        
        for i, v in enumerate(nums):
            if i != v:
                return i
        
        return N
    
    def value_inversion(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(1)
        
        Advantages:
            - Original Input array can be restored
        """"""
        
        for i, _ in enumerate(nums):
            nums[i] += 1
        
        for i, v in enumerate(nums):
            if abs(v) > len(nums):
                continue
        
            nums[abs(v)-1] = -abs(nums[abs(v)-1])
        
        for i, v in enumerate(nums):
            if v > 0:
                return i
        
        return len(nums)
                
    
    def missingNumber(self, nums: List[int]) -> int:
        # return self.brute_force(nums)
        # return self.sorting(nums)
        # return self.hashing(nums)
        # return self.gauss_formula(nums)
        # return self.xor(nums)
        # return self.cyclic_swapping(nums)
        # return self.binary_search(nums)
        return self.value_inversion(nums)";"def encontrar_numero_faltante(numeros):
    n = len(numeros)
    suma_esperada = n * (n + 1) // 2
    suma_real = 0
    for num in numeros:
        suma_real += num
    numero_faltante = suma_esperada - suma_real
    return numero_faltante"
"class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        
        @cache
        def fn(n, k):
            """"""Return min moves given n floors and k eggs.""""""
            if k == 1: return n
            if n == 0: return 0 
            lo, hi = 1, n + 1
            while lo < hi: 
                mid = lo + hi >> 1
                if fn(mid-1, k-1) < fn(n-mid, k): lo = mid + 1
                else: hi = mid 
            return 1 + max(fn(lo-1, k-1), fn(n-lo, k))
        
        return fn(n, k)";"def encontrar_piso_minimo(huevos, pisos):
    intentos = [[0] * (huevos + 1) for _ in range(pisos + 1)]
    
    for p in range(1, pisos + 1):
        for h in range(1, huevos + 1):
            intentos[p][h] = intentos[p - 1][h - 1] + intentos[p - 1][h] + 1
    
    for p in range(1, pisos + 1):
        if intentos[p][huevos] >= pisos:
            return p
    return pisos

k = int(input(""Ingresa el número de huevos: ""))
n = int(input(""Ingresa el número de pisos: ""))
print(encontrar_piso_minimo(k, n))"
"class Solution:
    def removeKdigits(self, nums: str, k: int) -> str:
       
        # Base Case
        if len(nums) == k:
            return ""0""
        
        # Init
        m = len(nums)
        
        # Build a monotonic stack, by removing
        # greater element previous to current
        # index
        stack = []
        for i in range(m):
            if stack:
                curr = int(nums[i])
                while k and stack and int(stack[-1]) > curr:
                    stack.pop()
                    k -= 1
            stack.append(nums[i])
        
        # Pop remaining k elements,
        # as they will be greatest in the
        # monotonic stack so created
        while k and stack:
            stack.pop()
            k -= 1
        
        # Join all the element in the stack
        # and first convert it to int, to
        # remove the leading zeros, and
        # then convert to string before
        # returning
        return str(int("""".join(stack)))
        
        """"""
        def REC(s: int, k: int, n: int):
            if n < 0 or k==0 or s=="""":
                return -1 if s=="""" else int(s)
            else:
                return min(REC(s[:n] + s[n+1:], k-1, n-1), REC(s,k,n-1))
        """"""
        
        """"""
        def REC(s: int, k: int, n: int, t: Dict = dict()):
            if n < 0 or k==0 or s=="""":
                return -1 if s=="""" else int(s)
            else:
                key = s 
                if key not in t:
                    t[key] = min(REC(s[:n] + s[n+1:], k-1, n-1, t), REC(s,k,n-1,t))
            return t[key]
        
        val = REC(nums, k, m-1)
        
        return """" if val == -1 else str(val) 
        """"""";"num = input(""Ingresa el número: "")
k = int(input(""Ingresa la cantidad de dígitos a eliminar: ""))

pila = []
for digito in num:
    while k > 0 and pila and pila[-1] > digito:
        pila.pop()
        k -= 1
    pila.append(digito)

while k > 0:
    pila.pop()
    k -= 1

resultado = ''.join(pila).lstrip('0')
if not resultado:
    resultado = '0'

print(resultado)"
"class Solution(object):
    def removeComments(self, source):
        """"""
        :type source: List[str]
        :rtype: List[str]
        """"""
        
        # initialize some variables to save lines and valid characters
        result = []
        current_line = """"
        
        # initialize some state variables
        in_block = False
        in_line = False
        skip_next = False
        
        for line in source:
            
            # in a new line we will never skip the first character
            skip_next = False
            
            # a new line can never be part of an inline comment
            in_line = False
            
            for index, character in enumerate(line):
                
                # ----------------------------------------------------------------
                # Guard clauses that will always skip the character, if we are in
                # a comment or notified the loop to skip the next
                # -----------------------------------------------------------------
                
                # guard clause whether we want to skip the current character
                if skip_next:
                    
                    # reset the boolean in case we skip
                    skip_next = False
                    continue
                
                # guard clause whether we are in an in line comment
                # this comment can only be ended by a new line so we do not need
                # to check the current character
                if in_line:
                    continue
                    
                # guard clause whether we are in a block comment
                if in_block:
                    
                    # since the block comment can be ended, we need to check whether we find
                    # our ending symbol
                    # line[index:index+2] slicing works also at the end of a line
                    # (even if index+2 is out of scope)
                    if line[index:index+2] == '*/':
                        
                        # in case we found the end of the block comment we switch the bool to false
                        # and we need to skip the next character
                        # Our current character (line[index]) is '*' and the next is '/' which we skip
                        in_block = False
                        skip_next = True
                        continue
                    else:
                        
                        # we are still in block comment and therefore can continue
                        continue
                
                
                # ----------------------------------------------------------------
                # After all guard clauses passed, we are not in a comment and
                # we need to check the current character whether it starts one
                # -----------------------------------------------------------------
                
                # check whether block comment begins
                # slicing of list works even if index+2 is out of scope
                if line[index:index+2] == '/*':
                    
                    # switch the comment boolean and 
                    # tell our loop we need to skip the next character
                    # since it will be a '*'
                    in_block = True
                    skip_next = True
                    continue
                
                # check whether in line comment starts
                # slicing works also at end of line
                if line[index:index+2] == '//':
                    
                    # we switch the boolean and  skip the next character as it will be
                    # '/'
                    in_line = True
                    skip_next = True
                    continue
                
                # ----------------------------------------------------------------
                # Now that all checks have passed we found
                # a character that is part of the code
                # -----------------------------------------------------------------
                
                
                # append our character to the current line
                current_line += character
            
            
            # we will append the current line to our result (finalize a line in the output)
            # a) if we are not in a block comment that hasn't ended
            # b) and the current line has characters in it
            if not in_block and current_line:
                
                # append the line and reset the current line
                result.append(current_line)
                current_line = """"
                
        return result";"def eliminar_comentarios(fuente):
    en_bloque = False
    resultado = []
    buffer = """"
    
    for linea in fuente:
        i = 0
        n = len(linea)
        while i < n:
            if en_bloque:
                if i + 1 < n and linea[i] == '*' and linea[i+1] == '/':
                    en_bloque = False
                    i += 2
                else:
                    i += 1
            else:
                if i + 1 < n and linea[i] == '/' and linea[i+1] == '*':
                    en_bloque = True
                    i += 2
                elif i + 1 < n and linea[i] == '/' and linea[i+1] == '/':
                    break
                else:
                    buffer += linea[i]
                    i += 1
        if not en_bloque and buffer:
            resultado.append(buffer)
            buffer = """"
    return resultado"
"class Solution:
    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
        a,b,c = sorted((a,b,c))
        ans = inf
        def hcf(a,b):
            if a %b == 0: return b
            return hcf(b , a % b)
        p,q,r= hcf(a,b),hcf(b,c),hcf(a,c)
        s = hcf(r,b)
        x1 = (a*b) // p
        x2 = (b*c) // q 
        x3 = (a*c) // r
        x4 = (a * b * c * s)// (p * q * r )
        low,high = a , a *n
        while low <= high:
            mid = (low + high)//2
            times = mid//a + mid//b + mid//c - mid//x1 - mid//x2 - mid//x3 + mid//x4
            if times < n : low = mid + 1
            elif times == n:
                ans = min(ans,mid)
                high = mid - 1
            else: high = mid - 1
        return ans";"n = int(input(""Ingresa n: ""))
a = int(input(""Ingresa a: ""))
b = int(input(""Ingresa b: ""))
c = int(input(""Ingresa c: ""))

contador = 0
numero = 1
uglies = []

while contador < n:
    if numero % a == 0 or numero % b == 0 or numero % c == 0:
        uglies.append(numero)
        contador += 1
    numero += 1

print(uglies[-1])"
"class Solution:
    def countAsterisks(self, s: str) -> int:
        count = 0
        if '|' not in s:
            count += s.count('*')
        while '|' in s:
            split_list = s.split('|', 2)
            count += split_list[0].count('*')
            s = split_list[2]
            if '|' not in split_list[2]:
                count += split_list[2].count('*')
        return count
    
# assert Solution().countAsterisks('""yo|uar|e**|b|e***au|tifu|l""') == 5
# assert Solution().countAsterisks('iamprogrammer') == 0
# assert Solution().countAsterisks('l|*e*et|c**o|*de|') == 2
# assert Solution().countAsterisks(""||*"") == 1
# assert Solution().countAsterisks(""|*|"") == 0
# assert Solution().countAsterisks(""||"") == 0
# assert Solution().countAsterisks(""*||"") == 1
# assert Solution().countAsterisks(""*"") == 1";"s = input(""Ingresa la cadena: "")
contador_asteriscos = 0
dentro_de_barras = False
for caracter in s:
    if caracter == '|':
        dentro_de_barras = not dentro_de_barras
    elif caracter == '*' and not dentro_de_barras:
        contador_asteriscos += 1
print(contador_asteriscos)"
"class Solution:
    def duplicateZeros(self, arr: List[int]) -> None:
        """"""
        Do not return anything, modify arr in-place instead.
        """"""
        possible_duplicates = 0
        length = len(arr) - 1
        # going left to right 
        # and counting zeros to be considered for duplication
        # why considering whole length of array and not leaving last element?
        # Ans:=> in this case last element could be zero and if we don't iterate over the whole array we would end up duplicating it in the next iteration as we would miss not considering the last element for no-duplication
        for left in range(length + 1):
            # left goes beyond allowed elements, stop iteration
            if left > length - possible_duplicates:
                break
            
            # count zeros
            if arr[left] == 0:
                # edge case: don't include the last element which can not be duplicated due to no more space available in the array
                if left == length - possible_duplicates:
                    # move this zero to the end of the array
                    arr[length] = arr[left]  # or 0
                    length -= 1  # we don't have to consider placing this element to its correct position because we already did so
                    break  # break out of the loop, we have already visited and seen all the elements that could be part of resulting arr, we don't have to calculate this 0 too.
                possible_duplicates += 1
        
        last_index = length - possible_duplicates
        # going right to left and placing elements at their correct index
        # also, duplicating zeros
        for right in range(last_index, -1, -1):
            if arr[right] == 0:
                arr[right + possible_duplicates] = arr[right]  # or 0
                # decrement zero
                possible_duplicates -= 1
                arr[right + possible_duplicates] = arr[right]  # or 0, duplicating zero
            
            else:
                arr[right + possible_duplicates] = arr[right]";"arr = [1, 0, 2, 3, 0, 4, 5, 0]
longitud_original = len(arr)
i = 0

while i < longitud_original:
    if arr[i] == 0:
        for j in range(longitud_original - 1, i, -1):
            arr[j] = arr[j - 1]
        if i + 1 < longitud_original:
            arr[i + 1] = 0
            i += 1
    i += 1

print(arr)"
"class Solution:
    def maximumGap(self, arr: List[int]) -> int:
        min1 = float('inf')
        max1 = float('-inf')
        n = len(arr)
        if (n < 2):
            return 0
        
        for i in range(0, n):
            min1 = min(min1, arr[i])
            max1 = max(max1, arr[i])
                
        if (max1 == min1):
            return 0
        gap = (max1 - min1) // (n-1)
        # print((max1-min1)/(n-1), min1, max1, n-1, max1-min1, 8/3)
        # print(gap)
        if ((max1 - min1) % (n-1) != 0):
            gap += 1 
        
        # print(gap, min1, max1)
        
        # new_arr = [0]*(n+1)
        # for i in range(0, n+1):
        #     new_arr[i]= [min1 + (i* gap), min1 + (i+1)*gap-1]
        # print(new_arr)
        min_bucket = [float('inf')] * (n)
        max_bucket = [float('-inf')] * (n)
        # print(min_bucket, max_bucket)
        for i in range(0, n):
            bucket_num = (arr[i] - min1) // gap
            # print(bucket_num)
            
            min_bucket[bucket_num] = min(arr[i], min_bucket[bucket_num])
            
            max_bucket[bucket_num] = max(arr[i], max_bucket[bucket_num])
            
            
        # print(min_bucket, max_bucket)
        
#         print(max_bucket[1])
        
#         if (max_bucket[1] == -inf):
#             print('es')
        
        prev = max_bucket[0]
        ans = float('-inf')
        for i in range(1, len(min_bucket)):
        # print(""Ok"", prev)
            if (prev == float('-inf') or min_bucket[i] == float('inf')): 
                # print(""EXE"")
                continue
            ans = max(ans, min_bucket[i] - prev)
            # print(""prev"",min_bucket[i], ans, prev)
            prev = max_bucket[i]

        return ans";"def maxima_diferencia(numeros):
    if len(numeros) < 2:
        return 0
    
    numeros_ordenados = sorted(numeros)
    maxima_diff = 0
    
    for i in range(len(numeros_ordenados) - 1):
        diferencia = numeros_ordenados[i + 1] - numeros_ordenados[i]
        if diferencia > maxima_diff:
            maxima_diff = diferencia
    
    return maxima_diff"
"class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if amount == 0 or not coins: return 0
        
        # this dp will hold the number of coins
        # required for every amount from 0..amount
        dp = [float('inf')] * (amount+1)
        
        # to have a sum of zero
        # we don't need any coins i.e 0
        dp[0] = 0
        
        # brute force, we'll calculate
        # the coins needed for every amount
        # starting from 1 since we've calculated 0
        for a in range(1, amount+1):
            # for every amount, we'll
            # try to form coins with every
            # available coin
            for c in coins:
                # if the current amount is less
                # than the current coin, you can't
                # make that amount with this coin
                # so skip it. i.e. if a = 2 and coin = 5
                # you should not bother computing anything here
                if a-c >= 0:
                    # otherwise, you check the min
                    # of the num(coins) for current amount
                    # and the 1 plus the coins required
                    # by amount-c i.e. to make the amount 0
                    # for e.g. if amount = 7 and coin = 3,
                    # we can say the coins needed to make 7
                    # would be the coin of denomination 4 (+1) and
                    # the number of coins taken to reach 3
                    # => 1 + dp[3] so that we can easily reach the sum i.e 7
                    dp[a] = min(dp[a], dp[a-c]+1)
            
        # we need to return -1 if we weren't able to find
        # an answer i.e. no updates were made and the amount
        # still has the initial value we had set i.e float('inf')
        return dp[amount] if dp[amount] != float('inf') else -1";"def monedas_minimas(monedas, cantidad):
    dp = [float('inf')] * (cantidad + 1)
    dp[0] = 0
    
    for moneda in monedas:
        for i in range(moneda, cantidad + 1):
            if dp[i - moneda] + 1 < dp[i]:
                dp[i] = dp[i - moneda] + 1
    
    if dp[cantidad] != float('inf'):
        return dp[cantidad]
    else:
        return -1"
"class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """"""
        Do not return anything, modify board in-place instead.
        """"""
        life = []
        for i in range(len(board)):
            col = []
            for j in range(len(board[0])):
                col.append(board[i][j])
            life.append(col)
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == 1:
                    if self.check(board,i,j) == True:
                        life[i][j] = 0
                else:
                    if self.check(board,i,j) == True:
                        life[i][j] = 1
        for i in range(len(life)):
            for j in range(len(life[0])):
                board[i][j] = life[i][j]
                
    def check(self,board,i,j):
        count = 0
        if board[i][j]==1:
            #diagonal top left to bottom right
            if i !=0 and j !=0 :
                if board[i-1][j-1] == 1:
                    count+=1
            if i != len(board)-1 and j != len(board[0])-1:
                if board[i+1][j+1] == 1:
                    count+=1
            #diagonal top right to bottom left
            if i!=0 and j != len(board[0])-1:
                if board[i-1][j+1] ==1:
                    count+=1
            if i!= len(board)-1 and j!=0:
                if board[i+1][j-1] == 1:
                    count +=1
            #top and bottom vertically
            if i!=0 and board[i-1][j]==1:
                count+=1
            if i!= len(board)-1 and board[i+1][j]==1:
                count +=1
            #left and right horizontally
            if j!=0 and board[i][j-1] ==1:
                count+=1
            if j!= len(board[0])-1 and board[i][j+1]==1:
                count+=1
            if count ==2 or count == 3:
                return False
            else:
                return True
        else:
            if board[i][j]==0:
                #diagonal top left to bottom right
                if i !=0 and j !=0 :
                    if board[i-1][j-1] == 1:
                        count+=1
                if i != len(board)-1 and j != len(board[0])-1:
                    if board[i+1][j+1] == 1:
                        count+=1
                #diagonal top right to bottom left
                if i!=0 and j != len(board[0])-1:
                    if board[i-1][j+1] ==1:
                        count+=1
                if i!= len(board)-1 and j!= 0:
                    if board[i+1][j-1] ==1:
                        count +=1
                #top and bottom vertically
                if i!=0 and board[i-1][j]==1:
                    count+=1
                if i!= len(board)-1 and board[i+1][j]==1:
                    count +=1
                #left and right horizontally
                if j!=0 and board[i][j-1] ==1:
                    count+=1
                if j!= len(board[0])-1 and board[i][j+1]==1:
                    count+=1
                if count == 3:
                    return True
                else:
                    return False";"def siguiente_estado(tablero):
    if not tablero:
        return
    
    filas = len(tablero)
    columnas = len(tablero[0])
    
    copia_tablero = [[0 for _ in range(columnas)] for _ in range(filas)]
    
    for i in range(filas):
        for j in range(columnas):
            copia_tablero[i][j] = tablero[i][j]
    
    direcciones = [(-1, -1), (-1, 0), (-1, 1),
                   (0, -1),          (0, 1),
                   (1, -1),  (1, 0), (1, 1)]
    
    for i in range(filas):
        for j in range(columnas):
            vecinos_vivos = 0
            
            for direccion in direcciones:
                ni = i + direccion[0]
                nj = j + direccion[1]
                
                if 0 <= ni < filas and 0 <= nj < columnas and copia_tablero[ni][nj] == 1:
                    vecinos_vivos += 1
            
            if copia_tablero[i][j] == 1:
                if vecinos_vivos < 2 or vecinos_vivos > 3:
                    tablero[i][j] = 0
            else:
                if vecinos_vivos == 3:
                    tablero[i][j] = 1"
"class Solution:
	#Time-Complexity: O(logn * (n/2)) -> O(nlogn) -> while loop runs at most logn times since
	#we divide nums array size by half each iteration, and the for loop runs at most n/2 times!
	#Space-Complexity: O(logn * (n/2)) -> for each iteration of while loop, we allocate
	#copy array of size at worst (n/2) -> O(nlogn)
    def minMaxGame(self, nums: List[int]) -> int:
        
        #just simulate it?
        min_flag = True
        
        while len(nums) > 1:
            copy = []
            for i in range(0, len(nums)-1, 2):
                if(min_flag):
                    copy.append(min(nums[i], nums[i+1]))
                    min_flag = (not min_flag)
                    continue
                
                else:
                    copy.append(max(nums[i], nums[i+1]))
                    min_flag = (not min_flag)
                    continue
            
            nums = copy
            min_flag = True
        
        return nums[0]";"nums = [1, 3, 5, 7, 9, 11, 13, 15]  # Ejemplo de entrada, puedes cambiarlo

while len(nums) > 1:
    nueva_longitud = len(nums) // 2
    nuevos_nums = [0] * nueva_longitud
    
    for i in range(nueva_longitud):
        if i % 2 == 0:
            nuevos_nums[i] = min(nums[2 * i], nums[2 * i + 1])
        else:
            nuevos_nums[i] = max(nums[2 * i], nums[2 * i + 1])
    
    nums = nuevos_nums

print(nums[0])"
"class Solution:
    def rob(self, nums: List[int]) -> int:
        # How many money we can make we we reach last house
        # How many money we can make when we reach i house
        # iterate from left to right
        # when reach i'th  house the money we can make is from
        # (First) dp[i-2] which is the maimum value we can make when reach (i-2)'th house plus the curr nums[i]
        # (Second) get the money from dp[i-1] which is the maximum value we can make when reach (i-1)'th house. However, we can't add current num[i], since when we take the money from (i-1)'th house, we can not take the adjacent house
        # store the maximum between (First) and (Second)
        # check the base case dp[0] give nums[0] is ok, However, dp[1] =  max(dp[1-1],dp[1-2]+nums[1]), we don't have dp[-1], therefore we give a extra space at the frony.
        # dp = [0]*(n+1). Therefore, i in dp correspond to i-1 in nums, That is now the dp[1] = nums[0]
        
        # Method 1
        # Time: O(n), Space: O(n)
        
        n = len(nums) 
        dp = [0]*(n+1)
        dp[1] = nums[0]
        for i in range(2,n+1):
            dp[i] = max(dp[i-1],dp[i-2]+nums[i-1])
        return dp[-1]
        
        # Method 2
        # Since we only need dp[i-1], dp[i-2]. we can create variable and save space
        # Time: O(n), Space: O(1)
        first = 0
        second = 0
        for num in nums:
            first, second =  second, max(first + num, second)
        return second            
            
        # Method 3 same as method 2
        # Time: O(n), Space: O(1)
        first_value = 0 
        second_value = 0
        
        for num in nums:
            temp = max(num + first_value, second_value)
            first_value = second_value
            second_value = temp
        return second_value";"def robo_casas(dinero):
    if not dinero:
        return 0
    if len(dinero) == 1:
        return dinero[0]
    
    max_dinero = [0] * len(dinero)
    max_dinero[0] = dinero[0]
    max_dinero[1] = max(dinero[0], dinero[1])
    
    for i in range(2, len(dinero)):
        max_dinero[i] = max(max_dinero[i-1], max_dinero[i-2] + dinero[i])
    
    return max_dinero[-1]"
"class Solution:
    def minimizeXor(self, num1: int, num2: int) -> int:
        # determine number of 1's in binary representation
        # which is also equal to bin(num2[1:]).count(""1"")
        n2 = 0
        while num2:
            if num2 &amp, 1:    # last bit is 1
                n2 += 1     # increase count
            num2 >>= 1      # shift the binary number to the right

        # search for indices for 0's and 1's
        # n = 110 (binary form) => bits1{0: [0], 1: [1, 2]}
        bits1 = {0: [], 1: []}
        i = 0    # index from the right side
        while num1:
            if num1 &amp, 1:   # decide which list to append
                bits1[1].append(i)
            else:
                bits1[0].append(i)
            i += 1        # increase index
            num1 >>= 1    # shift the number to the right

        # list of positions - reversed for 1 (left to right)
        # straight for 0 (right to left)
        target_pos = bits1[1][::-1] + bits1[0]    # positions for 1
        # if we need more 1's to be placed into the target number
        if len(target_pos) < n2:
            next_pos = target_pos[0] + 1    # most left position
            # fill it in with consecutive positions
            target_pos += list(range(next_pos,
                                     next_pos + n2 - len(target_pos)))
        # cut the list to the required length n2
        target_pos = target_pos[:n2]
        # find the final number by shifting 1's to the target positions
        # e.g. target = 101 == 100 + 001 in binary
        return sum(1 << pos for pos in target_pos)";"def contar_bits(num):
    contador = 0
    while num > 0:
        if num & 1:
            contador += 1
        num = num >> 1
    return contador

num1 = int(input())
num2 = int(input())
bits_num2 = contar_bits(num2)

x = 0
min_xor = float('inf')
mejor_x = 0

for posible_x in range(1, num1 + num2 + 1):
    if contar_bits(posible_x) == bits_num2:
        xor_actual = posible_x ^ num1
        if xor_actual < min_xor:
            min_xor = xor_actual
            mejor_x = posible_x

print(mejor_x)"
"class Solution:
    def wordPattern(self, letters: str, words: str) -> bool:
        '''
		Renamed parameters to less confusing names.
		""patterns"" to ""letters"".
		""s"" to ""words"".
		
		Solution:
		
        Return False if the number of letters and words are not the same.
   
        Traverse the letters, one by one and return False if:
        
        A letter together with its corresponding word in words
        (same index as in letters) meets a condition when compared:
        
        With letters as keys in the dictonary and words as
        corresponding values:
        
        1. Return False if: 
           Current letter/key in loop already exists but
           isn't the same as the letter/word pair currently in comparison.
        
        2. Return False if:
           Current letter in loop is not yet a key but the corresponding
           word is a value in the dictionary already. 
           (Otherwise add the letter and word 
           as key/value pairs to the dict)
           
        Return True if the loop is complete, which means that all letters 
		have been compared with corresponding words without finding any of the
		above issues.
        '''
        
        words = words.split()
        
        if len(letters) != len(words):
            return False
			
		pairs = dict()
        
        for i, letter in enumerate(letters):
            if letter in pairs.keys():
                if pairs[letter] != words[i]:
                    return False
            elif words[i] not in pairs.values():
                pairs[letter] = words[i]
            else:
                return False
            
        return True";"def cumple_patron(patron, cadena):
    palabras = cadena.split()
    if len(patron) != len(palabras):
        return False
    
    mapa = {}
    valores_mapeados = set()
    
    for i in range(len(patron)):
        letra = patron[i]
        palabra = palabras[i]
        
        if letra in mapa:
            if mapa[letra] != palabra:
                return False
        else:
            if palabra in valores_mapeados:
                return False
            mapa[letra] = palabra
            valores_mapeados.add(palabra)
    
    return True"
"class Solution:            # Suppose for example:
                           #    words1 = ['food', 'coffee', 'foofy']
                           #    words2 = ['foo', 'off']
                           #  
                           # Here's the plan:
                           #   1) Construct a dict in which the key is a char in
                           #      one or more words in words2, and the key's max
                           #      count in those words.
                           #            for 'foo': c2 = {'o': 2, 'f': 1}
                           #            for 'off': c2 = {'o': 1, 'f': 2}
                           #            so: d = {'o': 2, 'f': 2}
                           #
                           #   2) Use a counter for each word in words1 to determine 
                           #      whether the word has at least the quantity of each char
                           #      in d:
                           #            for 'food'  : c1 = {'o': 2, 'f': 1, 'd': 1}          (fails at 'f')
                           #            for 'coffee': c1 = {'f': 2, 'e': 2, 'o': 1, 'c': 1 } (fails at 'o')
                           #            for 'foofy ': c1 = {'f': 2, 'o': 2, 'y': 1}          (success)
                           #
                           #   3) return answer:
                           #            answer = ['foofy'] 
                           #
    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:
        d, ans = defaultdict(int), []

        for word in words2:                     #  <-- 1)
            c2 = Counter(word)
            for ch in c2:
                d[ch] = max(d[ch], c2[ch])

        for word in words1:                     #  <-- 2)
            c1 = Counter(word)

            for ch in d:
                if c1[ch] < d[ch]: break
            else:
                ans.append(word)                #  <-- else executes only if the for-loop
                                                #      completes without break

        return ans                              #  <-- 3)";"def es_subconjunto(b, a):
    conteo_b = {}
    for letra in b:
        if letra in conteo_b:
            conteo_b[letra] += 1
        else:
            conteo_b[letra] = 1
    
    conteo_a = {}
    for letra in a:
        if letra in conteo_a:
            conteo_a[letra] += 1
        else:
            conteo_a[letra] = 1
    
    for letra in conteo_b:
        if letra not in conteo_a or conteo_b[letra] > conteo_a[letra]:
            return False
    return True

def encontrar_universales(palabras1, palabras2):
    universales = []
    for palabra in palabras1:
        es_universal = True
        for b in palabras2:
            if not es_subconjunto(b, palabra):
                es_universal = False
                break
        if es_universal:
            universales.append(palabra)
    return universales"
"class Solution:
    def isHappy(self, n: int) -> bool:   
        # Maintain the additions we have done, so we know when the loop goes infinite
        duplicate = {}
        
        # Use recursion: calculate sum of digits, add to duplicates map, and re-call the method
        def check(n: int) -> bool:
            if n == 1:
                # we return true -> since it is a happy number
                return True
            
            # Find the digits. Note: order in the list does not matter here. 
            res = []
            while n > 0:
                w = n%10
                res.append(w)
                n = n//10
        
            # Since we have the digits now, add the digits
            add = 0
            for num in res:
                add += num**2
            
            # Return False if sum in duplicate map, or re-call the method with new sum
            if add in duplicate:
                # Loop detected
                return False
            else:
                duplicate[add] = 0
                return check(add)
        
        # calling the main method
        return check(n)";"def es_numero_feliz(n):
    visto = set()
    while n != 1 and n not in visto:
        visto.add(n)
        suma = 0
        temp = n
        while temp > 0:
            digito = temp % 10
            suma += digito * digito
            temp = temp // 10
        n = suma
    return n == 1"
"class Solution:
    def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:
        # Stack: go from back and use stack to get ans
        # Time: O(n)
        # Space: O(n)
        
        stack = [] # index
        ans = [-1] * len(cars)
        for i in range(len(cars)-1,-1,-1):
            # remove cars that are faster than current car since it will never collide
            while stack and cars[i][1] <= cars[stack[-1]][1]: 
                stack.pop()

            while stack: # if car left, we can compute collide time with current car. 
                collision_t = (cars[stack[-1]][0] - cars[i][0]) / (cars[i][1] - cars[stack[-1]][1])
                # if current car's collide time is greater than previous car's collide time 
                # (previous collided before current), then we have to find previous car's previous car
                # to compute collide time with that car, so we pop from stack and re-process
                # Otherwise, we add that collide time to answer and break
                if ans[stack[-1]] == -1 or collision_t <= ans[stack[-1]]:
                    ans[i] = collision_t
                    break
                stack.pop()
            stack.append(i)
        return ans";"def tiempo_colisiones(coches):
    respuesta = [-1] * len(coches)
    pila = []
    
    for i in range(len(coches) - 1, -1, -1):
        posicion, velocidad = coches[i]
        
        while pila:
            j = pila[-1]
            pos_j, vel_j = coches[j]
            
            if velocidad <= vel_j:
                pila.pop()
            else:
                tiempo_colision = (pos_j - posicion) / (velocidad - vel_j)
                if tiempo_colision <= respuesta[j] or respuesta[j] == -1:
                    respuesta[i] = tiempo_colision
                    break
                else:
                    pila.pop()
        
        pila.append(i)
    
    return respuesta"
"class Solution:
    def closestRoom(self, rooms: List[List[int]], queries: List[List[int]]) -> List[int]:
        ans = [0] * len(queries)
        
        # sort queries to handle largest size queries first
        q = deque(sorted([(size, room, i) for i, (room, size) in enumerate(queries)], key=lambda a: (-a[0], a[1], a[2])))

        # sort rooms by descending size
        rooms = deque(sorted(rooms, key=lambda x: -x[1]))

        # current available room ids
        cands = []
        
        
        while q:
            size, room, i = q.popleft()
            # add room ids to candidates as long as top of room size meet the requirements
            while rooms and rooms[0][1] >= size:
                bisect.insort(cands, rooms.popleft()[0])
                    
            # if no room size available, return -1
            if not cands: ans[i] = -1
                
            # else use bisect to find optimal room ids
            else:
                loc = bisect.bisect_left(cands, room)
                if loc == 0: ans[i] = cands[loc]
                elif loc == len(cands): ans[i] = cands[-1]
                else: ans[i] = cands[loc - 1] if room - cands[loc - 1] <= cands[loc] - room else cands[loc]
        
        return ans";"def encontrar_habitaciones(habitaciones, consultas):
    respuesta = []
    for consulta in consultas:
        preferida = consulta[0]
        min_tamano = consulta[1]
        candidatos = []
        for habitacion in habitaciones:
            id_habitacion = habitacion[0]
            tamano = habitacion[1]
            if tamano >= min_tamano:
                diferencia = abs(id_habitacion - preferida)
                candidatos.append((diferencia, id_habitacion))
        if not candidatos:
            respuesta.append(-1)
        else:
            candidatos.sort()
            respuesta.append(candidatos[0][1])
    return respuesta"
"class Solution:
    def stoneGameV(self, stoneValue: List[int]) -> int:
        def getPartialSum():
            for i in range(n):
                partial_sum[i][i] = stoneValue[i]
            for i in range(n):
                for j in range(i+1, n):
                    partial_sum[i][j] = partial_sum[i][j-1]+stoneValue[j]
                               
        # (O(n) search)    
        def preCalCutIdx():
            # based on the fact that cut index is increasing with k for 
            # partial_sum[start][k]
            for i in range(n-1):
                cp = i
                cut_index[i][i+1] = i
                for j in range(i+2, n):
                    while cp < j-1 and partial_sum[i][cp] < partial_sum[cp+1][j]:
                        cp += 1  
                    cut_index[i][j] = cp
		
			
        @lru_cache(None)
        def dfs(start, end):
            if start >= end:
                return 0
            max_score = 0
            # find first cut s.t. left sum >= right sum 
            cut = cut_index[start][end]
            # we can't find cut s.t. left sum >= right sum
            if cut == -1:
                cut = end-1
            sum1 = partial_sum[start][cut]
            sum2 = partial_sum[cut+1][end]
            if sum1 < sum2:
                # calcuate left[start][cut] if not yet
                dfs(start, cut)
                # the remaining will be the left part for sure, no 
                # matter where the cut is. 
                max_score = left[start][cut]
            elif sum1 == sum2:
                dfs(start, cut)
                dfs(cut+1, end)
                # if real cut in the range of [cut+1, end], remaining will be the right part
                # if real cut in the range of [0, cut], remaing will be the left part
                # if real cut is cut, either can be the remaining. 
                max_score = max(left[start][cut], right[cut+1][end])
            else:
                dfs(cut+1, end)
                # we are selecting the cut in the range of [cut, end] having 
                # the max score. For cut in that range, the remaining is 
                # the right part of the cut for sure. 
                max_score = right[cut+1][end]
                if cut > start:
                    dfs(start, cut-1)
                    # we are selecting the cut in the range of [0, cut] having 
                    # the max score. The remaining is the left part for sure. 
                    max_score = max(max_score, left[start][cut-1])
            dfs(start, end-1)
            dfs(start+1, end)
            # updating left and right arrays. 
            left[start][end] = max(left[start][end-1], partial_sum[start][end]+max_score)
            right[start][end] = max(right[start+1][end], partial_sum[start][end]+max_score)
            return max_score
            
        n = len(stoneValue)
        partial_sum = [[0]*n for _ in range(n)]
        cut_index = [[-1]*n for _ in range(n)]
        # left[i][j]: cut in the range of [i, j], max score of left part
        # right[i][j]: cut in the range of [i, j], max score of right part
        left = [[0]*n for _ in range(n)]
        right = [[0]*n for _ in range(n)]
        for i in range(n):
            left[i][i] = stoneValue[i]
            right[i][i] = stoneValue[i]
        getPartialSum()
        # for partial_sum[i][j], find cut index between i and j 
        # s.t partial_sum[i][cut_index] >= partial_sum[cut_index+1][j] or 
        # cut_index = j-1 if not exist. 
        preCalCutIdx()
        return dfs(0, n-1)";"def piedras(piedras_valor):
    n = len(piedras_valor)
    suma_prefijo = [0] * (n + 1)
    for i in range(n):
        suma_prefijo[i + 1] = suma_prefijo[i] + piedras_valor[i]
    
    memo = [[-1 for _ in range(n)] for _ in range(n)]
    
    def dp(izq, der):
        if izq == der:
            return 0
        if memo[izq][der] != -1:
            return memo[izq][der]
        
        max_puntaje = 0
        for k in range(izq, der):
            suma_izq = suma_prefijo[k + 1] - suma_prefijo[izq]
            suma_der = suma_prefijo[der + 1] - suma_prefijo[k + 1]
            
            if suma_izq < suma_der:
                puntaje = suma_izq + dp(izq, k)
            elif suma_izq > suma_der:
                puntaje = suma_der + dp(k + 1, der)
            else:
                puntaje = suma_izq + max(dp(izq, k), dp(k + 1, der))
            
            if puntaje > max_puntaje:
                max_puntaje = puntaje
        
        memo[izq][der] = max_puntaje
        return max_puntaje
    
    return dp(0, n - 1)"
"class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:  # Time: O(n) and Space: O(1)

        # Find Middle: find middle and divide the list in to two
        slow, fast = head, head.next  # head(slow) -> 1 -> 2(fast) -> ...
        while fast and fast.next:     # while fast exists and there is next element to travel keep moving
            slow = slow.next          # fast moving twice as much as slow, will lead slow to point in the middle 
            fast = fast.next.next     # Even(4): slow = 2, fast = 4 &amp, Odd(5): slow = 3, fast = None 

        # Reverse: reverse the second list
        second = slow.next       # in Odd case lets say 1-> 2(slow) -> 3 -> 4(fast): second = 3(2.next) 
        prev = slow.next = None  # Created Two separate nodes 1->2 &amp, 3->4 
        while second:
            tmp = second.next   # tmp = 4
            second.next = prev  # 3 -> None
            prev = second       # prev = 3
            second = tmp        # second = 4
        # So, in the next iteration 
            # tmp = None 
            # 4.next = prev(3) and our linked is reversed
			# prev = 4 
			# second = None

        # Merge: merge the first with the reversed second  
        first, second = head, prev  # first will point to starting of the 1st Node and second to 2nd Node
        while second:
            tmp1, tmp2 = first.next, second.next  # tmp1 = 2, tmp2 = 3
            first.next = second                   # 1 -> 4
            second.next = tmp1                    # 4.next = 2 i.e. 1 -> 4 -> 2 
            first, second = tmp1, tmp2            # first = 2, second = 3
        # So, in the next iteration 
            # tmp1 = tmp2 = None
            # 2 -> 3 i.e. 1 -> 4 -> 2 -> 3
            # 1 -> 4 -> 2 -> 3 -> None
			# first = second = None";"class Nodo:
    def __init__(self, valor=0, siguiente=None):
        self.valor = valor
        self.siguiente = siguiente

def reordenar_lista(cabeza):
    if not cabeza or not cabeza.siguiente:
        return cabeza
    
    # Encontrar el medio de la lista
    lento = cabeza
    rapido = cabeza
    while rapido.siguiente and rapido.siguiente.siguiente:
        lento = lento.siguiente
        rapido = rapido.siguiente.siguiente
    
    # Dividir la lista en dos mitades
    segunda_mitad = lento.siguiente
    lento.siguiente = None
    
    # Invertir la segunda mitad
    anterior = None
    actual = segunda_mitad
    while actual:
        siguiente_temp = actual.siguiente
        actual.siguiente = anterior
        anterior = actual
        actual = siguiente_temp
    segunda_mitad_invertida = anterior
    
    # Mezclar las dos mitades
    primera_mitad = cabeza
    while segunda_mitad_invertida:
        temp1 = primera_mitad.siguiente
        temp2 = segunda_mitad_invertida.siguiente
        
        primera_mitad.siguiente = segunda_mitad_invertida
        segunda_mitad_invertida.siguiente = temp1
        
        primera_mitad = temp1
        segunda_mitad_invertida = temp2
    
    return cabeza"
"class Solution:
    def countPrimes(self, n: int) -> int:
        # Prerequisite:
        # What is prime number. What are they just the starting. 
        
        truth = [True]*n # making a list of lenght n. And keep all the values as True.
        if n<2: # as 0 &amp, 1 are not prime numbers. 
            return 0
        truth[0], truth[1] = False, False #as we added True in the truth list. So will make false for ) &amp, 1 as they are not prime numbers.
        
        i=2 # As we know 0 &amp, 1 are not prime.
        while i*i<n: # why we are doing it as i*i here is bcz lets say 5*2 = 10 is divisble by 2 as well as 5 so if 10 is already removed why to traverse a value which is already travered once. so in case of n=5 - 5<5. CONCLUSION : i<sqrt(n)
#why we are running the loop till n is bcz question says "" prime numbers that are strictly less than n"".
            if truth[i] == True:
                for j in range(i*i,n,i): # if we have mutiple of a number in the range of n, we have to remove them as they can be prime. i.e 2 is prime, but its multiple in n = 10 are 4,6,8 they cant be prime. So we will make them false(means not a prime).
                    truth[j]=False
            i += 1 # increasing our iterator.
        return truth.count(True) # will count true value";"def contar_primos(n):
    if n <= 2:
        return 0
    es_primo = [True] * n
    es_primo[0] = False
    es_primo[1] = False
    for i in range(2, int(n ** 0.5) + 1):
        if es_primo[i]:
            for j in range(i*i, n, i):
                es_primo[j] = False
    return sum(es_primo)"
"class Solution:
    def isPowerOfTwo(self, x: int) -> bool:
        
        # TC = O(1), SC = O(1)
        
        # a power of 2 has only kth bit set in its binary representation 
        # and ( power of 2 ) - 1 -> has all bits set except the kth bit
        # so taking bitwise of these two numbers would always give 0
        
        return (x!=0) and (x &amp, (x-1)) == 0
		
		# Example 1:
        # if x = 0 ans = False 
        # if x = 1 ans = True and 1 &amp, 0 == 0 -> True so True and True = True
        #   00000
        # &amp, 00001
        # ---------
        #   00000
        # ---------
		
		# Example 2:
		# if x = 16 , then x - 1 = 15, so x &amp, x-1 == 0 will check:
		# 16 =     10000       
		# 15 =  &amp,  01111
		# --------------------
		#          00000
		# --------------------";"def es_potencia_de_dos(n):
    if n <= 0:
        return False
    while n % 2 == 0:
        n = n / 2
    return n == 1"
"class Solution:
    def reverseBits(self, n: int) -> int:
        
    # Short Version
        out = str(bin(n))[::-1][:-2]
        while len(out) < 32:
            out += '0'
        return int(out, 2)
    
    # Long, step-by-step version
    # First, let's see the binary of the original number
        #print(bin(n))
        
    # Then, let's turn the number into binary, and a string and save it to a variable
        #out = str(bin(n))
        #print(out)
        
    # Next, this is fancy python for: iterate through the list from end to start in increments of -1 (backwards)
    # returning each element. This effectively reverses the string from the step above.
        #out = out[::-1]
        #print(out)

    # Now, since we turned the binary representation into a string, we have a ""0b"" at the end (since we reversed order)
    # We can remove it with python indexing [:-2]
        #out = out[:-2]
    
    # The input binary may have had leading zeros that would have been truncated
    #   i.e. 000101 -> 101
    # When reversed, those zeros are important
    #   101000 =/= 101 
    # Since we know the input number is always 32 bits, we can just add trailing zeros until we reach a length of 32
        #while len(out) < 32:
        #    out += '0'
        #print(out)
    
    # Finally, we can convert back to base-10 and return!
        #out = int(out, 2)
        #return out";"def invertir_bits(numero):
    resultado = 0
    for i in range(32):
        bit = (numero >> i) & 1
        resultado = resultado | (bit << (31 - i))
    return resultado"
"class Solution:
    def readBinaryWatch(self, turnedOn: int) -> List[str]:
        ans = set()
        m_so_far = 0
        h_so_far = 0
        #hashmap tells the possible hr and min values we can recurse on!
        hashmap = {}
        hashmap[""hr""] = [1, 2, 4, 8]
        hashmap[""min""] = [1, 2, 4, 8, 16, 32]
        
        #Paramters:
        #1. LEDS -> tell number of LEDS turned on so far!
        #2. hr_set -> set of all hour values that are already used and not available!
        #3. min_set -> similar idea as hr_set!
        def helper(LEDS, hr_set, min_set):
            nonlocal m_so_far, h_so_far, ans, turnedOn, hashmap
            #check if m_so_far or h_so_far is out of range -> invalid time!
            if(m_so_far > 59 or h_so_far > 11):
                return
            
            #base case: LEDS == input: number of turnedOn!
            #we used all LEDs and current time is valid! So we need to record it!
            if(LEDS == turnedOn):
                m_string = """"
                #if minute is single digit, we need a leading zero!
                if(0<= m_so_far <= 9):
                    m_string = m_string + ""0"" + str(m_so_far)
                else:
                    m_string = str(m_so_far)
                #no leading zero for hour!
                res = str(h_so_far) + "":"" + m_string
                ans.add(res)
                return
            
            #otherwise, we can recurse over all 4 hour values nad 6 minutes values and
            #use them only if they are not already in set! 
            for hour in hashmap[""hr""]:
                if(hour in hr_set):
                    continue
                hr_set.add(hour)
                #update the hour count and add to set before recursing!
                h_so_far += hour
                
                helper(LEDS + 1, hr_set, min_set)
                #once rec. call returns, update the count of hours as well as state of hr!
                h_so_far -= hour
                hr_set.remove(hour)
            
            for minute in hashmap[""min""]:
                if(minute in min_set):
                    continue
                
                min_set.add(minute)
                m_so_far += minute
                
                helper(LEDS + 1, hr_set, min_set)
                m_so_far -= minute
                min_set.remove(minute)
        
        helper(0, set(), set())
        return list(ans)";"def leer_horas_posibles(leds_encendidos):
    resultados = []
    for hora in range(12):
        for minuto in range(60):
            if bin(hora).count('1') + bin(minuto).count('1') == leds_encendidos:
                hora_str = str(hora)
                minuto_str = f""{minuto:02d}""
                tiempo = f""{hora_str}:{minuto_str}""
                resultados.append(tiempo)
    return resultados"
"class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        swaps, i = 0, 0
        while swaps < len(nums): # we only make the necessary amount of swaps for each entry
            start, num = i, nums[i] # start index and current number to swap
            while True:
                temp = nums[(i+k) % len(nums)] # save the value at the final location of the current value
                nums[(i+k) % len(nums)] = num # store current value at final location
                num = temp # value at final location will now be placed at its final location next iteration
                swaps += 1 # update number of swaps
                i = (i+k) % len(nums) # update index
                if start == i: break # if we have swapped all entries in the group then break
            i += 1 # if we have to loop again, when len(nums) % k == 0, then we move to the next index";"def rotar_arreglo(numeros, k):
    if len(numeros) == 0:
        return numeros
    k = k % len(numeros)
    for _ in range(k):
        ultimo = numeros[-1]
        for i in range(len(numeros) - 1, 0, -1):
            numeros[i] = numeros[i - 1]
        numeros[0] = ultimo
    return numeros"
"class Solution:
    def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:
        if not p1 != p2 != p3 != p4: return False            # 4 points have to be different
        dis = lambda x, y: (y[1]-x[1])**2 + (y[0]-x[0])**2   # lambda function to calc distance**2
        points = [p1, p2, p3, p4]
        d = collections.defaultdict(list)
        for i in range(4):                                   # calculate distance between each points to other 3
            for j in range(i+1, 4):
                distance = dis(points[i], points[j])
                d[tuple(points[i])].append(distance)
                d[tuple(points[j])].append(distance)
        for point, distances in d.items():                   # check neighbour edges equality &amp, Pythagoras theorem
            distances.sort()
            if not (distances[0] == distances[1] and sum(distances[:2]) == distances[2]): return False
        return True";"def es_cuadrado(p1, p2, p3, p4):
    puntos = [p1, p2, p3, p4]
    distancias = []
    
    for i in range(len(puntos)):
        for j in range(i + 1, len(puntos)):
            x1, y1 = puntos[i]
            x2, y2 = puntos[j]
            distancia = (x1 - x2)**2 + (y1 - y2)**2
            distancias.append(distancia)
    
    distancias.sort()
    
    if len(distancias) != 6:
        return False
    
    if distancias[0] == 0:
        return False
    
    lado = distancias[0]
    diagonal = 2 * lado
    
    if distancias[0] == lado and distancias[1] == lado and distancias[2] == lado and distancias[3] == lado:
        if distancias[4] == diagonal and distancias[5] == diagonal:
            return True
    
    return False"
"class Solution:
    def minJumps(self, arr: List[int]) -> int:
        
        n = len(arr)
        visited = set()
        
        
        if n <= 1:
            return 0
        
        same_value = dict()
        
        for i, v in enumerate(arr):
            if v not in same_value.keys():
                same_value[v]= [i]
            else:
                same_value[v].append(i)
                
        stack = list()
        level = 0
        
        stack.append((0,0))
        total = -1
        
        
        while stack:
            level,node = stack.pop(0)
        
            visited.add(node)
            
            if node == n-1:
                return level
            else:
                for a in same_value[arr[node]] :
                    if a != node and a not in visited:
                        stack.append((level+1,a))
                
                same_value[arr[node]].clear()
                
                if node+1 < n and node+1 not in visited:
                    stack.append((level+1,node+1))
                 
                if node-1 >=0 and node-1 not in visited:
                    stack.append((level+1,node-1))
                    

                                 
        return level";"def pasos_minimos(arr):
    if not arr:
        return 0
    
    n = len(arr)
    if n == 1:
        return 0
    
    from collections import deque
    cola = deque()
    cola.append(0)
    visitado = {0: 0}
    valor_a_indices = {}
    
    for i in range(n):
        valor = arr[i]
        if valor not in valor_a_indices:
            valor_a_indices[valor] = []
        valor_a_indices[valor].append(i)
    
    while cola:
        actual = cola.popleft()
        pasos = visitado[actual]
        
        if actual == n - 1:
            return pasos
        
        siguiente = actual + 1
        if siguiente < n and siguiente not in visitado:
            visitado[siguiente] = pasos + 1
            cola.append(siguiente)
        
        anterior = actual - 1
        if anterior >= 0 and anterior not in visitado:
            visitado[anterior] = pasos + 1
            cola.append(anterior)
        
        valor_actual = arr[actual]
        for indice in valor_a_indices[valor_actual]:
            if indice != actual and indice not in visitado:
                visitado[indice] = pasos + 1
                cola.append(indice)
        
        valor_a_indices[valor_actual] = []
    
    return -1"
"class Solution:
    def findWords(self, words: List[str]) -> List[str]:
        l=[""qwertyuiop"",""asdfghjkl"",""zxcvbnm""] #This list contains alphabets which are in one row of keyboard , total three rows, hence three strings
        l1=[]
		'''
		i.)We now check if all the letter in word is present in a row or not
        ii.)For instance: ""Hello""---> 'H' is in second row, hence y will be incremented by 1 and 'e' is in first row , so x will be incremented by 1
		iii.)At the end , x=2, y=z and z=0 , with none of them equal to length of word, hence we dont append it to the result
		'''
		for word in words:
            x,y,z=0,0,0
            for letter in word.lower():                        
                if letter not in l[1] and letter not in l[2]:  
				    x+=1                                                       
                elif letter not in l[0] and letter not in l[2]: # To accout for casing of words, we have used word.lower()
                    y+=1
                elif letter not in l[0] and letter not in l[1]:
                    z+=1
            if x==len(word) or y==len(word) or z==len(word):
                l1.append(word)
        return l1";"teclado_fila_1 = ""qwertyuiop""
teclado_fila_2 = ""asdfghjkl""
teclado_fila_3 = ""zxcvbnm""

palabras = [""Hello"", ""Alaska"", ""Dad"", ""Peace""]
resultado = []

for palabra in palabras:
    palabra_minuscula = palabra.lower()
    en_fila_1 = True
    en_fila_2 = True
    en_fila_3 = True
    
    for letra in palabra_minuscula:
        if letra not in teclado_fila_1:
            en_fila_1 = False
        if letra not in teclado_fila_2:
            en_fila_2 = False
        if letra not in teclado_fila_3:
            en_fila_3 = False
    
    if en_fila_1 or en_fila_2 or en_fila_3:
        resultado.append(palabra)

print(resultado)"
"class Solution {
    public int[] findErrorNums(int[] nums) {
        var st = new HashSet<Integer>(),
        int dup = Arrays.stream(nums).boxed().filter(i -> !st.add(i)).toList().get(0), n = nums.length, s = (n * (n + 1)) / 2, ts = Arrays.stream(nums).sum(),
        return new int[]{dup, s - (ts - dup)},
    }
}




python :

class Solution:
    def findErrorNums(self, nums: list[int]) -> list[int]:
        n, a, b = len(nums), sum(nums), sum(set(nums))
        s = n*(n+1)//2
        return [a-b, s-b]



C++:

vector<int> findErrorNums(vector<int>&amp, nums) {
    //sum of elements on nums
    int initialSum = accumulate(nums.begin(), nums.end(), 0),

    //put the element of nums into set to remove the duplicate number
    set<int> s,
    for(auto &amp,i: nums){
        s.insert(i),
    }

    //sum of elements of the set
    int sum = accumulate(s.begin(), s.end(), 0),

    //difference of initialSum and sum will give us the repeated number
    int repeatedNum = initialSum - sum,

    //sum of all the natural numbers from 1 to n
    int n = nums.size() + 1,

    //subtracting the sum of elements in set i.e. sum from the sum of the natural numbers will give us the missing number
    int missingNum = n * (n-1)/2 - sum,

    return {repeatedNum, missingNum},
}";"def encontrar_error(numeros):
    n = len(numeros)
    duplicado = -1
    faltante = -1
    
    for i in range(n):
        num = abs(numeros[i])
        if numeros[num - 1] < 0:
            duplicado = num
        else:
            numeros[num - 1] *= -1
    
    for i in range(n):
        if numeros[i] > 0:
            faltante = i + 1
            break
    
    return [duplicado, faltante]"
"class Solution:
    def divisorGame(self, n: int) -> bool:
        #here, the state will have single parameter: current number on chalkboard!
        #Depending on current number on chalkboard, the player to make the first move
        #can either win or lose!
        
        #I will take bottom-up approach and use a dp table filling it from the most
        #trivial base case of n=1 up to original n!
        #size n+1 for indices from 0 to n, where we don't use index 0!
        dp = [None] * (n+1)
        #player who plays when 1 on board loses!
        dp[1] = False
        
        #iterate through state's parameters in inc. order to fill our dp table!
        for i in range(2, n+1, 1):
            #iterate through each and every number btw 1 and i//2 
            #we know that any number greater than i//2  can never be a factor of i!
            can_win = False
            for a in range(1, (i//2) + 1, 1):
                if(i % a == 0):
                    #if player playing at i-a number on board will lose, then
                    #current player that played first when i was on board can win
                    #since he will choose the most optimal path for him!
                    if(dp[i - a] == False):
                        can_win = True
                        break
            #once we tried all possible numbers btw 0 and i that are factors of i,
            #we check boolean flag!
            if(can_win):
                dp[i] = True
            else:
                dp[i] = False
        #since dp[n] equals True if Alice starts first and can win or False otherewise!
        return dp[n]";"def juego_divisor(n):
    if n % 2 == 0:
        return True
    else:
        return False"
"class Solution:
    # O(n) time,
    # O(n) space,
    # Approach: greedy, hashset
    def predictPartyVictory(self, senate: str) -> str:
        n = len(senate)
        count = Counter(senate)
        
        skip_r = 0
        skip_d = 0
        removed_r = set()
        removed_d = set()
        while count['D'] > 0 and count['R'] > 0:
            for i in range(n):
                s = senate[i]
                if s == 'R':
                    if skip_r <= 0 and i not in removed_r:
                        count['D'] -=1
                        skip_d +=1
                    else:
                        if i not in removed_r:
                            skip_r -=1
                            removed_r.add(i)
                else:
                    if skip_d <= 0 and i not in removed_d:
                        count['R'] -=1
                        skip_r +=1
                    else:
                        if i not in removed_d:
                            skip_d -=1
                            removed_d.add(i)
                        
        if count['D'] > 0:
            return 'Dire'
        else:
            return 'Radiant'";"senado = input()
radiantes = []
dire = []

for i, senador in enumerate(senado):
    if senador == 'R':
        radiantes.append(i)
    else:
        dire.append(i)

while radiantes and dire:
    if radiantes[0] < dire[0]:
        radiantes.append(radiantes[0] + len(senado))
    else:
        dire.append(dire[0] + len(senado))
    radiantes.pop(0)
    dire.pop(0)

if radiantes:
    print(""Radiante"")
else:
    print(""Dire"")"
"class Solution:
    def calculateMinimumHP(self, li: List[List[int]]) -> int:
        """"""
        Bottom Up Approach (Faster than 97% Submissions)
        Array:
            -2  -3  3
            -5 -10  1
            10  30 -5
        Working:
                      2
                      5  
               0   0  6
               
                    4+1  2
               6+0  11   5
               0.    0   6
        
               3+4    5      2
                6     11     5
                0     0      6
              
              7  5  2
              6 11  5
              0  0. 6
        """"""
        n,m = len(li), len(li[0])
        dp = [[None for i in range(m)] for i in range(n)]
        
        if li[-1][-1] >= 0:
            dp[-1][-1] = 0
        else:
            dp[-1][-1] = abs(li[-1][-1]) + 1
        
        #Populate last Column Values
        j = m-1
        for i in range(n-2,-1, -1):
            reqHealth = dp[i+1][j]
            if li[i][j] >= 0:
                cHealth = li[i][j]
                print(cHealth, reqHealth)
                if cHealth >= reqHealth:
                    dp[i][j] = 0
                else:
                    dp[i][j] = reqHealth - cHealth
            else:
                mandatoryHealthToSurvive = abs(li[i][j])+1
                cHealth = 1
                if cHealth >= reqHealth:
                    dp[i][j] = mandatoryHealthToSurvive
                else:
                    dp[i][j] = mandatoryHealthToSurvive + reqHealth - cHealth
        
        #Populate last Row Value
        i = n-1
        for j in range(m-2,-1,-1):
            reqHealth = dp[i][j+1]
            if li[i][j] >= 0:
                cHealth = li[i][j]
                if cHealth >= reqHealth:
                    dp[i][j] = 0
                else:
                    dp[i][j] = reqHealth - cHealth
            else:
                mandatoryHealthToSurvive = abs(li[i][j])+1
                cHealth = 1
                if cHealth >= reqHealth:
                    dp[i][j] = mandatoryHealthToSurvive
                else:
                    dp[i][j] = mandatoryHealthToSurvive + reqHealth - cHealth
          
        #Dp
        for i in range(n-2, -1, -1):
            for j in range(m-2, -1, -1):
                reqHealth = min(dp[i+1][j], dp[i][j+1])
                if li[i][j] >= 0:
                    cHealth = li[i][j]
                    if cHealth >= reqHealth:
                        dp[i][j] = 0
                    else:
                        dp[i][j] = reqHealth - cHealth
                else:
                    mandatoryHealthToSurvive = abs(li[i][j])+1
                    cHealth = 1
                    if cHealth >= reqHealth:
                        dp[i][j] = mandatoryHealthToSurvive
                    else:
                        dp[i][j] = mandatoryHealthToSurvive + reqHealth - cHealth
        for i in dp:
            print(i)
        return max(1, dp[0][0])";"dungeon = [[-2, -3, 3], [-5, -10, 1], [10, 30, -5]]

filas = len(dungeon)
columnas = len(dungeon[0])

salud = [[0 for _ in range(columnas)] for _ in range(filas)]

salud[filas-1][columnas-1] = max(1, 1 - dungeon[filas-1][columnas-1])

for i in range(filas-2, -1, -1):
    salud[i][columnas-1] = max(1, salud[i+1][columnas-1] - dungeon[i][columnas-1])

for j in range(columnas-2, -1, -1):
    salud[filas-1][j] = max(1, salud[filas-1][j+1] - dungeon[filas-1][j])

for i in range(filas-2, -1, -1):
    for j in range(columnas-2, -1, -1):
        minimo = min(salud[i+1][j], salud[i][j+1])
        salud[i][j] = max(1, minimo - dungeon[i][j])

print(salud[0][0])"
"class Solution:
    def removeBoxes(self, boxes: List[int]) -> int:

        @cache
        def dp(l, r, count = 0):
            if l > r: return 0
            // Initial count for the letter at boxes[l]
            count += 1
            ptr = l + 1
            while ptr <= r and boxes[l] == boxes[ptr]:
                ptr += 1
                count += 1
            points = (count ** 2) + dp(ptr, r)
            for i in range(ptr + 1, r + 1):
                if boxes[l] == boxes[i]:
                    points = max(points, dp(i, r, count) + dp(ptr, i - 1))
            return points

        return dp(0, len(boxes) - 1)";"def puntuacion_maxima(cajas):
    n = len(cajas)
    if n == 0:
        return 0
    dp = [[[0 for _ in range(n)] for _ in range(n)] for _ in range(n)]
    
    for i in range(n):
        for k in range(n):
            dp[i][i][k] = (k + 1) * (k + 1)
    
    for largo in range(1, n + 1):
        for i in range(n - largo + 1):
            j = i + largo - 1
            for k in range(n):
                if i > j:
                    continue
                max_puntos = (k + 1) * (k + 1) + puntuacion_maxima(cajas[i+1:j+1])
                for m in range(i + 1, j + 1):
                    if cajas[m] == cajas[i]:
                        puntos = dp[i+1][m-1][0] + dp[m][j][k+1]
                        if puntos > max_puntos:
                            max_puntos = puntos
                dp[i][j][k] = max_puntos
    
    return dp[0][n-1][0]"
"class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n-1, -1, -1):
            for j in range(i, n):
                if(i == j):
                    dp[i][j] = nums[i]
                else:
                    dp[i][j] = nums[i] + self.getMax(dp, i+1,j, min(i+k, n-1, j))
        
        return dp[0][-1]
    
    def getMax(self, dp, startIndex, j, endIndex):
        x = -float(""inf"")
        for index in range(startIndex, endIndex+1):
            x = max(x, dp[index][j])
        return x";"nums = [1, -1, -2, 4, -7, 3]
k = 2

n = len(nums)
if n == 0:
    print(0)
    exit()

puntaje_maximo = [0] * n
puntaje_maximo[0] = nums[0]

for i in range(1, n):
    max_actual = -float('inf')
    inicio = max(0, i - k)
    for j in range(inicio, i):
        if puntaje_maximo[j] > max_actual:
            max_actual = puntaje_maximo[j]
    puntaje_maximo[i] = max_actual + nums[i]

print(puntaje_maximo[-1])"
"class Solution(object):
    def pathSum(self, root, targetSum):
        """"""
        :type root: TreeNode
        :type targetSum: int
        :rtype: int
        """"""
        self.targetSum=targetSum
        self.hashmap={0:1}
        self.prefix=0
        self.result=0
        
        self.helper(root)
        
        return self.result
    def helper(self, root):
        
        if root is None:
            return
        
        self.prefix+=root.val
        if self.prefix-self.targetSum in self.hashmap:
            self.result+=self.hashmap[self.prefix-self.targetSum]
        
        if self.prefix in self.hashmap:
            self.hashmap[self.prefix]+=1
        else:
            self.hashmap[self.prefix]=1
            
        self.helper(root.left)
        self.helper(root.right)
        
        self.hashmap[self.prefix]-=1
        self.prefix-=root.val";"class Nodo:
    def __init__(self, valor=0, izquierda=None, derecha=None):
        self.valor = valor
        self.izquierda = izquierda
        self.derecha = derecha

def contar_caminos(raiz, suma_objetivo):
    if raiz is None:
        return 0
    
    def contar_desde_nodo(nodo, suma_actual):
        if nodo is None:
            return 0
        suma_actual += nodo.valor
        contador = 0
        if suma_actual == suma_objetivo:
            contador += 1
        contador += contar_desde_nodo(nodo.izquierda, suma_actual)
        contador += contar_desde_nodo(nodo.derecha, suma_actual)
        return contador
    
    return contar_desde_nodo(raiz, 0) + contar_caminos(raiz.izquierda, suma_objetivo) + contar_caminos(raiz.derecha, suma_objetivo)"
"class Solution:
    def maximumSwap(self, num: int) -> int:
        # larger digit to swap, digit position of this digit
        high_digit = high_pos = 0
        
        # smaller digit to swap, digit position of this digit
        low_digit = low_pos = 0
        
        # greatest digit seen so far, digit postion of this digit
        cur_high_digit, cur_high_pos = -1, 0
        
        # current digit position
        pos = 1
        
        res = num
        while num: # iterate through digits from right to left
            digit = num % 10
            
            # if digit is greatest digit yet
            if digit > cur_high_digit:
                cur_high_digit, cur_high_pos = digit, pos
            
            # if digit is less than greatest digit yet
            elif digit < cur_high_digit:
                # set the digits to swap as the greatest digit yet, and this digit
                high_digit, high_pos = cur_high_digit, cur_high_pos
                low_digit, low_pos = digit, pos
            
            pos *= 10
            num //= 10
        
        # swap the digits
        res += high_digit*(low_pos - high_pos) + low_digit*(high_pos - low_pos)
        return res";"num = 1234  # Ejemplo, puedes cambiar este valor
num_str = list(str(num))
max_num = num

for i in range(len(num_str)):
    for j in range(i + 1, len(num_str)):
        num_str[i], num_str[j] = num_str[j], num_str[i]
        nuevo_num = int(''.join(num_str))
        if nuevo_num > max_num:
            max_num = nuevo_num
        num_str[i], num_str[j] = num_str[j], num_str[i]

print(max_num)"
"class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:

        @cache
        def dp(x1, y1, x2):
            y2 = x1+y1-x2

            if not(0 <= x1 < len(grid) and 0 <= y1 < len(grid[0]) and 0 <= x2 < len(grid) and 0 <= y2 < len(grid[0])):
                return -float('inf')

            if grid[x1][y1] == -1 or grid [x2][y2] == -1 :
                return -float('inf')

            if x1 == len(grid)-1 and x2 == len(grid)-1 and y1 == len(grid[0])-1 and y1 == len(grid[0])-1 :
                if grid[x1][y1] == 1 :
                    return 1 
                else :
                    return 0 

            if x1 == x2 and y1 == y2 :
                if grid[x1][y1] == 1 :
                    return 1+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                else:
                    return max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
            else :
                if grid[x1][y1] == 1 and grid[x2][y2] == 1:
                    return 2+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                elif grid[x1][y1] == 1:
                    return 1+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                elif grid[x2][y2] == 1:
                    return 1+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                else:
                    return max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
        
        if dp(0,0,0) == -float('inf'):
            return 0
        else :
            return dp(0,0,0)";"n = len(grid)
if n == 0:
    print(0)
    exit()

# Inicializar la matriz de dp para dos caminos
dp = [[[-1 for _ in range(n)] for __ in range(n)] for ___ in range(n)]

dp[0][0][0] = grid[0][0]

for paso in range(1, 2 * n - 1):
    for i1 in range(n):
        for i2 in range(n):
            j1 = paso - i1
            j2 = paso - i2
            if j1 < 0 or j1 >= n or j2 < 0 or j2 >= n:
                continue
            if grid[i1][j1] == -1 or grid[i2][j2] == -1:
                continue
            max_actual = -1
            # Posibles movimientos previos
            movimientos = [(i1-1, i2-1), (i1-1, i2), (i1, i2-1), (i1, i2)]
            for m in movimientos:
                prev_i1, prev_i2 = m
                if prev_i1 >= 0 and prev_i2 >= 0 and prev_i1 < n and prev_i2 < n:
                    if dp[prev_i1][prev_i2][j1 - 1] > max_actual:
                        max_actual = dp[prev_i1][prev_i2][j1 - 1]
            if max_actual == -1:
                continue
            if i1 == i2 and j1 == j2:
                dp[i1][i2][j1] = max_actual + grid[i1][j1]
            else:
                dp[i1][i2][j1] = max_actual + grid[i1][j1] + grid[i2][j2]

resultado = dp[n-1][n-1][n-1] if dp[n-1][n-1][n-1] != -1 else 0
print(resultado)"
"class Solution:
    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:
        if s[-1] == ""1"": # If last one equal to ""1"", then just return False.
            return False
        if minJump <= len(s)-1 <= maxJump: # If the first jump can reach the end point, then return True.
            return True
        # Initialize th max index of s, the current and previous start point, end point.
        Len, start, end, pre_start, pre_end = len(s), minJump, maxJump, -1, -1
        
        while True:
            if pre_start == start and pre_end == end: # If we can't go any further(we'll never reach the last index), return False.
                return False
            pre_start, pre_end = start, end # Update previous values.
            # Search next round ""0""s
            for i in range(pre_start, pre_end+1):
                # If s[i] equals ""0"", then we can jump
                # and make sure that at least one ""0"" in the range if we jump from index i.
                if s[i] == ""0"" and ""0"" in s[i + minJump:i + maxJump + 1]:
                    if start <= pre_end: # Update start point to a minimum value that greater than previous end point.
                        start = i + minJump
                    end = i + maxJump # Update end point to the maximum of this round.
                    if start <= Len-1 <= end: # If the start and end points contain the last index, return True.
                        return True";"def puede_alcanzar(s, min_salto, max_salto):
    n = len(s)
    if s[0] != '0' or s[-1] != '0':
        return False
    
    alcanzable = [False] * n
    alcanzable[0] = True
    
    for i in range(n):
        if alcanzable[i]:
            inicio = i + min_salto
            fin = min(i + max_salto, n - 1)
            for j in range(inicio, fin + 1):
                if s[j] == '0':
                    alcanzable[j] = True
    
    return alcanzable[-1]"
"class Solution:
    def stoneGameVI(self, alice: List[int], bob: List[int]) -> int:
        n = len(alice)
        arr = [alice[i] + bob[i] for i in range(n)]
        s = sum(bob)
        res = 0
        k = (n+1)//2
        arr.sort(reverse=True)
        for i in range(0, n, 2):
            res += arr[i]
        
        
        if res > s:
            return 1
        elif res == s:
            return 0 
        else:
            return -1";"n = len(aliceValues)
piedras = []
for i in range(n):
    suma = aliceValues[i] + bobValues[i]
    piedras.append((suma, aliceValues[i], bobValues[i]))

piedras.sort(reverse=True)

puntos_alice = 0
puntos_bob = 0
turno_alice = True

for piedra in piedras:
    if turno_alice:
        puntos_alice += piedra[1]
    else:
        puntos_bob += piedra[2]
    turno_alice = not turno_alice

if puntos_alice > puntos_bob:
    resultado = 1
elif puntos_alice < puntos_bob:
    resultado = -1
else:
    resultado = 0

print(resultado)"
"class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        
        # Sorting method
        # Time: O(nlogn) Space: O(1)
        
        # Here, we'll simply sort the list and then check if the next element == current element
        # if yes, then we'll continue
        # else we'll return the element
        
        if len(nums) == 1:
            return nums[0]
        nums.sort()
        for i in range(1,len(nums),2):
            if nums[i] != nums[i-1]:
                return nums[i-1]
        return nums[len(nums)-1]
    
    
        # Using Dictionary
        # Time: O(n) Space:O(n)
        
        # Here, we'll simply traverse through the list and 
        # insert the element and it's count as (key,value) pair
        # then we'll start iterating through the dictionary 
        # and if we find any element having count 1
        # we'll return the element
        
        res = {}
        for el in nums:
            if el in res:
                res[el] += 1
            else:
                res[el] = 1
        for key in res.keys():
            if res[key] == 1:
                return key
        
        
        # XOR method
        # Time: O(n) Space: O(1)
        
        # If you know how XOR operation works then it's pretty straight forward for you.
        
        for i in range(1,len(nums)):
            nums[0] ^= nums[i]
        return nums[0]";"def encontrar_unico(numeros):
    unico = 0
    for num in numeros:
        unico = unico ^ num
    return unico"
"class Solution:
    #n = len(arr)
    #Time-Complexity: O(n), in worst case we visit each and every index position and finds out
    #there's no indices with integer 0 !
    #Space-Complexity: O(n + n), by same argument as T.C! -> O(n)
    def canReach(self, arr: List[int], start: int) -> bool:
        #We can model this as a general directed graph problem!
        #If we are at node i(at position index i), we can either
        #jump to two descendants: arr[i] + i or arr[i] - i!
        
        #We will only add to queue index positions not already visited
        #and in-bounds!
        visited = set()
        q = collections.deque()
        q.append(start)
        visited.add(start)
        #as long as queue is not empty, keep bfs going!
        while q:
            cur_index = q.popleft()
            #check if at current index has value 0! If so, immediately
            #break and return True
            if(arr[cur_index] == 0):
                return True
            #otherwise, process the two descendants and only add to queue
            #if it's not already visited and is in-bounds!
            neighbor1 = arr[cur_index] + cur_index
            neighbor2 = cur_index - arr[cur_index]
            if(neighbor1 not in visited and 0<=neighbor1 < len(arr)):
                q.append(neighbor1)
                visited.add(neighbor1)
            if(neighbor2 not in visited and 0<=neighbor2 < len(arr)):
                q.append(neighbor2)
                visited.add(neighbor2)
        
        #once bfs is over, we tried every possible path from start!
        #could not reach index position with value of 0!
        return False";"def puede_llegar_a_cero(arr, inicio):
    tamano = len(arr)
    visitado = [False] * tamano
    cola = []
    cola.append(inicio)
    visitado[inicio] = True
    
    while cola:
        actual = cola.pop(0)
        if arr[actual] == 0:
            return True
        salto_adelante = actual + arr[actual]
        if salto_adelante < tamano and not visitado[salto_adelante]:
            visitado[salto_adelante] = True
            cola.append(salto_adelante)
        salto_atras = actual - arr[actual]
        if salto_atras >= 0 and not visitado[salto_atras]:
            visitado[salto_atras] = True
            cola.append(salto_atras)
    return False"
"# Binary Search Tree Solution -> If exact matching of intervals found then return False
#                                Else you can add this interval to that particular node's left or right
class Node:
    def __init__(self, s, e):
        self.s = s
        self.e = e
        self.left = None
        self.right = None
class MyCalendar:
    def __init__(self):
        self.head = None
        
    def insert(self, s, e, node):
        if s >= node.e:
            if node.right: return self.insert(s, e, node.right)
            else: 
                nn = Node(s, e)
                node.right = nn
                return True
        elif e <= node.s:
            if node.left: return self.insert(s, e, node.left)
            else:
                nn = Node(s, e)
                node.left = nn
                return True
        else: return False
        
    def book(self, s: int, e: int) -> bool:
        if self.head == None:
            nn = Node(s, e)
            self.head = nn
            return True
        return self.insert(s, e, self.head)";"class MiCalendario:
    def __init__(self):
        self.eventos = []

    def reservar(self, inicio, fin):
        for evento in self.eventos:
            inicio_evento, fin_evento = evento
            if inicio < fin_evento and fin > inicio_evento:
                return False
        self.eventos.append((inicio, fin))
        return True"
"class Solution:
    def reformatDate(self, date: str) -> str:
        
        month_dict = {
            'Jan':'01', 'Feb':'02', 'Mar':'03', 'Apr':'04', 'May':'05', 'Jun':'06',
            'Jul':'07', 'Aug':'08', 'Sep':'09', 'Oct':'10', 'Nov':'11', 'Dec':'12',
        }
        
        date_list = date.split()
        
        #defining empty string
        date_string = ''
        
        #year
        date_string = date_string + date_list[2] + '-' 
        
        #month
        date_string = date_string + month_dict[date_list[1]] + '-'
        
        #day
        date_day = [x for x in date_list[0] if not x.isalpha()]
        date_day_digits = ''.join(date_day)
        if len(date_day_digits) == 1:
            date_string = date_string+'0'+date_day_digits
        else:
            date_string = date_string+date_day_digits
        
        
        return date_string
        # date_String = date_string + date_list[]";"cadena_fecha = ""1st Jan 1900""

partes = cadena_fecha.split()
dia_str = partes[0]
mes_str = partes[1]
anio_str = partes[2]

numero_dia = dia_str[:-2]
if len(numero_dia) == 1:
    numero_dia = ""0"" + numero_dia
else:
    numero_dia = numero_dia

meses = {
    ""Jan"": ""01"",
    ""Feb"": ""02"",
    ""Mar"": ""03"",
    ""Apr"": ""04"",
    ""May"": ""05"",
    ""Jun"": ""06"",
    ""Jul"": ""07"",
    ""Aug"": ""08"",
    ""Sep"": ""09"",
    ""Oct"": ""10"",
    ""Nov"": ""11"",
    ""Dec"": ""12""
}
mes_numero = meses[mes_str]

fecha_formateada = anio_str + ""-"" + mes_numero + ""-"" + numero_dia
print(fecha_formateada)"
"class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        trie=Trie()
        out=[]
        words=sentence.split("" "")
        for word in dictionary:
            trie.insert(word)
        for word in words:
            out.append(trie.transfer(word))
        return "" "".join(out)
        

class TrieNode(object):
        def __init__(self):
            self.children = {}
            self.isWord = False
class Trie:

    def __init__(self):
        self.root = TrieNode()
    def insert(self, word: str) -> None:
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.isWord = True
    def transfer(self, successor: str) -> bool:
        node = self.root
        out=""""
        for char in successor:
            if node.isWord:
                return out
            if char not in node.children:
                return successor
            out+=char
            node = node.children[char]
        return successor";"diccionario_raices = [""cat"",""bat"",""rat""]
oracion = ""the cattle was rattled by the battery""

lista_raices = diccionario_raices
palabras = oracion.split()

resultado = []
for palabra in palabras:
    reemplazado = False
    for raiz in lista_raices:
        if palabra.startswith(raiz):
            resultado.append(raiz)
            reemplazado = True
            break
    if not reemplazado:
        resultado.append(palabra)

oracion_final = ' '.join(resultado)
print(oracion_final)"
"class Solution:
    def containVirus(self, mat: List[List[int]]) -> int:
        m,n = len(mat),len(mat[0])

        def dfs(i,j,visited,nextInfected):  # return no. of walls require to quarantined dfs area
            if 0<=i<m and 0<=j<n and (i,j) not in visited:
                if mat[i][j]==2: # Already quarantined cell
                    return 0
                if mat[i][j]==0:
                    nextInfected.add((i,j)) # add cell which will be infected next day
                    return 1   # require one wall to quarantined cell from one side
                    
                else:
                    visited.add((i,j))
                    return dfs(i-1,j,visited,nextInfected) + dfs(i+1,j,visited,nextInfected) + dfs(i,j-1,visited,nextInfected) + dfs(i,j+1,visited,nextInfected)  # traverse all four direction
            else:
                return 0
				
        ans = 0 
        while True:   # this loop running ""how many days we should installing the walls"" times
            # For every day check which area infect more cells
            visited = set()  # Using in dfs
            All_nextinfect  = set()
            stop , walls = set(),0   # here stop store the indices of maximum no. of cells in which we stop spreading of virus this day
            
            for i in range(m):
                for j in range(n):
                    if mat[i][j]==1 and (i,j) not in visited:
                        nextInfected = set()
                        a = dfs(i,j,visited,nextInfected)
                        
                        if len(stop)<len(nextInfected):
                            All_nextinfect  = All_nextinfect | stop # leave previous saved area from virus
                            stop = nextInfected  # pick new area which we want to save
                            walls = a  # require walls
                            p,q = i,j  # starting position(indices) of this area
                        else:
                            All_nextinfect  = All_nextinfect | nextInfected   
                            
            if not stop : # if our job is done i.e. No cell will be infect Later
                break
            ans += walls  # add new walls installed this day
            
            # change each cell value to 2 which will be covered by quarantined area
            def fun(p,q):
                if 0<=p<m and 0<=q<n and mat[p][q]==1:
                    mat[p][q]=2
                    fun(p+1,q)
                    fun(p-1,q)
                    fun(p,q-1)
                    fun(p,q+1)
            fun(p,q) # start dfs from start point of quarantined area
            
            for a,b in All_nextinfect: # set new infected cell value = 1 for iterating next day
                mat[a][b] = 1

        return ans   # Final answer";"def contener_virus(isInfected):
    filas = len(isInfected)
    if filas == 0:
        return 0
    columnas = len(isInfected[0])
    total_paredes = 0
    
    while True:
        regiones = []
        visitado = [[False for _ in range(columnas)] for _ in range(filas)]
        
        for i in range(filas):
            for j in range(columnas):
                if isInfected[i][j] == 1 and not visitado[i][j]:
                    cola = [(i, j)]
                    visitado[i][j] = True
                    region = []
                    frontera = set()
                    paredes = 0
                    region.append((i, j))
                    
                    while cola:
                        x, y = cola.pop(0)
                        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                            nx, ny = x + dx, y + dy
                            if 0 <= nx < filas and 0 <= ny < columnas:
                                if isInfected[nx][ny] == 1 and not visitado[nx][ny]:
                                    visitado[nx][ny] = True
                                    cola.append((nx, ny))
                                    region.append((nx, ny))
                                elif isInfected[nx][ny] == 0:
                                    frontera.add((nx, ny))
                                    paredes += 1
                    if frontera:
                        regiones.append((len(frontera), paredes, region, frontera))
        
        if not regiones:
            break
        
        regiones.sort(reverse=True)
        mejor_region = regiones[0]
        total_paredes += mejor_region[1]
        
        for x, y in mejor_region[2]:
            isInfected[x][y] = -1
        
        for region in regiones[1:]:
            for x, y in region[3]:
                isInfected[x][y] = 1
    
    return total_paredes"
"class Solution:
    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:
        #Let len(richer) = n and let len(quiet) = m!
        #Time: O(n + m + m + m*m + m +  m) -> O(m^2 + n)
        #Space: O(m*m + m + m + m*m + m) -> O(m^2)
        #step 1: build adjacency list representation and update indegrees of every node initially!
        adj = [[] for _ in range(len(quiet))]
        indegrees = [0] * len(quiet)
        #we want edges to go from richer to poorer so that ancestors of every node are all people
        #who have more money than the node person!
        for rel in richer:
            richer, poorer = rel[0], rel[1]
            adj[richer].append(poorer)
            indegrees[poorer] += 1
        
        queue = deque()
        ancestors = []
        for i in range(len(quiet)):
            new = set()
            new.add(i)
            ancestors.append(new)
        #step 2: fill in the queue all nodes that have indegrees of 0!

        #step 3: proceeding with Kahn's algorithm and recording list of all ancestors to every node!
        while queue:
            cur = queue.pop()
            for neighbor in adj[cur]:
                ancestors[neighbor].add(cur)
                ancestors[neighbor].update(ancestors[cur])
                indegrees[neighbor] -= 1
                if(indegrees[neighbor] == 0):
                    queue.append(neighbor)
        
        ancestors = [list(s) for s in ancestors]
        output = []
        #step 4:for each person, find the least quiet person who also has more money than the current               #person we're iterating on!
        for a in range(len(ancestors)):
            cur_ancestors = ancestors[a]
            if(len(cur_ancestors) == 1):
                output.append(a)
                continue
            minimum = cur_ancestors[0]
            for ancestor in cur_ancestors:
                #check if current person with more money than person a has lower quiet level!
                if(quiet[ancestor] < quiet[minimum]):
                    minimum = ancestor
            output.append(minimum)
        return output";"n = len(quiet)
respuesta = [0] * n
grafo = [[] for _ in range(n)]

for a, b in richer:
    grafo[b].append(a)

for persona in range(n):
    visitados = [False] * n
    cola = [persona]
    visitados[persona] = True
    menos_ruidoso = persona
    min_ruido = quiet[persona]
    
    while cola:
        actual = cola.pop(0)
        for vecino in grafo[actual]:
            if not visitados[vecino]:
                visitados[vecino] = True
                cola.append(vecino)
                if quiet[vecino] < min_ruido:
                    min_ruido = quiet[vecino]
                    menos_ruidoso = vecino
    respuesta[persona] = menos_ruidoso

print(respuesta)"
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        
        # Using the ITERATIVE APPROACH with O(logn)
        
        '''
        Step-by-step Binary Search Algorithm: We basically ignore half of the elements just after one comparison.

        1. Compare x with the middle element.
        2. If x matches with the middle element, we return the mid index.
        3. Else If x is greater than the mid element, then x can only lie in the right half subarray after the mid element. So we recur for the right half.
        4. Else (x is smaller) recur for the left half.    
        
        '''
        
        # Two containers
        low_value  = 0              # Index of first element    
        high_value = len(nums) - 1  # Index of last element
        
        while low_value <= high_value:                  # check if the �high_value� is higher than the �low_value�
            middle_value = (low_value + high_value)//2  # middle index of our list which will be the floor of the average of �high_value� plus �low_value�
            
            if nums[middle_value] == target:    # check if the middle element and the target are equal 
                return middle_value             # If they are equal, the position of the item will be returned
            
            if target < nums[middle_value]:     # check if the middle element is less than the item to be searched
                
                high_value = middle_value - 1   # the new position will shift to the right once.
                
            else:                               # check if the value of the last index is greater than or equal to the value of the first index
                                                
                low_value = middle_value + 1    #  the new position will shift to the left once
                     
        return -1  # If the target is not in the list, it will return a statement";"def buscar_objetivo(numeros, objetivo):
    izquierda = 0
    derecha = len(numeros) - 1
    
    while izquierda <= derecha:
        medio = (izquierda + derecha) // 2
        if numeros[medio] == objetivo:
            return medio
        elif numeros[medio] < objetivo:
            izquierda = medio + 1
        else:
            derecha = medio - 1
    
    return -1"
"class Solution:
    def stoneGameVII(self, stones: List[int]) -> int:
        dp = [[0 for _ in range(len(stones))] for _ in range(len(stones))]     # dp table n x n
        run_sum = [0]                            # running sum -> sum [i..j] = run_sum[j] - run_sum[i]
        s = 0
        
		## Calculation of running sum
        for i in stones:
            s += i
            run_sum.append(s)
		
        n = len(stones) 
        
        for k in range(1, n):               # no. of stones left
            for i in range(0, n - k):   # from each starting point
                remove_i_stone = (run_sum[i+k+1] - run_sum[i+1])    # score after removing i th stone
                remove_j_stone = (run_sum[i+k] - run_sum[i])             # score after removing j th stone
                
                if (n-(k+1))%2 == 0:        # alice's move 
                    dp[i][i+k] = max(remove_i_stone + dp[i+1][i+k],
                                    remove_j_stone + dp[i][i+k-1])
                else:                       # bob's move
                    dp[i][i+k] = min(-remove_i_stone + dp[i+1][i+k],
                                    - remove_j_stone + dp[i][i+k-1])
                    
        return dp[0][n - 1]";"piedras = [1, 2, 3]  # Ejemplo de entrada, puedes cambiarlo

n = len(piedras)
suma_total = sum(piedras)

# Crear una tabla para almacenar los resultados
tabla = [[0] * n for _ in range(n)]

for i in range(n - 1, -1, -1):
    for j in range(i, n):
        if i == j:
            tabla[i][j] = 0
        else:
            suma_restante_izq = suma_total - sum(piedras[i:j])
            suma_restante_der = suma_total - sum(piedras[i+1:j+1])
            opcion_izq = suma_restante_izq - tabla[i + 1][j]
            opcion_der = suma_restante_der - tabla[i][j - 1]
            tabla[i][j] = max(opcion_izq, opcion_der)

diferencia = tabla[0][n - 1]
print(diferencia)"
"# Linked List Solution
class MyHashSet(object):
    
    def __init__(self):
        self.keyRange = 769
        self.bucketArray = [LinkedList() for i in range(self.keyRange)]
        
    def _hash(self, key):
        return key % self.keyRange
    
    def add(self, key):
        bucketIndex = self._hash(key)
        self.bucketArray[bucketIndex].append(key)
        
    def remove(self, key):
        bucketIndex = self._hash(key)
        self.bucketArray[bucketIndex].deleteNodeKeyAll(key)
        # while self.bucketArray[bucketIndex].search(key):
        #     self.bucketArray[bucketIndex].deleteNodeKeyOne(key)
        
    def contains(self, key):
        bucketIndex = self._hash(key)
        return self.bucketArray[bucketIndex].search(key)
    
# ---------------------------------------------------------
## Define a linked list

class Node:
    
    def __init__(self, val, next = None):
        self.val = val
        self.next = next
        
class LinkedList:
    
    def __init__(self):
        self.head = None

# ---------------------------------------------------------
## Insert a new node

### Insert the new node at the front of the linked list
    def push(self, new_val):
        new_node = Node(new_val)
        new_node.next = self.head
        self.head = new_node
        
### Insert the new node at the end of the linked list
    def append(self, new_val):
        new_node = Node(new_val)
        if self.head is None:
            self.head = new_node
            return
        # Traverse till the end of the linked list
        last = self.head
        while last.next:
            last = last.next
        last.next = new_node

### Insert the new node after a given node
    def insertAfter(self, new_val, prev_node):
        if prev_node is None:
            print(""Please enter the node which is the previous node of the inserted node."")
            return
        new_node = Node(new_val)
        new_node.next = prev_node.next
        prev_node.next = new_node
        
# ---------------------------------------------------------
## Delete a node

### Delete a node by value
# Iterative Method
    def deleteNodeKeyOne(self, key): # delete a single node
        temp = self.head
        if temp is None:
            return
        if temp.val == key:
            self.head = temp.next
            temp = None
            return
        while temp is not None:
            if temp.val == key:
                break
            prev = temp
            temp = temp.next
        if temp is None:
            return
        prev.next = temp.next
        temp = None
        
    def deleteNodeKeyAll(self, key): # delete all the nodes with value key
        temp = self.head
        if temp is None:
            return
        while temp.val == key:
            deletedNode = temp
            self.head = temp.next
            temp = self.head
            deletedNode = None
            if temp is None:
                return
        nxt = temp.next
        while nxt is not None:
            if nxt.val == key:
                deletedNode = nxt
                temp.next = nxt.next
                deletedNode = None
            temp = nxt
            nxt = nxt.next

### Delete a node by position and return the value of the deleted node
    def deleteNodePosition(self, position):
        if self.head is None:
            return
        if position == 0:
            temp = self.head
            self.head = self.head.next
            temp = None
            return
        idx = 0
        current = self.head
        prev = self.head
        nxt = self.head
        while current is not None:
            if idx == position:
                nxt = current.next
                break
            prev = current
            current = current.next
            idx += 1
        prev.next = nxt
        current = None
        
# ---------------------------------------------------------
# Print a linked list
    def printList(self):
        temp = self.head
        while temp:
            print ("" %d"" %(temp.val))
            temp = temp.next

# ---------------------------------------------------------
## Search an element in a linked list
    def search(self, x):
        current = self.head
        while current is not None:
            if current.val == x:
                return True
            current = current.next
        return False";"class MiHashSet:
    def __init__(self):
        self.conjunto = []

    def agregar(self, clave):
        if not self.contiene(clave):
            self.conjunto.append(clave)

    def contiene(self, clave):
        return clave in self.conjunto

    def remover(self, clave):
        if self.contiene(clave):
            self.conjunto.remove(clave)"
"class Solution:
    def reachNumber(self, target: int) -> int:
        def gaussSum(n):
            return n*(n+1)//2
        
        def binaryFind(lower, upper):
            t = abs(target)
            sums, n = -1, -1
            while lower <= upper:
                mid = (lower+upper)//2
                if gaussSum(mid) >= t:
                    sums, n = gaussSum(mid), mid
                    upper = mid-1
                else:
                    lower = mid+1
            return sums, n
        
                    
        lower, upper = 0, 10**5
        # find min n s.t. 1+2+...+n>=abs(target)
        sums, n = binaryFind(lower, upper)
        while sums%2 != abs(target)%2:
            sums += n+1
            n += 1
        return n";"objetivo = int(input(""Ingresa el objetivo: ""))
objetivo = abs(objetivo)
pasos = 0
suma = 0

while suma < objetivo or (suma - objetivo) % 2 != 0:
    pasos += 1
    suma += pasos

print(pasos)"
"class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        sortedList = sorted(nums)
        n = len(nums)
        if n%2==0:
            small = sortedList[:((n//2))][::-1]
            large = (sortedList[(n//2):])[::-1]
            for i in range(1,n,2):
                nums[i] = large[i//2]
            for i in range(0,n,2):
                nums[i] = small[i//2]
        else:
            small = sortedList[:1+((n//2))][::-1]
            large = (sortedList[1+(n//2):])[::-1]
            for i in range(1,n,2):
                nums[i] = large[i//2]
            for i in range(0,n,2):
                nums[i] = small[i//2]";"def ordenar_alternado(numeros):
    copia = numeros.copy()
    copia.sort()
    n = len(copia)
    mitad = (n + 1) // 2
    j = mitad - 1
    k = n - 1
    for i in range(0, n, 2):
        numeros[i] = copia[j]
        if i + 1 < n:
            numeros[i + 1] = copia[k]
        j -= 1
        k -= 1"
"class Solution:
    def rotatedDigits(self, N: int) -> int:
        smallSet = {0,1,8}
        bigSet = {2,5,6,9}
        smallNum = [0,0,1,1,1,2,3,3,3,4][N % 10]
        bigNum = [1,2,3,3,3,4,5,5,6,7][N % 10]
        N = N // 10
        smInc, bgInc = 4, 7
        while N:
            x = N % 10
            N = N // 10
            sm, bg = 0, 0
            for i in range(x):
                if i in smallSet:
                    sm += smInc
                    bg += bgInc
                elif i in bigSet:
                    sm += bgInc
                    bg += bgInc
            if x in smallSet:
                smallNum += sm
                bigNum += bg
            elif x in bigSet:
                smallNum = bigNum + sm
                bigNum += bg
            else:
                smallNum = sm
                bigNum = bg
            smInc, bgInc = 4*bgInc + 3*smInc, bgInc * 7
        return smallNum";"def es_bueno(numero):
    rotaciones = {'0': '0', '1': '1', '8': '8', '2': '5', '5': '2', '6': '9', '9': '6'}
    numero_str = str(numero)
    rotado_str = ''
    for digito in numero_str:
        if digito not in rotaciones:
            return False
        rotado_str += rotaciones[digito]
    return rotado_str != numero_str

def contar_buenos(n):
    contador = 0
    for numero in range(1, n + 1):
        if es_bueno(numero):
            contador += 1
    return contador"
"class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:

		""Edge Case checking""
        
        if endWord not in wordList:
            return []
        
        size = len(beginWord)
        
        
        ""create llokup got all the possible wordpatters""
        
        lookup = defaultdict(list)                                  
        
        for word in wordList:                                     
            for i in range(size):
                lookup[word[:i] + ""*"" + word[i+1:]].append(word)    
        
        cur_len = 9999
        
        ans = []      
        
        ""enter the first element in the queue""
        
        queue =  collections.deque([[beginWord, 1,[beginWord]]])
        
        visited = {beginWord: True}
        
        while(queue):
            
            currWord, pathLength,words_till_now = queue.popleft()
            
            """"""
            instead of marking an elemnt vistied , when we insert it in the queue,
            we mark it as visited only when we pop and element
            this way , same word can be used by other curWords
            <ex :>
            ""red""
            ""tax""
            [""ted"",""tex"",""red"",""tax"",""tad"",""den"",""rex"",""pee""]                        
            and we make sure that element can not be used again           
            """"""
            visited[currWord] = True
            
            """"""
            run a for loop for all values for all the possible patterns for the popped word
            """"""
            
            for i in range(size):
                
                possibleWordPattern = currWord[:i] + ""*"" + currWord[i+1:]
                
                for word in lookup[possibleWordPattern]:            
                    
                    if(currWord == word):
                        continue
                    
                    """"""
                    if the word for the possibleWordPattern key matches with the end word we add it to the 
                    ans list
                    """"""
                        
                    if(word == endWord):                                                    
                        
                        if cur_len == pathLength + 1:
                                                    
                            ans.append(words_till_now+[word])
                        elif cur_len > pathLength + 1:
                            
                            ans = [words_till_now+[word]]
                            
                            cur_len = pathLength + 1
                    
                    if(word not in visited):                        
                        queue.append([word, pathLength + 1,words_till_now+[word]])
        
        return ans";"from collections import deque

def encontrar_secuencias(palabra_inicio, palabra_fin, lista_palabras):
    if palabra_fin not in lista_palabras:
        return []
    
    lista_palabras = set(lista_palabras)
    cola = deque()
    cola.append([palabra_inicio])
    visitado = set()
    visitado.add(palabra_inicio)
    nivel = 1
    nivel_min = float('inf')
    resultados = []
    
    while cola:
        camino_actual = cola.popleft()
        if len(camino_actual) > nivel:
            for palabra in visitado:
                lista_palabras.remove(palabra)
            visitado.clear()
            if len(camino_actual) > nivel_min:
                break
            else:
                nivel = len(camino_actual)
        
        ultima_palabra = camino_actual[-1]
        for i in range(len(ultima_palabra)):
            for c in 'abcdefghijklmnopqrstuvwxyz':
                siguiente_palabra = ultima_palabra[:i] + c + ultima_palabra[i+1:]
                if siguiente_palabra in lista_palabras:
                    if siguiente_palabra == palabra_fin:
                        camino_actual.append(siguiente_palabra)
                        resultados.append(list(camino_actual))
                        nivel_min = nivel
                    else:
                        if siguiente_palabra not in visitado:
                            visitado.add(siguiente_palabra)
                            nuevo_camino = list(camino_actual)
                            nuevo_camino.append(siguiente_palabra)
                            cola.append(nuevo_camino)
    
    return resultados"
"class Solution:
    def numDecodings(self, s: str) -> int:
        non_zero = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
        first_incl, second_incl = 1, 0
        first_excl, second_excl = 0, 0
        
        if s[0] in non_zero:
            second_incl = 1
        if s[0] == '*':
            second_incl = 9
            
        for i in range(1, len(s)):
            new_incl, new_excl = 0, 0
            if s[i] == '*':
                new_incl = 9 * (second_incl + second_excl)
                
                if s[i-1] == '1':
                    # number is of type (1, *)
                    new_excl = 9 * (first_incl + first_excl)
                    
                elif s[i-1] == '2':
                    # number is of type (2, *)
                    new_excl = 6 * (first_incl + first_excl)
                    
                elif s[i-1] == '*':
                    # number is of type (*, *)
                    new_excl = 15 * (first_incl + first_excl)
            else:
                if s[i] in non_zero:
                    new_incl = second_incl + second_excl
                        
                if s[i-1] == '*':
                    # number is of type (*,digit)
                    if int(s[i]) <= 6:
                        new_excl = 2 * (first_excl + first_incl)
                    else:
                        new_excl = first_incl + first_excl
                        
                else:
                    # number is of type (digit,digit)
                    val = int(s[i-1:i+1])
                    if 10 <= val <= 26:
                        new_excl = first_incl + first_excl
                    else:
                        new_excl = 0
            first_incl, first_excl = second_incl, second_excl
            second_incl, second_excl = new_incl, new_excl
        return (second_incl + second_excl) % (10**9 + 7)";"def num_decodings(s):
    modulo = 10**9 + 7
    n = len(s)
    if n == 0:
        return 0
    
    dp = [0] * (n + 1)
    dp[0] = 1
    
    if s[0] == '0':
        return 0
    if s[0] == '*':
        dp[1] = 9
    else:
        dp[1] = 1
    
    for i in range(2, n + 1):
        actual = s[i-1]
        anterior = s[i-2]
        
        # Caso de un solo dígito
        if actual == '*':
            dp[i] += 9 * dp[i-1]
        elif actual != '0':
            dp[i] += dp[i-1]
        dp[i] %= modulo
        
        # Caso de dos dígitos
        if anterior == '*':
            if actual == '*':
                dp[i] += 15 * dp[i-2]  # 11-19 y 21-26
            elif '0' <= actual <= '6':
                dp[i] += 2 * dp[i-2]   # 1 o 2
            else:
                dp[i] += dp[i-2]       # solo 1
        elif anterior == '1':
            if actual == '*':
                dp[i] += 9 * dp[i-2]   # 11-19
            else:
                dp[i] += dp[i-2]       # 10-19
        elif anterior == '2':
            if actual == '*':
                dp[i] += 6 * dp[i-2]   # 21-26
            elif '0' <= actual <= '6':
                dp[i] += dp[i-2]       # 20-26
        dp[i] %= modulo
    
    return dp[n] % modulo"
"class Solution:
    def isThree(self, n):
        
        answers =  [4, 9, 25, 49, 121, 169, 289, 361, 529, 841, 961, 1369, 1681, 1849, 2209, 2809, 3481, 3721, 4489, 5041, 5329, 6241, 6889, 7921, 9409]
        
        while True:
            size = len(answers)
            if size == 1:
                return answers[0] == n
            elif size == 0:
                return False
            mp = size // 2
            
            if answers[mp] == n:
                return True
            elif answers[mp] > n:
                answers = answers[:mp]
            else:
                answers = answers[mp + 1:]";"def tiene_exactamente_tres_divisores(n):
    contador = 0
    for i in range(1, n + 1):
        if n % i == 0:
            contador += 1
    return contador == 3"
"class Solution:
    def nthUglyNumber(self, n: int) -> int:
        lst=[1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45, 48, 50, 54, 60, 64, 72, 75, 80, 81, 90, 96, 100, 108, 120, 125, 128, 135, 144, 150, 160, 162, 180, 192, 200, 216, 225, 240, 243, 250, 256, 270, 288, 300, 320, 324, 360, 375, 384, 400, 405, 432, 450, 480, 486, 500, 512, 540, 576, 600, 625, 640, 648, 675, 720, 729, 750, 768, 800, 810, 864, 900, 960, 972, 1000, 1024, 1080, 1125, 1152, 1200, 1215, 1250, 1280, 1296, 1350, 1440, 1458, 1500, 1536, 1600, 1620, 1728, 1800, 1875, 1920, 1944, 2000, 2025, 2048, 2160, 2187, 2250, 2304, 2400, 2430, 2500, 2560, 2592, 2700, 2880, 2916, 3000, 3072, 3125, 3200, 3240, 3375, 3456, 3600, 3645, 3750, 3840, 3888, 4000, 4050, 4096, 4320, 4374, 4500, 4608, 4800, 4860, 5000, 5120, 5184, 5400, 5625, 5760, 5832, 6000, 6075, 6144, 6250, 6400, 6480, 6561, 6750, 6912, 7200, 7290, 7500, 7680, 7776, 8000, 8100, 8192, 8640, 8748, 9000, 9216, 9375, 9600, 9720, 10000, 10125, 10240, 10368, 10800, 10935, 11250, 11520, 11664, 12000, 12150, 12288, 12500, 12800, 12960, 13122, 13500, 13824, 14400, 14580, 15000, 15360, 15552, 15625, 16000, 16200, 16384, 16875, 17280, 17496, 18000, 18225, 18432, 18750, 19200, 19440, 19683, 20000, 20250, 20480, 20736, 21600, 21870, 22500, 23040, 23328, 24000, 24300, 24576, 25000, 25600, 25920, 26244, 27000, 27648, 28125, 28800, 29160, 30000, 30375, 30720, 31104, 31250, 32000, 32400, 32768, 32805, 33750, 34560, 34992, 36000, 36450, 36864, 37500, 38400, 38880, 39366, 40000, 40500, 40960, 41472, 43200, 43740, 45000, 46080, 46656, 46875, 48000, 48600, 49152, 50000, 50625, 51200, 51840, 52488, 54000, 54675, 55296, 56250, 57600, 58320, 59049, 60000, 60750, 61440, 62208, 62500, 64000, 64800, 65536, 65610, 67500, 69120, 69984, 72000, 72900, 73728, 75000, 76800, 77760, 78125, 78732, 80000, 81000, 81920, 82944, 84375, 86400, 87480, 90000, 91125, 92160, 93312, 93750, 96000, 97200, 98304, 98415, 100000, 101250, 102400, 103680, 104976, 108000, 109350, 110592, 112500, 115200, 116640, 118098, 120000, 121500, 122880, 124416, 125000, 128000, 129600, 131072, 131220, 135000, 138240, 139968, 140625, 144000, 145800, 147456, 150000, 151875, 153600, 155520, 156250, 157464, 160000, 162000, 163840, 164025, 165888, 168750, 172800, 174960, 177147, 180000, 182250, 184320, 186624, 187500, 192000, 194400, 196608, 196830, 200000, 202500, 204800, 207360, 209952, 216000, 218700, 221184, 225000, 230400, 233280, 234375, 236196, 240000, 243000, 245760, 248832, 250000, 253125, 256000, 259200, 262144, 262440, 270000, 273375, 276480, 279936, 281250, 288000, 291600, 294912, 295245, 300000, 303750, 307200, 311040, 312500, 314928, 320000, 324000, 327680, 328050, 331776, 337500, 345600, 349920, 354294, 360000, 364500, 368640, 373248, 375000, 384000, 388800, 390625, 393216, 393660, 400000, 405000, 409600, 414720, 419904, 421875, 432000, 437400, 442368, 450000, 455625, 460800, 466560, 468750, 472392, 480000, 486000, 491520, 492075, 497664, 500000, 506250, 512000, 518400, 524288, 524880, 531441, 540000, 546750, 552960, 559872, 562500, 576000, 583200, 589824, 590490, 600000, 607500, 614400, 622080, 625000, 629856, 640000, 648000, 655360, 656100, 663552, 675000, 691200, 699840, 703125, 708588, 720000, 729000, 737280, 746496, 750000, 759375, 768000, 777600, 781250, 786432, 787320, 800000, 810000, 819200, 820125, 829440, 839808, 843750, 864000, 874800, 884736, 885735, 900000, 911250, 921600, 933120, 937500, 944784, 960000, 972000, 983040, 984150, 995328, 1000000, 1012500, 1024000, 1036800, 1048576, 1049760, 1062882, 1080000, 1093500, 1105920, 1119744, 1125000, 1152000, 1166400, 1171875, 1179648, 1180980, 1200000, 1215000, 1228800, 1244160, 1250000, 1259712, 1265625, 1280000, 1296000, 1310720, 1312200, 1327104, 1350000, 1366875, 1382400, 1399680, 1406250, 1417176, 1440000, 1458000, 1474560, 1476225, 1492992, 1500000, 1518750, 1536000, 1555200, 1562500, 1572864, 1574640, 1594323, 1600000, 1620000, 1638400, 1640250, 1658880, 1679616, 1687500, 1728000, 1749600, 1769472, 1771470, 1800000, 1822500, 1843200, 1866240, 1875000, 1889568, 1920000, 1944000, 1953125, 1966080, 1968300, 1990656, 2000000, 2025000, 2048000, 2073600, 2097152, 2099520, 2109375, 2125764, 2160000, 2187000, 2211840, 2239488, 2250000, 2278125, 2304000, 2332800, 2343750, 2359296, 2361960, 2400000, 2430000, 2457600, 2460375, 2488320, 2500000, 2519424, 2531250, 2560000, 2592000, 2621440, 2624400, 2654208, 2657205, 2700000, 2733750, 2764800, 2799360, 2812500, 2834352, 2880000, 2916000, 2949120, 2952450, 2985984, 3000000, 3037500, 3072000, 3110400, 3125000, 3145728, 3149280, 3188646, 3200000, 3240000, 3276800, 3280500, 3317760, 3359232, 3375000, 3456000, 3499200, 3515625, 3538944, 3542940, 3600000, 3645000, 3686400, 3732480, 3750000, 3779136, 3796875, 3840000, 3888000, 3906250, 3932160, 3936600, 3981312, 4000000, 4050000, 4096000, 4100625, 4147200, 4194304, 4199040, 4218750, 4251528, 4320000, 4374000, 4423680, 4428675, 4478976, 4500000, 4556250, 4608000, 4665600, 4687500, 4718592, 4723920, 4782969, 4800000, 4860000, 4915200, 4920750, 4976640, 5000000, 5038848, 5062500, 5120000, 5184000, 5242880, 5248800, 5308416, 5314410, 5400000, 5467500, 5529600, 5598720, 5625000, 5668704, 5760000, 5832000, 5859375, 5898240, 5904900, 5971968, 6000000, 6075000, 6144000, 6220800, 6250000, 6291456, 6298560, 6328125, 6377292, 6400000, 6480000, 6553600, 6561000, 6635520, 6718464, 6750000, 6834375, 6912000, 6998400, 7031250, 7077888, 7085880, 7200000, 7290000, 7372800, 7381125, 7464960, 7500000, 7558272, 7593750, 7680000, 7776000, 7812500, 7864320, 7873200, 7962624, 7971615, 8000000, 8100000, 8192000, 8201250, 8294400, 8388608, 8398080, 8437500, 8503056, 8640000, 8748000, 8847360, 8857350, 8957952, 9000000, 9112500, 9216000, 9331200, 9375000, 9437184, 9447840, 9565938, 9600000, 9720000, 9765625, 9830400, 9841500, 9953280, 10000000, 10077696, 10125000, 10240000, 10368000, 10485760, 10497600, 10546875, 10616832, 10628820, 10800000, 10935000, 11059200, 11197440, 11250000, 11337408, 11390625, 11520000, 11664000, 11718750, 11796480, 11809800, 11943936, 12000000, 12150000, 12288000, 12301875, 12441600, 12500000, 12582912, 12597120, 12656250, 12754584, 12800000, 12960000, 13107200, 13122000, 13271040, 13286025, 13436928, 13500000, 13668750, 13824000, 13996800, 14062500, 14155776, 14171760, 14348907, 14400000, 14580000, 14745600, 14762250, 14929920, 15000000, 15116544, 15187500, 15360000, 15552000, 15625000, 15728640, 15746400, 15925248, 15943230, 16000000, 16200000, 16384000, 16402500, 16588800, 16777216, 16796160, 16875000, 17006112, 17280000, 17496000, 17578125, 17694720, 17714700, 17915904, 18000000, 18225000, 18432000, 18662400, 18750000, 18874368, 18895680, 18984375, 19131876, 19200000, 19440000, 19531250, 19660800, 19683000, 19906560, 20000000, 20155392, 20250000, 20480000, 20503125, 20736000, 20971520, 20995200, 21093750, 21233664, 21257640, 21600000, 21870000, 22118400, 22143375, 22394880, 22500000, 22674816, 22781250, 23040000, 23328000, 23437500, 23592960, 23619600, 23887872, 23914845, 24000000, 24300000, 24576000, 24603750, 24883200, 25000000, 25165824, 25194240, 25312500, 25509168, 25600000, 25920000, 26214400, 26244000, 26542080, 26572050, 26873856, 27000000, 27337500, 27648000, 27993600, 28125000, 28311552, 28343520, 28697814, 28800000, 29160000, 29296875, 29491200, 29524500, 29859840, 30000000, 30233088, 30375000, 30720000, 31104000, 31250000, 31457280, 31492800, 31640625, 31850496, 31886460, 32000000, 32400000, 32768000, 32805000, 33177600, 33554432, 33592320, 33750000, 34012224, 34171875, 34560000, 34992000, 35156250, 35389440, 35429400, 35831808, 36000000, 36450000, 36864000, 36905625, 37324800, 37500000, 37748736, 37791360, 37968750, 38263752, 38400000, 38880000, 39062500, 39321600, 39366000, 39813120, 39858075, 40000000, 40310784, 40500000, 40960000, 41006250, 41472000, 41943040, 41990400, 42187500, 42467328, 42515280, 43046721, 43200000, 43740000, 44236800, 44286750, 44789760, 45000000, 45349632, 45562500, 46080000, 46656000, 46875000, 47185920, 47239200, 47775744, 47829690, 48000000, 48600000, 48828125, 49152000, 49207500, 49766400, 50000000, 50331648, 50388480, 50625000, 51018336, 51200000, 51840000, 52428800, 52488000, 52734375, 53084160, 53144100, 53747712, 54000000, 54675000, 55296000, 55987200, 56250000, 56623104, 56687040, 56953125, 57395628, 57600000, 58320000, 58593750, 58982400, 59049000, 59719680, 60000000, 60466176, 60750000, 61440000, 61509375, 62208000, 62500000, 62914560, 62985600, 63281250, 63700992, 63772920, 64000000, 64800000, 65536000, 65610000, 66355200, 66430125, 67108864, 67184640, 67500000, 68024448, 68343750, 69120000, 69984000, 70312500, 70778880, 70858800, 71663616, 71744535, 72000000, 72900000, 73728000, 73811250, 74649600, 75000000, 75497472, 75582720, 75937500, 76527504, 76800000, 77760000, 78125000, 78643200, 78732000, 79626240, 79716150, 80000000, 80621568, 81000000, 81920000, 82012500, 82944000, 83886080, 83980800, 84375000, 84934656, 85030560, 86093442, 86400000, 87480000, 87890625, 88473600, 88573500, 89579520, 90000000, 90699264, 91125000, 92160000, 93312000, 93750000, 94371840, 94478400, 94921875, 95551488, 95659380, 96000000, 97200000, 97656250, 98304000, 98415000, 99532800, 100000000, 100663296, 100776960, 101250000, 102036672, 102400000, 102515625, 103680000, 104857600, 104976000, 105468750, 106168320, 106288200, 107495424, 108000000, 109350000, 110592000, 110716875, 111974400, 112500000, 113246208, 113374080, 113906250, 114791256, 115200000, 116640000, 117187500, 117964800, 118098000, 119439360, 119574225, 120000000, 120932352, 121500000, 122880000, 123018750, 124416000, 125000000, 125829120, 125971200, 126562500, 127401984, 127545840, 128000000, 129140163, 129600000, 131072000, 131220000, 132710400, 132860250, 134217728, 134369280, 135000000, 136048896, 136687500, 138240000, 139968000, 140625000, 141557760, 141717600, 143327232, 143489070, 144000000, 145800000, 146484375, 147456000, 147622500, 149299200, 150000000, 150994944, 151165440, 151875000, 153055008, 153600000, 155520000, 156250000, 157286400, 157464000, 158203125, 159252480, 159432300, 160000000, 161243136, 162000000, 163840000, 164025000, 165888000, 167772160, 167961600, 168750000, 169869312, 170061120, 170859375, 172186884, 172800000, 174960000, 175781250, 176947200, 177147000, 179159040, 180000000, 181398528, 182250000, 184320000, 184528125, 186624000, 187500000, 188743680, 188956800, 189843750, 191102976, 191318760, 192000000, 194400000, 195312500, 196608000, 196830000, 199065600, 199290375, 200000000, 201326592, 201553920, 202500000, 204073344, 204800000, 205031250, 207360000, 209715200, 209952000, 210937500, 212336640, 212576400, 214990848, 215233605, 216000000, 218700000, 221184000, 221433750, 223948800, 225000000, 226492416, 226748160, 227812500, 229582512, 230400000, 233280000, 234375000, 235929600, 236196000, 238878720, 239148450, 240000000, 241864704, 243000000, 244140625, 245760000, 246037500, 248832000, 250000000, 251658240, 251942400, 253125000, 254803968, 255091680, 256000000, 258280326, 259200000, 262144000, 262440000, 263671875, 265420800, 265720500, 268435456, 268738560, 270000000, 272097792, 273375000, 276480000, 279936000, 281250000, 283115520, 283435200, 284765625, 286654464, 286978140, 288000000, 291600000, 292968750, 294912000, 295245000, 298598400, 300000000, 301989888, 302330880, 303750000, 306110016, 307200000, 307546875, 311040000, 312500000, 314572800, 314928000, 316406250, 318504960, 318864600, 320000000, 322486272, 324000000, 327680000, 328050000, 331776000, 332150625, 335544320, 335923200, 337500000, 339738624, 340122240, 341718750, 344373768, 345600000, 349920000, 351562500, 353894400, 354294000, 358318080, 358722675, 360000000, 362797056, 364500000, 368640000, 369056250, 373248000, 375000000, 377487360, 377913600, 379687500, 382205952, 382637520, 384000000, 387420489, 388800000, 390625000, 393216000, 393660000, 398131200, 398580750, 400000000, 402653184, 403107840, 405000000, 408146688, 409600000, 410062500, 414720000, 419430400, 419904000, 421875000, 424673280, 425152800, 429981696, 430467210, 432000000, 437400000, 439453125, 442368000, 442867500, 447897600, 450000000, 452984832, 453496320, 455625000, 459165024, 460800000, 466560000, 468750000, 471859200, 472392000, 474609375, 477757440, 478296900, 480000000, 483729408, 486000000, 488281250, 491520000, 492075000, 497664000, 500000000, 503316480, 503884800, 506250000, 509607936, 510183360, 512000000, 512578125, 516560652, 518400000, 524288000, 524880000, 527343750, 530841600, 531441000, 536870912, 537477120, 540000000, 544195584, 546750000, 552960000, 553584375, 559872000, 562500000, 566231040, 566870400, 569531250, 573308928, 573956280, 576000000, 583200000, 585937500, 589824000, 590490000, 597196800, 597871125, 600000000, 603979776, 604661760, 607500000, 612220032, 614400000, 615093750, 622080000, 625000000, 629145600, 629856000, 632812500, 637009920, 637729200, 640000000, 644972544, 645700815, 648000000, 655360000, 656100000, 663552000, 664301250, 671088640, 671846400, 675000000, 679477248, 680244480, 683437500, 688747536, 691200000, 699840000, 703125000, 707788800, 708588000, 716636160, 717445350, 720000000, 725594112, 729000000, 732421875, 737280000, 738112500, 746496000, 750000000, 754974720, 755827200, 759375000, 764411904, 765275040, 768000000, 774840978, 777600000, 781250000, 786432000, 787320000, 791015625, 796262400, 797161500, 800000000, 805306368, 806215680, 810000000, 816293376, 819200000, 820125000, 829440000, 838860800, 839808000, 843750000, 849346560, 850305600, 854296875, 859963392, 860934420, 864000000, 874800000, 878906250, 884736000, 885735000, 895795200, 900000000, 905969664, 906992640, 911250000, 918330048, 921600000, 922640625, 933120000, 937500000, 943718400, 944784000, 949218750, 955514880, 956593800, 960000000, 967458816, 972000000, 976562500, 983040000, 984150000, 995328000, 996451875, 1000000000, 1006632960, 1007769600, 1012500000, 1019215872, 1020366720, 1024000000, 1025156250, 1033121304, 1036800000, 1048576000, 1049760000, 1054687500, 1061683200, 1062882000, 1073741824, 1074954240, 1076168025, 1080000000, 1088391168, 1093500000, 1105920000, 1107168750, 1119744000, 1125000000, 1132462080, 1133740800, 1139062500, 1146617856, 1147912560, 1152000000, 1162261467, 1166400000, 1171875000, 1179648000, 1180980000, 1194393600, 1195742250, 1200000000, 1207959552, 1209323520, 1215000000, 1220703125, 1224440064, 1228800000, 1230187500, 1244160000, 1250000000, 1258291200, 1259712000, 1265625000, 1274019840, 1275458400, 1280000000, 1289945088, 1291401630, 1296000000, 1310720000, 1312200000, 1318359375, 1327104000, 1328602500, 1342177280, 1343692800, 1350000000, 1358954496, 1360488960, 1366875000, 1377495072, 1382400000, 1399680000, 1406250000, 1415577600, 1417176000, 1423828125, 1433272320, 1434890700, 1440000000, 1451188224, 1458000000, 1464843750, 1474560000, 1476225000, 1492992000, 1500000000, 1509949440, 1511654400, 1518750000, 1528823808, 1530550080, 1536000000, 1537734375, 1549681956, 1555200000, 1562500000, 1572864000, 1574640000, 1582031250, 1592524800, 1594323000, 1600000000, 1610612736, 1612431360, 1620000000, 1632586752, 1638400000, 1640250000, 1658880000, 1660753125, 1677721600, 1679616000, 1687500000, 1698693120, 1700611200, 1708593750, 1719926784, 1721868840, 1728000000, 1749600000, 1757812500, 1769472000, 1771470000, 1791590400, 1793613375, 1800000000, 1811939328, 1813985280, 1822500000, 1836660096, 1843200000, 1845281250, 1866240000, 1875000000, 1887436800, 1889568000, 1898437500, 1911029760, 1913187600, 1920000000, 1934917632, 1937102445, 1944000000, 1953125000, 1966080000, 1968300000, 1990656000, 1992903750, 2000000000, 2013265920, 2015539200, 2025000000, 2038431744, 2040733440, 2048000000, 2050312500, 2066242608, 2073600000, 2097152000, 2099520000, 2109375000, 2123366400]
        return lst[n-1]";"def encontrar_numero_feo(n):
    if n == 1:
        return 1
    feos = [1]
    i2 = i3 = i5 = 0
    siguiente_multiplo_de_2 = 2
    siguiente_multiplo_de_3 = 3
    siguiente_multiplo_de_5 = 5
    
    for _ in range(1, n):
        siguiente_feo = min(siguiente_multiplo_de_2, siguiente_multiplo_de_3, siguiente_multiplo_de_5)
        feos.append(siguiente_feo)
        
        if siguiente_feo == siguiente_multiplo_de_2:
            i2 += 1
            siguiente_multiplo_de_2 = feos[i2] * 2
        if siguiente_feo == siguiente_multiplo_de_3:
            i3 += 1
            siguiente_multiplo_de_3 = feos[i3] * 3
        if siguiente_feo == siguiente_multiplo_de_5:
            i5 += 1
            siguiente_multiplo_de_5 = feos[i5] * 5
    
    return feos[-1]"
"class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        def isSameCase(l, r, word, isUpper):
            while l <= r:
                if word[l].isupper() != isUpper or word[r].isupper() != isUpper:
                    return False
                l += 1
                r -= 1
            return True
        
        if len(word) == 1: # Base Case
            return True
        
        if word[0].isupper() and word[1].isupper(): #Case 1 ""USA""
            return isSameCase(1, len(word) - 1, word, True)
        elif word[0].islower() and word[1].islower(): #Case 2 ""leetcode""
            return isSameCase(1, len(word) - 1, word, False)
        elif word[0].isupper() and word[1].islower(): # Case 3 ""Google""
            return isSameCase(1, len(word) - 1, word, False)
        else:
            return False";"def uso_correcto_mayusculas(palabra):
    todas_mayusculas = True
    todas_minusculas = True
    primera_mayuscula = False

    for letra in palabra:
        if not letra.isupper():
            todas_mayusculas = False
        if not letra.islower():
            todas_minusculas = False

    if len(palabra) > 0:
        primera_mayuscula = palabra[0].isupper() and all(letra.islower() for letra in palabra[1:])

    return todas_mayusculas or todas_minusculas or primera_mayuscula"
"class Solution:
    
    def reversePairs(self, arr: List[int]) -> int:
        count = 0
        if len(arr) > 1:
            mid = len(arr)//2
            L = arr[:mid]
            R = arr[mid:]
            count = self.reversePairs(L) 
            count += self.reversePairs(R)
            count += self.merge(L,R,arr)
        return count
    
    def merge(self,L,R,arr):
		#finding count for the condition
        count = 0
        i,j = 0,0
        while i < len(L):
            while j < len(R):
                if L[i] > 2*R[j]:
                    j += 1
                else:
                    break
            
            if j > 0:
                count += j
            i += 1

		#merging the sorted arrays
        i,j,k = 0,0,0        
        while i < len(L) and j < len(R):    
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1   
            else:
                arr[k] = R[j]
                j += 1
            k += 1

        while i < len(L):
            arr[k] = L[i]
            k += 1
            i += 1   
        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1
                
        return count";"def contar_pares_inversos(numeros):
    contador = 0
    longitud = len(numeros)
    for i in range(longitud):
        for j in range(i + 1, longitud):
            if numeros[i] > 2 * numeros[j]:
                contador += 1
    return contador"
"class Solution:
    def stoneGameIX(self, stones: List[int]) -> bool:
        stones = [v % 3 for v in stones]
        
        d = defaultdict(int)
        for v in stones:
            d[v] += 1
        
        while d[1] >= 2 and d[2] >= 2:
            d[2] -= 1
            d[1] -= 1
        
        if d[0] % 2 == 0: # number of 0s will not influent the result
            if (d[1] == 1 and d[2] >= 1) or (d[2] == 1 and d[1] >= 1):
                return True
        else:
            if (d[1] == 0 and d[2] >= 3) or (d[2] == 0 and d[1] >= 3):
                return True
            if (d[1] == 1 and d[2] >= 4) or (d[2] == 1 and d[1] >= 4):
                return True

        return False";"piedras = [1, 2, 3, 4, 5]  # Ejemplo de entrada, puedes cambiarlo

suma_total = 0
for valor in piedras:
    suma_total += valor

resto = suma_total % 3

if resto == 0:
    alice_gana = False
else:
    alice_gana = True

print(alice_gana)"
"class Solution:
    def rotateString(self, s: str, goal: str) -> bool:
        if len(s) != len(goal):
            return False
        
        txt = s + s
        n, m = len(txt), len(goal) 

        lps = self.build_lps(goal)
       
        i, j = 0, 0

        while i < n:
            if txt[i] == goal[j] :
                i, j = i + 1, j + 1
                
                if j == m:
                    return True
            else: 
                if j == 0:
                   i += 1 
                else:
                    j = lps[j-1]
                    
                    
        return False

    
    def build_lps(self, pattern):
        lps = [0] * len(pattern) 
        prev_lps, i = 0, 1

        while i < len(pattern):
            if pattern[i] == pattern[prev_lps]:
                lps[i] = prev_lps + 1
                prev_lps, i = prev_lps + 1, i + 1
            else:
                if prev_lps == 0:
                    lps[i] = 0
                    i += 1
                else:
                    prev_lps = lps[prev_lps - 1]

        return lps";"def puede_convertirse(s, meta):
    if len(s) != len(meta):
        return False
    for i in range(len(s)):
        rotado = s[i:] + s[:i]
        if rotado == meta:
            return True
    return False"
"class Solution:
    def wordBreak(self, s: str, wordDict):
        output = []
        def backtracking(restString, candidate):
            # When the restString is empty, it means all substring/prefix of s are found in dictionary.
            # Add candidate to output answer.
            if restString == """":
                output.append(candidate)
                return
            
            # Process demonstration of the following for loop:
            # candidate = """"  <= 'cat'sanddog
            # candidate = ""cat""  <= 'sand'dog
            # candidate = ""cat sand""  <= dog
            # candidate = ""cat sand dog""  <= ''

            # candidate = """"  <= 'cats'anddog
            # candidate = ""cats""  <= 'and'dog
            # candidate = ""cats and""  <= dog
            # candidate = ""cats and dog""  <= ''

            # In the for loop range needs to add one, otherwise you will miss one char when you use restString[:i].
            # This for loop will keep checking if any prefix of restString was in dictionary.
            for i in range(len(restString)+1):
                if restString[:i] in wordDict:
                    # This if block can avoid the extra space in the from of candidate answer.
                    if candidate == """":
                        backtracking(restString[i:], restString[:i])
                    else:
                        backtracking(restString[i:], candidate+"" ""+restString[:i])
                    
        backtracking(s, """")
        return output

""""""
Input: s = ""catsanddog"", wordDict = [""cat"",""cats"",""and"",""sand"",""dog""]
Output: [""cats and dog"",""cat sand dog""]
""""""

if __name__ == ""__main__"":
    s = ""catsanddog"" 
    wordDict = [""cat"",""cats"",""and"",""sand"",""dog""]
    solution = Solution()
    print(f""s = {s}"")
    print(f""wordDict = {wordDict}"")
    print(f""wordBreak = {solution.wordBreak(s, wordDict)}"")";"def construir_oraciones(s, diccionario):
    resultados = []
    n = len(s)

    def backtrack(inicio, camino_actual):
        if inicio == n:
            resultados.append(' '.join(camino_actual))
            return
        for fin in range(inicio + 1, n + 1):
            palabra = s[inicio:fin]
            if palabra in diccionario:
                camino_actual.append(palabra)
                backtrack(fin, camino_actual)
                camino_actual.pop()

    backtrack(0, [])
    return resultados"
"class Solution:
    def bagOfTokensScore(self, tokens: List[int], power: int) -> int:
        # Establish score to return
        score = 0
        
        # Why use Collections.deque instead of the list 
        # as-is? One word - optimization! Deque has been 
        # written in such a way where popping items off
        # the front of the list using popleft occurs in O(1)
        # time, while running tokens.pop(0) runs in O(n) time.
        # Since we care a lot about runtime, deque's
        # the way to go here
        d = deque(sorted(tokens))
        while d:
            # Since we've sorted the list in ascending 
            # order, we don't need to compare the power to 
            # all values - if it's smaller than the smallest, 
            # it'll be smaller than everything
            if power < d[0]:
                # Pop the tail of the list (play token face-down)
                if score > 0 and len(d) > 1:
                    power += d.pop()
                    score -= 1
                # It's possible power will be smaller than 
                # all scores but either our score's too low
                # to play anything face-down OR there's only
                # one piece left, making the play redundnat.
                # In either of these cases, we're done
                else:
                    return score
            else:
                #Pop the head (play token face-up)
                power -= d.popleft()
                score += 1
        # Game over - time to return our score!
        return score";"def max_puntaje(poder, tokens):
    tokens.sort()
    izquierda = 0
    derecha = len(tokens) - 1
    puntaje = 0
    max_puntaje = 0
    
    while izquierda <= derecha:
        if poder >= tokens[izquierda]:
            poder -= tokens[izquierda]
            puntaje += 1
            izquierda += 1
            if puntaje > max_puntaje:
                max_puntaje = puntaje
        elif puntaje > 0:
            poder += tokens[derecha]
            puntaje -= 1
            derecha -= 1
        else:
            break
    
    return max_puntaje"
"class Solution:
    def buddyStrings(self, s: str, goal: str) -> bool:
        n1=len(s)
        n2=len(goal)
        if n1!=n2: #if length is not equal we cannot make them the same with interchange
            return False
        d=defaultdict(list)
        mx =0 #max count of individual
        cnt=defaultdict(int)
        for i in range(n1):
            cnt[s[i]]+=1
            if cnt[s[i]]>mx:
                mx=cnt[s[i]] # maximum times acharacter occurs in s 
            
            d[i]=[s[i],goal[i]] #store value of both strings at an index
        count=0
        dif=[]
       
        for k in d:
            
            
            a=d[k][0] #letter at index k of s
            b=d[k][1] #letter at index k of s
            if a!=b:
                count+=1 
                dif.append(k)
            if count>2: # only one interchange is allowed 
                return False 
        
        if count==1:
            return False #one index at has unmatched value , can never be interchanged
        if count==0:
            if mx >=2: #s='aa' goal='aa'
                
                return True
            return False #s='ab' goal='ab'
        
        if d[dif[0]][0]==d[dif[1]][1] and d[dif[1]][0]==d[dif[0]][1]: #if 2 values are at wrong index check if there interchange would make the strings same 
            return True 
        return False";"def puede_intercambiar(s, meta):
    if len(s) != len(meta):
        return False
    
    diferencias = []
    for i in range(len(s)):
        if s[i] != meta[i]:
            diferencias.append(i)
    
    if len(diferencias) == 0:
        return len(set(s)) < len(s)
    elif len(diferencias) == 2:
        i, j = diferencias
        if s[i] == meta[j] and s[j] == meta[i]:
            return True
    
    return False"
"class Solution:
    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:
        """"""LeetCode 835

        Not hard in terms of figuring out a method, but very complicated in
        implementation. First turn both images into bitmaps. Then brute force
        it by traversing all possible overlap states. At each state, compute
        the number of overlapped positions.

        The difficulty lies in accurately finding out the correct bitmap from
        both images at each overlapped state to perform the AND operation.

        O(N^4), 645 ms, faster than 81.87%
        """"""
        n = len(img1)
        bitmap1 = [sum(v << (n - i - 1) for i, v in enumerate(row)) for row in img1]
        bitmap2 = [sum(v << (n - i - 1) for i, v in enumerate(row)) for row in img2]
        res = 0
        for i in range(2 * n - 1):
            for j in range(2 * n - 1):
                cur = 0
                if i <= n - 1:
                    if j <= n - 1:
                        for ii in range(n - i - 1, n):
                            ol = ((bitmap1[ii] &amp, ((1 << (j + 1)) - 1)) << (n - j - 1)) &amp, (bitmap2[ii - (n - i - 1)])
                            cur += bin(ol).count('1')
                    else:
                        for ii in range(n - i - 1, n):
                            ol = (bitmap1[ii] >> (j - n + 1)) &amp, (bitmap2[ii - (n - i - 1)])
                            cur += bin(ol).count('1')
                else:
                    if j <= n - 1:
                        for ii in range(2 * n - i - 1):
                            ol = ((bitmap1[ii] &amp, ((1 << (j + 1)) - 1)) << (n - j - 1)) &amp, (bitmap2[ii + i - n + 1])
                            cur += bin(ol).count('1')
                    else:
                        for ii in range(2 * n - i - 1):
                            ol = (bitmap1[ii] >> (j - n + 1)) &amp, (bitmap2[ii + i - n + 1])
                            cur += bin(ol).count('1')
                res = max(res, cur)
        return res";"def mayor_solape(img1, img2):
    n = len(img1)
    max_solape = 0
    
    for desplaza_abajo in range(-n + 1, n):
        for desplaza_derecha in range(-n + 1, n):
            solape_actual = 0
            for i in range(n):
                for j in range(n):
                    nueva_i = i + desplaza_abajo
                    nueva_j = j + desplaza_derecha
                    if 0 <= nueva_i < n and 0 <= nueva_j < n:
                        if img1[nueva_i][nueva_j] == 1 and img2[i][j] == 1:
                            solape_actual += 1
            if solape_actual > max_solape:
                max_solape = solape_actual
                
    return max_solape"
"class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
	
        def helper(full, empty, drank):
		    # Base case, make sure we can continue (we have enough to cash in)
            if full + empty < numExchange:
                return drank+full
			# If we have any full bottles we'll make them empty
            if full:
                empty += full
            # Exchange empties for fulls
            new = empty // numExchange
			# Don't forget there might be remainders!
            remaining_empt = empty - (new*numExchange)
            return helper(new, remaining_empt, drank + full)
            
        return helper(numBottles, 0, 0)";"botellas_llenas = numBottles
botellas_vacias = 0
total_bebidas = 0

while botellas_llenas > 0:
    total_bebidas += botellas_llenas
    botellas_vacias += botellas_llenas
    botellas_llenas = 0
    
    if botellas_vacias >= numExchange:
        nuevas_llenas = botellas_vacias // numExchange
        botellas_llenas = nuevas_llenas
        botellas_vacias = botellas_vacias % numExchange

print(total_bebidas)"
"class Solution:
    def bulbSwitch(self, n: int) -> int:
        bulb_on = 0
        v = 2
        while n >= 1:
            bulb_on += 1
            n -= v + 1
            v += 2
        return bulb_on";"n = int(input(""Ingresa el número de bulbos: ""))
bulbos = [False] * n

for ronda in range(1, n + 1):
    for i in range(ronda - 1, n, ronda):
        bulbos[i] = not bulbos[i]

encendidos = 0
for estado in bulbos:
    if estado:
        encendidos += 1

print(encendidos)"
"class Solution:
    def orderlyQueue(self, s: str, k: int) -> str:
        # case1 : ? s ??????????? return ??? s ??
        if len(set(s)) == 1: return s
        # case2 : ? k ?? 1???? return ?????????(????????????)
        if k != 1: return """".join(sorted(s))
        # case3 : ? k ? 1????????????????
        Len = len(s)
        Min = ""{""
        Min_idxs = dict() # ???????? index ????key = index, val = smallest char
        for i in range(Len):
            if Min > s[i]: # ??????????????? {index:char}??????? == 1
                Min = s[i]
                Min_idxs = {i:s[i]}
            elif Min == s[i]: # ????????????? index:char??????? > 1
                Min_idxs[i] = s[i]
                
        step = 1 # ????? index ?????????????
        # ??????? 1 (????????????????????)?????????????????
        while len(Min_idxs) != 1 and step < Len:

            Min = ""{""
            for idx in Min_idxs:
                comp_idx = (idx+step)%Len # ? index ?? s ????? s[0] ?????
                if Min > s[comp_idx]: # ???? index ? step ????????
                    Min = s[comp_idx]
                Min_idxs[idx] = s[comp_idx] # ??? k,v ?? value ????? step ???
            
            # ? value ???????? key ????
            del_list = [k for k, v in Min_idxs.items() if v != Min]
            # ?? value ???????? k,v ?
            for idx in del_list:
                Min_idxs.pop(idx)
            # ????? step ???
            step += 1

        split_idx = list(Min_idxs.keys())[0] # ??????

        return s[split_idx:] + s[:split_idx] # ????? return";"s = input(""Ingresa la cadena: "")
k = int(input(""Ingresa el valor de k: ""))

menor_cadena = s
for _ in range(len(s)):
    primer_caracter = s[0]
    s = s[1:] + primer_caracter
    if s < menor_cadena:
        menor_cadena = s

print(menor_cadena)"
"class Solution:
    def leastBricks(self, wall: List[List[int]]) -> int:
        
        """"""
        
        Line can be drawn at one unit distance.
        
        Idea here is to create map of points where each row would like to have line
        Such that no brick is cut.
        
        Post this, check max row fine with particualr point.
        
        Ex For this row, [1,2,2,1]
        
        we can draw line without cutting any brick 
        at 1 or 1+2, or 1+2+2
        
        
        
        """"""
        
        
        lenMap  = collections.defaultdict(int)
        
        for w in wall:
            s = 0 
            for i in w[:-1]:
                s = s + i
                lenMap[s] = lenMap[s] + 1
        
        
        fine = 0
        if lenMap.values():
            fine = max(lenMap.values())
        
        return (len(wall) - fine)";"pared = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]

bordes = {}
for fila in pared:
    posicion = 0
    for ladrillo in fila[:-1]:
        posicion += ladrillo
        if posicion in bordes:
            bordes[posicion] += 1
        else:
            bordes[posicion] = 1

if bordes:
    cruces_minimos = len(pared) - max(bordes.values())
else:
    cruces_minimos = len(pared)

print(cruces_minimos)"
"class Solution:
    # O(logn) time,
    # O(1) space,
    # Approach: binary search,
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        
        def findLowerBoundIndexToNum(lo, hi, num):
            while True:
                mid = (lo+hi)//2
                curr = citations[mid]
                
                if curr == num and (mid == 0 or citations[mid-1] < num):
                    return mid
                elif curr == num:
                    hi = mid-1
                elif curr > num:
                    if mid == 0 or citations[mid-1] < num:
                        return mid
                    hi = mid-1
                else:
                    if lo >= hi:
                        if citations[hi] >= num:
                            return hi
                        else:
                            return n
                    lo = mid+1
        
        def valid(hindex):
            index = findLowerBoundIndexToNum(0, n-1, hindex)
            citation_num = n - index
            return citation_num >= hindex
        
        
        def findMaxHindex(lo, hi):
            while True:
                mid = (lo+hi)//2
                validCitation = valid(mid)
                
                if validCitation and (mid == n or not valid(mid+1)):
                    return mid
                elif not validCitation:
                    hi = mid-1
                else:
                    if lo >= hi:
                        return hi
                    lo = mid+1
                
        return findMaxHindex(0, n)";"def calcular_h_indice(citas):
    n = len(citas)
    izquierda = 0
    derecha = n - 1
    h_indice = 0
    
    while izquierda <= derecha:
        medio = (izquierda + derecha) // 2
        cantidad_papeles = n - medio
        
        if citas[medio] >= cantidad_papeles:
            h_indice = cantidad_papeles
            derecha = medio - 1
        else:
            izquierda = medio + 1
            
    return h_indice"
"class Solution:
    def addDigits(self, num: int) -> int:

        num = [int(i) for i in str(num)]

        if len(num) == 1:
          return num[0]

        while(len(num) != 1): 
          sum = 0
          for i in range(len(num)):
            sum += num[i]
          num = sum
          num = [int(i) for i in str(num)]
        return num[0]";"def suma_digitos_hasta_uno(numero):
    while numero >= 10:
        suma = 0
        temp = numero
        while temp > 0:
            suma += temp % 10
            temp = temp // 10
        numero = suma
    return numero"
"class Solution:

    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        # Step 0: Special case of an empty route
        if source == target: return 0

        # Step 1: Create a dict of [stop -> busses stopping at this stop]
        stop2bus = dict()
        for i in range(len(routes)):
            for stop in routes[i]:
                if stop not in stop2bus: stop2bus[stop] = set()
                stop2bus[stop].add(i)

        # Step 2: BFS over the bus stops
        bfs_queue = [(source,0)] # Tuple of (bus stop, number of busses taken to get to the stop)
        visited = {source} # Set of visited bus stops to avoid cycles
        
        while len(bfs_queue) > 0: # BFS
            stop, numBusses = bfs_queue.pop(0)
            if stop==target: return numBusses # If we arrived at the target, stop here!
            if stop in stop2bus:
                for bus in stop2bus[stop]: # Check all busses at this stop
                    for neighbour in routes[bus]: # Check all stops of each bus
                        if neighbour not in visited:
                            # Add all new stops to the neighbours
                            bfs_queue.append((neighbour,numBusses+1))
                            visited.add(neighbour)
                    routes[bus]=[]
            
        return -1 # If we finished the BFS and did not reach the target, it is unreachable";"def numero_minimo_buses(rutas, origen, destino):
    if origen == destino:
        return 0
    
    paradas_a_rutas = {}
    for i, ruta in enumerate(rutas):
        for parada in ruta:
            if parada not in paradas_a_rutas:
                paradas_a_rutas[parada] = []
            paradas_a_rutas[parada].append(i)
    
    cola = []
    visitado_rutas = set()
    visitado_paradas = set()
    
    cola.append((origen, 0))
    visitado_paradas.add(origen)
    
    while cola:
        parada_actual, num_buses = cola.pop(0)
        
        for ruta_idx in paradas_a_rutas.get(parada_actual, []):
            if ruta_idx not in visitado_rutas:
                visitado_rutas.add(ruta_idx)
                for parada_siguiente in rutas[ruta_idx]:
                    if parada_siguiente == destino:
                        return num_buses + 1
                    if parada_siguiente not in visitado_paradas:
                        visitado_paradas.add(parada_siguiente)
                        cola.append((parada_siguiente, num_buses + 1))
    
    return -1"
"class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        n = len(piles)
        memo = [[0] * n for i in range(n)]
        
        def dp(i, j):
            if (i > j): return 0
            if (memo[i][j] != 0):
                return memo[i][j]
            
            player_turn = (n - (j - i)) % 2
            if (player_turn == 1):
                # increasing player1's score when player1 picks a max pile
                memo[i][j] = max(piles[i] + dp(i+1, j), piles[j] + dp(i, j-1))
            else:
                # decreasing player1's score when player2 picks a pile and player2 is assumed to pick the larger pile leading to a min score for player1
                memo[i][j] = min(-piles[i] + dp(i+1, j), -piles[j] + dp(i, j-1))
            return memo[i][j]
                
        return dp(0, n-1) > 0";"def juego_de_pilas(pilas):
    n = len(pilas)
    tabla = [[0] * n for _ in range(n)]
    
    for i in range(n):
        tabla[i][i] = pilas[i]
    
    for longitud in range(2, n + 1):
        for i in range(n - longitud + 1):
            j = i + longitud - 1
            tabla[i][j] = max(pilas[i] - tabla[i + 1][j], pilas[j] - tabla[i][j - 1])
    
    return tabla[0][n - 1] > 0"
"class Solution:
    #Time-Complexity: O(rows*cols)
    #Space-Complexity: O(rows*cols + rows*cols) -> O(rows*cols)
    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:
        #this is a standard bfs problem!
        #we will add to queue pixels that share same color as the starting pixel point 
        #that have not already been visited!
        #For each element we dequeue from queue, we will overwrite that entry with the new
        #color!
        #our answer will return image parameter that is modified in-place!
        rows, cols = len(image), len(image[0])
        visited = set()
        q = collections.deque()
        orig_color = image[sr][sc]
        q.append([sr, sc])
        visited.add((sr, sc))
        four_directions = [[1,0],[-1,0], [0,1], [0,-1]]
        #initiate bfs!
        while q:
            cr, cc = q.popleft()
            image[cr][cc] = color
            #iterate through each of four directional neighbors!
            for direction in four_directions:
                r_change, c_change = direction
                if(cr + r_change in range(rows) and
                   cc + c_change in range(cols) and 
                   image[cr+r_change][cc+c_change] == orig_color and
                   (cr+r_change, cc+c_change) not in visited):
                    q.append([cr+r_change, cc+c_change])
                    visited.add((cr+r_change, cc+c_change))
        #once bfs ends, return grid changed in place!
        return image";"def rellenar_inundacion(imagen, fila_inicio, columna_inicio, nuevo_color):
    filas = len(imagen)
    if filas == 0:
        return imagen
    columnas = len(imagen[0])
    color_original = imagen[fila_inicio][columna_inicio]
    if color_original == nuevo_color:
        return imagen
    
    cola = []
    cola.append((fila_inicio, columna_inicio))
    
    while len(cola) > 0:
        fila_actual, columna_actual = cola.pop(0)
        if imagen[fila_actual][columna_actual] == color_original:
            imagen[fila_actual][columna_actual] = nuevo_color
            if fila_actual > 0:
                cola.append((fila_actual - 1, columna_actual))
            if fila_actual < filas - 1:
                cola.append((fila_actual + 1, columna_actual))
            if columna_actual > 0:
                cola.append((fila_actual, columna_actual - 1))
            if columna_actual < columnas - 1:
                cola.append((fila_actual, columna_actual + 1))
    
    return imagen"
"class Solution:
    def toGoatLatin(self, sentence: str) -> str:
        new = sentence.split() # Breaks up the input into individual sentences
        count = 1 # Starting at 1 since we only have one ""a"" to begin with.
        
        for x in range(len(new)):
            if new[x][0].casefold() in 'aeiou': # Checks if the first value of x is a vowel. The casefold, can be replaced with lower, lowers the case. Can also just be removed and have ""in 'aeiouAEIOU'
                new[x] = new[x] + 'ma' + 'a'*count # Brings it together with the count multiplying number of ""a""'s as needed.
                count += 1
            elif new[x].casefold() not in 'aeiou': # Same comment as above.
                new[x] = new[x][1:] + new[x][0] + 'ma' + 'a'*count # Just moves the first value to the end then does the a.
                count += 1
        
        return "" "".join(x for x in new) # Converts the list back into a string.";"oracion = input(""Ingresa la oración: "")
palabras = oracion.split()
vocales = ['a', 'e', 'i', 'o', 'u']
resultado = []

for indice in range(len(palabras)):
    palabra = palabras[indice]
    primera_letra = palabra[0].lower()
    
    if primera_letra in vocales:
        nueva_palabra = palabra + ""ma""
    else:
        nueva_palabra = palabra[1:] + palabra[0] + ""ma""
    
    nueva_palabra += 'a' * (indice + 1)
    resultado.append(nueva_palabra)

oracion_final = ' '.join(resultado)
print(oracion_final)"
"class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        # Break words into pieces
        # Empty word can be found in the dictionary
        # can the whole s be also represented in the dictionary?
        
        # BUILDING THE INTUITION HERE
        """"""
        1. can I generate all substrings and check if the strings in the 
        dictionary are present in the substring.
        2. This will not work, why? Because strings in the mother set 
        may have been used already to create another string
        
        SOLUTION
        --------------------------
        1. Go through the dictionary of words and find the string which is the 
        potential begining of the string
        2. segment the length of that string from the string.
        3. Check if the remaining string can also be segmented in words from 
        the dictionary.
        4. if there are no more strings to segment then we can return True.
        5. This is a recurrence problem and can be solved with the recurrence 
        solution.
        
        6. The recurrence function should go through the word dictionary 
        and the one which qualifies will now segment the rest of the string 
        and check for the rest of the segment of the string.
        
        FOR THE RECURRENCE RELATION
        
        1. With every word in the dictionary, get the length of the word.
        2. Check if a segment of the string is equal to that word.
        3. if True, call the function of the rest of the segment of the string.
        
        Base Case:
        1. If all strings are segmented, which means we have the empty ("""") string
        so we can then return True
        
        2. Else we return False
        
        """"""
        """""" RECURRENCE SOLUTION """"""
        def sectionBreak(string):
            if len(string) == 0:
                return True

            for word in wordDict:
                prefix = string[:len(word)]

                if prefix == word and sectionBreak(string[len(word):]):
                    return True
            return False
        
        return sectionBreak(s)
        
        """"""
        MOMOIZATION
        """"""
        def sectionBreak(string, memo):
            if len(string) == 0:
                return True
            elif string in memo:
                return memo[string]

            for word in wordDict:
                prefix = string[:len(word)]

                if prefix == word and sectionBreak(string[len(word):], memo):
                    memo[string] = True
                    return True
            memo[string] = False
            return False
        
        return sectionBreak(s, {})

        """"""
        The dynammic programming approach 
        1. The empty substring can be segmented to any of the words in the dictionary.
        2. Let the index of the words represents the sufix of words in the dictionary.
        3. If suffix of a word is in the dictionary then and the suffix of the previous 
        word is also in the dictionary, then it stands to prove that, the substring of 
        the string up to the current suffix can also be segmented
        """"""
    
        # Initialize a dp table with the length of the string + 1
        # Plus 1 is to compensate for the empty string
        # You can either iterate from the back if you want to use the prefix instead of suffix pointers.
        
        wordSet = set(wordDict) # put words in a hashSet to optimize lookup to O(1)
        dp = [False for _ in range(len(s)+1)]
        dp[0] = True
        
        for i in range(1, len(s)+1):
            for j in range(i-1, -1, -1):
                if dp[j] and s[j:i] in wordSet:
                    dp[i] = True
                    break  # break from the loop if a segment is found
        return dp[-1]";"def puede_segmentar(s, diccionario):
    n = len(s)
    dp = [False] * (n + 1)
    dp[0] = True
    
    for i in range(1, n + 1):
        for j in range(i):
            if dp[j] and s[j:i] in diccionario:
                dp[i] = True
                break
                
    return dp[n]"
"class Solution:
    def binaryGap(self, n: int) -> int:
        
        #Bit mask
        mask = 1,
        
        #Max streak and streak default to zero
        maxStreak = 0,
        streak = 0,
        
        #Burn through all of the rightmost zeroes
        #Keep bitshifting n to the right
        #As long as the rightmost bit is not 1 ( which means its even)
        while n > 0 and n % 2 != 1:
            n = n >> 1,
        
        #Then we can begin finding our distances
        while n > 0:
            #Each iteration, we see if the rightmost bit is 1
            isOne = ( mask &amp, n ) == 1,
            
            #If it is, we update our max
            if isOne:
                maxStreak = max( maxStreak, streak ),
                
                #And then increment the streak
                streak = 1,
                
            #If it is a zero, we increment the streak
            else:  
                streak += 1,
                
            #Each time, we bitshift right
            n = n >> 1,
        
        #Note, we will always end at a valid 1 as leading zeros are not
        #processed and we stop when n == 0
        return maxStreak,";"n = int(input(""Ingresa un número entero positivo: ""))
binario = bin(n)[2:]
max_distancia = 0
posicion_anterior = -1

for i in range(len(binario)):
    if binario[i] == '1':
        if posicion_anterior != -1:
            distancia = i - posicion_anterior
            if distancia > max_distancia:
                max_distancia = distancia
        posicion_anterior = i

print(max_distancia)"
"class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        
        """"""
        Let suppose we can divide the array in to two subsets S1 and S2.
        Such that, the difference of those subset is target value.
        sum(S1) + sum(S2) = total     --- (1)
        sum(S1) - sum(S2) = target    --- (2)
        _____________________________________
        2*sum(S1) = total + target    --- (1) + (2)
        
        Hence, sum(S1) = total + target // 2
        """"""
        
        # Total of array
        total = sum(nums)
        
        # Base Case:
        # If total is less than target it is not possible to find any subsets
        # If total + target is odd, no subset exists
        if (total < target) or ((total + target) % 2):
            return 0
        
        # Get the value of sum of subset S1
        sum_s1 = (total + target) // 2
        
        # Recurrsion with memoization
        def countSubsetSum(n: int, w : int, t: Dict):
            if n == 0:
                t[(n,w)] = (0 if w else 1)
            else:
                if (n,w) not in t:
                    if nums[n-1] <= w:
                        t[(n,w)] = countSubsetSum(n-1, w-nums[n-1], t) + countSubsetSum(n-1, w, t) 
                    else:
                        t[(n,w)] = countSubsetSum(n-1, w, t)
            return t[(n,w)]
            
        return countSubsetSum(len(nums), sum_s1, dict())";"def encontrar_expresiones(numeros, objetivo):
    total = 0
    n = len(numeros)
    
    def backtrack(suma_actual, indice):
        nonlocal total
        if indice == n:
            if suma_actual == objetivo:
                total += 1
            return
        
        backtrack(suma_actual + numeros[indice], indice + 1)
        backtrack(suma_actual - numeros[indice], indice + 1)
    
    backtrack(0, 0)
    return total"
"class Solution:
    #Time-Complexity: O(16rows*cols), in worst case our bfs algorithm needs to         process, and each iteration of while loop in worst case will run for loop
    #2 times, with each going through each of eight directions for total of 16!
    #-> O(rows*cols)
    #Space-Complexity: O(2rows*cols)->O(rows*cols)
    #each and every entry of grid that could be updated!
    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:
        #click is going to be start position of our bfs!
        
        #first thing we got to check is if click position clicks a unrevealed mine directly -> Immediate
        #Game Over!
        rows, cols = len(board), len(board[0])
        sr, sc = click
        if(board[sr][sc] == 'M'):
            board[sr][sc] = 'X'
            return board
        
        #otherwise, we need to inititate bfs starting from click position using a queue data structure!
        q = collections.deque()
        #need a visited hashset so we don't revisit empty cell again! Since we may need to bfs
        #continuously from a cell with no adjacent mines in terms of its neighbors!
        visited = set()
        q.append(click)
        visited.add((sr, sc))
        eight_directions = [[1, 0], [-1, 0], [0, 1], [0,-1], [-1, -1], [-1, 1], [1, -1], [1, 1]]
        # as long as queue is non-empty initiate bfs!
        while q:
            #cr = current row, cc = current column!
            cr, cc = q.popleft()
            #for each new empty cell we are processing, the number of adjacent mines starts as 0!
            number_of_mines = 0
            #we have to loop through each of the 8 directional neighbors and check how many of them
            #are in-bounds, unrevealed mine cell!
            for direction in eight_directions:
                r_change, c_change = direction
                if(cr + r_change in range(rows) and 
                   cc + c_change in range(cols) and 
                   board[cr+r_change][cc+c_change] == 'M'):
                    number_of_mines += 1
            #once we iterated through all possible eight neighbors, check if current empty cell
            #has no adjacent mines or even at least 1!
            if(number_of_mines == 0):
                #then, check each of eight directional neighbors: in-bounds, unrevealed empty cell, and
                #and it's not already visited!
                for direction2 in eight_directions:
                    r_change2, c_change2 = direction2
                    if(cr + r_change2 in range(rows) and
                       cc + c_change2 in range(cols) and
                       board[cr+r_change2][cc+c_change2] == 'E' and
                       (cr+r_change2, cc+c_change2) not in visited):
                        q.append([cr+r_change2, cc+c_change2])
                        visited.add((cr+r_change2, cc+c_change2))
                #current empty cell 
                board[cr][cc] = 'B'
            else:
                #otherwise, we need to stop bfs from current cell and label current cell
                #by number of adjacent land mines! digits 1-8 at most!
                board[cr][cc] = str(number_of_mines)
        #once bfs is done, our game board is updated! Simply return it!
        return board";"def actualizar_tablero(tablero, click):
    fila, columna = click
    if tablero[fila][columna] == 'M':
        tablero[fila][columna] = 'X'
        return tablero
    
    direcciones = [(-1, -1), (-1, 0), (-1, 1),
                   (0, -1),          (0, 1),
                   (1, -1),  (1, 0), (1, 1)]
    
    filas = len(tablero)
    columnas = len(tablero[0])
    
    def contar_minas_adyacentes(f, c):
        contador = 0
        for dr, dc in direcciones:
            nr, nc = f + dr, c + dc
            if 0 <= nr < filas and 0 <= nc < columnas and tablero[nr][nc] == 'M':
                contador += 1
        return contador
    
    minas = contar_minas_adyacentes(fila, columna)
    if minas > 0:
        tablero[fila][columna] = str(minas)
    else:
        tablero[fila][columna] = 'B'
        for dr, dc in direcciones:
            nr, nc = fila + dr, columna + dc
            if 0 <= nr < filas and 0 <= nc < columnas and tablero[nr][nc] == 'E':
                actualizar_tablero(tablero, [nr, nc])
    
    return tablero"
"class Solution:
    def isUgly(self, n):
        # Base Cases: 
        # For a number to be ""Ugly"" the first
        # prerequisite is that it is positive
        if n <= 0: return False
        if n == 1: return True

        # Initializing desired set for O(1) lookups later
        # Not a huge improvement, but it's non-zero improvement
        desired = {2,3,5}
        primes = (i for i in [2,3,5,7])

        current_prime = next(primes)
        while True:
            # As soon as our current prime exceeds 2,3,5 we know our n
            # has prime factors not included in the ""Ugly"" grouping
            if current_prime not in desired: return False
            
            # We want to divide n by said prime as many times as we can
            # If the prime doesn't divide evenly into n then we go to the
            # next prime. We would only do this shift 3 times, and once 
            # we have, we've gone into the realm of non-Ugly numbers
            while n % current_prime == 0:
                div= n/current_prime
                if div == 1: return True
                n = div
            current_prime = next(primes)";"def es_fea(numero):
    if numero <= 0:
        return False
    while numero % 2 == 0:
        numero = numero // 2
    while numero % 3 == 0:
        numero = numero // 3
    while numero % 5 == 0:
        numero = numero // 5
    return numero == 1"
"class Solution:
    def deserialize(self, s: str) -> NestedInteger:
        stack = []
        integerStr = ''
        
        for c in s:
            if c == '[':
                stack.append(NestedInteger())
            elif c == ']':
                if len(integerStr)>0:
                    stack[-1].add(NestedInteger(int(integerStr)))
                integerStr = ''
                poppedList = stack.pop()
                if len(stack)==0:
                    return poppedList
                stack[-1].add(poppedList)
            elif c == ',':
                if len(integerStr)>0:
                    stack[-1].add(NestedInteger(int(integerStr)))
                integerStr = ''
            else:
                integerStr += c
                
        return NestedInteger(int(s))";"class NestedInteger:
    def __init__(self, valor=None):
        self.valor = valor
        self.lista = []

def deserializar(s):
    if not s:
        return NestedInteger()
    if s[0] != '[':
        return NestedInteger(int(s))
    pila = []
    actual = NestedInteger()
    i = 0
    while i < len(s):
        if s[i] == '[':
            nuevo = NestedInteger()
            pila.append(actual)
            actual = nuevo
            i += 1
        elif s[i] == ']':
            if pila:
                padre = pila.pop()
                padre.lista.append(actual)
                actual = padre
            i += 1
        elif s[i] == ',':
            i += 1
        else:
            inicio = i
            while i < len(s) and (s[i].isdigit() or s[i] == '-'):
                i += 1
            num = s[inicio:i]
            if num:
                actual.lista.append(NestedInteger(int(num)))
    return actual.lista[0] if actual.lista else actual"
"class Solution:
    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:
        prev_key, prev_ts = ('',0) ## this tuple will contain the previous key press and when that was released (prev_ts)
        slowest_key, max_duration = ('',0) ## this tuple will contain the slowest key and for how long it was pressed for
        for key,release_ts in zip(keysPressed,releaseTimes): ## convert keyPressed and releaseTimes into tuples and example the tuple one-by-one
            cur_duration = release_ts - prev_ts ## get the duration for which the key was pressed
            if prev_ts == 0: ## initial case, first key press
                prev_ts = release_ts
                max_duration=release_ts
            if cur_duration > max_duration: ## subsequent keys, check if current duration is more than max we have seen so far
                slowest_key, max_duration = key, cur_duration ## assign the max tuple with the new max and corresponding key
            elif cur_duration == max_duration: ## if current key press duration and max are the same, 
                if key > slowest_key: ## check which one is higher lexically, if current key is higher then update the slowest key to current key
                    slowest_key = key
            prev_key, prev_ts = key, release_ts ## set current key and release_ts to prev for next iteration
        return slowest_key";"tiempos_liberacion = [9, 29, 49, 50]
teclas_presionadas = ""cbcd""

duracion_maxima = 0
tecla_resultado = ''

for i in range(len(tiempos_liberacion)):
    if i == 0:
        duracion = tiempos_liberacion[i]
    else:
        duracion = tiempos_liberacion[i] - tiempos_liberacion[i - 1]
    
    if duracion > duracion_maxima:
        duracion_maxima = duracion
        tecla_resultado = teclas_presionadas[i]
    elif duracion == duracion_maxima:
        if teclas_presionadas[i] > tecla_resultado:
            tecla_resultado = teclas_presionadas[i]

print(tecla_resultado)"
"class Solution:
    # O(n * m^2) time, n --> len(wordList), m --> len(wordList[i])
    # O(n*m) space,
    # Approach: BFS, hashtable, string
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        
        vstd = set()
        pattern_map = {}
        
        def buildPattern() -> None:
            addWordPattern(beginWord)
            for word in wordList:
                addWordPattern(word)
                
        
        def addWordPattern(word: str) -> None:
            patterns = getPatterns(word)
            
            for pattern in patterns:
                if pattern not in pattern_map.keys():
                    pattern_map[pattern] = []
                pattern_map[pattern].append(word)
        
        
        def getPatterns(word: str) -> List[str]:
            patterns = []
            for i in range(len(word)):
                pattern = word[:i] + '#' + word[i+1:]
                patterns.append(pattern)
                
            return patterns
        
        
        def getNeighbours(root_word: str) -> List[str]:
            neighbours = []
            patterns = getPatterns(root_word)
            
            for pattern in patterns:
                words = pattern_map[pattern]
                for word in words:
                    if word != root_word:
                        neighbours.append(word)
                
            return neighbours
        
        
        def bfs(root_word:str) -> int:
            qu = deque()
            qu.append(root_word)
            depth = 0
            
            while qu:
                n = len(qu)
                depth +=1
                for i in range(n):
                    root_word = qu.popleft()
                    if root_word in vstd:   continue
                    
                    if root_word == endWord:
                        return depth
                    
                    vstd.add(root_word)
                    neighbours = getNeighbours(root_word)
                    for nb in neighbours:
                        qu.append(nb)
                    
            return 0
            
        buildPattern()
        ans = bfs(beginWord)
        return ans";"from collections import deque

palabra_inicio = beginWord
palabra_fin = endWord
lista_palabras = wordList

if palabra_fin not in lista_palabras:
    print(0)
else:
    cola = deque()
    cola.append((palabra_inicio, 1))
    visitadas = set()
    visitadas.add(palabra_inicio)
    
    while cola:
        palabra_actual, nivel = cola.popleft()
        
        for i in range(len(palabra_actual)):
            for letra in 'abcdefghijklmnopqrstuvwxyz':
                nueva_palabra = palabra_actual[:i] + letra + palabra_actual[i+1:]
                
                if nueva_palabra == palabra_fin:
                    print(nivel + 1)
                    exit()
                
                if nueva_palabra in lista_palabras and nueva_palabra not in visitadas:
                    visitadas.add(nueva_palabra)
                    cola.append((nueva_palabra, nivel + 1))
    
    print(0)"
"class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        drop = {}   # passengers drop location list        
        nxt = trips[0][2]   # next/earliest drop point
        
        # swap-> numPassengersi and fromi in the trips, then
        # sort(asc) trips as per pickup location
        for p in trips:
            p[0], p[1]  = p[1], p[0]
        heapq.heapify(trips)
        
			seats = capacity    #available seats
        while trips:
            # current stop, num of passenger, dest/to
            (curr, psg, dest) = heapq.heappop(trips)
            # drop passengers
            while nxt <= curr:
                if drop:
                    seats += drop[nxt]
                    del drop[nxt]
                    if drop:
                        nxt = min(drop)                
                    else:
                        nxt = dest                            
            # pick passengers/psg        
            seats -= psg            
            if seats < 0:                
                return False
            #number of passengers to drop at location dest
            if dest in drop:
                drop[dest] += psg
            else:                
                drop[dest] = psg
            nxt = min(nxt, dest)            
            
        return True";"capacidad = 5
viajes = [[2,1,5],[3,3,7]]

es_posible = True
eventos = []

for viaje in viajes:
    pasajeros, inicio, fin = viaje
    eventos.append((inicio, pasajeros))
    eventos.append((fin, -pasajeros))

eventos.sort()

pasajeros_actuales = 0
for evento in eventos:
    pasajeros_actuales += evento[1]
    if pasajeros_actuales > capacidad:
        es_posible = False
        break

print(es_posible)"
"class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        
        dict_1 = from_str_to_dict(ransomNote)
        dict_2 = from_str_to_dict(magazine)
        
        return check_compatibility(dict_1, dict_2)
    
# Define helper method that checks if to dictionaries have keys in common, and 
# if the ransomNote needs more letters then what the magazine can provide.

def check_compatibility(dict_1, dict_2):
    
    # Check for common keys.
    for key in list(dict_1.keys()):
        
        if not key in dict_2:
            
            return False
        
        # Check for valid quantity.
        if dict_1[key] > dict_2[key]:
            
            return False
        
    return True

# Convert a string into a dictionary.

def from_str_to_dict(string: str):
    
    dic = {}
    
    for i in string:
        
        if i in dic:
            
            dic[i] += 1
            
        else:
            
            dic[i] = 1
            
    return dic        

# Runtime: 134 ms, faster than 24.02% of Python3 online submissions for Ransom Note.
# Memory Usage: 14.1 MB, less than 93.55% of Python3 online submissions for Ransom Note.

# If you like my work and found it helpful, then I'll appreciate a like. Thanks!";"def se_puede_construir(nota_rescate, revista):
    contador = {}
    
    for letra in revista:
        if letra in contador:
            contador[letra] += 1
        else:
            contador[letra] = 1
    
    for letra in nota_rescate:
        if letra in contador and contador[letra] > 0:
            contador[letra] -= 1
        else:
            return False
    
    return True"
"class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        self.targetSum, self.ans = targetSum, []            # variable initialization
        self.get_path_sum(root, 0, [])                      # calling function get path sum
        return self.ans                                     # return answer
        
    def get_path_sum(self, root, psum, path):
        if not root: return None                            # if not root return None
        if not root.left and not root.right:                # if curr node is leaf
            if root.val + psum == self.targetSum:           # if path sum from root to leaf = target sum
                path.append(root.val)                       # append node value to path
                self.ans.append([e for e in path])          # add path to ans list
                path.pop(-1)                                # remove node value from path
                return,                                     # return
        path.append(root.val)                               # append node value to path
        self.get_path_sum(root.left, psum + root.val, path) # left traversal
        self.get_path_sum(root.right, psum + root.val, path)# right traversal
        path.pop(-1)                                        # remove node value from path";"class Nodo:
    def __init__(self, valor=0, izquierda=None, derecha=None):
        self.valor = valor
        self.izquierda = izquierda
        self.derecha = derecha

def encontrar_caminos(raiz, suma_objetivo):
    if not raiz:
        return []
    caminos = []
    pila = [(raiz, [raiz.valor], raiz.valor)]
    while pila:
        nodo, camino, suma_actual = pila.pop()
        if not nodo.izquierda and not nodo.derecha and suma_actual == suma_objetivo:
            caminos.append(camino)
        if nodo.derecha:
            nuevo_camino = list(camino)
            nuevo_camino.append(nodo.derecha.valor)
            pila.append((nodo.derecha, nuevo_camino, suma_actual + nodo.derecha.valor))
        if nodo.izquierda:
            nuevo_camino = list(camino)
            nuevo_camino.append(nodo.izquierda.valor)
            pila.append((nodo.izquierda, nuevo_camino, suma_actual + nodo.izquierda.valor))
    return caminos"
"class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        # To adhere to the problem's constraints, we should probably hardcode this!
        tables_of_addition = {str(x): {str(i): str(x+i) for i in range(10)} for x in range(0, 10)}
        # Corner case
        for i in range(10, 20): tables_of_addition[""1""][str(i)] = str(1+i)
        
        # Ensuring that the 2 numbers are the same size.
        num1 = num1.zfill(max(len(num1), len(num2)))
        num2 = num2.zfill(max(len(num1), len(num2)))

        p = len(num1)-1
        
        carry, results = ""0"", """"
        while p > -1:
            curr_res = tables_of_addition[num1[p]][num2[p]]
            
            # Carry is a bit tricky since current result can be in the range 0, 18 (inclusive)
            curr_res_with_carry = tables_of_addition[str(carry)][curr_res] if str(carry) == ""1"" else curr_res
            carry = ""0""
            
            # We know that the maximum addition (between 9 &amp, 9) is 2 digits and will equal 18
            if len(curr_res_with_carry) > 1:
                carry = curr_res_with_carry[0]
                results = curr_res_with_carry[1]+results
            else:
                results = curr_res_with_carry[0]+results
            p-=1
        
        return results if carry == ""0"" else carry + results";"def sumar_numeros(num1, num2):
    i = len(num1) - 1
    j = len(num2) - 1
    acarreo = 0
    resultado = []
    
    while i >= 0 or j >= 0 or acarreo:
        digito1 = int(num1[i]) if i >= 0 else 0
        digito2 = int(num2[j]) if j >= 0 else 0
        
        suma = digito1 + digito2 + acarreo
        acarreo = suma // 10
        resultado.append(str(suma % 10))
        
        i -= 1
        j -= 1
    
    return ''.join(reversed(resultado))"
"class Solution:
    def maxJumps(self, nums: List[int], d: int) -> int:
        N = len(nums)
        seen = set() # seen for lookup, to memoize
        dp = [1]*N   # stores the values of jump we can make from Ith index in DP.                                    #  minimum being 1 jump (i.e its self)
        
        def recursion(indx):
            # if we have indx in seen return its value  dp[indx].
            if indx in seen:
                return dp[indx]
            # base case if indx is out of range we cant jump. return 0
            if indx<0 or indx >= N:
                return 0
            
        # tempR : all the jumps we can make to the right side of indx
        # tempL : all the jumps we can make to the left side of indx
            tempR,tempL= 0,0
            curr = nums[indx] # height of current indx so we only jump allowed jump 
                    # i.e nums[i] < curr <- allowed  if curr =< nums[i] break(jump not allowed)
            
            #max jump we can make to the right Side are stored in tempR, 
            for i in range(indx+1, min(indx+d+1,N) ):
                if nums[i] < curr:
                    tempR = max(tempR, recursion(i)) # store max jumps in right
                else:
                    break
            for i in range(indx-1, max(-1,indx-d-1) , -1): 
                if nums[i] < curr:
                    tempL = max(tempL, recursion(i)) # store max jumps in  left
                else:
                    break
            # update dp[indx] by (1 + maxjumps( right, left))   ( 1 becoz it can jump on itself)
            dp[indx] = max(tempR,tempL) + 1 
            seen.add(indx) # as Indx calculated, can use its value next time, so added to seen
            return dp[indx]
        
        
        # for all indices we check how many jumps we can make
        for i in range(N): 
            if i not in seen: # if ith index is not in seen then we have comupted its jumps.
                recursion(i)
        return max(dp)  # returns the max jumps";"def max_saltos(arr, d):
    n = len(arr)
    saltos_maximos = [1] * n
    
    for i in range(n):
        for x in range(1, d + 1):
            if i + x < n and arr[i] > arr[i + x]:
                saltos_maximos[i] = max(saltos_maximos[i], saltos_maximos[i + x] + 1)
            else:
                break
        
        for x in range(1, d + 1):
            if i - x >= 0 and arr[i] > arr[i - x]:
                saltos_maximos[i] = max(saltos_maximos[i], saltos_maximos[i - x] + 1)
            else:
                break
    
    return max(saltos_maximos)"
"class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if node is None: return None #if we have an empty graph
        visited = [] #will store all visited nodes
        cloneNodes = {} #will store cloned nodes. In each k:v pair k is the val attribute of 
                        #the old node and v is the corresponding cloned node
        adj = {} #the adjacency list for the graph. In each k:v pair k is the val attribute
                 #of a node and v is a list of the val attributes of its neighbors.
        stack = [node] #stack of nodes to be visited. Each time we visit a node, we will add
                       #its neighbors in the stack.
        while stack != []:
            curr = stack.pop() #take a node out of the stack
            if curr.val not in visited: #if node was already visited we do nothing
                visited.append(curr.val)
                cloneNodes[curr.val] = Node(curr.val) #create new node with the same val and 
                                                      #no neighbors
                adj[curr.val] = []
                for nd in curr.neighbors:
                    stack.append(nd) #add neighbors in the stack
                    adj[curr.val].append(nd.val) #save neighbors in adjacency dictionary
        for k, v in adj.items():
            #update neighbors of cloned nodes to match the neighbors of old ones
            cloneNodes[k].neighbors = [cloneNodes[i] for i in v]
        return cloneNodes[node.val] #return clone of initial node";"class Nodo:
    def __init__(self, val = 0, vecinos = None):
        self.val = val
        self.vecinos = vecinos if vecinos is not None else []

def clonar_grafo(nodo):
    if not nodo:
        return None
    
    visitados = {}
    cola = []
    cola.append(nodo)
    visitados[nodo] = Nodo(nodo.val)
    
    while cola:
        actual = cola.pop(0)
        
        for vecino in actual.vecinos:
            if vecino not in visitados:
                visitados[vecino] = Nodo(vecino.val)
                cola.append(vecino)
            visitados[actual].vecinos.append(visitados[vecino])
    
    return visitados[nodo]"
"class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        n=len(nums)
        
        # Brute Force: O(n^3) --> TLE
		# for i in range(n):
        #     for j in range(i+1, n):
        #         for k in range(j+1, n):
        #             if nums[i]<nums[k] and nums[k]<nums[j]:
        #                 return True
        
        # Optimised using BS: O(nlogn) --> TLE 
        # for i in range(n):
        #     j=i+1
        #     k=n-1
        #     while j<k:
        #         if nums[i]<nums[j] and nums[i]<nums[k]:
        #             if nums[j]<nums[k]:
        #                 k-=1
        #             elif nums[k]==nums[j]:
        #                 j+=1
        #             else:
        #                 return True
        #         elif nums[i]<nums[j]:
        #             k-=1
        #         else:
        #             j+=1
        
        # Optimised using Monotonic stack: O(n)
        st=[]
        mini=nums[0]
        for num in nums:
            while st and st[-1][0]<=num:
                st.pop()
            if st and st[-1][1]<num:
                return True
            st.append([num, mini])
            mini=min(mini, num)
        return False";"def tiene_patron_132(numeros):
    n = len(numeros)
    if n < 3:
        return False
    
    for i in range(n):
        for j in range(i + 1, n):
            for k in range(j + 1, n):
                if numeros[i] < numeros[k] < numeros[j]:
                    return True
    return False"
"class Solution:
    def new21Game(self, n: int, k: int, maxPts: int) -> float:
        if n >= k - 1 + maxPts: return 1 #the last possible stop-point is k-1, if we roll a maxPts and it will end within n, that means anyway it will end within n with prob 1, there is no need to continue
        dp = [0] * (n + 1) #dp[i] is the probability we reach point i. As we care what's the probability within n, at most we need dp to calculate from 1 to n
        dp[0], curSum = 1, 0 #dp[0] is the probability we reach 0. As we start with 0, we have a probability of 1 reaching 0
        for i in range(1, n + 1):
            if i - 1 < k: # when the previous point hasn't reached k, that means we can still continue to roll, and we'll add that point. Otherwise, when i - 1 already reaches k, then the game stops and we cannot reach status i from  i - 1 (we cannot pick any more number)
                curSum += dp[i - 1]
            if i - 1 >= maxPts: # we can only reach point i from point i - 1, i - 2, ..., i - maxPts. and hence when we calculate point i, we need to make sure the previous points outside of the range drops out
                curSum -= dp[i - 1 - maxPts]
            dp[i] = curSum / maxPts
        return sum(dp[k:]) # we calculate all the probabilities that we land in point k, point k + 1, until point n";"k = int(input(""Ingresa el valor de k: ""))
max_puntos = int(input(""Ingresa el valor de maxPts: ""))
n = int(input(""Ingresa el valor de n: ""))

if k == 0:
    print(1.0)
else:
    dp = [0.0] * (n + 1)
    dp[0] = 1.0
    
    for i in range(1, n + 1):
        for j in range(1, max_puntos + 1):
            if i - j >= 0 and i - j < k:
                dp[i] += dp[i - j] / max_puntos
    
    probabilidad = sum(dp[k:n+1])
    print(probabilidad)"
"class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        return self.moveZerosOptimal(nums)
		return self.moveZerosOptimalTwo(nums)
        # return self.moveZeroesByPopAndAppend(nums)

#     O(n) || O(1)
# runtime: 291ms 32.26%
    def moveZerosOptimal(self, nums):
        if not nums:return nums

        nextPtr = 0

        for num in nums:
            if num != 0:
                nums[nextPtr] = num
                nextPtr += 1
        
        for i in range(nextPtr, len(nums)):
            nums[i] = 0

        return nums
    
	# O(n) || O(1)
	def moveZerosOptimalTwo(self, nums):
		if not nums:
			return nums
			
		left = 0
		for right in range(len(nums)):
			if nums[right]:
				nums[left], nums[right] = nums[right], nums[left]
				left += 1
		return nums
    
# O(n) || O(1) space: but its a bad practice,
# appending a element is an O(1) operation but when you pop(O(1)) 
# all the elements to its right move to fill the space. O(n)
# runtime: 1698ms 5.69%
    def moveZeroesByPopAndAppend(self, nums):
        if not nums:
            return nums

        for i in nums:
            if i == 0:
                nums.remove(i)
                nums.append(i)

        return nums";"numeros = [0, 1, 0, 3, 12]
indice_no_cero = 0

for i in range(len(numeros)):
    if numeros[i] != 0:
        numeros[indice_no_cero] = numeros[i]
        indice_no_cero += 1

for i in range(indice_no_cero, len(numeros)):
    numeros[i] = 0

print(numeros)"
"class Solution:
        #greedy algorithm
        def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
                #if the gas at all stations is less than the cost at all stations then gas will not be sufficient to travel the circuit once
                if sum(gas) < sum(cost):
                        #so return - 1
                        return - 1
                #if the gas is sufficient 
                #we have to find from which index we should start
                total = 0 
                #res is a variable which is created to store the index from which we are going to start
                res = 0 
                #iterate of the indexes of gas
                for i in range(len(gas)):
                        #add the difference of gas and cost at each station
                        total += (gas[i]  - cost[i])
                        #if the difference is less than 0 
                        if total < 0:
                                #then we have to check the positive difference
                                #so reset total to 0 
                                total = 0
                                #increse the res value to next index
                                res = i + 1
                #after finishing the for-loop 
                #we the return the index where first positive difference is occured
                return res";"def estacion_inicial(gas, costo):
    total_gas = 0
    total_costo = 0
    tanque = 0
    inicio = 0
    
    for i in range(len(gas)):
        total_gas += gas[i]
        total_costo += costo[i]
    
    if total_gas < total_costo:
        return -1
    
    for i in range(len(gas)):
        tanque += gas[i] - costo[i]
        if tanque < 0:
            tanque = 0
            inicio = i + 1
    
    return inicio"
"class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        
        # Init
        m = len(matrix)
        n = len(matrix[0])
        max_len = 0
        
        # Convert matrix value of string to int
        for row in range(m):
            for col in range(n):
                matrix[row][col] = int(matrix[row][col])
        
        # Scan first row
        for col in range(n):
            max_len = max(max_len, matrix[0][col])
            
        # Scan first column
        for row in range(m):
            max_len = max(max_len, matrix[row][0])
        
        # For each row starting from second row
        for i in range(1,m):
            
            # For each col starting from second column
            for j in range(1,n):
                
                # If the current element is non-zero
                if matrix[i][j]:
                    
                    # If all three of it's adjacent elements are non-zero
                    # Three elements are:
                    # a) element in the previous row ""[i-1][j]""
                    # b) element in the previous column ""[i][j-1]""
                    # c) element in previous diagonal ""[i-1][j-1]""
                    if matrix[i-1][j] and matrix[i][j-1] and matrix[i-1][j-1]:
                        
                        # Get the minimum of all three adjacent elements and add one to it
                        # This updates length of the element w.r.t how many adjacent ones
                        # are available in the original matrix
                        matrix[i][j] = min(matrix[i-1][j], matrix[i][j-1], matrix[i-1][j-1]) + 1
                    
                    # Calc max len w.r.t the updated length of the current element
                    max_len = max(max_len, matrix[i][j])
                        
                    
        return max_len**2 # Area of a square of length ""l"" is l*l = l^2";"def area_cuadrado_maximo(matriz):
    if not matriz:
        return 0
    
    filas = len(matriz)
    columnas = len(matriz[0])
    dp = [[0] * columnas for _ in range(filas)]
    max_lado = 0
    
    for i in range(filas):
        for j in range(columnas):
            if matriz[i][j] == '1':
                if i == 0 or j == 0:
                    dp[i][j] = 1
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                if dp[i][j] > max_lado:
                    max_lado = dp[i][j]
    
    return max_lado * max_lado"
"class Solution2:
    def _get_all_divisors(self, num: int):
        for divisor in range(1, int(num ** 0.5) + 1):
            if num % divisor == 0:
                yield divisor
                other_divisor = num // divisor
                if divisor != other_divisor:
                    yield other_divisor

    def checkPerfectNumber(self, num: int) -> bool:
        sum_of_divisors = sum(self._get_all_divisors(num)) - num
        return sum_of_divisors == num";"def es_numero_perfecto(n):
    if n <= 1:
        return False
    suma_divisores = 0
    for i in range(1, n):
        if n % i == 0:
            suma_divisores += i
    return suma_divisores == n"
"class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        words_out = []
        for w_x in words:
            inx_words = []
            inx_count = []
            for xx in range(len(w_x)):
                inx_words.append(self.index_all(board, w_x[xx]))
                inx_count.append(len(inx_words[xx]))
            if inx_count.count(0) > 0:
                pass
            else:
                board_2 = []
                for x in range(len(board)):
                    for y in range(len(board[0])):
                        try:
                            b2 = [f'{board[x][y]}{board[x][y + 1]}']
                        except IndexError:
                            b2 = [0]
                        try:
                            b2 += [f'{board[x][y]}{board[x + 1][y]}']
                        except IndexError:
                            b2 += [0]
                        b2 += [f'{board[x][y]}{board[x][y - 1]}', f'{board[x][y]}{board[x - 1][y]}']
                        if x == 0 and y == 0:
                            board_2 += b2[:2]
                        elif x == 0 and y != 0:
                            board_2 += b2[:3]
                        elif x != 0 and y == 0:
                            board_2 += [b2[0], b2[1], b2[3]]
                        else:
                            board_2 += b2

                break_c = False
                for x in range(len(w_x) - 1):
                    words_2 = w_x[x] + w_x[x + 1]
                    if board_2.count(words_2) == 0:
                        break_c = True
                        break

                if break_c:
                    continue

                w_x0 = w_x[:]
                if inx_count[-1] <= inx_count[0]:
                    w_x = w_x[::-1]
                    inx_words = inx_words[::-1]

                inx = [0 for i in range(len(w_x))]
                while inx[0] < len(inx_words[0]):
                    inx_s1 = inx_words[0][inx[0]]
                    i = 1
                    path = [inx_s1]
                    inx_words0 = [aa[:] for aa in inx_words]
                    while i < len(w_x):
                        try:
                            for ix in range(i, len(w_x)):
                                if inx_words0[ix].count(inx_s1) > 0:
                                    inx_words0[ix].remove(inx_s1)
                            inx_s2 = inx_words0[i][inx[i]]
                            inx_s12 = [[inx_s1[0] + 1, inx_s1[1]], [inx_s1[0] - 1, inx_s1[1]],
                                       [inx_s1[0], inx_s1[1] + 1], [inx_s1[0], inx_s1[1] - 1]]

                            if inx_s12.count(inx_s2) == 0:
                                inx[i] += 1
                                break
                            inx_s1 = inx_s2
                            path.append(inx_s1)
                            i += 1
                        except IndexError:
                            inx[i - 1] += 1
                            inx[i:] = [0] * (len(w_x) - i)
                            break

                    if i == len(w_x):
                        inx[i - 1] += 1
                        if len(w_x) == len(set(map(tuple, path))):
                            words_out.append(w_x0)
                            break
        return words_out

    def index_all(self, my_list, v):
        inx_s = []
        for i, x in enumerate(my_list):
            inx_c = [i for i, m in enumerate(x) if m == v]
            for xx in inx_c:
                inx_s.append([i, xx])
        return inx_s";"def encontrar_palabras(tablero, palabras):
    if not tablero or not palabras:
        return []
    
    filas = len(tablero)
    columnas = len(tablero[0])
    resultado = []
    
    for palabra in palabras:
        encontrada = False
        for i in range(filas):
            for j in range(columnas):
                if buscar_palabra(tablero, i, j, palabra, 0, set()):
                    resultado.append(palabra)
                    encontrada = True
                    break
            if encontrada:
                break
    return resultado

def buscar_palabra(tablero, fila, columna, palabra, indice, visitados):
    if indice == len(palabra):
        return True
    
    if (fila < 0 or fila >= len(tablero) or 
        columna < 0 or columna >= len(tablero[0]) or 
        (fila, columna) in visitados or 
        tablero[fila][columna] != palabra[indice]):
        return False
    
    visitados.add((fila, columna))
    
    direcciones = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    for dr, dc in direcciones:
        if buscar_palabra(tablero, fila + dr, columna + dc, palabra, indice + 1, visitados):
            return True
    
    visitados.remove((fila, columna))
    return False"
"class Solution:
    def minimumBoxes(self, m: int) -> int:
        def cbrt(x):
            return x**(1. / 3)

        # Find the first tetrahedral number greater than
        # or equal to m.
        x = cbrt(sqrt(3)*sqrt(243*(m**2) - 1) + 27*m)
        n = ceil(x/cbrt(9) + 1/(cbrt(3)*x) - 1)
        
        # If m is the nth tetrahedral number, return the
        # nth triangular number (the base).
        t_n =n*(n+1)*(n+2) // 6 
        if m == t_n:
            return n*(n+1)//2

        # Otherwise, we must adjust the answer.
        ans = n*(n+1)//2
        j = t_n + 1
        while m < j:
            j -= n
            ans -= 1
            n -= 1

        return ans + 1";"n = int(input(""Ingresa el valor de n: ""))

if n == 1:
    resultado = 1
elif n == 2:
    resultado = 2
else:
    capa = 1
    total_pisos = 0
    while n > 0:
        necesarios = capa * capa
        if n >= necesarios:
            total_pisos += necesarios
            n -= necesarios
        else:
            total_pisos += n
            n = 0
        capa += 1
    resultado = total_pisos

print(resultado)"
"class Solution:
    def magicalString(self, n: int) -> int:
        ref = ""122112""
        actual = """"
        start = 0
        one = True
        
        while(len(ref) < n):
            for i in range(start, len(ref)):
                if(one):
                    actual += int(ref[i]) * ""1""
                    one = False
                else:
                    actual += int(ref[i]) * ""2""
                    one = True
                    
            if(len(actual) > len(ref)):
                start = len(ref)
                ref = actual
        
        return ref[:n].count(""1"")";"n = int(input(""Ingrese el valor de n: ""))
if n == 0:
    print(0)
else:
    cadena_magica = [1, 2, 2]
    indice = 2
    while len(cadena_magica) < n:
        siguiente_numero = 1 if cadena_magica[-1] == 2 else 2
        repeticiones = cadena_magica[indice]
        cadena_magica.extend([siguiente_numero] * repeticiones)
        indice += 1
    cantidad_unos = cadena_magica[:n].count(1)
    print(cantidad_unos)"
"class Solution:
    def reverseString(self, s: List[str]) -> None:
        """"""
        Do not return anything, modify s in-place instead.
        """"""
        return self.reverseStringOptimal(s)
    
#     O(n) || O(1)
# runtime: 342 19.09%
    def reverseStringOptimal(self, string):
        if not string: return string
        left, right = 0, len(string) - 1

        while left < right:
            string[left], string[right] = string[right], string[left]
            left += 1
            right -= 1

        return string
    
    
#     O(n) || O(n)
# brute force
    def reverseStringWithNewList(self, string):
        if not string:
            return string

        newList = [0] * len(string)

        j = 0
        for i in reversed(range(len(string))):
            newList[i] = string[j]
            j += 1

        return newList

# below are just 'some' python built in
    def reverseStringWithListCompression(self, string):
        if not string: return string
        return [string[i] for i in reversed(range(len(string)))]

    
    def reversedStringWithReverse(self, string):
        string.reverse() 
        return string or string[::-1]";"def invertir_cadena(s):
    inicio = 0
    fin = len(s) - 1
    while inicio < fin:
        temp = s[inicio]
        s[inicio] = s[fin]
        s[fin] = temp
        inicio += 1
        fin -= 1"
"class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        freq = [0] * 26
        for task in tasks: freq[ord(task) - ord('A')] += 1
        
        # highest freq, how many letters have it
        highest_freq, no_high_tasks = self.highest_freq1(freq, len(tasks))
        
        parts = highest_freq - 1
        empty_slots = (n - no_high_tasks + 1) * parts
        idle = max(0, empty_slots - ( len(tasks) - no_high_tasks * highest_freq))
        
        return len(tasks) + idle


    def highest_freq1(self, freq, total_tasks):
        '''
        sort in O(Nlog(N)) using heap, find the max frequency and 
        the no. of tasks that have it
        '''
        heapq.heapify(freq)
        max_so_far, high_tasks = -math.inf, 0
        
        while freq:
            occ = heapq.heappop(freq)
            if max_so_far < occ:
                max_so_far = occ
                high_tasks = 0
            if occ == max_so_far: high_tasks += 1
        
        return max_so_far, high_tasks
    
    
    def highest_freq2(self, freq, total_tasks):
        '''
        Sort in O(Nlog(N)) using Timsort and find the no. of tasks with max freq
        '''
        freq = sorted(freq, reverse=True)
        highest_freq, no_high_tasks = freq[0], 0
        
        for f in freq:
            if f == highest_freq: no_high_tasks += 1
        
        return highest_freq, no_high_tasks
    
    
    def highest_freq3(self, freq, total_tasks):
        '''
        Sort in O(N) using bucket sort and return the highest non-empty bucket
        and the number of elements in it
        '''
        buckets = [[] for _ in range(total_tasks + 1)]
        
        for i in range(len(freq)):
            f = freq[i]
            buckets[f].append(i)
        
        highest_freq = -1
        for i in range(len(buckets) - 1, 0, -1):
            if buckets[i]:
                highest_freq = i
                break
        
        return highest_freq, len(buckets[highest_freq])";"def tiempo_minimo(tareas, n):
    contador = {}
    for tarea in tareas:
        if tarea in contador:
            contador[tarea] += 1
        else:
            contador[tarea] = 1
    
    frecuencias = sorted(contador.values(), reverse=True)
    max_frec = frecuencias[0]
    
    huecos = (max_frec - 1) * n
    
    for freq in frecuencias[1:]:
        huecos -= min(max_frec - 1, freq)
    
    huecos = max(0, huecos)
    
    return len(tareas) + huecos"
"class Solution:
    def countPoints(self, rings: str) -> int:
        r = []
        g = []
        b = []
        ring_nums = set()
        count = 0
        for i in range(0, len(rings)):
            if rings[i] == 'R':
                r.append(int(rings[i+1]))
                if rings[i+1] not in ring_nums:
                    ring_nums.add(int(rings[i+1]))
            elif rings[i] == 'G':
                g.append(int(rings[i+1]))
                if rings[i+1] not in ring_nums:
                    ring_nums.add(int(rings[i+1]))
            elif rings[i] == 'B':
                b.append(int(rings[i+1]))
                if rings[i+1] not in ring_nums:
                    ring_nums.add(int(rings[i+1]))
        for i in ring_nums:
            if i in r and i in g and i in b:
                count += 1
        return count";"anillos = input(""Ingrese la cadena de anillos: "")
n = len(anillos) // 2
varillas = {}

for i in range(10):
    varillas[str(i)] = {'R': 0, 'G': 0, 'B': 0}

for i in range(n):
    color = anillos[2 * i]
    varilla = anillos[2 * i + 1]
    varillas[varilla][color] += 1

contador = 0
for varilla in varillas:
    if varillas[varilla]['R'] > 0 and varillas[varilla]['G'] > 0 and varillas[varilla]['B'] > 0:
        contador += 1

print(contador)"
"class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        
        """"""
        Input: Array of integers
        constraints:
        1. Infinite number of each coin
        output: integer
        
        1. Do I have duplicate integers in the array
        2. Choose a single coin and add it up till it hits the targetj
        or greater than the target.
        
        Input variables are going to be the target, and the coins
        Base Case:
        if target hits zero, then return 1
        elif target is less than zero return 0
        Can we have a target less than zero
        Can the target be zero itself
        """"""
        if amount <= 0 and not coins:
            return 0
        if not coins:
            return 0
        memo = {}
        def dfs(target, n, memo):
            if (target, n) in memo:
                return memo[(target, n)]
            if target == 0:
                return 1
            if target < 0 or n == 0:
                return 0
            
            if (coins[n-1] <= target):
                res = dfs(target-coins[n-1], n, memo) + dfs(target, n-1, memo)
                memo[(target, n)] = res
                return res
            else:
                res = dfs(target, n-1, memo)
                memo[(target, n)] = res
                return res
        res = dfs(amount, len(coins), {})
        return res
    
        """"""
        2D DYNAMIC PROGRAMMING
        """"""
        dp = [[0]*(amount+1) for _ in range(len(coins)+1)]
        dp[0][0] = 1

        for i in range(1, len(coins)+1):
            for j in range(amount+1):
                if (coins[i-1]<=j):
                    dp[i][j] = dp[i][j-coins[i-1]] + dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j]
        return dp[len(coins)][amount]
    
        """"""
        1D DYNAMIC PROGRAMMING
        """"""
        dp = [0 for _ in range(amount+1)]
        dp[0] = 1
        for x in coins:
            for j in range(amount+1):
                if x <= j:
                    dp[j] += dp[j-x]
        return dp[amount]";"def cambio(monedas, cantidad):
    dp = [0] * (cantidad + 1)
    dp[0] = 1
    
    for moneda in monedas:
        for i in range(moneda, cantidad + 1):
            dp[i] += dp[i - moneda]
    
    return dp[cantidad]"
"class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:
        def get_coordinates(x1,x2,y1,y2):
            return {0:[x1,y1],1:[x2,y1],2:[x2,y2],3:[x1,y2]}
        
        first = get_coordinates(ax1,ax2,ay1,ay2)
        second = get_coordinates(bx1,bx2,by1,by2)
        
        def left_overlap(a,b):
            if b[0][0]>=a[0][0] and b[0][0]<a[1][0] and b[1][0]>=a[1][0]:
                return abs(b[0][0]-a[1][0])
            if a[0][0]>=b[0][0] and a[0][0]<b[1][0] and a[1][0]>=b[1][0]:
                return abs(a[0][0]-b[1][0])
            if b[0][0]>=a[0][0] and b[0][0]<a[1][0] and b[1][0]<a[1][0]:
                return abs(b[1][0]-b[0][0])
            if a[0][0]>=b[0][0] and a[0][0]<b[1][0] and a[1][0]<b[1][0]:
                return abs(a[1][0]-a[0][0])
        
        def top_overlap(a,b):
            if b[0][1]>=a[0][1] and b[0][1]<a[2][1] and b[2][1]>=a[2][1]:
                return abs(b[0][1]-a[2][1])
            if a[0][1]>=b[0][1] and a[0][1]<b[2][1] and a[2][1]>=b[2][1]:
                return abs(a[0][1]-b[2][1])
            if b[0][1]>=a[0][1] and b[0][1]<a[2][1] and b[2][1]<a[2][1]:
                return abs(b[2][1]-b[0][1])
            if a[0][1]>=b[0][1] and a[0][1]<b[2][1] and a[2][1]<b[2][1]:
                return abs(a[2][1]-a[0][1])
        
        l=left_overlap(first,second)
        t=top_overlap(first, second)
        
        total_area = (first[1][0]-first[0][0])*(first[2][1]-first[0][1])
        total_area+=(second[1][0]-second[0][0])*(second[2][1]-second[0][1])
        if l is not None and t is not None:
            total_area -=l*t
        return total_area";"ax1 = int(input(""Ingresa ax1: ""))
ay1 = int(input(""Ingresa ay1: ""))
ax2 = int(input(""Ingresa ax2: ""))
ay2 = int(input(""Ingresa ay2: ""))

bx1 = int(input(""Ingresa bx1: ""))
by1 = int(input(""Ingresa by1: ""))
bx2 = int(input(""Ingresa bx2: ""))
by2 = int(input(""Ingresa by2: ""))

area_rectangulo_a = (ax2 - ax1) * (ay2 - ay1)
area_rectangulo_b = (bx2 - bx1) * (by2 - by1)

interseccion_x1 = max(ax1, bx1)
interseccion_y1 = max(ay1, by1)
interseccion_x2 = min(ax2, bx2)
interseccion_y2 = min(ay2, by2)

ancho_interseccion = interseccion_x2 - interseccion_x1
alto_interseccion = interseccion_y2 - interseccion_y1

if ancho_interseccion > 0 and alto_interseccion > 0:
    area_interseccion = ancho_interseccion * alto_interseccion
else:
    area_interseccion = 0

area_total = area_rectangulo_a + area_rectangulo_b - area_interseccion

print(""El área total cubierta por los dos rectángulos es:"", area_total)"
