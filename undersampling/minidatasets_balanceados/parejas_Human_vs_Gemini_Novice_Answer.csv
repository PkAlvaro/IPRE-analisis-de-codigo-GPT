Human_Code;IA_Code
"class Solution:
    def findSecretWord(self, words: List[str], master: 'Master') -> None:        
        k = 1 # for tracing the number of loops
        matches = 0
        blacklists = [[] for i in range(6)]
        
        while matches != 6:
            n = len(words)
            r = random.randint(0, n - 1)
            matches = master.guess(words[r])
            key = words[r]
            # print(k, n, r, matches, key)
            
            words.pop(r)
            
            if matches == 0:
                for i in range(6):
                    blacklists[i].append(key[i])
                # print(blacklists)
            
            elif matches > 0 and matches < 6:
                candidates = []
                for i in range(n - 1):
                    count = 0
                    for j in range(6):
                        if words[i][j] not in blacklists[j] and words[i][j] == key[j]:
                            count += 1
                    if count >= matches:
                        candidates.append(words[i])
                            
                words = candidates.copy()
                # print(words)
            
            k += 1";"class Solution:
    def findSecretWord(self, words, master, allowedGuesses):
        candidate_words = words
        
        guess_iteration = 0
        while guess_iteration < allowedGuesses:
            
            min_max_group_size = 101 
            best_guess = """"
            
            for guess_candidate in candidate_words:
                
                groups = [0, 0, 0, 0, 0, 0, 0]
                
                for other_word in candidate_words:
                    match_count = 0
                    char_index = 0
                    while char_index < 6:
                        if guess_candidate[char_index] == other_word[char_index]:
                            match_count = match_count + 1
                        char_index = char_index + 1
                    
                    groups[match_count] = groups[match_count] + 1
                
                max_group_size = 0
                for size in groups:
                    if size > max_group_size:
                        max_group_size = size
                
                if max_group_size < min_max_group_size:
                    min_max_group_size = max_group_size
                    best_guess = guess_candidate

            if best_guess == """":
                best_guess = candidate_words[0]

            matches = master.guess(best_guess)
            
            if matches == 6:
                return
            
            new_candidate_words = []
            for word in candidate_words:
                match_count = 0
                char_index = 0
                while char_index < 6:
                    if best_guess[char_index] == word[char_index]:
                        match_count = match_count + 1
                    char_index = char_index + 1
                
                if match_count == matches:
                    new_candidate_words.append(word)
            
            candidate_words = new_candidate_words
            guess_iteration = guess_iteration + 1"
"class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        # Dealing special case: 1.
        if n == 1:
            return True
        # If n is an odd, it is not a number that is power of three.
        # Also, eliminating those number did not have any factor of 3.
        elif n % 2 == 0 or n % 3 != 0:
            return False
        else:
            return power_of_three(n)

def power_of_three(n):
    # Base Case
    if n == 3:
        return True
    # If n is not devided by 3, it's not a power of three number.
    elif n % 3:
        return False
    elif n < 3:
        return False
    # Recursive
    else:
        return power_of_three(n / 3)";"class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n <= 0:
            return False
        
        while n % 3 == 0:
            n = n / 3
            
        if n == 1:
            return True
        else:
            return False"
"class Solution:
    def pushDominoes(self, dominoes: str) -> str:
        condensed = []
        
        index = 0
        currDir = dominoes[0]
        
        while index < len(dominoes) and dominoes[index] == currDir:
            index += 1
        
        count = index
                
        if index == len(dominoes):
            return dominoes
        elif currDir == '.' and dominoes[index] == 'L':
            currDir = dominoes[index]
            
            while index < len(dominoes) and dominoes[index] == currDir:
                index += 1
        
        condensed.append(currDir * index)
        count = 1
        
        if index == len(dominoes):
            return ''.join(condensed)
        
        currDir = dominoes[index]
        index += 1
        
        while index < len(dominoes):
            if dominoes[index] == currDir:
                count += 1
            else:
                if currDir == '.':
                    condensed.append([currDir, count])
                elif type(condensed[-1]) is not list:
                    condensed.append(currDir * count)
                else:
                    dotCount = condensed.pop()[1]
                    prevDir = condensed[-1][0]

                    if prevDir == currDir:
                        condensed.append(condensed.pop() + currDir * (dotCount + count))
                    elif prevDir == 'L':
                        condensed.append('.' * dotCount)
                        condensed.append(currDir * count)
                    else:
                        halfCount = dotCount // 2
                        hasExtraDot = halfCount*2 != dotCount
                        condensed.append(prevDir * halfCount)
                        if hasExtraDot:
                            condensed.append('.')
                        condensed.append(currDir * (halfCount + count))
                        
                currDir = dominoes[index]
                count = 1
                
            index += 1
        
        if condensed:
            if currDir == '.':            
                dotCount = count
                prevDir = condensed[-1][0]

                if prevDir == 'L':
                    condensed.append(currDir * dotCount)
                else:                
                    condensed.append(prevDir * dotCount)
            elif type(condensed[-1]) is list:
                dotCount = condensed.pop()[1]            
                
                if not condensed:
                    if currDir == 'L':
                        condensed.append(currDir * (dotCount + count))
                    else:
                        condensed.append('.' * dotCount)
                        condensed.append(currDir * count)
                else:
                    prevDir = condensed[-1][0]
                    
                    if prevDir == currDir:
                        condensed.append(condensed.pop() + currDir * (dotCount + count))
                    elif prevDir == 'L':
                        condensed.append('.' * dotCount)
                        condensed.append(currDir * count)
                    else:
                        halfCount = dotCount // 2
                        hasExtraDot = halfCount*2 != dotCount
                        condensed.append(prevDir * halfCount)
                        if hasExtraDot:
                            condensed.append('.')
                        condensed.append(currDir * (halfCount + count))
            else:
                condensed.append(currDir * count)
        else:
            condensed.append(currDir * count)
        
        return ''.join(condensed)";"class Solution:
    def pushDominoes(self, dominoes: str) -> str:
        dom = 'L' + dominoes + 'R'
        res = []
        for char in dom:
            res.append(char)
        
        i = 0
        j = 1
        
        while j < len(res):
            while res[j] == '.':
                j = j + 1
            
            left_char = res[i]
            right_char = res[j]
            
            if left_char == 'L' and right_char == 'L':
                k = i + 1
                while k < j:
                    res[k] = 'L'
                    k = k + 1
            elif left_char == 'R' and right_char == 'R':
                k = i + 1
                while k < j:
                    res[k] = 'R'
                    k = k + 1
            elif left_char == 'R' and right_char == 'L':
                low = i + 1
                high = j - 1
                while low < high:
                    res[low] = 'R'
                    res[high] = 'L'
                    low = low + 1
                    high = high - 1
            
            i = j
            j = j + 1
            
        final_string = """"
        index = 1
        while index < len(res) - 1:
            final_string = final_string + res[index]
            index = index + 1
            
        return final_string"
"class Solution:
    #Time-Complexity: O(n^2)
    #Space-Complexity: O(n)
    def integerBreak(self, n: int) -> int:
        #we know we can reduce n as 
        # n
    #   /  \
    #  1   n-1
    #     /  \
    #    1   n-2
    #     ...
    
        #Basically, we can keep reducing n like this in this tree structure above!
        #This is the pattern I recognized! I recognized for given n, there are 
        #potential sums of (1, n-1), (2, n-2), (3, n-3), ..., (n//2, n//2)!
        #For each pair, I can compare the direct number with the max product decomposition
        #and take the max of two!
        
        
        #Reason for comparison: for each of the sum factor of given n, either leave it
        #undecomposed or decompose it into further sum factors if the product of sum
        #factors produce ultimately a number that exceeds the orignal sum factor! This way
        #I am maximing product contribution for each and every sum factor!
        
        #For example, for 5, we decompose it into 2 and 3, since 2*3 > 5, so it will
        #maximize our product further!
        
        #However, for 3, we don't decompose since we can maximally decompose to
        #1 and 2 but 1*2 < 3!
        
        #Do that for both numbers of each pair and take the product!
        #Whatever is largest across the pairs will be answer for given input n!
    
        dp = [-1] * (n+1)
        #add dp-base!
        dp[1] = 1
    
        #this problem has only one state parameter: the given number to start decomposing           #from!
        #iterate through each subproblem or state!
        #Bottom-Up
        for i in range(2, n+1, 1):
            upper_bound = (i // 2) + 1
            #iterate through all possible pairs!
            for j in range(1, upper_bound, 1):
                #current pair (j, i-j), which we probably already solved its subproblems!
                first = max(j, dp[j])
                second = max(i-j, dp[i-j])
                #get product for current pair!
                sub_ans = first * second
                #compare current pair's product against built up answer maximum!
                dp[i] = max(dp[i], sub_ans)
    
        #then, once we are done, we can return dp[n]!
        return dp[n]";"class Solution:
    def integerBreak(self, n: int) -> int:
        if n == 2:
            return 1
        
        if n == 3:
            return 2
        
        product = 1
        
        while n > 4:
            product = product * 3
            n = n - 3
            
        product = product * n
        
        return product"
"class Solution:
    def catMouseGame(self, graph: List[List[int]]) -> int:
        n = len(graph)
        
        @cache
        def fn(i, m, c): 
            """"""Return """"""
            if i == 2*n: return 0 # tie 
            if m == 0: return 1 # mouse wins
            if m == c: return 2 # cat wins 
            if i&amp,1: # cat's turn 
                tie = 0 
                for cc in graph[c]: 
                    if cc != 0: 
                        x = fn(i+1, m, cc)
                        if x == 2: return 2 
                        if x == 0: tie = 1
                if tie: return 0 
                return 1
            else: # mouse's turn 
                tie = 0 
                for mm in graph[m]: 
                    x = fn(i+1, mm, c)
                    if x == 1: return 1 
                    if x == 0: tie = 1
                if tie: return 0
                return 2 
        
        return fn(0, 1, 2)";"class Solution:
    def catMouseGame(self, graph):
        n = len(graph)
        
        MOUSE_TURN = 0
        CAT_TURN = 1
        
        DRAW = 0
        MOUSE_WIN = 1
        CAT_WIN = 2
        
        # states are (mouse_pos, cat_pos, turn)
        # color[m][c][t] stores the outcome of the game from that state
        color = []
        for i in range(n):
            mouse_row = []
            for j in range(n):
                turn_row = [DRAW, DRAW]
                mouse_row.append(turn_row)
            color.append(mouse_row)

        # degree[m][c][t] counts how many moves from state (m,c,t) lead to a DRAW
        degree = []
        for i in range(n):
            mouse_row = []
            for j in range(n):
                cat_moves = 0
                for neighbor in graph[j]:
                    if neighbor != 0:
                        cat_moves = cat_moves + 1
                degree_row = [len(graph[i]), cat_moves]
                mouse_row.append(degree_row)
            degree.append(mouse_row)

        q = []
        
        # Initialize terminal states
        for i in range(n):
            for t in range(2): # Both for mouse and cat's turn
                # Mouse reaches hole
                if i > 0:
                    color[0][i][t] = MOUSE_WIN
                    q.append((0, i, t))
                
                # Cat catches mouse
                if i > 0:
                    color[i][i][t] = CAT_WIN
                    q.append((i, i, t))

        # BFS starting from terminal states
        q_idx = 0
        while q_idx < len(q):
            mouse, cat, turn = q[q_idx]
            q_idx = q_idx + 1
            
            outcome = color[mouse][cat][turn]

            # Find parent states that lead to the current state
            if turn == MOUSE_TURN: # Mouse just moved, it was Cat's turn before
                prev_turn = CAT_TURN
                for prev_cat in graph[cat]:
                    if prev_cat == 0:
                        continue
                    
                    # Parent state is (mouse, prev_cat, prev_turn)
                    if color[mouse][prev_cat][prev_turn] == DRAW:
                        if outcome == CAT_WIN: # Cat found a winning move
                            color[mouse][prev_cat][prev_turn] = CAT_WIN
                            q.append((mouse, prev_cat, prev_turn))
                        else:
                            degree[mouse][prev_cat][prev_turn] = degree[mouse][prev_cat][prev_turn] - 1
                            if degree[mouse][prev_cat][prev_turn] == 0:
                                # All Cat's moves lead to Mouse winning
                                color[mouse][prev_cat][prev_turn] = MOUSE_WIN
                                q.append((mouse, prev_cat, prev_turn))
            
            else: # Cat just moved, it was Mouse's turn before
                prev_turn = MOUSE_TURN
                for prev_mouse in graph[mouse]:
                    
                    # Parent state is (prev_mouse, cat, prev_turn)
                    if color[prev_mouse][cat][prev_turn] == DRAW:
                        if outcome == MOUSE_WIN: # Mouse found a winning move
                            color[prev_mouse][cat][prev_turn] = MOUSE_WIN
                            q.append((prev_mouse, cat, prev_turn))
                        else:
                            degree[prev_mouse][cat][prev_turn] = degree[prev_mouse][cat][prev_turn] - 1
                            if degree[prev_mouse][cat][prev_turn] == 0:
                                # All Mouse's moves lead to Cat winning
                                color[prev_mouse][cat][prev_turn] = CAT_WIN
                                q.append((prev_mouse, cat, prev_turn))

        return color[1][2][MOUSE_TURN]"
"class Solution:
    def isPathCrossing(self, path: str) -> bool:
        #Store the directions(key) with their corresponding actions(values)
        directions = {'N': [0,1], 'E':[1,0], 'W':[-1,0], 'S':[0,-1]}
        
        #Keep the track of visited points
        visited = set()
        
        #Add the initial point from where you're starting
        visited.add((0,0))
        
        #Current trackers of x and y coordinates
        curr_x,curr_y = 0,0
        
        #Loop through all the path
        for i in path:
            curr_x += directions[i][0]
            curr_y += directions[i][1]
            
            #If visited for first time, add them to visited
            if (curr_x,curr_y) not in visited:
                visited.add((curr_x,curr_y))
            else:
                return True #Else return True
            
        return False #Return True if there is no re-visiting";"class Solution:
    def isPathCrossing(self, path: str) -> bool:
        x = 0
        y = 0
        
        visited_points = []
        visited_points.append((0, 0))
        
        for direction in path:
            if direction == 'N':
                y = y + 1
            elif direction == 'S':
                y = y - 1
            elif direction == 'E':
                x = x + 1
            elif direction == 'W':
                x = x - 1
            
            current_point = (x, y)
            
            is_visited = False
            for point in visited_points:
                if point == current_point:
                    is_visited = True
                    break
            
            if is_visited:
                return True
            else:
                visited_points.append(current_point)
                
        return False"
"class Solution:
    def winnerSquareGame(self, n: int) -> bool:
        @cache
        def doIWin(n, isAlice):
            if n == 0: return False # I lost, i cannot pick anything more :(
            sqr = 1
            while sqr*sqr <= n:
                if False == doIWin(n-sqr*sqr, 1 ^ isAlice):
                    # i forced my opponent to lose :)
                    return True
                
                sqr += 1
            
            
            # I did not find any way to make opponent lose..
            return False
        
        return doIWin(n, True)
        """"""
        No need of 'isAlice' :)
        Just makes the code cleaner?
        """"""

		@cache
        def doIWin(n):
            if n == 0: return False # I lost, i cannot pick anything more :(
            sqr = 1
            while sqr*sqr <= n:
                if False == doIWin(n-sqr*sqr):
                    # i forced my opponent to lose :)
                    return True
                
                sqr += 1
            
            
            # I did not find any way to make opponent lose..
            return False
        
        return doIWin(n)

		# final optimization.. travel backwards from sqrt to 1 :)
        @cache
        def doIWin(n):
            if n == 0: return False # I lost, i cannot pick anything more :(
            sqr = floor(sqrt(n))
            while sqr:
                if not doIWin(n-sqr*sqr):
                    # i forced my opponent to lose :)
                    return True
                
                sqr -= 1
            
            # I did not find any way to make opponent lose..
            return False
        
        return doIWin(n)";"class Solution:
    def winnerSquareGame(self, n: int) -> bool:
        dp = [False] * (n + 1)
        
        i = 1
        while i <= n:
            k = 1
            while True:
                square = k * k
                if square > i:
                    break
                
                if dp[i - square] == False:
                    dp[i] = True
                    break
                
                k = k + 1
            i = i + 1
            
        return dp[n]"
"class Solution:
    def knightDialer1(self, n: int) -> int:
        # observe pattern of knight moves and store in lookup table

        # 0 -> 4, 6
        # 1 -> 6, 8
        # 2 -> 7, 9
        # 3 -> 4, 8
        # 4 -> 3, 9, 0
        # 5 -> -
        # 6 -> 1, 7, 0
        # 7 -> 2, 6
        # 8 -> 1, 3
        # 9 -> 2, 4

        # approach #1: recursive with memo
        # helper function takes (curr, left),
        # returns number of possible moves based on (curr)ent value and moves (left)
        # if left is 1, return 1
        # otherwise, recursive call into next value based on lookup dict

        lut = { 0 : [4,6],
                1 : [6,8],
                2 : [7,9],
                3 : [4,8],
                4 : [0,3,9],
                5 : [],
                6 : [0,1,7],
                7 : [2,6],
                8 : [1,3],
                9 : [2,4] }

        def hlpr(curr: int, left: int) -> int:
            if left == 1: return 1
            if (curr, left) in memo: return memo[(curr, left)]

            res = 0
            for next in lut[curr]:
                res += hlpr(next, left-1)

            memo[(curr, left)] = res
            return res

        # setup and recursive call
        memo = {}
        res = 0
        for i in [0,1,2,3,4,5,6,7,8,9]:
            res += hlpr(i, n)
        return res % (10**9 + 7)

    def knightDialer2(self, n: int) -> int:
        # tabulate the solution above
        # two dimensional table
        # dp[i][j] is total moves starting from j, with i moves left
        # curr, which can be from 0-9 (cols)
        # left, which is strictly decreasing (rows)
        # O(N) time and space

        lut = { 0 : [4,6],
                1 : [6,8],
                2 : [7,9],
                3 : [4,8],
                4 : [0,3,9],
                5 : [],
                6 : [0,1,7],
                7 : [2,6],
                8 : [1,3],
                9 : [2,4] }

        dp = [[0 for _ in range(10)] for __ in range(n)]

        for i in range(10):
            dp[0][i] = 1

        for i in range(1,n):
            for j in range(10):
                tmp = 0
                for next in lut[j]:
                    tmp += dp[i-1][next]
                dp[i][j] += tmp

        return sum(dp[-1]) % (10**9 + 7)

    def knightDialer(self, n: int) -> int:
        # last trick, only need a single row of array rather than N rows
        # dp[i] represents total moves starting from i
        # make a copy of current dp row, and refer to that
        # using the actual dp row to store subproblem result
        # O(N) time, O(1) space

        lut = { 0 : [4,6],
                1 : [6,8],
                2 : [7,9],
                3 : [4,8],
                4 : [0,3,9],
                5 : [],
                6 : [0,1,7],
                7 : [2,6],
                8 : [1,3],
                9 : [2,4] }

        dp = [1 for _ in range(10)]

        for _ in range(1,n):
            last = dp[:]

            for j in range(10):
                tmp = 0
                for next in lut[j]:
                    tmp += last[next]
                dp[j] = tmp

        return sum(dp) % (10**9 + 7)";"def knightDialer(n):
    MOD = 10**9 + 7

    if n == 1:
        return 10

    jumps = [
        [4, 6],
        [6, 8],
        [7, 9],
        [4, 8],
        [0, 3, 9],
        [],
        [0, 1, 7],
        [2, 6],
        [1, 3],
        [2, 4]
    ]

    dp = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

    i = 1
    while i < n:
        new_dp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        
        start_digit = 0
        while start_digit < 10:
            for end_digit in jumps[start_digit]:
                new_dp[end_digit] = new_dp[end_digit] + dp[start_digit]
            start_digit = start_digit + 1
        
        j = 0
        while j < 10:
            dp[j] = new_dp[j] % MOD
            j = j + 1
        
        i = i + 1
        
    total_count = 0
    for count in dp:
        total_count = total_count + count

    return total_count % MOD"
"class Solution:
    def stoneGameII(self, piles: List[int]) -> int:
        n = len(piles)
        dp = {} 
        def recursion(index,M):
            # if we reached to the end we cannot score any value
            if index == n:
                return 0
            # we search if we have solved the same case earlier
            if (index,M) in dp:
                return dp[(index,M)] 
            # total remaining score is the sum of array from index to the end
            total = sum(piles[index:])           
            # if we can take the complete array it is the best choice
            if index + 2*M >= n :return total
            # my_score is the score we are getting as the player who is playing
            my_score = 0
            for x in range(index,index+2*M):
                # opponent score will be calculated by next recursion
                opponent_score = recursion(x+1,max(M,x-index+1))
                # my_score is the remaining value of total - opponent_score
                my_score = max(my_score,total - opponent_score)          
            # this is memoization part
            dp[(index,M)] = my_score
            # return the score
            return my_score
        
        return recursion(0,1)";"class Solution:
    def stoneGameII(self, piles: list[int]) -> int:
        n = len(piles)
        
        suffix_sum = [0] * (n + 1)
        i = n - 1
        while i >= 0:
            suffix_sum[i] = suffix_sum[i + 1] + piles[i]
            i = i - 1
            
        dp = []
        i = 0
        while i <= n:
            row = []
            j = 0
            while j <= n:
                row.append(0)
                j = j + 1
            dp.append(row)
            i = i + 1

        i = n - 1
        while i >= 0:
            m = 1
            while m <= n:
                best_score = 0
                x = 1
                while x <= 2 * m and i + x <= n:
                    opponent_start_index = i + x
                    
                    new_m = m
                    if x > m:
                        new_m = x
                    
                    opponent_score = dp[opponent_start_index][new_m]
                    
                    current_player_score = suffix_sum[i] - opponent_score
                    
                    if current_player_score > best_score:
                        best_score = current_player_score
                    
                    x = x + 1
                
                dp[i][m] = best_score
                m = m + 1
            i = i - 1
            
        return dp[0][1]"
"class Solution:
    def countBits(self, n: int) -> List[int]:
        #knowing the number of 1-bits in bin. rep of lower values of i than the current i
        #can have to solve current subproblem for i, since if i is odd,
        #number of 1 bits for i = number of 1 bits for previous number(even) + 1
        #number of 1 bits for i if it is even and power of 2 = 1
        #number of 1 bits for i if it not power of 2 but even = number of 
        #largest powers of 2 even numbers I can use to sum up to i!
        #Ex. 6 = 4 + 2 -> used 2 powers of 2 = need 2 1-bits in bin. rep of 6!
        #Ex. 7 = 6 + 1 -> 6 uses 2 1-bits so 7 requires 2+1 = 3 1-bits in its bin. rep!
        
        #I showed with above examples that this problem demonstrates optimal substructure
        #property! -> Might be useful in bottom-up solve for lower values of state
        #parameter i and work your way in inc. order -> State parameter i corresponds
        #to each and every index of ans array length n+1!
        
        #also, we may need to refer to same number multiple times while
        #building up our solution -> Overlapping subproblem property satisfied!
        
        
        #Let me first attempt recursive approach!
        #I know I will face TLE so let's add dp memo for memoization!
        dp = [-1] * (n+1)
        #base cases
        if(n == 0):
            return [0]
        if(n == 1):
            return [0, 1]
        
        #add a memo base case
        if(dp[n] != -1):
            return dp[n]
        
        #for n>1, array with at least 3 elements!
        
        #check if n is even and is power of 2!
        #if it is power of 2, taking bitwise and with itself and one less in value
        #bin. rep should produce all 0-bits1
        if(n % 2 == 0 and (n &amp, n-1) == 0):
            #answer will be array from recursive call on n-1 plus the 1 1-bit required
            #for base 2 power even numbered n!
            dp[n] = self.countBits(n-1) + [1]
            return  self.countBits(n-1) + [1]
        #last index n is odd case!
        if(n%2 != 0):
            recurse = self.countBits(n-1)
            num_bits_prev_num = recurse[-1]
            dp[n] = recurse + [num_bits_prev_num + 1]
            return recurse + [num_bits_prev_num + 1]
        
        #last case: even number n not power of 2!
        else:
            #as long as we didn't reduce n!
            i = 2
            ans = 0
            while n:
                if((n - i) &amp, (n-i-1) == 0):
                    n -= (n-i)
                    i = 2
                    continue
                else:
                    i += 2
            dp[n] = self.countBits(n-1) + [ans]
            return self.countBits(n-1) + [ans]";"class Solution:
    def countBits(self, n):
        ans = []
        
        for i in range(n + 1):
            count = 0
            num = i
            
            if num == 0:
                ans.append(0)
                continue
            
            while num > 0:
                if num % 2 == 1:
                    count = count + 1
                num = num // 2
            
            ans.append(count)
            
        return ans"
"class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        
        #Create a dictionary which will store the frequency of each of character 
        d={}  
        
        #iterate over all the characters in the string 's' 
        for element in s:
            if element in d:
                #increse the frequency count by 1 if it is already there in the dictionary 'd'
                d[element]+=1
            else:
                #initiate that element frequency by 1 in the 'd' if it is not there previously.
                d[element]=1
                
        #iterate over all the characters in the string 't'
        for element in t:
            if element in d:
        #decrease the frequency count by 1 so as to check the same frequency count of each character
                d[element]-=1
            else:
                #if the element is not there in the dictionary that means that particular element is not there in the string 's' which tends the result to False
                return False
        for key,value in d.items():
            if value!=0:
            #Return False if the any of element value is not 0 after cancelling their each occurence from both side 's' and 't'
                return False
        return True";"class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        s_letras = {}
        t_letras = {}

        for letra in s:
            if letra in s_letras:
                s_letras[letra] = s_letras[letra] + 1
            else:
                s_letras[letra] = 1

        for letra in t:
            if letra in t_letras:
                t_letras[letra] = t_letras[letra] + 1
            else:
                t_letras[letra] = 1
        
        if s_letras == t_letras:
            return True
        else:
            return False"
"class Solution:
    def decodeString(self, s: str) -> str:
        #base case: single character that's not a number!
        if(len(s) == 1 and s.isdigit() == False and s[0] != '[' and s[0] != ']'):
            return s
        
        #otherwise, we need to intialize the ans variable which we will return at the end!
        ans = """"
        i = 0
        
        current_num = """"
        #iterate through each and every char until it goes out of bounds!
        while i < len(s):
            cur = s[i]
            #append stand alone characters!
            if(cur.isdigit() == False and cur != '[' and cur != ']'):
                ans += cur
                i += 1
                continue
            #otherwise, the other case we have to take account is if
            #current character is number, in which we have to decode
            #in recursive manner!
            if(cur.isdigit()):
                current_num += cur
                i += 1
                continue
            if(cur == '['):
                num = int(current_num)
                #we have to find index positions of all characters
                #between open and closed brackets -> recurse over
                #those characters in substring -> append to ans
                #the result num times!
                
                #to know when we reached the appropriate closing char,
                #we can use a stack!
                
                #push initial opening char!
                stack = ['[']
                #since i assume input is valid, there gaurantees
                #corresponding closing char!
                #start index = i + 2 since i+1th index is bracket char!
                start = i+1
                while stack:
                    if(s[start] == '['):
                        stack.append('[')
                    if(s[start] == ']'):
                        stack.pop()
                    start += 1
                #once we exit, we know range of chars to recurse over!
                #it will go from index i +2 to index start - 2!
                recurse = self.decodeString(s[i+1:start - 1])
                #add to answer num times the rec. call!
                for i in range(num):
                    ans += recurse
                #update i to index start since start points to first char after the closing bracket of
                #current decoded string!
                i = start
                current_num = """"
                continue
                
        return ans";"class Solution:
    def decodeString(self, s: str) -> str:
        stack = []
        current_str = """"
        current_num = 0
        
        for char in s:
            if char.isdigit():
                current_num = current_num * 10 + int(char)
            elif char == '[':
                stack.append(current_str)
                stack.append(current_num)
                current_str = """"
                current_num = 0
            elif char == ']':
                num = stack.pop()
                prev_str = stack.pop()
                
                temp_str = """"
                i = 0
                while i < num:
                    temp_str = temp_str + current_str
                    i = i + 1
                
                current_str = prev_str + temp_str
            else:
                current_str = current_str + char
                
        return current_str"
"class Solution:
    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:
        capital_profit = defaultdict(list)
        for p, c in zip(profits, capital):
            insort_left(capital_profit[c], p)
        sorted_capital = sorted(capital_profit.keys())
        if sorted_capital[-1] <= w and k == len(profits):
            return w + sum(profits)
        for _ in range(k):
            max_key, max_profit = -inf, -inf
            for key in sorted_capital:
                if key <= w:
                    if capital_profit[key][-1] > max_profit:
                        max_key, max_profit = key, capital_profit[key][-1]
                else:
                    break
            if max_profit > -inf:
                w += max_profit
                capital_profit[max_key].pop()
                if not capital_profit[max_key]:
                    capital_profit.pop(max_key)
                    sorted_capital.remove(max_key)
            else:
                break
        return w";"class Solution:
    def findMaximizedCapital(self, k: int, w: int, profits: list[int], capital: list[int]) -> int:
        n = len(profits)
        projects_completed = []
        i = 0
        while i < n:
            projects_completed.append(False)
            i = i + 1

        projects_done_count = 0
        while projects_done_count < k:
            best_profit_for_this_round = -1
            best_project_index = -1
            
            j = 0
            while j < n:
                if not projects_completed[j]:
                    if w >= capital[j]:
                        if profits[j] > best_profit_for_this_round:
                            best_profit_for_this_round = profits[j]
                            best_project_index = j
                j = j + 1

            if best_project_index == -1:
                break
            
            w = w + profits[best_project_index]
            projects_completed[best_project_index] = True
            projects_done_count = projects_done_count + 1

        return w"
"class Solution:
    def candy(self, ratings: List[int]) -> int:
        # Analogy:
        # \   /    \
        #  \ / \  / \ /
        #   v   v    v  v
        #
        # Distribute candies such that it looks
        # like a bunch of troughs of varying heights aligned
        # side by side. Where the base of the troughs (v) are
        # the lowest rated children, and the heights of its
        # sides (\ or /) are the children with incrementally better
        # ratings
        
        # Problem is essentially looking for the next lowest ratings
        # and distributing candies in larger increments to the left
        # side and the right side IF their current rating is
        # greater than their previous rating
        
        # Use a priority queue to identify the lowest ratings
        heapq = [(ratings[i], i) for i in range(len(ratings))]
        heapify(heapq)
        
        # Array of candies parallel to the array of ratings of the child
        # where candies[i] represents the amount of candies the child at
        # ratings[i] will have
        candies = [1 for _ in range(len(ratings))]
        
        while(heapq):
            base = heappop(heapq) # Get next lowest rating
            
            # If the candy count has been modified, then it indicates
            # that this child isn't part of the lowest rating. We
            # only work with the lowest rating child (candy == 1), so skip
            if candies[base[1]] != 1:
                continue
            
            # Distribute candies to the left, when applicable
            curr = base[0]
            for i in range(base[1] - 1, -1, -1):
                # Give more candies when the current child has a greater
                # rating than the previous child AND when the current child
                # has fewer than or equal to the amount of candies than the
                # previous child
                #
                # The second condition is important since it will solve the
                # problem where the current child has already been
                # distributed candies, but may become overwritten in this new
                # distribution:
                # 
                # Distribute from lowest starting from left to right ========>
                # index:     0  1  2  3  4        0  1  2  3  4
                # ratings:  [1, 4, 3, 2, 1]  OR  [1, 2, 3, 4, 1]
                # candies:  [1, 2, 3, 2, 1]      [1, 2, 3, 4, 1]   
                #               ^                          ^
                # Solution: Let it overwrite WITH the larger amount of candies
                if ratings[i] > curr and candies[i] <= candies[i + 1]:
                    curr = ratings[i]
                    candies[i] = candies[i + 1] + 1
                else:
                    break
            
            # Distribute candies to the right, when applicable
            curr = base[0]
            for i in range(base[1] + 1, len(ratings)):
                # See line 41, same principle
                if ratings[i] > curr and candies[i] <= candies[i - 1]:
                    curr = ratings[i]
                    candies[i] = candies[i - 1] + 1
                else:
                    break
        
        return sum(candies)";"class Solution:
    def candy(self, ratings):
        n = len(ratings)
        
        candies = []
        i = 0
        while i < n:
            candies.append(1)
            i = i + 1
        
        i = 1
        while i < n:
            if ratings[i] > ratings[i-1]:
                candies[i] = candies[i-1] + 1
            i = i + 1
        
        i = n - 2
        while i >= 0:
            if ratings[i] > ratings[i+1]:
                if candies[i] <= candies[i+1]:
                    candies[i] = candies[i+1] + 1
            i = i - 1
            
        total_candies = 0
        for candy_count in candies:
            total_candies = total_candies + candy_count
            
        return total_candies"
"class Solution:
    def convertToBase7(self, num: int) -> str:
        abs_num = abs(num)
        val = ''
        ans = ''
        while abs_num >= 7:# we want to add up every remainder until the dividend(num) equals to 7 or less than 7.
            val += str(abs_num % 7)
            abs_num = abs_num // 7
        val += str(abs_num % 7) # we add up the remainder first, then the quotient.
        val = val[::-1] # Revise its order.
        if num < 0: 
            ans += '-'
        ans += val
        return ans";"class Solution:
    def convertToBase7(self, num: int) -> str:
        if num == 0:
            return ""0""

        is_negative = False
        if num < 0:
            is_negative = True
            num = -num

        result = """"
        temp_num = num

        while temp_num > 0:
            remainder = temp_num % 7
            result = str(remainder) + result
            temp_num = temp_num // 7

        if is_negative:
            return ""-"" + result
        else:
            return result"
"class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -> int:
        houses.sort()
        heaters.sort()
        total, size = len(houses), len(heaters)
		#dummy solution to check if heater with radius r, to cover all houses
        def valid_radius(r):
            house_offset = 0
            heater_offset = 0
            while house_offset < total:
                #case 1: current house is covered by current house, simply pass
                if abs(houses[house_offset] - heaters[heater_offset]) <= r:
                    house_offset += 1
                    continue
				#case 2 house cannot be covered, and locates on left side of heater, we can never find a heater to cover this house
                if houses[house_offset] < heaters[heater_offset]:
                    return False
                    break
				#case 3 go ahead to further heater, find the closest heater to cover the house or find no such heater valid
                while heater_offset < size and abs(houses[house_offset] - heaters[heater_offset]) > r:
                    heater_offset += 1
                if heater_offset >= size:return False
                if abs(houses[house_offset] - heaters[heater_offset]) <= r:
                    house_offset += 1
                    continue
                else:
                    return False
                    break
            return True
		#binary search to get radius
        low, high = 0, max(abs(heaters[0] - houses[0]), abs(heaters[0] - houses[-1]))
        mid = (low + high)//2
        while high - low > 1:
            if valid_radius(mid):
                high = mid
            else:low = mid
            mid = (low + high)//2

        return low if valid_radius(low) else high";"houses.sort()
heaters.sort()

max_radius = 0
heater_index = 0
number_of_heaters = len(heaters)

for house_position in houses:
    
    while heater_index + 1 < number_of_heaters and heaters[heater_index + 1] <= house_position:
        heater_index = heater_index + 1

    distance_to_left_heater = 1000000001
    if house_position >= heaters[heater_index]:
        distance_to_left_heater = house_position - heaters[heater_index]
    else:
        distance_to_left_heater = heaters[heater_index] - house_position

    distance_to_right_heater = 1000000001
    if heater_index + 1 < number_of_heaters:
        if house_position >= heaters[heater_index + 1]:
            distance_to_right_heater = house_position - heaters[heater_index + 1]
        else:
            distance_to_right_heater = heaters[heater_index + 1] - house_position
    
    min_dist_for_house = 0
    if distance_to_left_heater < distance_to_right_heater:
        min_dist_for_house = distance_to_left_heater
    else:
        min_dist_for_house = distance_to_right_heater
        
    if min_dist_for_house > max_radius:
        max_radius = min_dist_for_house

# The result is max_radius
# Example: print(max_radius)"
"class Solution:
    def hIndex(self, citations: List[int]) -> int:
        """"""
        citations = [3,0,6,1,5]
        
        n : length of citations
        
        H - index defination: A scientist has an index h if h of their n 
        papers have at least h citations each, and the other n ? h papers 
        have no more than h citations each.
        
        [0, 0, 0, 0, 0, 0] we define a list of size n + 1
         0  1  2  3  4  5
        
        The above list will be used as a bucket which will keep the count
        of papers with i(index in the list) citations.
        
        citations[0] = 3 
        [0, 0, 0, 1, 0, 0]
         0  1  2  3  4  5
         
         citations[1] = 0
        [1, 0, 0, 1, 0, 0]
         0  1  2  3  4  5
         
         citations[2] = 6
        [1, 0, 0, 1, 0, 1] when cits for a paper is > 5 then put the value in n lst index
         0  1  2  3  4  5
         
         citations[3] = 1
        [1, 1, 0, 1, 0, 1]
         0  1  2  3  4  5
         
         citations[4] = 5
        [1, 1, 0, 1, 0, 2]
         0  1  2  3  4  5
         
         
         Find suffix sum of above list:
         [5, 4, 3, 3, 2, 2]  Find the larget index where index value(i) <= A[i]
          0  1  2  3  4  5
          
          which is 3
          ans : 3
        """"""
        
        n = len(citations)
        b = [0] * (n + 1)
        for i in range(n):
            b[min(citations[i], n)] += 1
        for i in range(n, -1, -1):
            if b[i] >= i:
                return i
            b[i - 1] += b[i]
        return -1";"class Solution:
    def hIndex(self, citations: list[int]) -> int:
        citations.sort()
        n = len(citations)
        h = 0
        i = n - 1
        while i >= 0:
            if citations[i] >= h + 1:
                h = h + 1
            else:
                break
            i = i - 1
        return h"
"class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        
        #Brute Force way of thinking
        #Generate all subarrays and as soon as we find the condition getting fulfilled, append it to our answer
        #Note - as per question, only 1 valid answer exists, so repetition will not be an issue
        #If at all there was repetition, it can be avoided by traversing as below
        #O(N^2) Time -- Accepted Solution
        

        n = len(nums)
        answer = list()
        for i in range(n):
            for j in range(i+1,n):
                if (nums[i] + nums[j] == target):
                    answer.append(i)
                    answer.append(j)
        return answer        

        
        #Let us try to optimize 
        
        #NOTE - We CANNOT SORT THIS array as we have to retrieve the indices and sorting it 
        #would change the original indices at which elements are present
        #If the given array would have already been sorted, this would have worked completely fine
        
        #if we fix one of the numbers as arr[i], so other would be arr[j] = (target - arr[i]) 
        #now, we simply have to see if this arr[j] exists in the given array or not
        #O(N) Time --- Accepted Solution (TAKEN HELP FROM DISCUSSION SECTION)
        
        #NOTE - Looking up an element in a dictionary is O(1) and not O(N) 
        
        n = len(nums)
        seen = {} #empty dictionary

        for index, value in enumerate(nums): 
            
            remaining = target - value 
            #here, value is nums[i]
            #we are looking for this remaining, which is nums[j] 
            #we have to find if remaining or nums[j] is present in the given array or not
            #this equation comes from the fact that as per question : 
            #nums[i] + nums[j] = target 
           
            if remaining in seen: 
                
                #if nums[j] is present in dictionary
                #just return index of nums[i] and nums[j] 
                return [index, seen[remaining]] 
                #index represents index of nums[i] and seen[remaining] will
                #hold index of nums[j]
            
            else: 
            #otherwise, add the value corresponding to its index in the dictionary
            #so, if it searched again, we can directly retrieve its index
                seen[value] = index";"class Solution:
    def twoSum(self, nums, target):
        list_length = len(nums)
        for i in range(list_length):
            for j in range(list_length):
                if i == j:
                    continue
                
                sum_of_two = nums[i] + nums[j]
                
                if sum_of_two == target:
                    result = [i, j]
                    return result"
"class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        
        mp = {}
        count = 0
        
        # nested loop 1 
        for uno in nums1:
            for dos in nums2:
                # get = value for the key, value if you don't get it 
                # if uno+dos exists in hashmap, increment value 
                # else: increment with value 1 
                mp[uno + dos] = mp.get(uno + dos, 0) + 1
                
        # nested loop 2
        for tres in nums3:
            for quatro in nums4:
                # get(value for key, value if you don't get it)
                # getting hashmap value if the added number already exists in hashmap
                # if there is no complimentary value in the hashmap -> return 0 -> doesn't change count
                count += mp.get(-(tres + quatro), 0)
        # return mp
        return count";"class Solution:
    def fourSumCount(self, nums1: list[int], nums2: list[int], nums3: list[int], nums4: list[int]) -> int:
        sums_map = {}
        count = 0
        
        for num1 in nums1:
            for num2 in nums2:
                current_sum = num1 + num2
                if current_sum in sums_map:
                    sums_map[current_sum] = sums_map[current_sum] + 1
                else:
                    sums_map[current_sum] = 1
        
        for num3 in nums3:
            for num4 in nums4:
                target = 0 - (num3 + num4)
                if target in sums_map:
                    count = count + sums_map[target]
                    
        return count"
"class Solution:
    def canWinNim(self, n: int) -> bool:        
        if n <= 3:
            return True
        new_size = n + 1
        memo = [False] * (new_size)
        
        for i in range(4): 
            memo[i] = True
        
        for i in range(4,new_size):
            for j in range(1,4):
                if memo[i] == True:
                    break
                if memo[i-j] == True:
                    memo[i] = False
                else:
                    memo[i] = True
        
        return memo[n]";"class Solution:
    def canWinNim(self, n: int) -> bool:
        if n % 4 == 0:
            return False
        else:
            return True"
"class Solution:
    def sumGame(self, num: str) -> bool:
        n = len(num)
        q_cnt_1 = s1 = 0
        for i in range(n//2):    # get digit sum and question mark count for the first half of `num`
            if num[i] == '?':
                q_cnt_1 += 1
            else:    
                s1 += int(num[i])
        q_cnt_2 = s2 = 0				
        for i in range(n//2, n): # get digit sum and question mark count for the second half of `num`
            if num[i] == '?':
                q_cnt_2 += 1
            else:    
                s2 += int(num[i])
        s_diff = s1 - s2         # calculate sum difference and question mark difference
        q_diff = q_cnt_2 - q_cnt_1
        return not (q_diff % 2 == 0 and q_diff // 2 * 9 == s_diff) # When Bob can't win, Alice wins";"class Solution:
    def sumGame(self, num: str) -> bool:
        n = len(num)
        half_n = n // 2

        left_sum = 0
        left_q = 0
        i = 0
        while i < half_n:
            char = num[i]
            if char == '?':
                left_q = left_q + 1
            else:
                left_sum = left_sum + int(char)
            i = i + 1

        right_sum = 0
        right_q = 0
        i = half_n
        while i < n:
            char = num[i]
            if char == '?':
                right_q = right_q + 1
            else:
                right_sum = right_sum + int(char)
            i = i + 1

        sum_difference = left_sum - right_sum
        q_difference = left_q - right_q

        if (q_difference % 2) != 0:
            return True
        
        if sum_difference + q_difference // 2 * 9 == 0:
            return False
            
        return True"
"class Solution:
#     Follow-up Solution DP Iterative, Time = O(N), Space = O(1), In-Place Algorithm
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        for lvl in range(len(triangle) - 2, -1, -1):
            for idx in range(len(triangle[lvl])):
                triangle[lvl][idx] += min(triangle[lvl + 1][idx], triangle[lvl + 1][idx + 1])
        return triangle[0][0]

#     DP Iterative, Time = O(N), Space = O(triangle)
#     def minimumTotal(self, triangle: List[List[int]]) -> int:
#         sum_cp = triangle
#         for lvl in range(len(triangle) - 2, -1, -1):
#             for idx in range(len(triangle[lvl])):
#                 sum_cp[lvl][idx] += min(sum_cp[lvl + 1][idx], sum_cp[lvl + 1][idx + 1])
#         return sum_cp[0][0]
        
#     DP Recursion, Time = O(N), Space = O(triangle)
#     def minimumTotal(self, triangle: List[List[int]]) -> int:
#         sum_dp = [[[False, 0] for j in range(len(triangle[i]))] for i in range(len(triangle))]
#         self.rec(triangle, sum_dp, 0, 0, len(triangle) - 1)
#         return sum_dp[0][0][1]
#     
#     def rec(self, triangle, sum_dp, lvl, idx, hgt):
#         if sum_dp[lvl][idx][0] == True:
#             return sum_dp[lvl][idx][1]
#         elif lvl == hgt:
#             sum_dp[lvl][idx][0] = True
#             sum_dp[lvl][idx][1] = triangle[lvl][idx]
#         else:
#             sum_dp[lvl][idx][0] = True
#             sum_dp[lvl][idx][1] = min(self.rec(triangle, sum_dp, lvl + 1, idx, hgt), self.rec(triangle, sum_dp, lvl + 1, idx + 1, hgt)) + triangle[lvl][idx]
#         return sum_dp[lvl][idx][1]
        
#     Simple Recursion, Time = O(2^N), Space = O(2^N), TLE
#     def minimumTotal(self, triangle: List[List[int]]) -> int:
#         return self.rec(triangle, 0, 0, len(triangle) - 1)
#         
#     def rec(self, triangle, lvl, idx, hgt):
#         if lvl == hgt:
#             return triangle[lvl][idx]
#         return min(self.rec(triangle, lvl + 1, idx, hgt), self.rec(triangle, lvl + 1, idx + 1, hgt)) + triangle[lvl][idx]";"class Solution:
    def minimumTotal(self, triangle: list[list[int]]) -> int:
        numero_de_filas = len(triangle)

        if numero_de_filas == 0:
            return 0
        
        fila_actual = numero_de_filas - 2
        while fila_actual >= 0:
            
            columna_actual = 0
            while columna_actual < len(triangle[fila_actual]):
                
                valor_abajo_1 = triangle[fila_actual + 1][columna_actual]
                valor_abajo_2 = triangle[fila_actual + 1][columna_actual + 1]
                
                valor_minimo_abajo = 0
                if valor_abajo_1 < valor_abajo_2:
                    valor_minimo_abajo = valor_abajo_1
                else:
                    valor_minimo_abajo = valor_abajo_2
                
                triangle[fila_actual][columna_actual] = triangle[fila_actual][columna_actual] + valor_minimo_abajo
                
                columna_actual = columna_actual + 1
            
            fila_actual = fila_actual - 1
            
        return triangle[0][0]"
"class Solution:
    def racecar(self, target: int) -> int:
        q = [(0, 1)]
        steps = 0
        
        while q:
            num = len(q)
            for i in range(num):
                pos, speed = q.pop(0)
                if pos == target:
                    return steps
                q.append((pos+speed, speed*2))
                rev_speed = -1 if speed > 0 else 1
                if (pos+speed) < target and speed < 0 or (pos+speed) > target and speed > 0:
                    q.append((pos, rev_speed))
            steps += 1";"class Solution:
  def racecar(self, target: int) -> int:
    queue = []
    
    # State is (position, speed, length)
    queue.append((0, 1, 0))
    
    visited_states = set()
    visited_states.add((0, 1))
    
    while len(queue) > 0:
      current_position, current_speed, current_length = queue.pop(0)
      
      if current_position == target:
        return current_length
      
      # Option 1: Accelerate
      next_pos_A = current_position + current_speed
      next_speed_A = current_speed * 2
      
      if (next_pos_A, next_speed_A) not in visited_states:
        # A simple check to avoid exploring too far, which would be very slow.
        # This boundary is a guess but helps the program finish.
        if abs(next_pos_A - target) < target * 2:
            visited_states.add((next_pos_A, next_speed_A))
            queue.append((next_pos_A, next_speed_A, current_length + 1))
        
      # Option 2: Reverse
      next_speed_R = 0
      if current_speed > 0:
        next_speed_R = -1
      else:
        next_speed_R = 1
      
      # The position does not change with 'R'
      next_pos_R = current_position
      
      if (next_pos_R, next_speed_R) not in visited_states:
        visited_states.add((next_pos_R, next_speed_R))
        queue.append((next_pos_R, next_speed_R, current_length + 1))
        
    return -1"
"class Solution:
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
	
		# Recursive dfs. 
		# Accumulate the number as you traverse the tree and compare with targetSum
		# T: O(N)
		# S: O(N)
		
        return self.dfs(root, targetSum, 0)
        
    def dfs(self, root, targetSum, total):
        if not root:
            return False
        
        total += root.val
        #print(total)
        
        if not root.left and not root.right:
            return total == targetSum
        
        return self.dfs(root.left, targetSum, total) or self.dfs(root.right, targetSum, total) 
        
        
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        
        # Iterative DFS
		# Same logic
        # T: O(N)
        # S: O(N)
        
        if not root:
            return False
        
        stack = [root]
        total = root.val
        while stack:
            node = stack.pop()
            #print(node.val)
            if node.left:
                node.left.val += node.val
                stack.append(node.left)
                
            if node.right:
                node.right.val += node.val
                stack.append(node.right)
            
            if not node.right and not node.left:
                if node.val == targetSum:
                    return True
        return False
		
	def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        
        # Optimized recursive DFS
		# Instead of accumulation, we substract the value of node from the targetSum
        # T: O(N)
        # S: O(N)
        
        if not root:
            return False
        
        targetSum -= root.val
        if not root.left and not root.right:
            return targetSum == 0
        
        return self.hasPathSum(root.left, targetSum) or self.hasPathSum(root.right, targetSum)";"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def hasPathSum(self, root, targetSum):
        if root is None:
            return False

        is_leaf = root.left is None and root.right is None

        if is_leaf:
            if root.val == targetSum:
                return True
            else:
                return False

        new_target = targetSum - root.val

        has_path_in_left = False
        if root.left is not None:
            has_path_in_left = self.hasPathSum(root.left, new_target)

        if has_path_in_left:
            return True

        has_path_in_right = False
        if root.right is not None:
            has_path_in_right = self.hasPathSum(root.right, new_target)

        if has_path_in_right:
            return True

        return False"
"class Solution:
    
    def modpow(self, a: int, b: int, m: int) -> int:
        """""" Compute a^b mod m with fast exponentiation""""""
        if b == 0:
            return 1
        r = self.modpow(a, b//2, m)
        if b % 2 == 0:
            return (r * r) % m
        else:
            return (a * r * r) % m
    
    def superPow(self, a: int, b: List[int]) -> int:
        m = 1337
        r = 1  # this will contain the final result
        base = a  # this is the starting base
        for e in b[::-1]:  # note that I will traverse the list backward
            r = (r * self.modpow(base, e, m)) % m
            base = self.modpow(base, 10, m)  #  updating base
            if base == 1:  # this trick will save computation: if you find a base==1 no need to compute more
                return r
        return r";"class Solution:
    def superPow(self, a, b):
        MOD = 1337
        
        result = 1
        
        base = a % MOD
        
        for digit in b:
            # This is for result^10
            temp_result_pow_10 = 1
            i = 0
            while i < 10:
                temp_result_pow_10 = (temp_result_pow_10 * result) % MOD
                i = i + 1

            # This is for a^digit
            temp_a_pow_digit = 1
            j = 0
            while j < digit:
                temp_a_pow_digit = (temp_a_pow_digit * base) % MOD
                j = j + 1
            
            result = (temp_result_pow_10 * temp_a_pow_digit) % MOD
            
        return result"
"class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        # * merge sort constant space (bottom up)

        cnt = 0
        node = head
        while node is not None:
            node = node.next
            cnt += 1
        
        if cnt < 2:
            return head
        
        dummy = ListNode(-1)
        dummy.next = head

        merge_size = 1
        # merging all sublists with size <merge_size>
        # this loop will go on for log n times
        while merge_size < cnt:
            pre = dummy
            end = None
            i = 0
            # this loop takes O(n) time
            while cnt - i > merge_size:
                # find two sublists
                list0 = pre.next
                node = pre

                for _ in range(merge_size):
                    node = node.next
                
                i += merge_size
                
                # mark the break point
                mid = node
                
                for _ in range(min(merge_size, cnt - i)):
                    node = node.next

                i += min(merge_size, cnt - i)
                
                # break up the sublist from the nodes after it
                end = None
                if node is not None:
                    end = node.next
                    node.next = None
                
                # break the sublist into two parts
                list1 = mid.next
                mid.next = None

                # break the sublist from the nodes before it (optional)
                pre.next = None

                # merge the two sublists (and concatenate the new sublist to the nodes before)
                # the following steps take linear time because we are essentially concatenating nodes to ''pre''
                while list0 is not None and list1 is not None:
                    if list0.val < list1.val:
                        pre.next = list0
                        list0 = list0.next
                    else:
                        pre.next = list1
                        list1 = list1.next
                    
                    pre = pre.next
                
                pre.next = list0 if list0 is not None else list1
                while pre.next is not None:
                    pre = pre.next
                
                # concatenate these nodes to the rest
                pre.next = end

            merge_size <<= 1

        return dummy.next";"class Solution:
    def sortList(self, head):
        if not head or not head.next:
            return head

        was_swapped = True
        while was_swapped:
            was_swapped = False
            current_node = head
            while current_node.next:
                if current_node.val > current_node.next.val:
                    
                    temp_value = current_node.val
                    current_node.val = current_node.next.val
                    current_node.next.val = temp_value
                    
                    was_swapped = True
                
                current_node = current_node.next
        
        return head"
"class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:
        # Calculate the max time for a pig to test buckets...
        # Note that, max time will not be (minutesToTest / minutesToDie)...
        # Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...
        max_time = minutesToTest / minutesToDie + 1
        # Initialize the required minimum number of pigs...
        req_pigs = 0
        # To find the minimum number of pigs, find the minimum req_pigs such that Math.pow(max_time, req_pigs) >= buckets...
        while (max_time) ** req_pigs < buckets:
            # Increment until it will be greater or equals to bucket...
            req_pigs += 1
        # Return the required minimum number of pigs...
        return req_pigs";"class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:
        estados_posibles = (minutesToTest // minutesToDie) + 1
        
        cerdos = 0
        cubetas_verificables = 1
        
        while cubetas_verificables < buckets:
            cubetas_verificables = cubetas_verificables * estados_posibles
            cerdos = cerdos + 1
            
        return cerdos"
"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        lis=[]
        #First way to solve this question
        
        for val in range(1,n+1):
            #print(val%3, val%5)
            if (val%3==0 and val%5==0):
                lis.append(""FizzBuzz"")
            elif val%3==0:
                lis.append(""Fizz"")
            elif val%5==0:
                lis.append(""Buzz"")
            else:
                lis.append(str(val))
		return lis
        #Runtime: 88 ms, faster than 42.22% of Python3 online submissions for Fizz Buzz.
        #Memory Usage: 14.9 MB, less than 85.86% of Python3 online submissions for Fizz Buzz
        
        #Second way to solve this question
         
        for val in range(1,n+1):
            lis.append(""FizzBuzz"") if (val%3==0 and val%5==0) else (lis.append(""Fizz"") if val%3==0 else (lis.append(""Buzz"") if val%5==0 else lis.append(str(val)) ) )
        return lis,
         
        #Runtime: 87 ms, faster than 44.84% of Python3 online submissions for Fizz Buzz.
        #Memory Usage: 15.1 MB, less than 43.11% of Python3 online submissions for Fizz Buzz.
        
        #Third way to solve this solution
        
        # Learned this way to solve the question from https://leetcode.com/problems/fizz-buzz/discuss/2704645/Python-One-liner
        
        #Runtime: 96 ms, faster than 22.65% of Python3 online submissions for Fizz Buzz.
        #Memory Usage: 15.2 MB, less than 17.01% of Python3 online submissions for Fizz Buzz.
        return [ ""Fizz""*(val%3==0)+""Buzz""*(val%5==0) or f""{val}"" for val in range(1,n+1)]";"class Solution:
    def fizzBuzz(self, n: int):
        answer = []
        for i in range(1, n + 1):
            if i % 3 == 0 and i % 5 == 0:
                answer.append(""FizzBuzz"")
            elif i % 3 == 0:
                answer.append(""Fizz"")
            elif i % 5 == 0:
                answer.append(""Buzz"")
            else:
                answer.append(str(i))
        return answer"
"class Solution:
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        """"""
        sort the start position.
        the car behind can only catch up no exceed.
        so if the car start late and speed is faster, it will catch up the car ahead of itself and they become a fleet.
        there is a target(or desitination),so use arrive time to measure. 
        
        start late but arrive ealier means the car is behind and will catch up before arriving the destination.
        
        position  10  8  5  3  0
        distance  2   4  7  9  12
        speed.    2   4  1  3  1
        time.     1   1  7  3  12
                      ^     ^
                      |     |
                     catch  catch up the previous car before target, join the fleet
		stack = [1] , [1],[1,7],[1,7][1,7,12] 			 
                                
        """"""
        stack = []
        for pos, v in sorted(zip(position, speed),reverse = True):

            dist = target - pos
            time = dist / v 
            
            if not stack:
                stack.append(time)
            elif time > stack[-1]:
                stack.append(time)

        return len(stack)";"class Solution:
    def carFleet(self, target: int, position: list[int], speed: list[int]) -> int:
        n = len(position)
        if n == 0:
            return 0

        cars = []
        for i in range(n):
            cars.append((position[i], speed[i]))

        cars.sort()

        arrival_times = []
        for i in range(n):
            pos = cars[i][0]
            spd = cars[i][1]
            time = (target - pos) / spd
            arrival_times.append(time)

        fleets = 0
        max_time = 0.0

        i = n - 1
        while i >= 0:
            current_time = arrival_times[i]
            if current_time > max_time:
                fleets = fleets + 1
                max_time = current_time
            i = i - 1
            
        return fleets"
"class MinStack:

    def __init__(self):
                
        self.Stack = []
        self.minVal = None
        

    def push(self, val: int) -> None:
        
        if not self.Stack or self.minVal == None:
            self.minVal = val
        
        
        if not self.Stack: 
            self.Stack.append(val)
        elif val < self.minVal: 
            self.Stack.append(2*val - self.minVal)
            self.minVal = val
        else: 
            self.Stack.append(val)
        

    def pop(self) -> None:
        
        if not self.Stack: 
            return
        elif self.Stack[-1] < self.minVal: 
            self.minVal = 2*self.minVal - self.Stack[-1]
            self.Stack.pop()
        else: 
            self.Stack.pop()
        

    def top(self) -> int:
        
        if self.Stack[-1] > self.minVal : 
            return self.Stack[-1]
        else: 
            return self.minVal
        

    def getMin(self) -> int:
        
        return self.minVal
        
        


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()";"class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val):
        self.stack.append(val)
        if not self.min_stack:
            self.min_stack.append(val)
        else:
            if val <= self.min_stack[-1]:
                self.min_stack.append(val)

    def pop(self):
        if self.stack:
            popped_element = self.stack.pop()
            if popped_element == self.min_stack[-1]:
                self.min_stack.pop()

    def top(self):
        if self.stack:
            return self.stack[-1]
        return None

    def getMin(self):
        if self.min_stack:
            return self.min_stack[-1]
        return None"
"class Node:
    def __init__(self, key, val):
        self.val = val
        self.key = key
        self.prev = None
        self.nxt_ = None

# use a DL
class DLinked:
    def __init__(self):
        self.head = None
        self.tail = None
    
    def remove(self, node):
        """""" return the deleted node key
        """"""
        # 3 basic postion cases
        prev = node.prev
        nxt_  = node.nxt_
        
        # if the removing node is the single node in the list
        if prev is None and nxt_ is None:
            # eariler termination
            self.head = None
            self.tail = None
            return node.key
        
        # head node and not single, happy 2.14's day !
        if prev is None:
            self.head = nxt_
            nxt_.prev  = None
        
        # tail node not single
        elif nxt_ is None:
            self.tail = prev
            prev.nxt_ = None
            
        else:
            # mid node
            prev.nxt_ = nxt_
            nxt_.prev = prev
        
        # either way you should return the old key        
        return node.key
    
    def add(self, node):
        """""" return the node ref if added
        """"""
        # when head is None
        if self.head is None:
            self.head = node
        
            if self.tail is None:
                self.tail = node
        else:
            node.nxt_ = self.head
            node.prev = None
            self.head.prev = node
            self.head = node
        
        return self.head
    
    
class LRUCache:
    def __init__(self, capacity):
        self.cap = capacity
        self.table = {}
        self.dlinked = DLinked()
    
    def get(self, key):
        # also check key first
        node = self.table.get(key, None)
        if node is not None:
            # update hit
            self.dlinked.remove(node)
            self.dlinked.add(node)
            return node.val
        else:
            return -1
    
    def put(self, key, val):
        # let Dlinked class to handle add / remove
        # let cache class to handle capacity cases
        # use forward logic to make thing clear
        
        # no need to check cap first, instead, we need to check key in table or not.
		# becase if key exist, there is nothing to deal with the capacity
        node = self.table.get(key, None)
        if node is not None:
            # update key hit
            self.dlinked.remove(node)
            node.val = val  # same key overwrite
            self.dlinked.add(node)
			# return as soon as possible to prevent logic twists
            return
        
        # if key not in table, then we need to add key, hence we need to check capacity
        
        if len(self.table) == self.cap:
            # cache full, kill the tail and add to head
			# seperating the operations by returning the old key
            old_key = self.dlinked.remove(self.dlinked.tail)
            del self.table[old_key]
            node = self.dlinked.add(Node(key, val)) 
            self.table[key] = node
        else:    
            # cache not full, add directly
            node = self.dlinked.add(Node(key, val))
            self.table[key] = node

        return";"class Node:
    def __init__(self, key, val):
        self.key = key
        self.val = val
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}
        self.head = Node(0, 0)
        self.tail = Node(0, 0)
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key):
        if key in self.cache:
            node = self.cache[key]
            
            # Remove node from its current position
            prev_node = node.prev
            next_node = node.next
            prev_node.next = next_node
            next_node.prev = prev_node
            
            # Add node to the front (right after head)
            first_node = self.head.next
            self.head.next = node
            node.prev = self.head
            node.next = first_node
            first_node.prev = node
            
            return node.val
        return -1

    def put(self, key, value):
        if key in self.cache:
            node = self.cache[key]
            node.val = value
            
            # Remove node from its current position
            prev_node = node.prev
            next_node = node.next
            prev_node.next = next_node
            next_node.prev = prev_node
            
            # Add node to the front (right after head)
            first_node = self.head.next
            self.head.next = node
            node.prev = self.head
            node.next = first_node
            first_node.prev = node
        else:
            if len(self.cache) == self.capacity:
                lru_node = self.tail.prev
                
                # Remove lru_node from list
                prev_node = lru_node.prev
                prev_node.next = self.tail
                self.tail.prev = prev_node
                
                # Remove from cache
                del self.cache[lru_node.key]
            
            new_node = Node(key, value)
            self.cache[key] = new_node
            
            # Add new_node to the front (right after head)
            first_node = self.head.next
            self.head.next = new_node
            new_node.prev = self.head
            new_node.next = first_node
            first_node.prev = new_node"
"class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:
        # 1,2,3,4,5 -> player 1
        # 2,3,4,5 -> player 2, choose any of them, cannot win
        # Then 1 win
        candidate = [i for i in range(1, maxChoosableInteger + 1)]

        if sum(candidate) < desiredTotal:
            return False
        
        memo = dict()
        def dfs(candidate, remain):
            if candidate[-1] >= remain:
                return True
            
            if tuple(candidate) in memo:
                return memo[tuple(candidate)]
            
            for i in range(len(candidate)):
                if not dfs(candidate[:i] + candidate[i + 1:], remain - candidate[i]):
                    memo[tuple(candidate)] = True
                    return True
            
            memo[tuple(candidate)] = False
            return False
                
        return dfs(candidate, desiredTotal)";"class Solution:
    def canIWin(self, maxChoosableInteger, desiredTotal):
        
        total_sum = 0
        i = 1
        while i <= maxChoosableInteger:
            total_sum = total_sum + i
            i = i + 1

        if total_sum < desiredTotal:
            return False

        if desiredTotal <= 0:
            return True

        memo = {}
        
        used_numbers = []
        i = 0
        while i < maxChoosableInteger:
            used_numbers.append(False)
            i = i + 1
        
        used_numbers_tuple = tuple(used_numbers)

        def solve(current_used_tuple, remaining_total):
            if current_used_tuple in memo:
                return memo[current_used_tuple]

            i = 1
            while i <= maxChoosableInteger:
                is_used = current_used_tuple[i - 1]
                if not is_used:
                    if i >= remaining_total:
                        memo[current_used_tuple] = True
                        return True
                    
                    next_used_list = list(current_used_tuple)
                    next_used_list[i-1] = True
                    next_used_tuple = tuple(next_used_list)
                    
                    opponent_can_win = solve(next_used_tuple, remaining_total - i)
                    
                    if not opponent_can_win:
                        memo[current_used_tuple] = True
                        return True
                i = i + 1
            
            memo[current_used_tuple] = False
            return False

        return solve(used_numbers_tuple, desiredTotal)"
"class Solution:
    # optimized prefix sum
    def gridGame(self, grid: List[List[int]]) -> int:
        n = len(grid[0])
        ans = math.inf
        topSum = sum(grid[0])
        bottomSum = 0

        for i in range(n):
            topSum -= grid[0][i]
            ans = min(ans, max(topSum, bottomSum))
            bottomSum += grid[1][i]

        return ans

    # neetcode's prefix sum method
    def gridGame(self, grid: List[List[int]]) -> int:
        res = float('inf') # max value
        prefixSum1 = [grid[0][0]]
        prefixSum2 = [grid[1][0]] # has the first value done so that we can iterate more smoothly
        length = len(grid[0])

        for i in range(1, length): # from 1 to end because we don't want to deal with an out of bounds error
            prefixSum1.append(grid[0][i] + prefixSum1[i-1]) # doing it this way bc it seems faster but you really just want to calculate the prefix sums of each row and save it to the index
            prefixSum2.append(grid[1][i] + prefixSum2[i-1])
        for i in range(length): # so here we want to calculate the turning point of the first robot
            # calculate the values excluding the current index
            top_row = prefixSum1[-1] - prefixSum1[i] # so total - the current index (which is the accumulated value of the left side, index inclusive)
            bottom_row = prefixSum2[i-1] if i > 0 else 0 # bounds checking here bc 0-1 is -1 and that is not the right place to be.
            current = max(top_row, bottom_row) # take the max values of this index that the second robot can grab
            res = min(res, current) # the first robot is a bad robot so we want to take the minimum values of all the maxes that we calculate and this here is O(1) space complexity instead of saving it all to an array. In taking the minimum, we take thus maximize robot 1's take and robot 2's take per the properties.
        return res



    # simple solution (runs out of time due to not storing the calculations)
    def gridGame(self, grid: List[List[int]]) -> int:

        # this is the simpler code but it doesn't work because of a time limit problem. simply having the prefix sum's already calculated makes this problem ultra efficient
        res = float('inf') # max
        length = len(grid[0])
        for i in range(length): # check each index of the array
            # take the sum of everything after the index on the top row and before the index on the bottom row
            top = sum(grid[0][i+1:])
            bot = sum(grid[1][:i])
            current = max(top, bot) # max of robot 2's take if robot 1 were to turn at this specific index
            res = min(res, current) # determines robot 2's real take that would maximize robot 1's take
        return res";"class Solution:
    def gridGame(self, grid: list[list[int]]) -> int:
        n = len(grid[0])
        
        top_sum = 0
        for i in range(n):
            top_sum = top_sum + grid[0][i]
            
        bottom_sum = 0
        
        ans = -1

        for i in range(n):
            top_sum = top_sum - grid[0][i]
            
            second_robot_score = 0
            if top_sum > bottom_sum:
                second_robot_score = top_sum
            else:
                second_robot_score = bottom_sum
            
            if ans == -1:
                ans = second_robot_score
            else:
                if second_robot_score < ans:
                    ans = second_robot_score
            
            bottom_sum = bottom_sum + grid[1][i]
            
        return ans"
"class Solution:
    def canCross(self, stones: List[int]) -> bool:
        jump_mods = [-1,0,1]
        stone_ref = {}
        prev = 0
        
        # Make dictionary of the indexes of each stone
        for i,stone in enumerate(stones):
            stone_ref[stone] = i
            
            # if any stone is further away from the previous one than its index,
            # it is unreachable in all scenarios and we can return False early
            if stone-prev > i:
                return False
            
            prev = stone
        
        stack = [(0,0)]
        seen = set()    
        
        # DFS
        while stack:
            jump,stone = stack.pop()
            
            seen.add((jump,stone))
            
            # Return true if we reached our goal
            if stone == stones[-1]:
                return True
            
            # Go through each of the jump modifiers to see if any of them result in the following conditions:
            # 1) There is a stone that matches the current stone's value plus that modified jump value
            # 2) The index of that matching stone is greater than the index that the frog is currently on
            # 3) We have not visited that stone with the same jump value in the past
            for mod in jump_mods:
                if stone+jump+mod in stone_ref and stone_ref[stone+jump+mod] > stone_ref[stone]:
                    if (jump+mod,stone+jump+mod) not in seen:
                        stack.append((jump+mod,stone+jump+mod))
        return False";"class Solution:
    def canCross(self, stones: list[int]) -> bool:
        if len(stones) == 0:
            return True

        if stones[0] != 0:
            return False

        if len(stones) > 1 and stones[1] != 1:
            return False

        last_stone = stones[len(stones) - 1]

        jumps_map = {}
        for stone in stones:
            jumps_map[stone] = set()

        if len(stones) > 1:
            jumps_map[stones[1]].add(1)

        for i in range(1, len(stones)):
            current_stone = stones[i]
            possible_jumps = jumps_map[current_stone]

            for k in possible_jumps:
                
                # Next jump can be k - 1
                next_jump = k - 1
                if next_jump > 0:
                    next_stone_position = current_stone + next_jump
                    if next_stone_position == last_stone:
                        return True
                    if next_stone_position in jumps_map:
                        jumps_map[next_stone_position].add(next_jump)

                # Next jump can be k
                next_jump = k
                if next_jump > 0:
                    next_stone_position = current_stone + next_jump
                    if next_stone_position == last_stone:
                        return True
                    if next_stone_position in jumps_map:
                        jumps_map[next_stone_position].add(next_jump)
                
                # Next jump can be k + 1
                next_jump = k + 1
                if next_jump > 0:
                    next_stone_position = current_stone + next_jump
                    if next_stone_position == last_stone:
                        return True
                    if next_stone_position in jumps_map:
                        jumps_map[next_stone_position].add(next_jump)
        
        if len(jumps_map[last_stone]) > 0:
            return True
        else:
            return False"
"class Solution:
    def findNthDigit(self, n: int) -> int:
        """"""
        imagine the number you need to find have 4 digit
        so you need to go throught all num have 1 digit, 2 digit, 3 digit
        number have 1 digit:  10 ** 1 - 1 = 9 => 9 * 1 = 9 digit
        number have 2 digit:  10 ** 2 - 1 = 90 => 90 * 2 = 180 digit
        number have 3 digit:  10 ** 3 - 1 = 900 => 900 * 3 = 2700 digit
        ...
        just subtract until you find how many digit of the number you need to find
        when you got the number of digit 
        """"""
        if n < 10:
            return n
        
        number_of_digit = 0 # check how many digit of the number you need to find
        while n > 0:
            number_of_digit += 1
            n -= 9 * 10 ** ((number_of_digit - 1)) * number_of_digit
        n += 9 * 10 ** ((number_of_digit - 1)) * number_of_digit
        
        """""" 
        print(n , number_of_digit) if you dont understand 
        after subtract you will find number of digit
        all you need to do now is find exactly number by just a little bit of math
        """""" 
        tmp_num = 0
        
        if n % number_of_digit == 0:
            n //= number_of_digit 
            tmp_num += 10 ** ((number_of_digit - 1)) - 1
            return int(str(tmp_num + n)[-1])
        else:
            n /= number_of_digit
            digit = int((n * number_of_digit) % number_of_digit)
            tmp_num += 10 ** ((number_of_digit - 1)) - 1
            return int(str(int(tmp_num + n) + 1)[digit - 1])";"class Solution:
    def findNthDigit(self, n: int) -> int:
        length = 1
        count = 9
        start = 1

        while n > length * count:
            n = n - (length * count)
            length = length + 1
            count = count * 10
            start = start * 10

        n = n - 1

        number = start + (n // length)
        digit_index = n % length

        s_number = str(number)
        digit_char = s_number[digit_index]
        result = int(digit_char)

        return result"
"class Solution:
    def findMinStep(self, board: str, hand: str) -> int:
        
        # start from i and remove continues ball
        def remove_same(s, i):
            if i < 0:
                return s
            
            left = right = i
            while left > 0 and s[left-1] == s[i]:
                left -= 1
            while right+1 < len(s) and s[right+1] == s[i]:
                right += 1
            
            length = right - left + 1
            if length >= 3:
                new_s = s[:left] + s[right+1:]
                return remove_same(new_s, left-1)
            else:
                return s



        hand = """".join(sorted(hand))

        # board, hand and step
        q = collections.deque([(board, hand, 0)])
        visited = set([(board, hand)])

        while q:
            curr_board, curr_hand, step = q.popleft()
            for i in range(len(curr_board)+1):
                for j in range(len(curr_hand)):
                    # skip the continue balls in hand
                    if j > 0 and curr_hand[j] == curr_hand[j-1]:
                        continue
                    
                    # only insert at the begin of continue balls in board
                    if i > 0 and curr_board[i-1] == curr_hand[j]: # left side same color
                        continue
                    
                    pick = False
                    # 1. same color with right
                    # 2. left and right are same but pick is different
                    if i < len(curr_board) and curr_board[i] == curr_hand[j]:
                        pick = True
                    if 0<i<len(curr_board) and curr_board[i-1] == curr_board[i] and curr_board[i] != curr_hand[j]:
                        pick = True
                    
                    if pick:
                        new_board = remove_same(curr_board[:i] + curr_hand[j] + curr_board[i:], i)
                        new_hand = curr_hand[:j] + curr_hand[j+1:]
                        if not new_board:
                            return step + 1
                        if (new_board, new_hand) not in visited:
                            q.append((new_board, new_hand, step+1))
                            visited.add((new_board, new_hand))

        return -1";"def findMinStep(board, hand):
    hand_list = []
    c = 0
    while c < len(hand):
        hand_list.append(hand[c])
        c = c + 1
    
    n = len(hand_list)
    i = 0
    while i < n:
        j = 0
        while j < n - i - 1:
            if hand_list[j] > hand_list[j+1]:
                temp = hand_list[j]
                hand_list[j] = hand_list[j+1]
                hand_list[j+1] = temp
            j = j + 1
        i = i + 1

    sorted_hand = """"
    c = 0
    while c < len(hand_list):
        sorted_hand = sorted_hand + hand_list[c]
        c = c + 1

    queue = []
    queue.append((board, sorted_hand, 0))

    visited = set()
    visited.add((board, sorted_hand))

    while len(queue) > 0:
        current_board, current_hand, steps = queue.pop(0)

        if not current_board:
            return steps

        hand_idx = 0
        while hand_idx < len(current_hand):
            if hand_idx > 0 and current_hand[hand_idx] == current_hand[hand_idx - 1]:
                hand_idx = hand_idx + 1
                continue

            ball_to_use = current_hand[hand_idx]
            remaining_hand = current_hand[0:hand_idx] + current_hand[hand_idx+1:]
            
            board_idx = 0
            while board_idx < len(current_board) + 1:
                if board_idx > 0 and current_board[board_idx - 1] == ball_to_use:
                    board_idx = board_idx + 1
                    continue
                
                next_board = current_board[0:board_idx] + ball_to_use + current_board[board_idx:]
                
                while True:
                    has_changed = False
                    start = 0
                    while start < len(next_board):
                        color = next_board[start]
                        end = start
                        while end < len(next_board) and next_board[end] == color:
                            end = end + 1
                        
                        if end - start >= 3:
                            next_board = next_board[0:start] + next_board[end:]
                            has_changed = True
                            break
                        else:
                            start = end
                    
                    if not has_changed:
                        break

                new_state = (next_board, remaining_hand)
                if new_state not in visited:
                    visited.add(new_state)
                    queue.append((next_board, remaining_hand, steps + 1))
                
                board_idx = board_idx + 1
            hand_idx = hand_idx + 1

    return -1"
"class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        '''
        The idea is similar to Unique Paths, https://leetcode.com/problems/unique-paths/
        in that, we get the minimum of the accumulated path totals from TOP + LEFT
		but here, we also then compare against accumulated path costs from BOTTOM + RIGHT
            
        Specifics of why 2 at a time and not all 4 is not fully clear but when done with 4
            runs infinitely / maxes out / keeps looping
        '''
        R, C = len(mat), len(mat[0])
        
        # Get the min of accumulated totals for NON-0's from TOP and LEFT
        # Out of bounds are rendered irrelevant by assigning infinity
        for r in range(R):
            for c in range(C):
                if mat[r][c] != 0:
                    top = float('inf') if r == 0 else mat[r - 1][c]
                    left = float('inf') if c == 0 else mat[r][c - 1]
                    mat[r][c] = 1 + min(top, left) # Note the +1 to account for the path-move
        
        # Do the same, but with BOTTOM and RIGHT and this time also compare against current value
        # Likewise, igore out of bounds by setting them as infinity
        for r in range(R-1, -1, -1):
            for c in range(C-1, -1, -1):
                if mat[r][c] != 0:
                    bottom = float('inf') if (r + 1) == R else mat[r + 1][c]
                    right = float('inf') if (c + 1) == C else mat[r][c + 1]
                    mat[r][c] = min(mat[r][c], 1 + bottom, 1 + right) # Note the pre-calculated one from last loop is fine but the others need +1 to pay for path move
                    
        # We got our minimums, let's return
        return mat";"class Solution:
    def updateMatrix(self, mat):
        rows = len(mat)
        cols = len(mat[0])
        
        distances = []
        for r in range(rows):
            new_row = []
            for c in range(cols):
                new_row.append(-1)
            distances.append(new_row)
            
        queue = []
        
        for r in range(rows):
            for c in range(cols):
                if mat[r][c] == 0:
                    distances[r][c] = 0
                    queue.append((r, c))

        head = 0
        while head < len(queue):
            row, col = queue[head]
            head = head + 1
            
            # Neighbor below
            next_row = row + 1
            next_col = col
            if next_row < rows:
                if distances[next_row][next_col] == -1:
                    distances[next_row][next_col] = distances[row][col] + 1
                    queue.append((next_row, next_col))

            # Neighbor above
            next_row = row - 1
            next_col = col
            if next_row >= 0:
                if distances[next_row][next_col] == -1:
                    distances[next_row][next_col] = distances[row][col] + 1
                    queue.append((next_row, next_col))
                    
            # Neighbor to the right
            next_row = row
            next_col = col + 1
            if next_col < cols:
                if distances[next_row][next_col] == -1:
                    distances[next_row][next_col] = distances[row][col] + 1
                    queue.append((next_row, next_col))

            # Neighbor to the left
            next_row = row
            next_col = col - 1
            if next_col >= 0:
                if distances[next_row][next_col] == -1:
                    distances[next_row][next_col] = distances[row][col] + 1
                    queue.append((next_row, next_col))
                    
        return distances"
"class Solution:
    def restoreString(self, s: str, indices: List[int]) -> str:
        res = [''] * len(s)
        for i in range(len(s)):
            res[indices[i]] = s[i]
        
        return ''.join(res)

class Solution:
    def restoreString(self, s: str, indices: List[int]) -> str:
        s = list(s)
        
        for i in range(len(indices)):
            while i != indices[i]:
                tmp = indices[i]
                indices[i] = indices[tmp]
                indices[tmp] = tmp
    
                s[i], s[tmp] = s[tmp], s[i]

        return ''.join(s)";"class Solution:
    def restoreString(self, s: str, indices: list[int]) -> str:
        longitud = len(s)
        lista_resultado = [""""] * longitud

        for i in range(longitud):
            caracter = s[i]
            posicion = indices[i]
            lista_resultado[posicion] = caracter

        cadena_final = """"
        for caracter in lista_resultado:
            cadena_final = cadena_final + caracter
        
        return cadena_final"
"class Solution:
    #Time-Complexity: O(n + n^2) -> O(n^2)
    #Space-Complexity: O(n + n + n) -> O(n)
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        
        q = collections.deque()
        number_of_rooms = len(rooms)
        #if we visited every room, our visited set will match wanted_set!
        wanted_set = set()
        for i in range(number_of_rooms):
            wanted_set.add(i)
        #visited will keep track of all distinct visited rooms which will be updated as bfs traversal                   progresess!
        visited = set()
        
        #before initiating bfs, we append to queue room 0 and mark room 0 as visited!
        visited.add(0)
        q.append(0)
        
        #as long as queue is non-emtpy, continue bfs!
        #all elements of queue are waited to be processed and are not already visited!
        #in worst case, our queue have to process all n rooms if we can simply hop from ith room to i+1th room
        #until we visit every single room!
        while q:
            cur_room = q.popleft()
            set_of_keys = rooms[cur_room]
            #For each room our current room can lead to, check that it is not already visited to avoid
            #revisiting node(stuck in cycle) and make sure it's not a self loop!
            #this inner for loop in worst case runs n-1 times, cause ith room may provide keys to 
            #all other rooms!
            for key in set_of_keys:
                if(key not in visited and key != cur_room):
                    q.append(key)
                    visited.add(key)
        #once our queue ends, see if visited == wanted_set
        if(visited == wanted_set):
            return True
        return False";"class Solution:
    def canVisitAllRooms(self, rooms: list[list[int]]) -> bool:
        num_rooms = len(rooms)
        
        visited = []
        for i in range(num_rooms):
            visited.append(False)
            
        stack = []
        stack.append(0)
        
        visited[0] = True
        
        while len(stack) > 0:
            current_room = stack.pop()
            
            keys_in_room = rooms[current_room]
            
            for key in keys_in_room:
                if visited[key] == False:
                    visited[key] = True
                    stack.append(key)
                    
        for has_been_visited in visited:
            if has_been_visited == False:
                return False
                
        return True"
"class Solution:
    def minPatches(self, nums: List[int], n: int) -> int:
        ans = prefix = k = 0 
        while prefix < n: 
            if k < len(nums) and nums[k] <= prefix + 1: 
                prefix += nums[k]
                k += 1
            else: 
                ans += 1
                prefix += prefix + 1
        return ans";"class Solution:
    def minPatches(self, nums, n):
        patches = 0
        reach = 0
        i = 0
        nums_len = len(nums)

        while reach < n:
            if i < nums_len and nums[i] <= reach + 1:
                reach = reach + nums[i]
                i = i + 1
            else:
                reach = reach + (reach + 1)
                patches = patches + 1
        
        return patches"
"class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        
        def mergeSort(arr, l, r):
            if l < r:
                m = l + (r-l)//2
                mergeSort(arr, l, m)
                mergeSort(arr, m+1, r)
                merge(arr, l, m, r)
        
        def merge(arr, l, m, r):
            ans = []
            i = l
            j = m+1
            while i <= m and j <= r:
                if int(arr[i]+arr[j]) > int(arr[j]+arr[i]):
                    ans.append(arr[i])
                    i += 1
                else:
                    ans.append(arr[j])
                    j += 1
            while i <= m:
                ans.append(arr[i])
                i+=1
            while j <= r:
                ans.append(arr[j])
                j+=1
            
            for i in range(len(ans)):
                arr[l+i] = ans[i]
        
        arr = [str(num) for num in nums]

        mergeSort(arr, 0, len(arr)-1)

        return ""0"" if arr and arr[0] == ""0"" else """".join(arr)";"class Solution:
    def largestNumber(self, nums: list[int]) -> str:
        string_nums = []
        for n in nums:
            string_nums.append(str(n))

        i = 0
        while i < len(string_nums):
            j = 0
            while j < len(string_nums) - 1 - i:
                if string_nums[j] + string_nums[j + 1] < string_nums[j + 1] + string_nums[j]:
                    temp = string_nums[j]
                    string_nums[j] = string_nums[j + 1]
                    string_nums[j + 1] = temp
                j = j + 1
            i = i + 1

        result = """"
        for s in string_nums:
            result = result + s

        if result[0] == '0':
            return ""0""
        else:
            return result"
"class Solution:
    # each state 6 len and 012345 permutation => (mn)! = 720 -> space = vis array of (mn)!
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        
        def getState(board):
            return ''.join(str(x) for row in board  for x in row)
        
        # print(getState(board))
        
        def setState(state):
            si = 0
            zx, zy = 0, 0
            for row in range(2):
                for i in range(3):
                    board[row][i] = int(state[si])
                    if board[row][i] == 0:
                        zx,zy = row, i
                    si += 1
                    
            # returns the position of zero ,)
            return zx, zy
        
        parent = dict() 
        def findPath(state):
            res = []
            while state in parent
                res.append(state)
                state = parent[state]
            return res
        
        # now template BFS...
        q = deque([getState(board)])
        dist = 0
        vis = set()
        while q: # level order traversal, expand one level at a time 
            # print(q)
            level_len = len(q)
            for _ in range(level_len):
                if q[0] == '123450':
                    return findPath(q[0])
                
                parent_state = q[0]
                
                zx, zy = setState(q.popleft())
                # now check all four neighbours.. after swap what happens :)
                for x, y in [[zx,zy+1], [zx+1,zy],[zx,zy-1],[zx-1,zy]]:
                    if 0<=x<2 and 0<=y<3:
                        board[zx][zy], board[x][y] = board[x][y], board[zx][zy]
                        
                        kid_state = getState(board)
                        
                        parent[kid_state] = parent_state
                        
                        if state not in vis:
                            vis.add(state)
                            q.append(state)
                        board[zx][zy], board[x][y] = board[x][y], board[zx][zy]
            dist += 1
        
        return -1";"def slidingPuzzle(board):
    target_board_tuple = ((1, 2, 3), (4, 5, 0))

    start_row1_list = board[0]
    start_row2_list = board[1]
    start_row1_tuple = tuple(start_row1_list)
    start_row2_tuple = tuple(start_row2_list)
    start_board_tuple = (start_row1_tuple, start_row2_tuple)

    queue = []
    queue.append((start_board_tuple, 0))

    visited = set()
    visited.add(start_board_tuple)

    while len(queue) > 0:
        current_board_tuple, moves = queue.pop(0)

        if current_board_tuple == target_board_tuple:
            return moves

        zero_row = -1
        zero_col = -1
        
        # Find the row and column of the '0'
        r = 0
        while r < 2:
            c = 0
            while c < 3:
                if current_board_tuple[r][c] == 0:
                    zero_row = r
                    zero_col = c
                    break
                c = c + 1
            if zero_row != -1:
                break
            r = r + 1

        # Possible move directions: up, down, left, right
        row_changes = [-1, 1, 0, 0]
        col_changes = [0, 0, -1, 1]

        i = 0
        while i < 4:
            next_row = zero_row + row_changes[i]
            next_col = zero_col + col_changes[i]
            i = i + 1

            is_valid_row = next_row >= 0 and next_row < 2
            is_valid_col = next_col >= 0 and next_col < 3

            if is_valid_row and is_valid_col:
                
                # Create a mutable copy of the board to change it
                temp_row1_list = list(current_board_tuple[0])
                temp_row2_list = list(current_board_tuple[1])
                new_board_list = [temp_row1_list, temp_row2_list]

                # Swap the zero with the neighbor tile
                tile_to_swap = new_board_list[next_row][next_col]
                new_board_list[zero_row][zero_col] = tile_to_swap
                new_board_list[next_row][next_col] = 0

                # Convert the modified board back to a tuple
                new_row1_tuple = tuple(new_board_list[0])
                new_row2_tuple = tuple(new_board_list[1])
                new_board_tuple = (new_row1_tuple, new_row2_tuple)

                # If we have not seen this board state before, add it to the queue
                if new_board_tuple not in visited:
                    visited.add(new_board_tuple)
                    queue.append((new_board_tuple, moves + 1))

    return -1"
"class Solution:
    def heightChecker(self, heights: List[int]) -> int:
        # O(N)
        sortedList = []
        count = 0
        
        # initialize 1 to 100 count dictionary
        oneToHundredDict = dict((k, 0) for k in range(1,101))
        
        # count the repeatations and updating the dictionary
        for i in range(0, len(heights)):
            oneToHundredDict[heights[i]] = oneToHundredDict[heights[i]] + 1
            
        # sorting the list
        for key,value in oneToHundredDict.items():
            if value > 0:
                # Reapting key by value times thereby sorting the list
                sortedList.extend(repeat(key, value))
        
        # compare
        for i in range(0,len(heights)):
            if sortedList[i] != heights[i]:
                count = count + 1
        
        return count";"class Solution:
    def heightChecker(self, heights: list[int]) -> int:
        expected = []
        for h in heights:
            expected.append(h)

        expected.sort()

        mismatches = 0
        i = 0
        while i < len(heights):
            if heights[i] != expected[i]:
                mismatches = mismatches + 1
            i = i + 1
            
        return mismatches"
"class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        nums = [1] + nums + [1]
        size = len(nums)        
        
        t = [[-1 for p in range(0,size+1)]
            for q in range(0,size+1)]
        
        return self.solve(nums,1,size-1,t)
        
    def solve(self,arr,i,j,t):
        if i >= j:
            return 0
        
        if t[i][j] > 0:
            return t[i][j]
        
        ans = float('-inf')
        
        for k in range(i,j):
            if t[i][k] != -1:
                left = t[i][k]
            else:
                left = self.solve(arr,i,k,t)
                t[i][k] = left
                
            if t[k+1][j] != -1:
                right = t[k+1][j]
            else:
                right = self.solve(arr,k+1,j,t)
                t[k+1][j] = right
                
            temp = left + right + (arr[i-1]*arr[k]*arr[j])
            
            ans = max(ans,temp)
            
        t[i][j] = ans
        return t[i][j]";"class Solution:
    def maxCoins(self, nums: list[int]) -> int:
        new_nums = [1]
        for num in nums:
            new_nums.append(num)
        new_nums.append(1)

        n = len(new_nums)

        dp = []
        i = 0
        while i < n:
            row = []
            j = 0
            while j < n:
                row.append(0)
                j = j + 1
            dp.append(row)
            i = i + 1

        length = 2
        while length < n:
            i = 0
            while i < n - length:
                j = i + length
                max_coins_for_ij = 0
                k = i + 1
                while k < j:
                    coins = dp[i][k] + dp[k][j] + new_nums[i] * new_nums[k] * new_nums[j]
                    if coins > max_coins_for_ij:
                        max_coins_for_ij = coins
                    k = k + 1
                dp[i][j] = max_coins_for_ij
                i = i + 1
            length = length + 1

        return dp[0][n - 1]"
"class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        
        # Setup counts for bulls and cows
        bulls = cows = 0
        
        # Copy secret and guess into lists that are easier to work with
        secretCopy = list(secret)
        guessCopy = list(guess)
        
        # In a for loop, check every pair of letters at the same index in both guess and secret for matching letters, AKA bulls
        for i in range(len(secret)):
            
            # If they match, bulls += 1 and pop() the letters from the copy lists via their .index()
            if secret[i] == guess[i]:
                bulls += 1
                secretCopy.pop(secretCopy.index(secret[i]))
                guessCopy.pop(guessCopy.index(guess[i]))
                
                
        # Count() the letters remaining in secret and guess lists
        secretCounter = Counter(secretCopy)
        guessCounter = Counter(guessCopy)
        
        # Counter1 - Counter2 gives us Counter1 with any matching values of Counter1 and Counter2 removed, leftover Counter2 values are trashed
        # secretCounter - guessCounter gives us the secretCounter except for any correctly guessed letters
        # Therefore, subtract this difference from the OG secretCounter to be left with a counter of only correctly guessed letters
        dif = secretCounter - (secretCounter - guessCounter)
        
        # The .total() of the dif Counter is the number of cows
        cows = dif.total()

        # return the formatted string with req. info
        return f'{bulls}A{cows}B'";"class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        bulls = 0
        cows = 0
        
        secret_chars = []
        guess_chars = []
        
        i = 0
        while i < len(secret):
            if secret[i] == guess[i]:
                bulls = bulls + 1
            else:
                secret_chars.append(secret[i])
                guess_chars.append(guess[i])
            i = i + 1
            
        secret_counts = {}
        for char in secret_chars:
            if char in secret_counts:
                secret_counts[char] = secret_counts[char] + 1
            else:
                secret_counts[char] = 1
                
        for char in guess_chars:
            if char in secret_counts:
                if secret_counts[char] > 0:
                    cows = cows + 1
                    secret_counts[char] = secret_counts[char] - 1
        
        bulls_string = str(bulls)
        cows_string = str(cows)
        
        result = bulls_string + ""A"" + cows_string + ""B""
        
        return result"
"class Solution:
    def imageSmoother(self, img: List[List[int]]) -> List[List[int]]:
        
        #Pull the dimensions
        m_rows = len( img ),
        n_cols = len( img[ 0 ] ),
        
        #Kernel size is 3,
        k = 3,
        
        #Create a new image for each averaged total to be stored
        newImage = [ [ 0 for _ in range( n_cols ) ] for _ in range( m_rows ) ],
        
        #Start is the grid cordinate [ column , row ],
        start = [ 0, 0 ],
        
        #direction right tells us if we are true
        directionRight = [ True ],
        
        #Total keeps track of our total
        total = [ 0 ],
        
        #Initialize the kernel at [ 0 , 0 ],
        #Valid kernel will tell us how many valid squares
        #We are averaging
        total[ 0 ] , validKernel = self.initializeKernel( img, m_rows, n_cols, start ),
        
        #Previous direction will help us snake down the matrix
        #By snake down, we go right to left, then down, then left to right
        #As we find the total
        
        #This allows us to reuse our counts, and prevents overlapping calculations
        
        #When previous direction is True
        #It means we are going from right to left
        #When it is False, we are going from left to right
        prevDirection = True,

        #While our row value is at a valid index, process:
        while start[ 1 ] < m_rows:

            #Pull the x and y coordinate
            x = start[ 0 ],
            y = start[ 1 ],
            
            #Assign the average value
            newImage[ y ][ x ] = total[ 0 ] // validKernel,
            
            #Find the next coordinate by calling self.snake() to snake through the matri
            #Instead of scanning and going back to the beginning at the end,
            #Like when we read,
            #We continue our calculations in the other direction
            
            #next cord will go from
            #BEGIN [ 0, 0] , [ 1 , 0 ] , [ 2 ,  0] , END , [ 2, 1 ], [ 1 , 1 ], [ 0, 1 ] 
            # BEGIN [ 0, 2 ] [ 1, 2 ] [ 2, 2 ] END [ 2, 3 ]  ...
            nextCoord = self.snake(img, m_rows , n_cols, start, directionRight ),
            
            #nextCoord modifies the directionRight flag if it changes
            #to false, and thus begins going left
            
            #When we change directions, we want to go down a row
            if prevDirection != directionRight[ 0 ]:
                #We adjust the slice of the kernel by KEEPING
                #the overlapped elements
                
                #Adjust prev will remove from the total a slice of the kernel
                #That does not overlap
                
                #Since we are always going down, the below call to change slice
                #Will always remove the non overlapping top part of the kernel
                adjustPrev = self.changeSlice( img, m_rows, n_cols, [ x, y ] ,total, False, 0 ),
                validKernel -= adjustPrev,
                #We remove the count so our average will only consider the overlapped
                
                #Next we add the new slice that comes with our new coordinate
                #This will always be the bottom part of the kernel
                adjustCurr = self.changeSlice( img, m_rows, n_cols, [ x, y + 1 ] ,total, True, 1 ),
                validKernel += adjustCurr ,
                #and same thing, we add to the count the pieces of our new slice
                

            #If we are going in the same direction, 
            else: 
                #These values keep track of changeSlice
                #Minus condition and plus condition
                #Tell us which part of the kernel we are changing
                
                #If we are going right:
                #We remove the left slice of the old kernel
                #And add the right slice of the new kernel
                if directionRight[ 0 ]:
                    minusCondition = 3,
                    plusCondition = 2,
                    
                #If we are going left:
                #It is the opposide
                #We remove the right slice of the old kernel
                #And add the left slice of the new kernel
                else:
                    minusCondition = 2,
                    plusCondition = 3,
                    
                #Like with the above, We adjust the slices and update the validKernel count
                adjustPrev = self.changeSlice( img, m_rows, n_cols, [ x, y ], total, False, minusCondition ),
                validKernel -= adjustPrev,
                adjustCurr = self.changeSlice( img, m_rows, n_cols, nextCoord, total, True, plusCondition ),
                validKernel += adjustCurr,
                
                
            
           
            
            #At the end, we update the start value with our nextCoord
            #And we overWrite our prevDirection flag with our current direction
            start = nextCoord,
            prevDirection = directionRight[ 0 ],
        return newImage,
        
        
    #Is validCoord takes in the dimensions of the matrix
    #And returns if a current coordinate pair is not a valid index
    def isValidCoord( self, m, n, current ):
        x = current[ 0 ],
        y = current[ 1 ],
        
        if x < 0 or y < 0:
            return False,
        if x >= n or y >= m:
            return False,
        return True,
        
    #Intialize kernel will create the first instance of our kernel
    #at the top left of our matrix
    def initializeKernel( self, grid, m, n, start , k = 3):
        x = start[ 0 ],
        y = start[ 1 ],
        
        starting_total = 0,
        validCoord = 0,
        
        #It is generalized to take any slice of k
        #Since we are starting at the top left
        #We only need half of the kernel to begin with
        #Which is k // 2
        #The plus one comes from including the middle section of the kernel
        for i in range( ( k // 2) + 1 ):
            for j in range( (k // 2 ) + 1 ):
                #For each potential kernel location, 
                #We see if it is a valid coordinate
                #This is needed for when the kernel is larger than the matrix
                if self.isValidCoord( m , n , [ x + j, y + i ] ):
                    starting_total += grid[ y + i ][ x + j ],
                    validCoord += 1,

        #We return our starting total 
        #And our count, validCoord, which is used to divide the total to find
        #the average
        return starting_total, validCoord,

    
    #Change slice will tally slices of the kernel
    #The top or bottom row,
    #The left or right hand side of the column
    #Change slice will find the valid coordinates of the slice
    #And will either add them or subtract them from the total
    #Depending on the passed in paratmeters
    
    #It is the swiss-army-knife of this solution
    def changeSlice( self, grid, m , n, current, total, addition = True, condition = 0 ,k = 3 ):
        
        
        #Condition 0 tallies the top row
        #Condition 1 tallies the bottom row
        #Condition 2 tallies the right column
        #Condition 3 tallies the left column
        
        #If addition is True, we add to the total
        #If addition is False, we subtract from the total
        
        #We take the current center of the kernel
        x = current[ 0 ],
        y = current[ 1 ],
        
        #Adjust slice allows us to generalize to other sizes of k
        adjustSlice = ( k // 2 ),
        
        #We see how many valid coordinates are being modified
        #That is, how many are going into the addition or subtraction of the total
        validCoord = 0,
        
        #Going down or right from the top left of the kernel
        if condition == 0 or condition == 3:
            start = [ x - adjustSlice , y - adjustSlice ],
        #Going right from bottom left of the kernel
        elif condition == 1:
            start = [ x - adjustSlice , y + adjustSlice ],
        #Going down from top right of the kernel
        elif condition == 2:
            start = [ x + adjustSlice , y - adjustSlice ],
        else:
            raise ValueError,
        
        #For the size of the slice
        for i in range( k ):
            #Horizontal slice of k: condition 0 is top, 1 is bottom
            if condition == 0 or condition == 1:
                a = start[ 0 ] + i,
                b = start[ 1 ] ,
            #Vertical slice of k: 2 is righthand side, 3 is lefthand side
            else:
                a = start[ 0 ] ,
                b = start[ 1 ] + i,
                
            #Check to see if the generated coordinate is on the matrix
            if self.isValidCoord( m , n , [ a ,b ] ):
                #If it is, add to our subtotal count
                validCoord += 1,
            
                #If the addition flag is true:
                #Add the value to the total
                if addition:
                    total[ 0 ] += grid[ b ][ a ],  
                #If it is subtraction, remove the value from the total
                else:
                    total[ 0 ] -= grid[ b ][ a ],
                    
        #Return the number of coordinates that changed the total
        return validCoord,
                
        #Snake will, given the current coordinate, generate the next one
        #If directionRight is True, we are going right
        #If directionRight is False, we are going left
    def snake( self, grid, m, n, current , directionRight):
        
        #Pull the coordinates
        x = current[ 0 ],
        y = current[ 1 ],
        
        #Adjust the x value in accordance with the direction 
        if directionRight[ 0 ]:
            x = x + 1,
        else:
            x = x - 1,
        
        #If we are outside of a valid coordinate,
        if x == -1 or x == n:
            #Change direction
            directionRight[ 0 ] = not directionRight[ 0 ],
            
            #Return the original x, and increment y
            return [ current[ 0 ] , y + 1 ]
            
        #Otherwise, return the modified x, and the original y
        return [ x , y ],";"class Solution:
    def imageSmoother(self, img: list[list[int]]) -> list[list[int]]:
        rows = len(img)
        cols = len(img[0])
        
        result = []
        for r in range(rows):
            row_list = []
            for c in range(cols):
                row_list.append(0)
            result.append(row_list)

        for r in range(rows):
            for c in range(cols):
                total_sum = 0
                count = 0
                
                for i in range(r - 1, r + 2):
                    for j in range(c - 1, c + 2):
                        if i >= 0 and i < rows and j >= 0 and j < cols:
                            total_sum = total_sum + img[i][j]
                            count = count + 1
                
                result[r][c] = total_sum // count
                
        return result"
"class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        #create a adjacent lists that have connections 
        dic = collections.defaultdict(set)
        email_to_name={}
        visited = set()
        ans = []
        for account in accounts:
            name = account[0]
            for email in account[1:]:
                dic[email].add(account[1])
                dic[account[1]].add(email)
                email_to_name[email] = name
        def dfs(intial_email,dic,visited):
            if intial_email in visited:
                return 
            stack = [intial_email]
            visited.add(intial_email)
            lst = []
            lst.append(intial_email)
            while stack:
                sub_email = stack.pop()
                if dic[sub_email]:
                    for other_email in dic[sub_email]:
                        if other_email not in visited:
                            lst.append(other_email)
                            stack.append(other_email)
                            visited.add(other_email)
                        else:
                            continue
            result = sorted(lst)
            return result
        for email in dic:
            result = dfs(email,dic,visited)
            if result:
                ans.append([email_to_name[email]]+result)
        return ans 

            

                    



        


        # dic_emails = {}
        # for account in accounts:
        #     for i in range(1,len(account)):
        #         if account[i] not in dic_emails:
        #             dic_emails[account[i]] =1
        #         else:
        #             dic_emails[account[i]] +=1
        # dic_email2 = {}
        # dic_email3 = []
        # for key,value in dic_emails.items():
        #     if value > 1:
        #         for account in accounts:
        #             if key in account and key not in dic_email2:
        #                 dic_email2[key] = []
        #                 dic_email2[key].append(account)
        #             elif key in account and key in dic_email2:
        #                 dic_email2[key].append(account)
        #             elif key not in account:
        #                 dic_email3.append(account)
        # total = []
        # for key,value in dic_email2.items():
        #     lst = []
        #     if len(value) > 1:
        #         for infor in value:
        #             for in_f in infor:
        #                 if in_f not in lst:
        #                     lst.append(in_f)
        #     total.append(lst[:1]+sorted(lst[1:]))
        # print(total)
        # print(dic_email3)
        # return sorted((total + dic_email3))";"class Solution:
    def accountsMerge(self, accounts: list[list[str]]) -> list[list[str]]:
        email_to_name = {}
        email_graph = {}

        for acc in accounts:
            name = acc[0]
            for i in range(1, len(acc)):
                email = acc[i]
                email_to_name[email] = name
                if email not in email_graph:
                    email_graph[email] = set()

            if len(acc) > 2:
                first_email = acc[1]
                for i in range(2, len(acc)):
                    email = acc[i]
                    email_graph[first_email].add(email)
                    email_graph[email].add(first_email)

        merged_accounts = []
        visited_emails = set()

        all_emails = list(email_to_name.keys())

        for email in all_emails:
            if email not in visited_emails:
                component = []
                stack = [email]
                visited_emails.add(email)

                while len(stack) > 0:
                    current_email = stack.pop()
                    component.append(current_email)

                    for neighbor in email_graph[current_email]:
                        if neighbor not in visited_emails:
                            visited_emails.add(neighbor)
                            stack.append(neighbor)
                
                component.sort()
                
                account_name = email_to_name[email]
                final_account = [account_name]
                for mail_item in component:
                    final_account.append(mail_item)
                
                merged_accounts.append(final_account)

        return merged_accounts"
"class Solution:
		def isEvenOddTree(self, root: Optional[TreeNode]) -> bool:
			if root is None:
				return False

			level_order = self.level_order(root)

			# check level 0
			if level_order[0][0] % 2 == 0:
				return False

			# check level 1 ~ end
			for i, level in enumerate(level_order[1:], 2):
				if i % 2 == 0:
					# even and decreasing order
					previous_element = level[0]
					if previous_element % 2 != 0:
						return False

					for element in level[1:]:
						if element % 2 != 0 or previous_element < element:
							return False
						previous_element = element

				else:
					# odd and increasing order
					previous_element = level[0]
					if previous_element % 2 == 0:
						return False

					for element in level[1:]:
						if element % 2 == 0 or element < previous_element:
							return False
						previous_element = level

			return True

		def level_order(self, root: Optional[TreeNode]) -> List[List[int]]:
				queue = [root]
				level_order = []
				while queue:
					size = len(queue)
					level = []
					for _ in range(size):
						node = queue.pop(0)

						if node.left:
							queue.append(node.left)

						if node.right:
							queue.append(node.right)

						level.append(node.val)

					level_order.append(level)

				return level_order";"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isEvenOddTree(root):
    if root is None:
        return True

    queue = []
    queue.append(root)
    level_index = 0

    while len(queue) > 0:
        count_at_level = len(queue)
        previous_node_val = None

        for i in range(count_at_level):
            current_node = queue.pop(0)

            is_level_even = level_index % 2 == 0

            if is_level_even:
                is_value_odd = current_node.val % 2 != 0
                if not is_value_odd:
                    return False
                if previous_node_val is not None:
                    is_increasing = current_node.val > previous_node_val
                    if not is_increasing:
                        return False
            else: 
                is_value_even = current_node.val % 2 == 0
                if not is_value_even:
                    return False
                if previous_node_val is not None:
                    is_decreasing = current_node.val < previous_node_val
                    if not is_decreasing:
                        return False

            previous_node_val = current_node.val

            if current_node.left is not None:
                queue.append(current_node.left)
            if current_node.right is not None:
                queue.append(current_node.right)

        level_index = level_index + 1

    return True"
"class Solution:
    def sumFourDivisors(self, nums: List[int]) -> int:
        res = 0
        for num in nums:
            divisor = set() 
            for i in range(1, floor(sqrt(num)) + 1):
                if num % i == 0:
                    divisor.add(num//i)
                    divisor.add(i)
                if len(divisor) > 4:    
                    break
                    
            if len(divisor) == 4:
                res += sum(divisor)
        return res";"def sumFourDivisors(nums):
    total_sum = 0
    for num in nums:
        divisors_sum = 0
        divisors_count = 0
        i = 1
        while i * i <= num:
            if num % i == 0:
                if i * i == num:
                    divisors_count = divisors_count + 1
                    divisors_sum = divisors_sum + i
                else:
                    divisors_count = divisors_count + 2
                    divisors_sum = divisors_sum + i + (num // i)
            i = i + 1
        
        if divisors_count == 4:
            total_sum = total_sum + divisors_sum
            
    return total_sum"
"class Solution:
    def findRotateSteps(self, ring: str, key: str) -> int:
        char_pos = defaultdict(set)
        for i, c in enumerate(ring):
            char_pos[c].add(i)
        
        def minStep(fromm, to):
            if fromm == to:
                return 0
            minSteps = abs(fromm - to)
            minSteps = min(minSteps, abs(len(ring) - minSteps))
            return minSteps
        
        n = len(key)
        dp = [0] * len(ring)
        for p in char_pos[key[0]]:
            dp[p] = minStep(0, p)
        prev_char = key[0]
        for c in key[1:]:
            if prev_char == c:
                continue
            for next_pos in char_pos[c]:
                dp[next_pos] = min(dp[prev_pos] + minStep(prev_pos, next_pos) for prev_pos in char_pos[prev_char])
            prev_char = c
        return min(dp[p] for p in char_pos[prev_char]) + len(key)";"class Solution:
    def findRotateSteps(self, ring: str, key: str) -> int:
        ring_len = len(ring)
        key_len = len(key)
        
        infinity = 1000000000

        dp = [infinity] * ring_len

        # Base case: Spell the first character of the key
        first_char = key[0]
        for i in range(ring_len):
            if ring[i] == first_char:
                # Steps to rotate from index 0 to index i
                steps = abs(i - 0)
                # Consider clockwise and anticlockwise
                min_steps = min(steps, ring_len - steps)
                # Add 1 step for pressing the button
                dp[i] = min_steps + 1

        # Iterate for the rest of the characters in the key
        for k in range(1, key_len):
            next_dp = [infinity] * ring_len
            current_char = key[k]
            for i in range(ring_len):
                if ring[i] == current_char:
                    # Find the minimum steps to reach this ring position `i`
                    min_prev_total_steps = infinity
                    # From each possible previous position `j`
                    for j in range(ring_len):
                        # If a previous state was reachable
                        if dp[j] != infinity:
                            # Steps to rotate from `j` to `i`
                            steps = abs(i - j)
                            min_rotation = min(steps, ring_len - steps)
                            # Total steps is previous steps + rotation
                            total_steps = dp[j] + min_rotation
                            if total_steps < min_prev_total_steps:
                                min_prev_total_steps = total_steps
                    
                    # Add 1 step for pressing the button
                    next_dp[i] = min_prev_total_steps + 1
            
            # Update dp for the next character
            dp = next_dp

        # The result is the minimum steps in the final dp array
        min_total_steps = infinity
        for steps in dp:
            if steps < min_total_steps:
                min_total_steps = steps

        return min_total_steps"
"class Solution:
    def isValid(self, code: str) -> bool:
        if code[0] != '<' or code[-1] != '>': return False
        i, n = 0, len(code)
        stk = []
        while i < n:
            if code[i] == '<':
                if i != 0 and code[i: i + 9] == '<![CDATA[':
                    if not stk: return False
                    j = i + 9
                    while j + 3 <= n and code[j: j + 3] != ']]>': j += 1
                    if code[j: j + 3] == ']]>': i = j + 3
                    else: return False
                else:
                    start = i
                    isend = False
                    i += 1
                    if i >= n: return False
                    if code[i] == r'/':
                        isend = True
                        i += 1
                    if i >= n: return False
                    tag = ''
                    while i < n and code[i] != '>':
                        if not code[i].isupper(): return False
                        tag += code[i]
                        i += 1
                    if i >= n or len(tag) == 0 or len(tag) > 9: return False
                    if isend:
                        if not stk or stk[-1] != tag: return False
                        stk.pop(-1)
                    else:
                        if start != 0 and not stk: return False
                        stk.append(tag)
                    i += 1
            else:
                if not stk: return False
                while i < n and code[i] != '<': i += 1
        return not stk";"class Solution:
    def isValid(self, code: str) -> bool:
        stack = []
        i = 0
        n = len(code)

        # An empty string or a string that is just content is invalid
        # because it's not wrapped in a tag. The first character must be '<'.
        # This check is implicitly handled later, but an explicit check at the
        # start for an empty string is clearer. If code is not empty,
        # the loop will start, and if the first char isn't '<', it will be treated
        # as content, and since the stack is empty, it will correctly return False.
        if n == 0:
            return False

        while i < n:
            # If we have finished parsing a full tag (stack is empty) but we are not
            # at the end of the string, it means there are multiple root-level tags
            # or trailing text, which is invalid.
            if i > 0 and len(stack) == 0:
                return False

            # Check for different types of elements starting with '<'
            if code[i] == '<':
                # Check for CDATA section: <![CDATA[...]]>
                is_cdata = False
                if i + 8 < n:
                    if code[i+1:i+9] == '![CDATA[':
                        is_cdata = True
                
                if is_cdata:
                    # CDATA is only valid if it is inside a tag.
                    if len(stack) == 0:
                        return False
                    
                    j = i + 9
                    cdata_end_found = False
                    while j <= n - 3:
                        if code[j:j+3] == ']]>':
                            i = j + 3
                            cdata_end_found = True
                            break
                        j += 1
                    
                    if not cdata_end_found:
                        return False
                    
                    continue

                # Check for an end tag: </TAG_NAME>
                is_end_tag = False
                if i + 1 < n:
                    if code[i+1] == '/':
                        is_end_tag = True
                
                if is_end_tag:
                    j = i + 2
                    gt_found = False
                    while j < n:
                        if code[j] == '>':
                            gt_found = True
                            break
                        j += 1
                    
                    if not gt_found:
                        return False

                    tag_name = code[i+2:j]
                    
                    if len(stack) == 0:
                        return False
                    
                    last_tag = stack.pop()
                    if last_tag != tag_name:
                        return False

                    i = j + 1
                    continue

                # It must be a start tag: <TAG_NAME>
                j = i + 1
                gt_found = False
                while j < n:
                    if code[j] == '>':
                        gt_found = True
                        break
                    j += 1
                
                if not gt_found:
                    return False

                tag_name = code[i+1:j]
                
                # Validate the tag name
                if len(tag_name) < 1 or len(tag_name) > 9:
                    return False
                
                k = 0
                is_valid_name = True
                while k < len(tag_name):
                    char = tag_name[k]
                    if not ('A' <= char <= 'Z'):
                        is_valid_name = False
                        break
                    k += 1
                
                if not is_valid_name:
                    return False

                stack.append(tag_name)
                i = j + 1

            else:
                # Any character not part of a tag is content.
                # Content is only valid if it is inside a tag.
                if len(stack) == 0:
                    return False
                i += 1

        # After checking the whole string, the stack must be empty for it to be valid.
        if len(stack) == 0:
            return True
        else:
            return False"
"class Solution:
    def toLowerCase(self, s: str) -> str:
        # Instead of using .lower(), let's implement with ASCII
        # ord() returns the ascii value of a passed character
        
        # Uncomment the line below to see the ASCII value of some important characters
        # print(ord('a'), ord('z'), ord('A'), ord('Z'))
        
        # Notice 'a'=97, and 'A'=65
        # This can be used to tell whether a character is upper/lower case, and can help us convert between them
        
        # First, make the string a list so we can change each char individually
        s = list(s)
        
        # Then, loop through the characters, and if their ascii value is <= 90 and >= 65, they must be upper case
        # Use the difference (97 - 65 = 32) to convert it from upper to lower, then use chr() to convert from ascii to char
        #   - ord('A') + 32 = 97 = ord('a')
        for i in range(len(s)):
            if ord(s[i]) <= 90 and ord(s[i]) >= 65:
                s[i] = chr(ord(s[i])+32)
        return ''.join(s)";"def to_lowercase(s):
    result_string = """"
    for character in s:
        if 'A' <= character <= 'Z':
            ascii_code = ord(character)
            new_ascii_code = ascii_code + 32
            new_character = chr(new_ascii_code)
            result_string = result_string + new_character
        else:
            result_string = result_string + character
    return result_string"
"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        # self.selectionSort(nums)
        # self.bubbleSort(nums)
        # self.insertionSort(nums)
        # self.mergeSort(nums)       
        self.quickSort(nums)
        return nums
    
    ''' 
    Selection Sort (TLE)
    TC: O(n^2) ,  SC: O(1), in-place
    Not Stable
    Minimum swaps
    '''
    def selectionSort(self, nums):
        for i in range(len(nums)):
            min_idx=i
            for j in range(i, len(nums)):
                if nums[j]<nums[min_idx]:
                    min_idx=j
            nums[i], nums[min_idx] = nums[min_idx], nums[i]
            
    '''
    Bubble Sort (TLE)
    TC: best-O(n), worst-O(n^2)
    SC: O(1)
    Stable
    Use when array is almost sorted
    '''
    def bubbleSort(self, nums):
        for i in range(len(nums)):
            swapped = False
            for j in range(len(nums)-i-1):
                if nums[j]>nums[j+1]:
                    nums[j], nums[j+1] = nums[j+1], nums[j]
                    swapped = True
            
            if not swapped:
                break
                
    '''
    Insertion Sort (TLE)
    TC: best-O(n), worst-O(n^2)
    SC: O(1)
    Stable
    '''
    def insertionSort(self, nums):
        for i in range(1, len(nums)):
            key = nums[i]
            j=i-1
            while j>=0 and key<nums[j]:
                nums[j+1]=nums[j]
                j-=1
            nums[j+1]=key
    
    '''
    Merge Sort
    Recursive
    TC: O(nlogn)
    SC: O(n)
    Stable
    '''
    def mergeSort(self, nums):
        def merge(nums,L,R):
            i = j = k = 0
            while i < len(L) and j < len(R): 
                if L[i] < R[j]: 
                    nums[k] = L[i] 
                    i+=1
                else: 
                    nums[k] = R[j] 
                    j+=1
                k+=1
                
            while i < len(L): 
                nums[k] = L[i] 
                i+=1
                k+=1

            while j < len(R): 
                nums[k] = R[j] 
                j+=1
                k+=1
                
        if len(nums)>1:
                mid=len(nums)//2
                L=nums[:mid]
                R=nums[mid:]
                self.mergeSort(L)
                self.mergeSort(R)
                merge(nums,L,R)
        
    '''
    QuickSort
    Recursive
    TC: average-O(nlogn), worst-O(n^2)
    SC: average-O(logn), worst-O(n) recursion stack, in-place
    Not stable
    '''
    def quickSort(self, nums):
        # 3-way randomized
        def partition(l, r):
            pivot_idx = random.choice(range(l,r+1))
            pivot = nums[pivot_idx]
            # print(pivot)
            left, move, right = l,l,r
            while move<=right:
                if nums[move]<pivot:
                    nums[left], nums[move] = nums[move], nums[left]
                    move+=1
                    left+=1
                elif nums[move]>pivot:
                    nums[right], nums[move] = nums[move], nums[right]
                    right-=1
                else:
                    move+=1
            return left-1, move
        
        def quicksort(nums, low, high):
            if low<high:
                l,r = partition(low, high)
                quicksort(nums, low, l)
                quicksort(nums, r, high)
                
        quicksort(nums, 0, len(nums)-1)
        
        #---------------------------------------------------------------
        # def helper(head, tail):
        #     if head >= tail: return 
        #     l, r = head, tail
        #     m = (r - l) // 2 + l
        #     pivot = nums[m]
        #     while r >= l:
        #         while r >= l and nums[l] < pivot: l += 1
        #         while r >= l and nums[r] > pivot: r -= 1
        #         if r >= l:
        #             nums[l], nums[r] = nums[r], nums[l]
        #             l += 1
        #             r -= 1
        #     helper(head, r)
        #     helper(l, tail)

        # helper(0, len(nums)-1)";"def sortArray(nums):
    n = len(nums)

    i = n // 2 - 1
    while i >= 0:
        root = i
        while True:
            child = 2 * root + 1
            if child >= n:
                break
            
            if child + 1 < n and nums[child + 1] > nums[child]:
                child = child + 1
            
            if nums[root] < nums[child]:
                temp = nums[root]
                nums[root] = nums[child]
                nums[child] = temp
                root = child
            else:
                break
        i = i - 1

    i = n - 1
    while i > 0:
        temp = nums[0]
        nums[0] = nums[i]
        nums[i] = temp
        
        heap_size = i
        root = 0
        while True:
            child = 2 * root + 1
            if child >= heap_size:
                break

            if child + 1 < heap_size and nums[child + 1] > nums[child]:
                child = child + 1

            if nums[root] < nums[child]:
                temp = nums[root]
                nums[root] = nums[child]
                nums[child] = temp
                root = child
            else:
                break
        i = i - 1
                
    return nums"
"class Solution:
    def calPoints(self, ops: List[str]) -> int:
        stack = [] # taking an empty stack. 
        prod = 2 # taking a variable to double a provided number. 
        prev_sum = 0 # taking a variable to have sum of previous elems of the stack. 
        
        for i in range(len(ops)): # Traversing through the provided list.
            if ops[i] is not ""C"" and ops[i] is not ""D"" and ops[i] is not ""+"": # if we are having other then a number then we`ll just add it to stack. 
                stack.append(int(ops[i])) # pushing elements to the stack and making it as int bcz originally it is provided as char.
            elif ops[i] is ""C"": # if its other then a number we`ll check what it is.
                stack.pop() # removing the previous record, we as coder refer it as a last element in the stack. 
            elif ops[i] is ""D"": # if its other then a number we`ll check what it is.
                prod*=int(stack[-1]) # Again making stack element as a integer for performing product operation. 
                stack.append(prod) # Pushing the product to the stack. 
                prod=2 # reseting variable. 
            elif ops[i] is ""+"": # if its other then a number we`ll check what it is.
                prev_sum = int(stack[-2]) + int(stack[-1]) # Again as we have list elem as char, to perform adding we have to change it to int. 
                stack.append(prev_sum) # Pushing the sum to the stack. 
                prev_sum=0 # reseting variable. 
        return sum(stack) # Returning the sum of all the scores on the record(sum of elements in the stack).";"class Solution:
  def calPoints(self, operations: list[str]) -> int:
    record = []
    
    for op in operations:
      if op == '+':
        score1 = record[-1]
        score2 = record[-2]
        record.append(score1 + score2)
      elif op == 'D':
        last_score = record[-1]
        record.append(2 * last_score)
      elif op == 'C':
        record.pop()
      else:
        score_val = int(op)
        record.append(score_val)
        
    final_score = 0
    for score in record:
      final_score = final_score + score
      
    return final_score"
"class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        # Solution 1 using recursion
        while n % 4 == 0 and n > 0:
            return self.isPowerOfFour(n/4)
        return n == 1
        
        # Solution 2 iteration
        if n == 1:
            return True
        if n % 4:
            return False
        while n > 1:
            if n % 4:
                return False
            n //= 4
        return n == 1
        
        # Solution 3 using bit manipulation
        '''
        Once we write numbers in it's binary representation, from there we can observe:=>
        i. 000001 , power of 2 and 4
        ii. 000010, power of only 2
        iii. 000100 , power of 2 and 4
        iv. 001000, power of only 2
        v. 010000 , power of 2 and 4
        vi. 100000, power of only 2
        We can see if the set bit is at an odd position and is a power of 2, it's also power of 4.
        '''
        return n.bit_length() &amp, 1 and not(n &amp, (n-1))";"class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        if n <= 0:
            return False
        
        while n > 1:
            if n % 4 != 0:
                return False
            n = n // 4
            
        return True"
"class Solution:
    def oddEvenJumps(self, A: List[int]) -> int:
        
		# find next index of current index that is the least larger/smaller
        def getNextIndex(sortedIdx):
            stack = []
            result = [None] * len(sortedIdx)
        
            for i in sortedIdx:
                while stack and i > stack[-1]:
                    result[stack.pop()] = i
                stack.append(i)
            return result
        
        sortedIdx = sorted(range(len(A)), key= lambda x: A[x])
        oddIndexes = getNextIndex(sortedIdx)
        sortedIdx.sort(key=lambda x: -A[x])
        evenIndexes = getNextIndex(sortedIdx)
        
		# [odd, even], the 0th jump is even
        dp = [[0,1] for _ in range(len(A))]
        
        for i in range(len(A)):
            if oddIndexes[i] is not None:
                dp[oddIndexes[i]][0] += dp[i][1]
            if evenIndexes[i] is not None:
                dp[evenIndexes[i]][1] += dp[i][0]
				
        return dp[-1][0] + dp[-1][1]";"class Solution:
    def oddEvenJumps(self, arr):
        n = len(arr)
        
        odd_good = []
        i = 0
        while i < n:
            odd_good.append(False)
            i = i + 1
            
        even_good = []
        i = 0
        while i < n:
            even_good.append(False)
            i = i + 1
        
        odd_good[n - 1] = True
        even_good[n - 1] = True
        
        i = n - 2
        while i >= 0:
            
            # --- Find next ODD jump ---
            min_val_for_odd = -1
            next_odd_jump_index = -1
            
            j = i + 1
            while j < n:
                if arr[i] <= arr[j]:
                    if next_odd_jump_index == -1:
                        min_val_for_odd = arr[j]
                        next_odd_jump_index = j
                    elif arr[j] < min_val_for_odd:
                        min_val_for_odd = arr[j]
                        next_odd_jump_index = j
                j = j + 1
            
            if next_odd_jump_index != -1:
                if even_good[next_odd_jump_index]:
                    odd_good[i] = True

            # --- Find next EVEN jump ---
            max_val_for_even = -1
            next_even_jump_index = -1
            
            j = i + 1
            while j < n:
                if arr[i] >= arr[j]:
                    if next_even_jump_index == -1:
                        max_val_for_even = arr[j]
                        next_even_jump_index = j
                    elif arr[j] > max_val_for_even:
                        max_val_for_even = arr[j]
                        next_even_jump_index = j
                j = j + 1
                
            if next_even_jump_index != -1:
                if odd_good[next_even_jump_index]:
                    even_good[i] = True
            
            i = i - 1
            
        count = 0
        for is_good in odd_good:
            if is_good:
                count = count + 1
                
        return count"
"class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        
        visited = set()
        
        size = len(nums)
        
        max_subset_size = 0
        
        # check each index in input array
        for i in range(size):
            
            if nums[i] in visited:
                
                # current number has been visited
                continue
            
            # reset picking subset size to zero
            cur_subset_size = 0
            
            # keep picking if current nums[i] has not been visited 
            while nums[i] not in visited:
                
                # update current nums[i] as visited
                visited.add( nums[i] )
                
                # update subset size
                cur_subset_size += 1
                
                # i goes to next nesting index
                i = nums[i]
            
            # finished current element picking
            max_subset_size = max(max_subset_size, cur_subset_size)
            
        return max_subset_size";"max_length = 0
n = len(nums)
visited = []
i = 0
while i < n:
    visited.append(False)
    i = i + 1

i = 0
while i < n:
    if visited[i] == False:
        current_length = 0
        j = i
        while visited[j] == False:
            visited[j] = True
            j = nums[j]
            current_length = current_length + 1
        
        if current_length > max_length:
            max_length = current_length
    i = i + 1

return max_length"
"class Solution:
    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        self.cyclic(grid, k, len(grid), len(grid[0]))
        self.redact(grid, len(grid), len(grid[0]))
        return grid
    
    def cyclic(self, grid: List[List[int]], k: int, rows: int, cols: int):
        for r in range(rows):
            for c in range(cols):
                cell = grid[r][c]
                if cell > 1000:
                    continue
                destx, desty = self.calculate(k, r, c, rows, cols)
                while not (r == destx and c == desty):
                    self.swap(grid, r, c, destx, desty)
                    destx, desty = self.calculate(k, destx, desty, rows, cols)
                self.mark(grid, r, c)
                
    def calculate(self, k: int, currx: int, curry: int, rows: int, cols: int) -> Tuple[int, int]:
        desty = (curry + k) % cols
        destx = (currx + ((curry + k) // cols)) % rows
        return destx, desty
    
    def swap(self, m: List[List[int]], fromx: int, fromy: int, tox: int, toy: int):
        temp = m[tox][toy]
        m[tox][toy] = m[fromx][fromy] + 2001
        m[fromx][fromy] = temp
        
    def mark(self, m:List[List[int]], x: int, y: int):
        m[x][y] += 2001
        
    def redact(self, m: List[List[int]], rows: int, cols: int):
        for r in range(rows):
            for c in range(cols):
                m[r][c] -= 2001";"class Solution:
    def shiftGrid(self, grid, k):
        m = len(grid)
        n = len(grid[0])
        
        total_elements = m * n
        k = k % total_elements
        
        flat_list = []
        r = 0
        while r < m:
            c = 0
            while c < n:
                flat_list.append(grid[r][c])
                c = c + 1
            r = r + 1
            
        rotated_list = [0] * total_elements
        i = 0
        while i < total_elements:
            new_index = (i + k) % total_elements
            rotated_list[new_index] = flat_list[i]
            i = i + 1
        
        new_grid = []
        list_index = 0
        r = 0
        while r < m:
            new_row = []
            c = 0
            while c < n:
                new_row.append(rotated_list[list_index])
                list_index = list_index + 1
                c = c + 1
            new_grid.append(new_row)
            r = r + 1
            
        return new_grid"
"class Solution:
    def soupServings(self, n: int) -> float:
        if n > 4275: return 1                                        # handle special case
        n = n // 25 + (n%25 > 0)                                     # count size of tabulation
        dp = [[0] * (n+1) for _ in range(n+1)]
        dp[n][n] = 1
        for i in range(n, 0, -1):                                    # starting from (n, n) for each soup
            for j in range(n, 0, -1):
                for a, b in [[4, 0], [3, 1], [2, 2], [1, 3]]:
                    dp[max(0, i-a)][max(0, j-b)] += dp[i][j] * 0.25  # traverse backwards from (n,n) to (0,0)
        ans = dp[0][0] / 2                                           # half the probability when `a` &amp, `b` both use up at the same time
        for j in range(1, n+1):                                      # plus when `a` use up first
            ans += dp[0][j]
        return ans";"class Solution:
    def soupServings(self, n: int) -> float:
        if n >= 5000:
            return 1.0

        if n == 0:
            return 0.5

        N = (n + 24) // 25

        dp = []
        i = 0
        while i <= N:
            row = []
            j = 0
            while j <= N:
                row.append(0.0)
                j = j + 1
            dp.append(row)
            i = i + 1
        
        dp[0][0] = 0.5

        i = 1
        while i <= N:
            dp[0][i] = 1.0
            i = i + 1

        i = 1
        while i <= N:
            j = 1
            while j <= N:
                val1 = 0.0
                i_val1 = i - 4
                j_val1 = j
                if i_val1 < 0:
                    i_val1 = 0
                val1 = dp[i_val1][j_val1]

                val2 = 0.0
                i_val2 = i - 3
                j_val2 = j - 1
                if i_val2 < 0:
                    i_val2 = 0
                if j_val2 < 0:
                    j_val2 = 0
                val2 = dp[i_val2][j_val2]

                val3 = 0.0
                i_val3 = i - 2
                j_val3 = j - 2
                if i_val3 < 0:
                    i_val3 = 0
                if j_val3 < 0:
                    j_val3 = 0
                val3 = dp[i_val3][j_val3]

                val4 = 0.0
                i_val4 = i - 1
                j_val4 = j - 3
                if i_val4 < 0:
                    i_val4 = 0
                if j_val4 < 0:
                    j_val4 = 0
                val4 = dp[i_val4][j_val4]

                dp[i][j] = 0.25 * (val1 + val2 + val3 + val4)
                j = j + 1
            i = i + 1

        return dp[N][N]"
"class Solution:
    def findRelativeRanks(self, score: List[int]) -> List[str]:
        
        sorted_score = sorted(score, reverse=True)
        
        hashmap = {}
        
        if len(score) > 2:
            hashmap[sorted_score[0]] = ""Gold Medal""
            hashmap[sorted_score[1]] = ""Silver Medal""
            hashmap[sorted_score[2]] = ""Bronze Medal""
        
        elif len(score) == 1:
            return [""Gold Medal""]
        
        else:
            if score[0] > score[1]:
                return [""Gold Medal"", ""Silver Medal""]
            else:
                return [""Silver Medal"", ""Gold Medal""]
            
        rank = 4
        for index in range(3, len(sorted_score)):
            hashmap[sorted_score[index]] = str(rank)
            rank += 1
            
        
        return [hashmap[x] for x in score]";"class Solution:
    def findRelativeRanks(self, score: list[int]) -> list[str]:
        n = len(score)
        
        # Create a copy of the list to sort it
        sorted_scores = []
        for s in score:
            sorted_scores.append(s)
        
        # Sort the scores from highest to lowest
        sorted_scores.sort(reverse=True)
        
        # Create a dictionary to map a score to its rank
        ranks = {}
        
        # Assign the rank for each score
        i = 0
        while i < n:
            current_score = sorted_scores[i]
            if i == 0:
                ranks[current_score] = ""Gold Medal""
            elif i == 1:
                ranks[current_score] = ""Silver Medal""
            elif i == 2:
                ranks[current_score] = ""Bronze Medal""
            else:
                # Rank is the position + 1
                ranks[current_score] = str(i + 1)
            i = i + 1
        
        # Create the final answer list in the original order
        answer = []
        for s in score:
            # Find the rank for the original score
            rank = ranks[s]
            answer.append(rank)
            
        return answer"
"class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:        
        # Define some CORNER Cases #
		if len(nums) == 0:
            # Nothing to do if no integers are given
			return nums
        elif len(nums) == 1:
            # Nothing to do if single integer is given
			return list(map(str, nums))
        else:
            # MAIN program begins only if 2(+) integers are provided.
			# 1st convert all integers to strings
			str_num_list = list(map(str, nums))
			# Initiate 2 lists - Slave list constitutes the 1st element of the above list, while Master is initiated as blank list.  
            slave_list = [str_num_list[0]] , master_list = [] 
			# Invoke a Lambda function to be used later.  
			# The function appends the slave element to the master list if slave list only has a single element. 
			# Otherwise, it clips the 1st and last element of the slave list, adds a ""->"" character in between them, and then appends this new element in the master list. 
            add_2_master_list = lambda mlist, slist : mlist.append(slist[0] + str(""->"") + slist[-1]) if len(slist) > 1 else mlist.append(slist[0])
            # Run a loop from 2nd element to last 
			for i in str_num_list[1:]:
				# Check if reducing 1 from i doesn't gives us last element of slave list 
				if int(i)-1 != int(slave_list[-1]):
                    # If yes, invoke that lambda function &amp, start appending elements to the master list based on elements present in slave list
					add_2_master_list(master_list, slave_list)
                    # Clear the slave_list to prepare for the next element
					slave_list.clear()
                # After every iteration, keep on appending the items in slave. Note : Slave must never be kept empty.
				slave_list.append(i)
            # Once all iterations are done, whatever items are there in the slave list have to be now added to the master list.
			# Hence again invoke the lambda function. 
			add_2_master_list(master_list, slave_list)
            # Return the master list
			return master_list";"class Solution:
    def summaryRanges(self, nums):
        if not nums:
            return []

        result = []
        start_of_range = nums[0]

        index = 1
        while index < len(nums):
            if nums[index] == nums[index - 1] + 1:
                index = index + 1
            else:
                end_of_range = nums[index - 1]
                if start_of_range == end_of_range:
                    result.append(str(start_of_range))
                else:
                    range_string = str(start_of_range) + ""->"" + str(end_of_range)
                    result.append(range_string)
                
                start_of_range = nums[index]
                index = index + 1
        
        end_of_range = nums[len(nums) - 1]
        if start_of_range == end_of_range:
            result.append(str(start_of_range))
        else:
            range_string = str(start_of_range) + ""->"" + str(end_of_range)
            result.append(range_string)
            
        return result"
"class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        """"""
        Using a 2-pointer approach, compare two strings and determines if the first string is a subset of the second string.

        :param s:
            str: String of alpha characters
        :param t:
            str: String of alpha characters
        :return
            bool: True if first string is a contiguous subset of the second string
        """"""
        # Set variables equal to the length of each input string
        left_bound, right_bound = len(s), len(t)

        # Initialize index for each pointer
        p_left = p_right = 0

        while p_left < left_bound and p_right < right_bound:
            # Move both pointers if the equal each other
            if s[p_left] == t[p_right]:
                p_left += 1
            p_right += 1
        # Return when left pointer equals length of source string
        return p_left == left_bound";"class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        i = 0
        j = 0
        
        while i < len(s) and j < len(t):
            if s[i] == t[j]:
                i = i + 1
            j = j + 1
            
        if i == len(s):
            return True
        else:
            return False"
"class Solution:
    def brute_force(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N*N)
        Space Complexity: O(1)
        """"""
        for i in range(len(nums)):
            if i not in nums:
                return i
        return len(nums)
    
    def sorting(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(Nlog(N))
        Space Complexity: O(N)
        """"""
        nums.sort()
        
        for i, num in enumerate(nums):
            if i != num:
                return i
        return len(nums)
    
    def binary_search(self, nums: List[int]) -> int:
        """"""
        Time Complexity:
            O(Nlog(N)) if nums not sorted
            O(log(N)) if nums already sorted
        
        Space Complexity:
            O(N) if nums not sorted
            O(1) if nums sorted
        """"""
        nums.sort()
        left, right = 0, len(nums)
        mid = (left+right)//2
        while left < right:
            if nums[mid] == mid:
                left = mid+1
            else:
                right = mid - 1
            
            mid = (left + right)//2
        
        return mid + 1
    
    def hashing(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(N)
        """"""
        nums_set = set(nums)
        N = len(nums)
        for i in range(N):
            if i not in nums_set:
                return i
        
        return len(nums)
        
    def gauss_formula(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(1)
        """"""
        N = len(nums)
        return N*(N + 1)//2 - sum(nums)
    
    def xor(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(1)
        """"""
        result = len(nums)
        for i, v in enumerate(nums):
            result ^= i^v
        
        return result
    
    def cyclic_swapping(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(1)
        """"""
        current = 0
        N = len(nums)
        count = 0
        while current < N:
            count+= 1
            if nums[current] == N:
                current += 1
                continue
            
            if nums[current] == nums[nums[current]]:
                current += 1
            else:
                temp = nums[current]
                nums[current] = nums[nums[current]]
                nums[temp] = temp
        
        for i, v in enumerate(nums):
            if i != v:
                return i
        
        return N
    
    def value_inversion(self, nums: List[int]) -> int:
        """"""
        Time Complexity: O(N)
        Space Complexity: O(1)
        
        Advantages:
            - Original Input array can be restored
        """"""
        
        for i, _ in enumerate(nums):
            nums[i] += 1
        
        for i, v in enumerate(nums):
            if abs(v) > len(nums):
                continue
        
            nums[abs(v)-1] = -abs(nums[abs(v)-1])
        
        for i, v in enumerate(nums):
            if v > 0:
                return i
        
        return len(nums)
                
    
    def missingNumber(self, nums: List[int]) -> int:
        # return self.brute_force(nums)
        # return self.sorting(nums)
        # return self.hashing(nums)
        # return self.gauss_formula(nums)
        # return self.xor(nums)
        # return self.cyclic_swapping(nums)
        # return self.binary_search(nums)
        return self.value_inversion(nums)";"def missingNumber(nums):
    n = len(nums)

    expected_sum = 0
    i = 0
    while i <= n:
        expected_sum = expected_sum + i
        i = i + 1

    actual_sum = 0
    for num in nums:
        actual_sum = actual_sum + num

    missing = expected_sum - actual_sum
    return missing"
"class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        
        @cache
        def fn(n, k):
            """"""Return min moves given n floors and k eggs.""""""
            if k == 1: return n
            if n == 0: return 0 
            lo, hi = 1, n + 1
            while lo < hi: 
                mid = lo + hi >> 1
                if fn(mid-1, k-1) < fn(n-mid, k): lo = mid + 1
                else: hi = mid 
            return 1 + max(fn(lo-1, k-1), fn(n-lo, k))
        
        return fn(n, k)";"def superEggDrop(k, n):
    dp = []
    i = 0
    while i <= k:
        dp.append(0)
        i = i + 1

    moves = 0
    while dp[k] < n:
        moves = moves + 1
        j = k
        while j > 0:
            dp[j] = 1 + dp[j] + dp[j - 1]
            j = j - 1
    
    return moves"
"class Solution:
    def removeKdigits(self, nums: str, k: int) -> str:
       
        # Base Case
        if len(nums) == k:
            return ""0""
        
        # Init
        m = len(nums)
        
        # Build a monotonic stack, by removing
        # greater element previous to current
        # index
        stack = []
        for i in range(m):
            if stack:
                curr = int(nums[i])
                while k and stack and int(stack[-1]) > curr:
                    stack.pop()
                    k -= 1
            stack.append(nums[i])
        
        # Pop remaining k elements,
        # as they will be greatest in the
        # monotonic stack so created
        while k and stack:
            stack.pop()
            k -= 1
        
        # Join all the element in the stack
        # and first convert it to int, to
        # remove the leading zeros, and
        # then convert to string before
        # returning
        return str(int("""".join(stack)))
        
        """"""
        def REC(s: int, k: int, n: int):
            if n < 0 or k==0 or s=="""":
                return -1 if s=="""" else int(s)
            else:
                return min(REC(s[:n] + s[n+1:], k-1, n-1), REC(s,k,n-1))
        """"""
        
        """"""
        def REC(s: int, k: int, n: int, t: Dict = dict()):
            if n < 0 or k==0 or s=="""":
                return -1 if s=="""" else int(s)
            else:
                key = s 
                if key not in t:
                    t[key] = min(REC(s[:n] + s[n+1:], k-1, n-1, t), REC(s,k,n-1,t))
            return t[key]
        
        val = REC(nums, k, m-1)
        
        return """" if val == -1 else str(val) 
        """"""";"class Solucion:
    def removeKdigits(self, num, k):
        pila_numeros = []

        for digito in num:
            while pila_numeros and k > 0 and pila_numeros[-1] > digito:
                pila_numeros.pop()
                k = k - 1
            pila_numeros.append(digito)

        while k > 0:
            pila_numeros.pop()
            k = k - 1

        resultado_str = """"
        for elemento in pila_numeros:
            resultado_str = resultado_str + elemento

        if not resultado_str:
            return ""0""

        indice_inicio = 0
        longitud = len(resultado_str)
        while indice_inicio < longitud - 1 and resultado_str[indice_inicio] == '0':
            indice_inicio = indice_inicio + 1
        
        resultado_final = """"
        posicion_actual = indice_inicio
        while posicion_actual < longitud:
            resultado_final = resultado_final + resultado_str[posicion_actual]
            posicion_actual = posicion_actual + 1

        return resultado_final"
"class Solution(object):
    def removeComments(self, source):
        """"""
        :type source: List[str]
        :rtype: List[str]
        """"""
        
        # initialize some variables to save lines and valid characters
        result = []
        current_line = """"
        
        # initialize some state variables
        in_block = False
        in_line = False
        skip_next = False
        
        for line in source:
            
            # in a new line we will never skip the first character
            skip_next = False
            
            # a new line can never be part of an inline comment
            in_line = False
            
            for index, character in enumerate(line):
                
                # ----------------------------------------------------------------
                # Guard clauses that will always skip the character, if we are in
                # a comment or notified the loop to skip the next
                # -----------------------------------------------------------------
                
                # guard clause whether we want to skip the current character
                if skip_next:
                    
                    # reset the boolean in case we skip
                    skip_next = False
                    continue
                
                # guard clause whether we are in an in line comment
                # this comment can only be ended by a new line so we do not need
                # to check the current character
                if in_line:
                    continue
                    
                # guard clause whether we are in a block comment
                if in_block:
                    
                    # since the block comment can be ended, we need to check whether we find
                    # our ending symbol
                    # line[index:index+2] slicing works also at the end of a line
                    # (even if index+2 is out of scope)
                    if line[index:index+2] == '*/':
                        
                        # in case we found the end of the block comment we switch the bool to false
                        # and we need to skip the next character
                        # Our current character (line[index]) is '*' and the next is '/' which we skip
                        in_block = False
                        skip_next = True
                        continue
                    else:
                        
                        # we are still in block comment and therefore can continue
                        continue
                
                
                # ----------------------------------------------------------------
                # After all guard clauses passed, we are not in a comment and
                # we need to check the current character whether it starts one
                # -----------------------------------------------------------------
                
                # check whether block comment begins
                # slicing of list works even if index+2 is out of scope
                if line[index:index+2] == '/*':
                    
                    # switch the comment boolean and 
                    # tell our loop we need to skip the next character
                    # since it will be a '*'
                    in_block = True
                    skip_next = True
                    continue
                
                # check whether in line comment starts
                # slicing works also at end of line
                if line[index:index+2] == '//':
                    
                    # we switch the boolean and  skip the next character as it will be
                    # '/'
                    in_line = True
                    skip_next = True
                    continue
                
                # ----------------------------------------------------------------
                # Now that all checks have passed we found
                # a character that is part of the code
                # -----------------------------------------------------------------
                
                
                # append our character to the current line
                current_line += character
            
            
            # we will append the current line to our result (finalize a line in the output)
            # a) if we are not in a block comment that hasn't ended
            # b) and the current line has characters in it
            if not in_block and current_line:
                
                # append the line and reset the current line
                result.append(current_line)
                current_line = """"
                
        return result";"class Solution:
    def removeComments(self, source):
        result = []
        in_block_comment = False
        buffer = """"

        for line in source:
            i = 0
            n = len(line)
            while i < n:
                if in_block_comment:
                    if i + 1 < n and line[i] == '*' and line[i+1] == '/':
                        in_block_comment = False
                        i = i + 2
                    else:
                        i = i + 1
                else:
                    if i + 1 < n and line[i] == '/' and line[i+1] == '//':
                        break
                    elif i + 1 < n and line[i] == '/' and line[i+1] == '/*':
                        in_block_comment = True
                        i = i + 2
                    else:
                        buffer = buffer + line[i]
                        i = i + 1
            
            if not in_block_comment and len(buffer) > 0:
                result.append(buffer)
                buffer = """"
        
        return result"
"class Solution:
    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
        a,b,c = sorted((a,b,c))
        ans = inf
        def hcf(a,b):
            if a %b == 0: return b
            return hcf(b , a % b)
        p,q,r= hcf(a,b),hcf(b,c),hcf(a,c)
        s = hcf(r,b)
        x1 = (a*b) // p
        x2 = (b*c) // q 
        x3 = (a*c) // r
        x4 = (a * b * c * s)// (p * q * r )
        low,high = a , a *n
        while low <= high:
            mid = (low + high)//2
            times = mid//a + mid//b + mid//c - mid//x1 - mid//x2 - mid//x3 + mid//x4
            if times < n : low = mid + 1
            elif times == n:
                ans = min(ans,mid)
                high = mid - 1
            else: high = mid - 1
        return ans";"class Solution:
    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
        
        num1 = a
        num2 = b
        while num2 > 0:
            temp = num2
            num2 = num1 % num2
            num1 = temp
        gcd_ab = num1
        lcm_ab = (a * b) // gcd_ab

        num1 = a
        num2 = c
        while num2 > 0:
            temp = num2
            num2 = num1 % num2
            num1 = temp
        gcd_ac = num1
        lcm_ac = (a * c) // gcd_ac

        num1 = b
        num2 = c
        while num2 > 0:
            temp = num2
            num2 = num1 % num2
            num1 = temp
        gcd_bc = num1
        lcm_bc = (b * c) // gcd_bc

        num1 = lcm_ab
        num2 = c
        while num2 > 0:
            temp = num2
            num2 = num1 % num2
            num1 = temp
        gcd_abc = num1
        lcm_abc = (lcm_ab * c) // gcd_abc
        
        low = 1
        high = n * a 
        ans = high

        while low <= high:
            mid = low + (high - low) // 2
            
            count = 0
            count = count + mid // a
            count = count + mid // b
            count = count + mid // c
            count = count - mid // lcm_ab
            count = count - mid // lcm_ac
            count = count - mid // lcm_bc
            count = count + mid // lcm_abc
            
            if count >= n:
                ans = mid
                high = mid - 1
            else:
                low = mid + 1
        
        return ans"
"class Solution:
    def countAsterisks(self, s: str) -> int:
        count = 0
        if '|' not in s:
            count += s.count('*')
        while '|' in s:
            split_list = s.split('|', 2)
            count += split_list[0].count('*')
            s = split_list[2]
            if '|' not in split_list[2]:
                count += split_list[2].count('*')
        return count
    
# assert Solution().countAsterisks('""yo|uar|e**|b|e***au|tifu|l""') == 5
# assert Solution().countAsterisks('iamprogrammer') == 0
# assert Solution().countAsterisks('l|*e*et|c**o|*de|') == 2
# assert Solution().countAsterisks(""||*"") == 1
# assert Solution().countAsterisks(""|*|"") == 0
# assert Solution().countAsterisks(""||"") == 0
# assert Solution().countAsterisks(""*||"") == 1
# assert Solution().countAsterisks(""*"") == 1";"class Solution:
    def countAsterisks(self, s: str) -> int:
        bar_count = 0
        asterisk_count = 0
        
        for character in s:
            if character == '|':
                bar_count = bar_count + 1
            
            is_outside_pair = (bar_count % 2 == 0)
            
            if is_outside_pair:
                if character == '*':
                    asterisk_count = asterisk_count + 1
                    
        return asterisk_count"
"class Solution:
    def duplicateZeros(self, arr: List[int]) -> None:
        """"""
        Do not return anything, modify arr in-place instead.
        """"""
        possible_duplicates = 0
        length = len(arr) - 1
        # going left to right 
        # and counting zeros to be considered for duplication
        # why considering whole length of array and not leaving last element?
        # Ans:=> in this case last element could be zero and if we don't iterate over the whole array we would end up duplicating it in the next iteration as we would miss not considering the last element for no-duplication
        for left in range(length + 1):
            # left goes beyond allowed elements, stop iteration
            if left > length - possible_duplicates:
                break
            
            # count zeros
            if arr[left] == 0:
                # edge case: don't include the last element which can not be duplicated due to no more space available in the array
                if left == length - possible_duplicates:
                    # move this zero to the end of the array
                    arr[length] = arr[left]  # or 0
                    length -= 1  # we don't have to consider placing this element to its correct position because we already did so
                    break  # break out of the loop, we have already visited and seen all the elements that could be part of resulting arr, we don't have to calculate this 0 too.
                possible_duplicates += 1
        
        last_index = length - possible_duplicates
        # going right to left and placing elements at their correct index
        # also, duplicating zeros
        for right in range(last_index, -1, -1):
            if arr[right] == 0:
                arr[right + possible_duplicates] = arr[right]  # or 0
                # decrement zero
                possible_duplicates -= 1
                arr[right + possible_duplicates] = arr[right]  # or 0, duplicating zero
            
            else:
                arr[right + possible_duplicates] = arr[right]";"def duplicateZeros(arr):
    longitud_original = len(arr)
    i = 0
    while i < longitud_original:
        if arr[i] == 0:
            indice_final = longitud_original - 1
            while indice_final > i:
                arr[indice_final] = arr[indice_final - 1]
                indice_final = indice_final - 1
            i = i + 2
        else:
            i = i + 1"
"class Solution:
    def maximumGap(self, arr: List[int]) -> int:
        min1 = float('inf')
        max1 = float('-inf')
        n = len(arr)
        if (n < 2):
            return 0
        
        for i in range(0, n):
            min1 = min(min1, arr[i])
            max1 = max(max1, arr[i])
                
        if (max1 == min1):
            return 0
        gap = (max1 - min1) // (n-1)
        # print((max1-min1)/(n-1), min1, max1, n-1, max1-min1, 8/3)
        # print(gap)
        if ((max1 - min1) % (n-1) != 0):
            gap += 1 
        
        # print(gap, min1, max1)
        
        # new_arr = [0]*(n+1)
        # for i in range(0, n+1):
        #     new_arr[i]= [min1 + (i* gap), min1 + (i+1)*gap-1]
        # print(new_arr)
        min_bucket = [float('inf')] * (n)
        max_bucket = [float('-inf')] * (n)
        # print(min_bucket, max_bucket)
        for i in range(0, n):
            bucket_num = (arr[i] - min1) // gap
            # print(bucket_num)
            
            min_bucket[bucket_num] = min(arr[i], min_bucket[bucket_num])
            
            max_bucket[bucket_num] = max(arr[i], max_bucket[bucket_num])
            
            
        # print(min_bucket, max_bucket)
        
#         print(max_bucket[1])
        
#         if (max_bucket[1] == -inf):
#             print('es')
        
        prev = max_bucket[0]
        ans = float('-inf')
        for i in range(1, len(min_bucket)):
        # print(""Ok"", prev)
            if (prev == float('-inf') or min_bucket[i] == float('inf')): 
                # print(""EXE"")
                continue
            ans = max(ans, min_bucket[i] - prev)
            # print(""prev"",min_bucket[i], ans, prev)
            prev = max_bucket[i]

        return ans";"def maximum_gap(nums):
    n = len(nums)
    if n < 2:
        return 0

    min_val = nums[0]
    max_val = nums[0]
    for num in nums:
        if num < min_val:
            min_val = num
        if num > max_val:
            max_val = num

    if max_val == min_val:
        return 0

    bucket_size = (max_val - min_val) // (n - 1)
    if bucket_size == 0:
        bucket_size = 1
        
    bucket_count = ((max_val - min_val) // bucket_size) + 1

    buckets_min = []
    i = 0
    while i < bucket_count:
        buckets_min.append(None)
        i = i + 1

    buckets_max = []
    i = 0
    while i < bucket_count:
        buckets_max.append(None)
        i = i + 1

    for num in nums:
        bucket_index = (num - min_val) // bucket_size
        
        if buckets_min[bucket_index] is None:
            buckets_min[bucket_index] = num
        elif num < buckets_min[bucket_index]:
            buckets_min[bucket_index] = num
        
        if buckets_max[bucket_index] is None:
            buckets_max[bucket_index] = num
        elif num > buckets_max[bucket_index]:
            buckets_max[bucket_index] = num

    max_gap = 0
    previous_max = min_val
    i = 0
    while i < bucket_count:
        if buckets_min[i] is None:
            i = i + 1
            continue

        gap = buckets_min[i] - previous_max
        if gap > max_gap:
            max_gap = gap
        
        previous_max = buckets_max[i]
        i = i + 1

    return max_gap"
"class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if amount == 0 or not coins: return 0
        
        # this dp will hold the number of coins
        # required for every amount from 0..amount
        dp = [float('inf')] * (amount+1)
        
        # to have a sum of zero
        # we don't need any coins i.e 0
        dp[0] = 0
        
        # brute force, we'll calculate
        # the coins needed for every amount
        # starting from 1 since we've calculated 0
        for a in range(1, amount+1):
            # for every amount, we'll
            # try to form coins with every
            # available coin
            for c in coins:
                # if the current amount is less
                # than the current coin, you can't
                # make that amount with this coin
                # so skip it. i.e. if a = 2 and coin = 5
                # you should not bother computing anything here
                if a-c >= 0:
                    # otherwise, you check the min
                    # of the num(coins) for current amount
                    # and the 1 plus the coins required
                    # by amount-c i.e. to make the amount 0
                    # for e.g. if amount = 7 and coin = 3,
                    # we can say the coins needed to make 7
                    # would be the coin of denomination 4 (+1) and
                    # the number of coins taken to reach 3
                    # => 1 + dp[3] so that we can easily reach the sum i.e 7
                    dp[a] = min(dp[a], dp[a-c]+1)
            
        # we need to return -1 if we weren't able to find
        # an answer i.e. no updates were made and the amount
        # still has the initial value we had set i.e float('inf')
        return dp[amount] if dp[amount] != float('inf') else -1";"class Solution:
    def coinChange(self, coins, amount):
        max_value = amount + 1
        dp = []
        i = 0
        while i < amount + 1:
            dp.append(max_value)
            i = i + 1
        
        dp[0] = 0
        
        a = 1
        while a <= amount:
            for coin in coins:
                if coin <= a:
                    if dp[a - coin] != max_value:
                        new_count = 1 + dp[a - coin]
                        if new_count < dp[a]:
                            dp[a] = new_count
            a = a + 1
            
        if dp[amount] == max_value:
            return -1
        else:
            return dp[amount]"
"class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """"""
        Do not return anything, modify board in-place instead.
        """"""
        life = []
        for i in range(len(board)):
            col = []
            for j in range(len(board[0])):
                col.append(board[i][j])
            life.append(col)
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == 1:
                    if self.check(board,i,j) == True:
                        life[i][j] = 0
                else:
                    if self.check(board,i,j) == True:
                        life[i][j] = 1
        for i in range(len(life)):
            for j in range(len(life[0])):
                board[i][j] = life[i][j]
                
    def check(self,board,i,j):
        count = 0
        if board[i][j]==1:
            #diagonal top left to bottom right
            if i !=0 and j !=0 :
                if board[i-1][j-1] == 1:
                    count+=1
            if i != len(board)-1 and j != len(board[0])-1:
                if board[i+1][j+1] == 1:
                    count+=1
            #diagonal top right to bottom left
            if i!=0 and j != len(board[0])-1:
                if board[i-1][j+1] ==1:
                    count+=1
            if i!= len(board)-1 and j!=0:
                if board[i+1][j-1] == 1:
                    count +=1
            #top and bottom vertically
            if i!=0 and board[i-1][j]==1:
                count+=1
            if i!= len(board)-1 and board[i+1][j]==1:
                count +=1
            #left and right horizontally
            if j!=0 and board[i][j-1] ==1:
                count+=1
            if j!= len(board[0])-1 and board[i][j+1]==1:
                count+=1
            if count ==2 or count == 3:
                return False
            else:
                return True
        else:
            if board[i][j]==0:
                #diagonal top left to bottom right
                if i !=0 and j !=0 :
                    if board[i-1][j-1] == 1:
                        count+=1
                if i != len(board)-1 and j != len(board[0])-1:
                    if board[i+1][j+1] == 1:
                        count+=1
                #diagonal top right to bottom left
                if i!=0 and j != len(board[0])-1:
                    if board[i-1][j+1] ==1:
                        count+=1
                if i!= len(board)-1 and j!= 0:
                    if board[i+1][j-1] ==1:
                        count +=1
                #top and bottom vertically
                if i!=0 and board[i-1][j]==1:
                    count+=1
                if i!= len(board)-1 and board[i+1][j]==1:
                    count +=1
                #left and right horizontally
                if j!=0 and board[i][j-1] ==1:
                    count+=1
                if j!= len(board[0])-1 and board[i][j+1]==1:
                    count+=1
                if count == 3:
                    return True
                else:
                    return False";"class Solution:
    def gameOfLife(self, board):
        rows = 0
        for r in board:
            rows = rows + 1
        
        cols = 0
        if rows > 0:
            for c in board[0]:
                cols = cols + 1

        copy_board = []
        for r_idx in range(rows):
            new_row = []
            for c_idx in range(cols):
                new_row.append(board[r_idx][c_idx])
            copy_board.append(new_row)

        for r in range(rows):
            for c in range(cols):
                
                live_neighbors = 0

                if r > 0 and c > 0:
                    if copy_board[r - 1][c - 1] == 1:
                        live_neighbors = live_neighbors + 1
                
                if r > 0:
                    if copy_board[r - 1][c] == 1:
                        live_neighbors = live_neighbors + 1

                if r > 0 and c < cols - 1:
                    if copy_board[r - 1][c + 1] == 1:
                        live_neighbors = live_neighbors + 1

                if c > 0:
                    if copy_board[r][c - 1] == 1:
                        live_neighbors = live_neighbors + 1

                if c < cols - 1:
                    if copy_board[r][c + 1] == 1:
                        live_neighbors = live_neighbors + 1

                if r < rows - 1 and c > 0:
                    if copy_board[r + 1][c - 1] == 1:
                        live_neighbors = live_neighbors + 1

                if r < rows - 1:
                    if copy_board[r + 1][c] == 1:
                        live_neighbors = live_neighbors + 1
                
                if r < rows - 1 and c < cols - 1:
                    if copy_board[r + 1][c + 1] == 1:
                        live_neighbors = live_neighbors + 1

                if copy_board[r][c] == 1:
                    if live_neighbors < 2:
                        board[r][c] = 0
                    elif live_neighbors > 3:
                        board[r][c] = 0
                else:
                    if live_neighbors == 3:
                        board[r][c] = 1"
"class Solution:
	#Time-Complexity: O(logn * (n/2)) -> O(nlogn) -> while loop runs at most logn times since
	#we divide nums array size by half each iteration, and the for loop runs at most n/2 times!
	#Space-Complexity: O(logn * (n/2)) -> for each iteration of while loop, we allocate
	#copy array of size at worst (n/2) -> O(nlogn)
    def minMaxGame(self, nums: List[int]) -> int:
        
        #just simulate it?
        min_flag = True
        
        while len(nums) > 1:
            copy = []
            for i in range(0, len(nums)-1, 2):
                if(min_flag):
                    copy.append(min(nums[i], nums[i+1]))
                    min_flag = (not min_flag)
                    continue
                
                else:
                    copy.append(max(nums[i], nums[i+1]))
                    min_flag = (not min_flag)
                    continue
            
            nums = copy
            min_flag = True
        
        return nums[0]";"class Solution:
    def minMaxGame(self, nums: list[int]) -> int:
        longitud_actual = len(nums)

        while longitud_actual > 1:
            nueva_lista = []
            
            i = 0
            while i < longitud_actual / 2:
                
                if i % 2 == 0:
                    valor1 = nums[2 * i]
                    valor2 = nums[2 * i + 1]
                    if valor1 < valor2:
                        nueva_lista.append(valor1)
                    else:
                        nueva_lista.append(valor2)
                else:
                    valor1 = nums[2 * i]
                    valor2 = nums[2 * i + 1]
                    if valor1 > valor2:
                        nueva_lista.append(valor1)
                    else:
                        nueva_lista.append(valor2)
                
                i = i + 1

            nums = nueva_lista
            longitud_actual = len(nums)

        resultado_final = nums[0]
        return resultado_final"
"class Solution:
    def rob(self, nums: List[int]) -> int:
        # How many money we can make we we reach last house
        # How many money we can make when we reach i house
        # iterate from left to right
        # when reach i'th  house the money we can make is from
        # (First) dp[i-2] which is the maimum value we can make when reach (i-2)'th house plus the curr nums[i]
        # (Second) get the money from dp[i-1] which is the maximum value we can make when reach (i-1)'th house. However, we can't add current num[i], since when we take the money from (i-1)'th house, we can not take the adjacent house
        # store the maximum between (First) and (Second)
        # check the base case dp[0] give nums[0] is ok, However, dp[1] =  max(dp[1-1],dp[1-2]+nums[1]), we don't have dp[-1], therefore we give a extra space at the frony.
        # dp = [0]*(n+1). Therefore, i in dp correspond to i-1 in nums, That is now the dp[1] = nums[0]
        
        # Method 1
        # Time: O(n), Space: O(n)
        
        n = len(nums) 
        dp = [0]*(n+1)
        dp[1] = nums[0]
        for i in range(2,n+1):
            dp[i] = max(dp[i-1],dp[i-2]+nums[i-1])
        return dp[-1]
        
        # Method 2
        # Since we only need dp[i-1], dp[i-2]. we can create variable and save space
        # Time: O(n), Space: O(1)
        first = 0
        second = 0
        for num in nums:
            first, second =  second, max(first + num, second)
        return second            
            
        # Method 3 same as method 2
        # Time: O(n), Space: O(1)
        first_value = 0 
        second_value = 0
        
        for num in nums:
            temp = max(num + first_value, second_value)
            first_value = second_value
            second_value = temp
        return second_value";"class Solution:
    def rob(self, nums: list[int]) -> int:
        rob1 = 0
        rob2 = 0

        # [rob1, rob2, n, n+1, ...]
        for n in nums:
            temp = max(n + rob1, rob2)
            rob1 = rob2
            rob2 = temp
        
        return rob2"
"class Solution:
    def minimizeXor(self, num1: int, num2: int) -> int:
        # determine number of 1's in binary representation
        # which is also equal to bin(num2[1:]).count(""1"")
        n2 = 0
        while num2:
            if num2 &amp, 1:    # last bit is 1
                n2 += 1     # increase count
            num2 >>= 1      # shift the binary number to the right

        # search for indices for 0's and 1's
        # n = 110 (binary form) => bits1{0: [0], 1: [1, 2]}
        bits1 = {0: [], 1: []}
        i = 0    # index from the right side
        while num1:
            if num1 &amp, 1:   # decide which list to append
                bits1[1].append(i)
            else:
                bits1[0].append(i)
            i += 1        # increase index
            num1 >>= 1    # shift the number to the right

        # list of positions - reversed for 1 (left to right)
        # straight for 0 (right to left)
        target_pos = bits1[1][::-1] + bits1[0]    # positions for 1
        # if we need more 1's to be placed into the target number
        if len(target_pos) < n2:
            next_pos = target_pos[0] + 1    # most left position
            # fill it in with consecutive positions
            target_pos += list(range(next_pos,
                                     next_pos + n2 - len(target_pos)))
        # cut the list to the required length n2
        target_pos = target_pos[:n2]
        # find the final number by shifting 1's to the target positions
        # e.g. target = 101 == 100 + 001 in binary
        return sum(1 << pos for pos in target_pos)";"class Solution:
    def minimizeXor(self, num1: int, num2: int) -> int:
        set_bits_num2 = 0
        temp_num = num2
        while temp_num > 0:
            if (temp_num & 1) == 1:
                set_bits_num2 = set_bits_num2 + 1
            temp_num = temp_num >> 1

        set_bits_num1 = 0
        temp_num = num1
        while temp_num > 0:
            if (temp_num & 1) == 1:
                set_bits_num1 = set_bits_num1 + 1
            temp_num = temp_num >> 1

        x = num1

        if set_bits_num1 > set_bits_num2:
            bits_to_turn_off = set_bits_num1 - set_bits_num2
            i = 0
            while bits_to_turn_off > 0:
                bit_mask = 1 << i
                if (x & bit_mask) != 0:
                    x = x ^ bit_mask
                    bits_to_turn_off = bits_to_turn_off - 1
                i = i + 1

        elif set_bits_num1 < set_bits_num2:
            bits_to_turn_on = set_bits_num2 - set_bits_num1
            i = 0
            while bits_to_turn_on > 0:
                bit_mask = 1 << i
                if (x & bit_mask) == 0:
                    x = x | bit_mask
                    bits_to_turn_on = bits_to_turn_on - 1
                i = i + 1

        return x"
"class Solution:
    def wordPattern(self, letters: str, words: str) -> bool:
        '''
		Renamed parameters to less confusing names.
		""patterns"" to ""letters"".
		""s"" to ""words"".
		
		Solution:
		
        Return False if the number of letters and words are not the same.
   
        Traverse the letters, one by one and return False if:
        
        A letter together with its corresponding word in words
        (same index as in letters) meets a condition when compared:
        
        With letters as keys in the dictonary and words as
        corresponding values:
        
        1. Return False if: 
           Current letter/key in loop already exists but
           isn't the same as the letter/word pair currently in comparison.
        
        2. Return False if:
           Current letter in loop is not yet a key but the corresponding
           word is a value in the dictionary already. 
           (Otherwise add the letter and word 
           as key/value pairs to the dict)
           
        Return True if the loop is complete, which means that all letters 
		have been compared with corresponding words without finding any of the
		above issues.
        '''
        
        words = words.split()
        
        if len(letters) != len(words):
            return False
			
		pairs = dict()
        
        for i, letter in enumerate(letters):
            if letter in pairs.keys():
                if pairs[letter] != words[i]:
                    return False
            elif words[i] not in pairs.values():
                pairs[letter] = words[i]
            else:
                return False
            
        return True";"class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        palabras = s.split(' ')

        if len(pattern) != len(palabras):
            return False

        mapa_caracter_a_palabra = {}
        mapa_palabra_a_caracter = {}

        i = 0
        while i < len(pattern):
            caracter = pattern[i]
            palabra = palabras[i]

            if caracter in mapa_caracter_a_palabra:
                if mapa_caracter_a_palabra[caracter] != palabra:
                    return False
            else:
                if palabra in mapa_palabra_a_caracter:
                    return False
                else:
                    mapa_caracter_a_palabra[caracter] = palabra
                    mapa_palabra_a_caracter[palabra] = caracter
            
            i = i + 1

        return True"
"class Solution:            # Suppose for example:
                           #    words1 = ['food', 'coffee', 'foofy']
                           #    words2 = ['foo', 'off']
                           #  
                           # Here's the plan:
                           #   1) Construct a dict in which the key is a char in
                           #      one or more words in words2, and the key's max
                           #      count in those words.
                           #            for 'foo': c2 = {'o': 2, 'f': 1}
                           #            for 'off': c2 = {'o': 1, 'f': 2}
                           #            so: d = {'o': 2, 'f': 2}
                           #
                           #   2) Use a counter for each word in words1 to determine 
                           #      whether the word has at least the quantity of each char
                           #      in d:
                           #            for 'food'  : c1 = {'o': 2, 'f': 1, 'd': 1}          (fails at 'f')
                           #            for 'coffee': c1 = {'f': 2, 'e': 2, 'o': 1, 'c': 1 } (fails at 'o')
                           #            for 'foofy ': c1 = {'f': 2, 'o': 2, 'y': 1}          (success)
                           #
                           #   3) return answer:
                           #            answer = ['foofy'] 
                           #
    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:
        d, ans = defaultdict(int), []

        for word in words2:                     #  <-- 1)
            c2 = Counter(word)
            for ch in c2:
                d[ch] = max(d[ch], c2[ch])

        for word in words1:                     #  <-- 2)
            c1 = Counter(word)

            for ch in d:
                if c1[ch] < d[ch]: break
            else:
                ans.append(word)                #  <-- else executes only if the for-loop
                                                #      completes without break

        return ans                              #  <-- 3)";"def wordSubsets(words1, words2):
    max_counts = [0] * 26
    for word in words2:
        word2_counts = [0] * 26
        for char in word:
            index = ord(char) - ord('a')
            word2_counts[index] = word2_counts[index] + 1
        
        i = 0
        while i < 26:
            if word2_counts[i] > max_counts[i]:
                max_counts[i] = word2_counts[i]
            i = i + 1

    result = []
    for word in words1:
        word1_counts = [0] * 26
        for char in word:
            index = ord(char) - ord('a')
            word1_counts[index] = word1_counts[index] + 1
        
        is_universal = True
        i = 0
        while i < 26:
            if word1_counts[i] < max_counts[i]:
                is_universal = False
                break
            i = i + 1
        
        if is_universal:
            result.append(word)
            
    return result"
"class Solution:
    def isHappy(self, n: int) -> bool:   
        # Maintain the additions we have done, so we know when the loop goes infinite
        duplicate = {}
        
        # Use recursion: calculate sum of digits, add to duplicates map, and re-call the method
        def check(n: int) -> bool:
            if n == 1:
                # we return true -> since it is a happy number
                return True
            
            # Find the digits. Note: order in the list does not matter here. 
            res = []
            while n > 0:
                w = n%10
                res.append(w)
                n = n//10
        
            # Since we have the digits now, add the digits
            add = 0
            for num in res:
                add += num**2
            
            # Return False if sum in duplicate map, or re-call the method with new sum
            if add in duplicate:
                # Loop detected
                return False
            else:
                duplicate[add] = 0
                return check(add)
        
        # calling the main method
        return check(n)";"class Solution:
    def isHappy(self, n: int) -> bool:
        numeros_vistos = []
        while n != 1:
            if n in numeros_vistos:
                return False
            
            numeros_vistos.append(n)
            
            suma_cuadrados = 0
            numero_temporal = n
            
            while numero_temporal > 0:
                digito = numero_temporal % 10
                suma_cuadrados = suma_cuadrados + (digito * digito)
                numero_temporal = numero_temporal // 10
            
            n = suma_cuadrados
            
        return True"
"class Solution:
    def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:
        # Stack: go from back and use stack to get ans
        # Time: O(n)
        # Space: O(n)
        
        stack = [] # index
        ans = [-1] * len(cars)
        for i in range(len(cars)-1,-1,-1):
            # remove cars that are faster than current car since it will never collide
            while stack and cars[i][1] <= cars[stack[-1]][1]: 
                stack.pop()

            while stack: # if car left, we can compute collide time with current car. 
                collision_t = (cars[stack[-1]][0] - cars[i][0]) / (cars[i][1] - cars[stack[-1]][1])
                # if current car's collide time is greater than previous car's collide time 
                # (previous collided before current), then we have to find previous car's previous car
                # to compute collide time with that car, so we pop from stack and re-process
                # Otherwise, we add that collide time to answer and break
                if ans[stack[-1]] == -1 or collision_t <= ans[stack[-1]]:
                    ans[i] = collision_t
                    break
                stack.pop()
            stack.append(i)
        return ans";"n = len(cars)
respuesta = []
contador = 0
while contador < n:
    respuesta.append(-1.0)
    contador = contador + 1

pila = []

i = n - 1
while i >= 0:
    posicion_i = cars[i][0]
    velocidad_i = cars[i][1]
    
    while len(pila) > 0:
        j = pila[-1]
        posicion_j = cars[j][0]
        velocidad_j = cars[j][1]
        
        if velocidad_i <= velocidad_j:
            pila.pop()
        else:
            tiempo_choque = (posicion_j - posicion_i) / (velocidad_i - velocidad_j)
            
            if respuesta[j] != -1.0 and tiempo_choque >= respuesta[j]:
                pila.pop()
            else:
                respuesta[i] = tiempo_choque
                break
    
    pila.append(i)
    i = i - 1"
"class Solution:
    def closestRoom(self, rooms: List[List[int]], queries: List[List[int]]) -> List[int]:
        ans = [0] * len(queries)
        
        # sort queries to handle largest size queries first
        q = deque(sorted([(size, room, i) for i, (room, size) in enumerate(queries)], key=lambda a: (-a[0], a[1], a[2])))

        # sort rooms by descending size
        rooms = deque(sorted(rooms, key=lambda x: -x[1]))

        # current available room ids
        cands = []
        
        
        while q:
            size, room, i = q.popleft()
            # add room ids to candidates as long as top of room size meet the requirements
            while rooms and rooms[0][1] >= size:
                bisect.insort(cands, rooms.popleft()[0])
                    
            # if no room size available, return -1
            if not cands: ans[i] = -1
                
            # else use bisect to find optimal room ids
            else:
                loc = bisect.bisect_left(cands, room)
                if loc == 0: ans[i] = cands[loc]
                elif loc == len(cands): ans[i] = cands[-1]
                else: ans[i] = cands[loc - 1] if room - cands[loc - 1] <= cands[loc] - room else cands[loc]
        
        return ans";"def closestRoom(rooms, queries):
    answer = []
    for query in queries:
        preferred = query[0]
        minSize = query[1]
        
        best_room_id = -1
        smallest_abs_diff = 2000000001

        for room in rooms:
            room_id = room[0]
            size = room[1]
            
            if size >= minSize:
                current_diff = preferred - room_id
                if current_diff < 0:
                    current_diff = -current_diff

                if current_diff < smallest_abs_diff:
                    smallest_abs_diff = current_diff
                    best_room_id = room_id
                elif current_diff == smallest_abs_diff:
                    if best_room_id > room_id:
                        best_room_id = room_id
                        
        answer.append(best_room_id)
        
    return answer"
"class Solution:
    def stoneGameV(self, stoneValue: List[int]) -> int:
        def getPartialSum():
            for i in range(n):
                partial_sum[i][i] = stoneValue[i]
            for i in range(n):
                for j in range(i+1, n):
                    partial_sum[i][j] = partial_sum[i][j-1]+stoneValue[j]
                               
        # (O(n) search)    
        def preCalCutIdx():
            # based on the fact that cut index is increasing with k for 
            # partial_sum[start][k]
            for i in range(n-1):
                cp = i
                cut_index[i][i+1] = i
                for j in range(i+2, n):
                    while cp < j-1 and partial_sum[i][cp] < partial_sum[cp+1][j]:
                        cp += 1  
                    cut_index[i][j] = cp
		
			
        @lru_cache(None)
        def dfs(start, end):
            if start >= end:
                return 0
            max_score = 0
            # find first cut s.t. left sum >= right sum 
            cut = cut_index[start][end]
            # we can't find cut s.t. left sum >= right sum
            if cut == -1:
                cut = end-1
            sum1 = partial_sum[start][cut]
            sum2 = partial_sum[cut+1][end]
            if sum1 < sum2:
                # calcuate left[start][cut] if not yet
                dfs(start, cut)
                # the remaining will be the left part for sure, no 
                # matter where the cut is. 
                max_score = left[start][cut]
            elif sum1 == sum2:
                dfs(start, cut)
                dfs(cut+1, end)
                # if real cut in the range of [cut+1, end], remaining will be the right part
                # if real cut in the range of [0, cut], remaing will be the left part
                # if real cut is cut, either can be the remaining. 
                max_score = max(left[start][cut], right[cut+1][end])
            else:
                dfs(cut+1, end)
                # we are selecting the cut in the range of [cut, end] having 
                # the max score. For cut in that range, the remaining is 
                # the right part of the cut for sure. 
                max_score = right[cut+1][end]
                if cut > start:
                    dfs(start, cut-1)
                    # we are selecting the cut in the range of [0, cut] having 
                    # the max score. The remaining is the left part for sure. 
                    max_score = max(max_score, left[start][cut-1])
            dfs(start, end-1)
            dfs(start+1, end)
            # updating left and right arrays. 
            left[start][end] = max(left[start][end-1], partial_sum[start][end]+max_score)
            right[start][end] = max(right[start+1][end], partial_sum[start][end]+max_score)
            return max_score
            
        n = len(stoneValue)
        partial_sum = [[0]*n for _ in range(n)]
        cut_index = [[-1]*n for _ in range(n)]
        # left[i][j]: cut in the range of [i, j], max score of left part
        # right[i][j]: cut in the range of [i, j], max score of right part
        left = [[0]*n for _ in range(n)]
        right = [[0]*n for _ in range(n)]
        for i in range(n):
            left[i][i] = stoneValue[i]
            right[i][i] = stoneValue[i]
        getPartialSum()
        # for partial_sum[i][j], find cut index between i and j 
        # s.t partial_sum[i][cut_index] >= partial_sum[cut_index+1][j] or 
        # cut_index = j-1 if not exist. 
        preCalCutIdx()
        return dfs(0, n-1)";"class Solution:
    def stoneGameV(self, stoneValue: list[int]) -> int:
        n = len(stoneValue)

        if n <= 1:
            return 0

        prefix_sum = [0] * (n + 1)
        total = 0
        i = 0
        while i < n:
            total = total + stoneValue[i]
            prefix_sum[i + 1] = total
            i = i + 1

        dp = []
        i = 0
        while i < n:
            new_row = []
            j = 0
            while j < n:
                new_row.append(0)
                j = j + 1
            dp.append(new_row)
            i = i + 1

        length = 2
        while length <= n:
            i = 0
            while i <= n - length:
                j = i + length - 1
                
                max_for_range = 0
                
                k = i
                while k < j:
                    left_sum = prefix_sum[k + 1] - prefix_sum[i]
                    right_sum = prefix_sum[j + 1] - prefix_sum[k + 1]
                    
                    current_score = 0
                    if left_sum < right_sum:
                        current_score = left_sum + dp[i][k]
                    elif right_sum < left_sum:
                        current_score = right_sum + dp[k + 1][j]
                    else:
                        option1 = dp[i][k]
                        option2 = dp[k + 1][j]
                        if option1 > option2:
                            current_score = left_sum + option1
                        else:
                            current_score = left_sum + option2

                    if current_score > max_for_range:
                        max_for_range = current_score
                    
                    k = k + 1
                
                dp[i][j] = max_for_range
                i = i + 1
            length = length + 1
            
        return dp[0][n-1]"
"class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:  # Time: O(n) and Space: O(1)

        # Find Middle: find middle and divide the list in to two
        slow, fast = head, head.next  # head(slow) -> 1 -> 2(fast) -> ...
        while fast and fast.next:     # while fast exists and there is next element to travel keep moving
            slow = slow.next          # fast moving twice as much as slow, will lead slow to point in the middle 
            fast = fast.next.next     # Even(4): slow = 2, fast = 4 &amp, Odd(5): slow = 3, fast = None 

        # Reverse: reverse the second list
        second = slow.next       # in Odd case lets say 1-> 2(slow) -> 3 -> 4(fast): second = 3(2.next) 
        prev = slow.next = None  # Created Two separate nodes 1->2 &amp, 3->4 
        while second:
            tmp = second.next   # tmp = 4
            second.next = prev  # 3 -> None
            prev = second       # prev = 3
            second = tmp        # second = 4
        # So, in the next iteration 
            # tmp = None 
            # 4.next = prev(3) and our linked is reversed
			# prev = 4 
			# second = None

        # Merge: merge the first with the reversed second  
        first, second = head, prev  # first will point to starting of the 1st Node and second to 2nd Node
        while second:
            tmp1, tmp2 = first.next, second.next  # tmp1 = 2, tmp2 = 3
            first.next = second                   # 1 -> 4
            second.next = tmp1                    # 4.next = 2 i.e. 1 -> 4 -> 2 
            first, second = tmp1, tmp2            # first = 2, second = 3
        # So, in the next iteration 
            # tmp1 = tmp2 = None
            # 2 -> 3 i.e. 1 -> 4 -> 2 -> 3
            # 1 -> 4 -> 2 -> 3 -> None
			# first = second = None";"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reorderList(head: ListNode) -> None:
    if not head or not head.next:
        return

    slow = head
    fast = head
    while fast.next and fast.next.next:
        slow = slow.next
        fast = fast.next.next

    second_half = slow.next
    slow.next = None

    prev = None
    current = second_half
    while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
    
    second_half_reversed = prev

    first_half = head
    while second_half_reversed:
        temp1 = first_half.next
        temp2 = second_half_reversed.next
        
        first_half.next = second_half_reversed
        second_half_reversed.next = temp1
        
        first_half = temp1
        second_half_reversed = temp2"
"class Solution:
    def countPrimes(self, n: int) -> int:
        # Prerequisite:
        # What is prime number. What are they just the starting. 
        
        truth = [True]*n # making a list of lenght n. And keep all the values as True.
        if n<2: # as 0 &amp, 1 are not prime numbers. 
            return 0
        truth[0], truth[1] = False, False #as we added True in the truth list. So will make false for ) &amp, 1 as they are not prime numbers.
        
        i=2 # As we know 0 &amp, 1 are not prime.
        while i*i<n: # why we are doing it as i*i here is bcz lets say 5*2 = 10 is divisble by 2 as well as 5 so if 10 is already removed why to traverse a value which is already travered once. so in case of n=5 - 5<5. CONCLUSION : i<sqrt(n)
#why we are running the loop till n is bcz question says "" prime numbers that are strictly less than n"".
            if truth[i] == True:
                for j in range(i*i,n,i): # if we have mutiple of a number in the range of n, we have to remove them as they can be prime. i.e 2 is prime, but its multiple in n = 10 are 4,6,8 they cant be prime. So we will make them false(means not a prime).
                    truth[j]=False
            i += 1 # increasing our iterator.
        return truth.count(True) # will count true value";"class Solution:
    def countPrimes(self, n: int) -> int:
        if n < 3:
            return 0

        numbers_are_prime = [True] * n
        numbers_are_prime[0] = False
        numbers_are_prime[1] = False

        p = 2
        while p * p < n:
            if numbers_are_prime[p] == True:
                multiple = p * p
                while multiple < n:
                    numbers_are_prime[multiple] = False
                    multiple = multiple + p
            p = p + 1

        count = 0
        i = 0
        while i < n:
            if numbers_are_prime[i] == True:
                count = count + 1
            i = i + 1
            
        return count"
"class Solution:
    def isPowerOfTwo(self, x: int) -> bool:
        
        # TC = O(1), SC = O(1)
        
        # a power of 2 has only kth bit set in its binary representation 
        # and ( power of 2 ) - 1 -> has all bits set except the kth bit
        # so taking bitwise of these two numbers would always give 0
        
        return (x!=0) and (x &amp, (x-1)) == 0
		
		# Example 1:
        # if x = 0 ans = False 
        # if x = 1 ans = True and 1 &amp, 0 == 0 -> True so True and True = True
        #   00000
        # &amp, 00001
        # ---------
        #   00000
        # ---------
		
		# Example 2:
		# if x = 16 , then x - 1 = 15, so x &amp, x-1 == 0 will check:
		# 16 =     10000       
		# 15 =  &amp,  01111
		# --------------------
		#          00000
		# --------------------";"class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n <= 0:
            return False
        
        numero = n
        
        while numero > 1:
            if numero % 2 != 0:
                return False
            numero = numero // 2
            
        return True"
"class Solution:
    def reverseBits(self, n: int) -> int:
        
    # Short Version
        out = str(bin(n))[::-1][:-2]
        while len(out) < 32:
            out += '0'
        return int(out, 2)
    
    # Long, step-by-step version
    # First, let's see the binary of the original number
        #print(bin(n))
        
    # Then, let's turn the number into binary, and a string and save it to a variable
        #out = str(bin(n))
        #print(out)
        
    # Next, this is fancy python for: iterate through the list from end to start in increments of -1 (backwards)
    # returning each element. This effectively reverses the string from the step above.
        #out = out[::-1]
        #print(out)

    # Now, since we turned the binary representation into a string, we have a ""0b"" at the end (since we reversed order)
    # We can remove it with python indexing [:-2]
        #out = out[:-2]
    
    # The input binary may have had leading zeros that would have been truncated
    #   i.e. 000101 -> 101
    # When reversed, those zeros are important
    #   101000 =/= 101 
    # Since we know the input number is always 32 bits, we can just add trailing zeros until we reach a length of 32
        #while len(out) < 32:
        #    out += '0'
        #print(out)
    
    # Finally, we can convert back to base-10 and return!
        #out = int(out, 2)
        #return out";"class Solution:
    def reverseBits(self, n: int) -> int:
        resultado = 0
        i = 0
        while i < 32:
            resultado = resultado << 1
            ultimo_bit = n & 1
            resultado = resultado | ultimo_bit
            n = n >> 1
            i = i + 1
        return resultado"
"class Solution:
    def readBinaryWatch(self, turnedOn: int) -> List[str]:
        ans = set()
        m_so_far = 0
        h_so_far = 0
        #hashmap tells the possible hr and min values we can recurse on!
        hashmap = {}
        hashmap[""hr""] = [1, 2, 4, 8]
        hashmap[""min""] = [1, 2, 4, 8, 16, 32]
        
        #Paramters:
        #1. LEDS -> tell number of LEDS turned on so far!
        #2. hr_set -> set of all hour values that are already used and not available!
        #3. min_set -> similar idea as hr_set!
        def helper(LEDS, hr_set, min_set):
            nonlocal m_so_far, h_so_far, ans, turnedOn, hashmap
            #check if m_so_far or h_so_far is out of range -> invalid time!
            if(m_so_far > 59 or h_so_far > 11):
                return
            
            #base case: LEDS == input: number of turnedOn!
            #we used all LEDs and current time is valid! So we need to record it!
            if(LEDS == turnedOn):
                m_string = """"
                #if minute is single digit, we need a leading zero!
                if(0<= m_so_far <= 9):
                    m_string = m_string + ""0"" + str(m_so_far)
                else:
                    m_string = str(m_so_far)
                #no leading zero for hour!
                res = str(h_so_far) + "":"" + m_string
                ans.add(res)
                return
            
            #otherwise, we can recurse over all 4 hour values nad 6 minutes values and
            #use them only if they are not already in set! 
            for hour in hashmap[""hr""]:
                if(hour in hr_set):
                    continue
                hr_set.add(hour)
                #update the hour count and add to set before recursing!
                h_so_far += hour
                
                helper(LEDS + 1, hr_set, min_set)
                #once rec. call returns, update the count of hours as well as state of hr!
                h_so_far -= hour
                hr_set.remove(hour)
            
            for minute in hashmap[""min""]:
                if(minute in min_set):
                    continue
                
                min_set.add(minute)
                m_so_far += minute
                
                helper(LEDS + 1, hr_set, min_set)
                m_so_far -= minute
                min_set.remove(minute)
        
        helper(0, set(), set())
        return list(ans)";"def readBinaryWatch(turnedOn):
    result = []
    h = 0
    while h < 12:
        m = 0
        while m < 60:
            hour_bits = bin(h).count('1')
            minute_bits = bin(m).count('1')

            if hour_bits + minute_bits == turnedOn:
                minute_string = str(m)
                if m < 10:
                    minute_string = ""0"" + str(m)
                
                hour_string = str(h)
                
                time_string = hour_string + "":"" + minute_string
                result.append(time_string)
            
            m = m + 1
        h = h + 1
        
    return result"
"class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        swaps, i = 0, 0
        while swaps < len(nums): # we only make the necessary amount of swaps for each entry
            start, num = i, nums[i] # start index and current number to swap
            while True:
                temp = nums[(i+k) % len(nums)] # save the value at the final location of the current value
                nums[(i+k) % len(nums)] = num # store current value at final location
                num = temp # value at final location will now be placed at its final location next iteration
                swaps += 1 # update number of swaps
                i = (i+k) % len(nums) # update index
                if start == i: break # if we have swapped all entries in the group then break
            i += 1 # if we have to loop again, when len(nums) % k == 0, then we move to the next index";"class Solution:
    def rotate(self, nums, k):
        n = len(nums)
        
        if n == 0:
            return
        
        k = k % n
        
        if k == 0:
            return
            
        copia_nums = []
        for elemento in nums:
            copia_nums.append(elemento)
            
        for i in range(n):
            nueva_posicion = i + k
            if nueva_posicion >= n:
                nueva_posicion = nueva_posicion - n
            
            nums[nueva_posicion] = copia_nums[i]"
"class Solution:
    def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:
        if not p1 != p2 != p3 != p4: return False            # 4 points have to be different
        dis = lambda x, y: (y[1]-x[1])**2 + (y[0]-x[0])**2   # lambda function to calc distance**2
        points = [p1, p2, p3, p4]
        d = collections.defaultdict(list)
        for i in range(4):                                   # calculate distance between each points to other 3
            for j in range(i+1, 4):
                distance = dis(points[i], points[j])
                d[tuple(points[i])].append(distance)
                d[tuple(points[j])].append(distance)
        for point, distances in d.items():                   # check neighbour edges equality &amp, Pythagoras theorem
            distances.sort()
            if not (distances[0] == distances[1] and sum(distances[:2]) == distances[2]): return False
        return True";"class Solution:
    def validSquare(self, p1, p2, p3, p4):
        d12 = (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2
        d13 = (p1[0] - p3[0])**2 + (p1[1] - p3[1])**2
        d14 = (p1[0] - p4[0])**2 + (p1[1] - p4[1])**2
        d23 = (p2[0] - p3[0])**2 + (p2[1] - p3[1])**2
        d24 = (p2[0] - p4[0])**2 + (p2[1] - p4[1])**2
        d34 = (p3[0] - p4[0])**2 + (p3[1] - p4[1])**2

        distances = [d12, d13, d14, d23, d24, d34]
        
        counts = {}
        for d in distances:
            if d == 0:
                return False
            if d in counts:
                counts[d] = counts[d] + 1
            else:
                counts[d] = 1
        
        if len(counts) != 2:
            return False

        keys = []
        for k in counts:
            keys.append(k)
        
        side_squared = 0
        diag_squared = 0
        
        if counts[keys[0]] == 4:
            side_squared = keys[0]
            diag_squared = keys[1]
        elif counts[keys[1]] == 4:
            side_squared = keys[1]
            diag_squared = keys[0]
        else:
            return False
            
        if diag_squared == 2 * side_squared:
            return True
        else:
            return False"
"class Solution:
    def minJumps(self, arr: List[int]) -> int:
        
        n = len(arr)
        visited = set()
        
        
        if n <= 1:
            return 0
        
        same_value = dict()
        
        for i, v in enumerate(arr):
            if v not in same_value.keys():
                same_value[v]= [i]
            else:
                same_value[v].append(i)
                
        stack = list()
        level = 0
        
        stack.append((0,0))
        total = -1
        
        
        while stack:
            level,node = stack.pop(0)
        
            visited.add(node)
            
            if node == n-1:
                return level
            else:
                for a in same_value[arr[node]] :
                    if a != node and a not in visited:
                        stack.append((level+1,a))
                
                same_value[arr[node]].clear()
                
                if node+1 < n and node+1 not in visited:
                    stack.append((level+1,node+1))
                 
                if node-1 >=0 and node-1 not in visited:
                    stack.append((level+1,node-1))
                    

                                 
        return level";"def minJumps(arr):
    n = len(arr)
    if n <= 1:
        return 0

    value_map = {}
    i = 0
    while i < n:
        value = arr[i]
        if value in value_map:
            value_map[value].append(i)
        else:
            value_map[value] = [i]
        i = i + 1

    queue = [(0, 0)]
    
    visited = []
    i = 0
    while i < n:
        visited.append(False)
        i = i + 1
    visited[0] = True

    while len(queue) > 0:
        index, steps = queue.pop(0)

        if index == n - 1:
            return steps

        # Jump to i + 1
        next_index = index + 1
        if next_index < n and not visited[next_index]:
            visited[next_index] = True
            queue.append((next_index, steps + 1))

        # Jump to i - 1
        prev_index = index - 1
        if prev_index >= 0 and not visited[prev_index]:
            visited[prev_index] = True
            queue.append((prev_index, steps + 1))

        # Jump to j where arr[i] == arr[j]
        val = arr[index]
        if val in value_map:
            indices_with_same_value = value_map[val]
            for j in indices_with_same_value:
                if not visited[j]:
                    visited[j] = True
                    queue.append((j, steps + 1))
            # Avoid re-processing these jumps
            del value_map[val]
    
    return -1"
"class Solution:
    def findWords(self, words: List[str]) -> List[str]:
        l=[""qwertyuiop"",""asdfghjkl"",""zxcvbnm""] #This list contains alphabets which are in one row of keyboard , total three rows, hence three strings
        l1=[]
		'''
		i.)We now check if all the letter in word is present in a row or not
        ii.)For instance: ""Hello""---> 'H' is in second row, hence y will be incremented by 1 and 'e' is in first row , so x will be incremented by 1
		iii.)At the end , x=2, y=z and z=0 , with none of them equal to length of word, hence we dont append it to the result
		'''
		for word in words:
            x,y,z=0,0,0
            for letter in word.lower():                        
                if letter not in l[1] and letter not in l[2]:  
				    x+=1                                                       
                elif letter not in l[0] and letter not in l[2]: # To accout for casing of words, we have used word.lower()
                    y+=1
                elif letter not in l[0] and letter not in l[1]:
                    z+=1
            if x==len(word) or y==len(word) or z==len(word):
                l1.append(word)
        return l1";"class Solution:
    def findWords(self, words):
        row1 = ""qwertyuiop""
        row2 = ""asdfghjkl""
        row3 = ""zxcvbnm""
        
        result_words = []
        
        for word in words:
            lower_word = word.lower()
            
            in_row1 = True
            for char in lower_word:
                if char not in row1:
                    in_row1 = False
                    break
            
            in_row2 = True
            for char in lower_word:
                if char not in row2:
                    in_row2 = False
                    break
            
            in_row3 = True
            for char in lower_word:
                if char not in row3:
                    in_row3 = False
                    break
            
            if in_row1 or in_row2 or in_row3:
                result_words.append(word)
                
        return result_words"
"class Solution {
    public int[] findErrorNums(int[] nums) {
        var st = new HashSet<Integer>(),
        int dup = Arrays.stream(nums).boxed().filter(i -> !st.add(i)).toList().get(0), n = nums.length, s = (n * (n + 1)) / 2, ts = Arrays.stream(nums).sum(),
        return new int[]{dup, s - (ts - dup)},
    }
}




python :

class Solution:
    def findErrorNums(self, nums: list[int]) -> list[int]:
        n, a, b = len(nums), sum(nums), sum(set(nums))
        s = n*(n+1)//2
        return [a-b, s-b]



C++:

vector<int> findErrorNums(vector<int>&amp, nums) {
    //sum of elements on nums
    int initialSum = accumulate(nums.begin(), nums.end(), 0),

    //put the element of nums into set to remove the duplicate number
    set<int> s,
    for(auto &amp,i: nums){
        s.insert(i),
    }

    //sum of elements of the set
    int sum = accumulate(s.begin(), s.end(), 0),

    //difference of initialSum and sum will give us the repeated number
    int repeatedNum = initialSum - sum,

    //sum of all the natural numbers from 1 to n
    int n = nums.size() + 1,

    //subtracting the sum of elements in set i.e. sum from the sum of the natural numbers will give us the missing number
    int missingNum = n * (n-1)/2 - sum,

    return {repeatedNum, missingNum},
}";"def findErrorNums(nums):
    counts = {}
    for num in nums:
        if num in counts:
            counts[num] = counts[num] + 1
        else:
            counts[num] = 1
    
    duplicate = 0
    missing = 0
    i = 1
    n = len(nums)
    
    while i <= n:
        if i not in counts:
            missing = i
        elif counts[i] == 2:
            duplicate = i
        i = i + 1
            
    result = [duplicate, missing]
    return result"
"class Solution:
    def divisorGame(self, n: int) -> bool:
        #here, the state will have single parameter: current number on chalkboard!
        #Depending on current number on chalkboard, the player to make the first move
        #can either win or lose!
        
        #I will take bottom-up approach and use a dp table filling it from the most
        #trivial base case of n=1 up to original n!
        #size n+1 for indices from 0 to n, where we don't use index 0!
        dp = [None] * (n+1)
        #player who plays when 1 on board loses!
        dp[1] = False
        
        #iterate through state's parameters in inc. order to fill our dp table!
        for i in range(2, n+1, 1):
            #iterate through each and every number btw 1 and i//2 
            #we know that any number greater than i//2  can never be a factor of i!
            can_win = False
            for a in range(1, (i//2) + 1, 1):
                if(i % a == 0):
                    #if player playing at i-a number on board will lose, then
                    #current player that played first when i was on board can win
                    #since he will choose the most optimal path for him!
                    if(dp[i - a] == False):
                        can_win = True
                        break
            #once we tried all possible numbers btw 0 and i that are factors of i,
            #we check boolean flag!
            if(can_win):
                dp[i] = True
            else:
                dp[i] = False
        #since dp[n] equals True if Alice starts first and can win or False otherewise!
        return dp[n]";"class Solution:
    def divisorGame(self, n: int) -> bool:
        if n % 2 == 0:
            return True
        else:
            return False"
"class Solution:
    # O(n) time,
    # O(n) space,
    # Approach: greedy, hashset
    def predictPartyVictory(self, senate: str) -> str:
        n = len(senate)
        count = Counter(senate)
        
        skip_r = 0
        skip_d = 0
        removed_r = set()
        removed_d = set()
        while count['D'] > 0 and count['R'] > 0:
            for i in range(n):
                s = senate[i]
                if s == 'R':
                    if skip_r <= 0 and i not in removed_r:
                        count['D'] -=1
                        skip_d +=1
                    else:
                        if i not in removed_r:
                            skip_r -=1
                            removed_r.add(i)
                else:
                    if skip_d <= 0 and i not in removed_d:
                        count['R'] -=1
                        skip_r +=1
                    else:
                        if i not in removed_d:
                            skip_d -=1
                            removed_d.add(i)
                        
        if count['D'] > 0:
            return 'Dire'
        else:
            return 'Radiant'";"class Solution:
    def predictPartyVictory(self, senate: str) -> str:
        n = len(senate)
        
        radiant_indices = []
        dire_indices = []
        
        i = 0
        while i < n:
            if senate[i] == 'R':
                radiant_indices.append(i)
            else:
                dire_indices.append(i)
            i = i + 1
            
        while len(radiant_indices) > 0 and len(dire_indices) > 0:
            radiant_turn = radiant_indices[0]
            radiant_indices.pop(0)
            
            dire_turn = dire_indices[0]
            dire_indices.pop(0)
            
            if radiant_turn < dire_turn:
                radiant_indices.append(radiant_turn + n)
            else:
                dire_indices.append(dire_turn + n)
                
        if len(radiant_indices) > 0:
            winner = ""Radiant""
        else:
            winner = ""Dire""
            
        return winner"
"class Solution:
    def calculateMinimumHP(self, li: List[List[int]]) -> int:
        """"""
        Bottom Up Approach (Faster than 97% Submissions)
        Array:
            -2  -3  3
            -5 -10  1
            10  30 -5
        Working:
                      2
                      5  
               0   0  6
               
                    4+1  2
               6+0  11   5
               0.    0   6
        
               3+4    5      2
                6     11     5
                0     0      6
              
              7  5  2
              6 11  5
              0  0. 6
        """"""
        n,m = len(li), len(li[0])
        dp = [[None for i in range(m)] for i in range(n)]
        
        if li[-1][-1] >= 0:
            dp[-1][-1] = 0
        else:
            dp[-1][-1] = abs(li[-1][-1]) + 1
        
        #Populate last Column Values
        j = m-1
        for i in range(n-2,-1, -1):
            reqHealth = dp[i+1][j]
            if li[i][j] >= 0:
                cHealth = li[i][j]
                print(cHealth, reqHealth)
                if cHealth >= reqHealth:
                    dp[i][j] = 0
                else:
                    dp[i][j] = reqHealth - cHealth
            else:
                mandatoryHealthToSurvive = abs(li[i][j])+1
                cHealth = 1
                if cHealth >= reqHealth:
                    dp[i][j] = mandatoryHealthToSurvive
                else:
                    dp[i][j] = mandatoryHealthToSurvive + reqHealth - cHealth
        
        #Populate last Row Value
        i = n-1
        for j in range(m-2,-1,-1):
            reqHealth = dp[i][j+1]
            if li[i][j] >= 0:
                cHealth = li[i][j]
                if cHealth >= reqHealth:
                    dp[i][j] = 0
                else:
                    dp[i][j] = reqHealth - cHealth
            else:
                mandatoryHealthToSurvive = abs(li[i][j])+1
                cHealth = 1
                if cHealth >= reqHealth:
                    dp[i][j] = mandatoryHealthToSurvive
                else:
                    dp[i][j] = mandatoryHealthToSurvive + reqHealth - cHealth
          
        #Dp
        for i in range(n-2, -1, -1):
            for j in range(m-2, -1, -1):
                reqHealth = min(dp[i+1][j], dp[i][j+1])
                if li[i][j] >= 0:
                    cHealth = li[i][j]
                    if cHealth >= reqHealth:
                        dp[i][j] = 0
                    else:
                        dp[i][j] = reqHealth - cHealth
                else:
                    mandatoryHealthToSurvive = abs(li[i][j])+1
                    cHealth = 1
                    if cHealth >= reqHealth:
                        dp[i][j] = mandatoryHealthToSurvive
                    else:
                        dp[i][j] = mandatoryHealthToSurvive + reqHealth - cHealth
        for i in dp:
            print(i)
        return max(1, dp[0][0])";"class Solution:
    def calculateMinimumHP(self, dungeon: list[list[int]]) -> int:
        rows = len(dungeon)
        cols = len(dungeon[0])

        dp = []
        for i in range(rows):
            row = []
            for j in range(cols):
                row.append(0)
            dp.append(row)

        if dungeon[rows - 1][cols - 1] > 0:
            dp[rows - 1][cols - 1] = 1
        else:
            dp[rows - 1][cols - 1] = 1 - dungeon[rows - 1][cols - 1]

        for i in range(rows - 2, -1, -1):
            needed = dp[i + 1][cols - 1] - dungeon[i][cols - 1]
            if needed <= 0:
                dp[i][cols - 1] = 1
            else:
                dp[i][cols - 1] = needed

        for j in range(cols - 2, -1, -1):
            needed = dp[rows - 1][j + 1] - dungeon[rows - 1][j]
            if needed <= 0:
                dp[rows - 1][j] = 1
            else:
                dp[rows - 1][j] = needed

        for i in range(rows - 2, -1, -1):
            for j in range(cols - 2, -1, -1):
                down = dp[i + 1][j]
                right = dp[i][j + 1]
                
                min_health = 0
                if down < right:
                    min_health = down
                else:
                    min_health = right
                
                needed = min_health - dungeon[i][j]
                
                if needed <= 0:
                    dp[i][j] = 1
                else:
                    dp[i][j] = needed
                    
        return dp[0][0]"
"class Solution:
    def removeBoxes(self, boxes: List[int]) -> int:

        @cache
        def dp(l, r, count = 0):
            if l > r: return 0
            // Initial count for the letter at boxes[l]
            count += 1
            ptr = l + 1
            while ptr <= r and boxes[l] == boxes[ptr]:
                ptr += 1
                count += 1
            points = (count ** 2) + dp(ptr, r)
            for i in range(ptr + 1, r + 1):
                if boxes[l] == boxes[i]:
                    points = max(points, dp(i, r, count) + dp(ptr, i - 1))
            return points

        return dp(0, len(boxes) - 1)";"class Solution:
    def removeBoxes(self, boxes):
        n = len(boxes)
        if n == 0:
            return 0
        
        memo = {}

        def solve(i, j, k):
            if i > j:
                return 0
            
            state = (i, j, k)
            if state in memo:
                return memo[state]

            i_original = i
            k_original = k
            
            while i + 1 <= j and boxes[i + 1] == boxes[i]:
                i = i + 1
                k = k + 1
            
            # Option 1: Remove the current group of (k+1) boxes
            result = (k + 1) * (k + 1) + solve(i + 1, j, 0)
            
            # Option 2: Look for another box of the same color to merge with
            for m in range(i + 1, j + 1):
                if boxes[m] == boxes[i_original]:
                    potential_score = solve(i + 1, m - 1, 0) + solve(m, j, k + 1)
                    if potential_score > result:
                        result = potential_score

            memo[state] = result
            return result

        return solve(0, n - 1, 0)"
"class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n-1, -1, -1):
            for j in range(i, n):
                if(i == j):
                    dp[i][j] = nums[i]
                else:
                    dp[i][j] = nums[i] + self.getMax(dp, i+1,j, min(i+k, n-1, j))
        
        return dp[0][-1]
    
    def getMax(self, dp, startIndex, j, endIndex):
        x = -float(""inf"")
        for index in range(startIndex, endIndex+1):
            x = max(x, dp[index][j])
        return x";"class Solution:
    def maxResult(self, nums: list[int], k: int) -> int:
        n = len(nums)
        if n == 0:
            return 0
        
        dp = [0] * n
        dp[0] = nums[0]

        for i in range(1, n):
            max_previous_score = -2000000000

            start_index = i - k
            if start_index < 0:
                start_index = 0

            j = start_index
            while j < i:
                if dp[j] > max_previous_score:
                    max_previous_score = dp[j]
                j = j + 1
            
            dp[i] = nums[i] + max_previous_score
            
        return dp[n-1]"
"class Solution(object):
    def pathSum(self, root, targetSum):
        """"""
        :type root: TreeNode
        :type targetSum: int
        :rtype: int
        """"""
        self.targetSum=targetSum
        self.hashmap={0:1}
        self.prefix=0
        self.result=0
        
        self.helper(root)
        
        return self.result
    def helper(self, root):
        
        if root is None:
            return
        
        self.prefix+=root.val
        if self.prefix-self.targetSum in self.hashmap:
            self.result+=self.hashmap[self.prefix-self.targetSum]
        
        if self.prefix in self.hashmap:
            self.hashmap[self.prefix]+=1
        else:
            self.hashmap[self.prefix]=1
            
        self.helper(root.left)
        self.helper(root.right)
        
        self.hashmap[self.prefix]-=1
        self.prefix-=root.val";"class Solution:
    def pathSum(self, root, targetSum):
        if root is None:
            return 0

        nodes_to_start_from = []
        nodes_to_start_from.append(root)

        total_paths = 0

        while len(nodes_to_start_from) > 0:
            current_start_node = nodes_to_start_from.pop()

            if current_start_node.right is not None:
                nodes_to_start_from.append(current_start_node.right)
            if current_start_node.left is not None:
                nodes_to_start_from.append(current_start_node.left)

            path_traversal_stack = []
            path_traversal_stack.append((current_start_node, 0))

            while len(path_traversal_stack) > 0:
                node_in_path, sum_so_far = path_traversal_stack.pop()

                path_sum = sum_so_far + node_in_path.val
                
                if path_sum == targetSum:
                    total_paths = total_paths + 1

                if node_in_path.right is not None:
                    path_traversal_stack.append((node_in_path.right, path_sum))
                if node_in_path.left is not None:
                    path_traversal_stack.append((node_in_path.left, path_sum))

        return total_paths"
"class Solution:
    def maximumSwap(self, num: int) -> int:
        # larger digit to swap, digit position of this digit
        high_digit = high_pos = 0
        
        # smaller digit to swap, digit position of this digit
        low_digit = low_pos = 0
        
        # greatest digit seen so far, digit postion of this digit
        cur_high_digit, cur_high_pos = -1, 0
        
        # current digit position
        pos = 1
        
        res = num
        while num: # iterate through digits from right to left
            digit = num % 10
            
            # if digit is greatest digit yet
            if digit > cur_high_digit:
                cur_high_digit, cur_high_pos = digit, pos
            
            # if digit is less than greatest digit yet
            elif digit < cur_high_digit:
                # set the digits to swap as the greatest digit yet, and this digit
                high_digit, high_pos = cur_high_digit, cur_high_pos
                low_digit, low_pos = digit, pos
            
            pos *= 10
            num //= 10
        
        # swap the digits
        res += high_digit*(low_pos - high_pos) + low_digit*(high_pos - low_pos)
        return res";"class Solution:
    def maximumSwap(self, num: int) -> int:
        s_num = str(num)
        
        list_of_chars = []
        for char in s_num:
            list_of_chars.append(char)
        
        n = len(list_of_chars)
        max_num = num
        
        for i in range(n):
            for j in range(i + 1, n):
                
                # Make a copy of the list to swap
                temp_list = []
                for item in list_of_chars:
                    temp_list.append(item)
                
                # Swap characters
                temp_char = temp_list[i]
                temp_list[i] = temp_list[j]
                temp_list[j] = temp_char
                
                # Convert the new list of characters back to a number
                new_s_num = """"
                for char in temp_list:
                    new_s_num = new_s_num + char
                
                current_num = int(new_s_num)
                
                # Check if this new number is the biggest we've seen
                if current_num > max_num:
                    max_num = current_num
                    
        return max_num"
"class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:

        @cache
        def dp(x1, y1, x2):
            y2 = x1+y1-x2

            if not(0 <= x1 < len(grid) and 0 <= y1 < len(grid[0]) and 0 <= x2 < len(grid) and 0 <= y2 < len(grid[0])):
                return -float('inf')

            if grid[x1][y1] == -1 or grid [x2][y2] == -1 :
                return -float('inf')

            if x1 == len(grid)-1 and x2 == len(grid)-1 and y1 == len(grid[0])-1 and y1 == len(grid[0])-1 :
                if grid[x1][y1] == 1 :
                    return 1 
                else :
                    return 0 

            if x1 == x2 and y1 == y2 :
                if grid[x1][y1] == 1 :
                    return 1+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                else:
                    return max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
            else :
                if grid[x1][y1] == 1 and grid[x2][y2] == 1:
                    return 2+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                elif grid[x1][y1] == 1:
                    return 1+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                elif grid[x2][y2] == 1:
                    return 1+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                else:
                    return max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
        
        if dp(0,0,0) == -float('inf'):
            return 0
        else :
            return dp(0,0,0)";"class Solution:
    def cherryPickup(self, grid: list[list[int]]) -> int:
        n = len(grid)

        dp = []
        i = 0
        while i < n:
            row = []
            j = 0
            while j < n:
                row.append(-1)
                j = j + 1
            dp.append(row)
            i = i + 1

        dp[0][0] = grid[0][0]

        max_k = 2 * n - 2
        k = 1
        while k <= max_k:
            next_dp = []
            i = 0
            while i < n:
                row = []
                j = 0
                while j < n:
                    row.append(-1)
                    j = j + 1
                next_dp.append(row)
                i = i + 1

            r1 = 0
            while r1 < n:
                r2 = 0
                while r2 < n:
                    c1 = k - r1
                    c2 = k - r2

                    if c1 >= 0 and c1 < n and c2 >= 0 and c2 < n:
                        if grid[r1][c1] != -1 and grid[r2][c2] != -1:
                            
                            prev_cherries = -1

                            if dp[r1][r2] != -1:
                                prev_cherries = dp[r1][r2]
                            
                            if r1 > 0 and dp[r1 - 1][r2] > prev_cherries:
                                prev_cherries = dp[r1 - 1][r2]
                            
                            if r2 > 0 and dp[r1][r2 - 1] > prev_cherries:
                                prev_cherries = dp[r1][r2 - 1]
                            
                            if r1 > 0 and r2 > 0 and dp[r1 - 1][r2 - 1] > prev_cherries:
                                prev_cherries = dp[r1 - 1][r2 - 1]

                            if prev_cherries != -1:
                                current_cherries = 0
                                if r1 == r2:
                                    current_cherries = grid[r1][c1]
                                else:
                                    current_cherries = grid[r1][c1] + grid[r2][c2]
                                
                                next_dp[r1][r2] = prev_cherries + current_cherries
                    r2 = r2 + 1
                r1 = r1 + 1
            
            dp = next_dp
            k = k + 1

        final_cherries = dp[n - 1][n - 1]
        
        if final_cherries == -1:
            return 0
        else:
            return final_cherries"
"class Solution:
    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:
        if s[-1] == ""1"": # If last one equal to ""1"", then just return False.
            return False
        if minJump <= len(s)-1 <= maxJump: # If the first jump can reach the end point, then return True.
            return True
        # Initialize th max index of s, the current and previous start point, end point.
        Len, start, end, pre_start, pre_end = len(s), minJump, maxJump, -1, -1
        
        while True:
            if pre_start == start and pre_end == end: # If we can't go any further(we'll never reach the last index), return False.
                return False
            pre_start, pre_end = start, end # Update previous values.
            # Search next round ""0""s
            for i in range(pre_start, pre_end+1):
                # If s[i] equals ""0"", then we can jump
                # and make sure that at least one ""0"" in the range if we jump from index i.
                if s[i] == ""0"" and ""0"" in s[i + minJump:i + maxJump + 1]:
                    if start <= pre_end: # Update start point to a minimum value that greater than previous end point.
                        start = i + minJump
                    end = i + maxJump # Update end point to the maximum of this round.
                    if start <= Len-1 <= end: # If the start and end points contain the last index, return True.
                        return True";"class Solution:
    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:
        n = len(s)
        dp = [False] * n
        dp[0] = True
        
        reachable_count = 0
        
        for i in range(1, n):
            if i >= minJump:
                if dp[i - minJump] == True:
                    reachable_count = reachable_count + 1
            
            if i > maxJump:
                if dp[i - maxJump - 1] == True:
                    reachable_count = reachable_count - 1
            
            if s[i] == '0' and reachable_count > 0:
                dp[i] = True
                
        return dp[n - 1]"
"class Solution:
    def stoneGameVI(self, alice: List[int], bob: List[int]) -> int:
        n = len(alice)
        arr = [alice[i] + bob[i] for i in range(n)]
        s = sum(bob)
        res = 0
        k = (n+1)//2
        arr.sort(reverse=True)
        for i in range(0, n, 2):
            res += arr[i]
        
        
        if res > s:
            return 1
        elif res == s:
            return 0 
        else:
            return -1";"class Solution:
    def stoneGameVI(self, aliceValues, bobValues):
        n = len(aliceValues)
        stones = []
        for i in range(n):
            total_value = aliceValues[i] + bobValues[i]
            # [total_value, alice_value, bob_value]
            stones.append([total_value, aliceValues[i], bobValues[i]])
        
        # Sort by total value in descending order
        # A simple way for a novice is bubble sort
        for i in range(n):
            for j in range(0, n - i - 1):
                if stones[j][0] < stones[j + 1][0]:
                    # Swap the stones
                    temp = stones[j]
                    stones[j] = stones[j+1]
                    stones[j+1] = temp

        alice_score = 0
        bob_score = 0

        # Alice goes first, then Bob, and so on
        for i in range(n):
            # Alice's turn is on even indices 0, 2, 4, ...
            is_alice_turn = (i % 2 == 0)

            if is_alice_turn:
                # Alice takes the stone with the highest combined value
                alice_score = alice_score + stones[i][1]
            else:
                # Bob takes the stone with the highest remaining combined value
                bob_score = bob_score + stones[i][2]

        if alice_score > bob_score:
            return 1
        elif bob_score > alice_score:
            return -1
        else:
            return 0"
"class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        
        # Sorting method
        # Time: O(nlogn) Space: O(1)
        
        # Here, we'll simply sort the list and then check if the next element == current element
        # if yes, then we'll continue
        # else we'll return the element
        
        if len(nums) == 1:
            return nums[0]
        nums.sort()
        for i in range(1,len(nums),2):
            if nums[i] != nums[i-1]:
                return nums[i-1]
        return nums[len(nums)-1]
    
    
        # Using Dictionary
        # Time: O(n) Space:O(n)
        
        # Here, we'll simply traverse through the list and 
        # insert the element and it's count as (key,value) pair
        # then we'll start iterating through the dictionary 
        # and if we find any element having count 1
        # we'll return the element
        
        res = {}
        for el in nums:
            if el in res:
                res[el] += 1
            else:
                res[el] = 1
        for key in res.keys():
            if res[key] == 1:
                return key
        
        
        # XOR method
        # Time: O(n) Space: O(1)
        
        # If you know how XOR operation works then it's pretty straight forward for you.
        
        for i in range(1,len(nums)):
            nums[0] ^= nums[i]
        return nums[0]";"resultado_unico = 0
for numero in nums:
    resultado_unico = resultado_unico ^ numero

# El nmero que no se repite es resultado_unico"
"class Solution:
    #n = len(arr)
    #Time-Complexity: O(n), in worst case we visit each and every index position and finds out
    #there's no indices with integer 0 !
    #Space-Complexity: O(n + n), by same argument as T.C! -> O(n)
    def canReach(self, arr: List[int], start: int) -> bool:
        #We can model this as a general directed graph problem!
        #If we are at node i(at position index i), we can either
        #jump to two descendants: arr[i] + i or arr[i] - i!
        
        #We will only add to queue index positions not already visited
        #and in-bounds!
        visited = set()
        q = collections.deque()
        q.append(start)
        visited.add(start)
        #as long as queue is not empty, keep bfs going!
        while q:
            cur_index = q.popleft()
            #check if at current index has value 0! If so, immediately
            #break and return True
            if(arr[cur_index] == 0):
                return True
            #otherwise, process the two descendants and only add to queue
            #if it's not already visited and is in-bounds!
            neighbor1 = arr[cur_index] + cur_index
            neighbor2 = cur_index - arr[cur_index]
            if(neighbor1 not in visited and 0<=neighbor1 < len(arr)):
                q.append(neighbor1)
                visited.add(neighbor1)
            if(neighbor2 not in visited and 0<=neighbor2 < len(arr)):
                q.append(neighbor2)
                visited.add(neighbor2)
        
        #once bfs is over, we tried every possible path from start!
        #could not reach index position with value of 0!
        return False";"class Solution:
    def canReach(self, arr: list[int], start: int) -> bool:
        n = len(arr)
        queue = [start]
        visited = [False] * n
        visited[start] = True
        
        head = 0
        while head < len(queue):
            current_index = queue[head]
            head = head + 1
            
            if arr[current_index] == 0:
                return True
            
            jump = arr[current_index]
            
            next_index_forward = current_index + jump
            if next_index_forward < n:
                if not visited[next_index_forward]:
                    visited[next_index_forward] = True
                    queue.append(next_index_forward)

            next_index_backward = current_index - jump
            if next_index_backward >= 0:
                if not visited[next_index_backward]:
                    visited[next_index_backward] = True
                    queue.append(next_index_backward)
                    
        return False"
"# Binary Search Tree Solution -> If exact matching of intervals found then return False
#                                Else you can add this interval to that particular node's left or right
class Node:
    def __init__(self, s, e):
        self.s = s
        self.e = e
        self.left = None
        self.right = None
class MyCalendar:
    def __init__(self):
        self.head = None
        
    def insert(self, s, e, node):
        if s >= node.e:
            if node.right: return self.insert(s, e, node.right)
            else: 
                nn = Node(s, e)
                node.right = nn
                return True
        elif e <= node.s:
            if node.left: return self.insert(s, e, node.left)
            else:
                nn = Node(s, e)
                node.left = nn
                return True
        else: return False
        
    def book(self, s: int, e: int) -> bool:
        if self.head == None:
            nn = Node(s, e)
            self.head = nn
            return True
        return self.insert(s, e, self.head)";"class MyCalendar:
    def __init__(self):
        self.events = []

    def book(self, start, end):
        i = 0
        while i < len(self.events):
            existing_event = self.events[i]
            existing_start = existing_event[0]
            existing_end = existing_event[1]

            if start < existing_end and existing_start < end:
                return False
            
            i = i + 1
        
        new_event = [start, end]
        self.events.append(new_event)
        return True"
"class Solution:
    def reformatDate(self, date: str) -> str:
        
        month_dict = {
            'Jan':'01', 'Feb':'02', 'Mar':'03', 'Apr':'04', 'May':'05', 'Jun':'06',
            'Jul':'07', 'Aug':'08', 'Sep':'09', 'Oct':'10', 'Nov':'11', 'Dec':'12',
        }
        
        date_list = date.split()
        
        #defining empty string
        date_string = ''
        
        #year
        date_string = date_string + date_list[2] + '-' 
        
        #month
        date_string = date_string + month_dict[date_list[1]] + '-'
        
        #day
        date_day = [x for x in date_list[0] if not x.isalpha()]
        date_day_digits = ''.join(date_day)
        if len(date_day_digits) == 1:
            date_string = date_string+'0'+date_day_digits
        else:
            date_string = date_string+date_day_digits
        
        
        return date_string
        # date_String = date_string + date_list[]";"def reformatDate(date):
    parts = date.split("" "")
    day_part = parts[0]
    month_part = parts[1]
    year_part = parts[2]

    day_number_string = day_part[:-2]
    
    final_day = """"
    if len(day_number_string) == 1:
        final_day = ""0"" + day_number_string
    else:
        final_day = day_number_string

    final_month = """"
    if month_part == ""Jan"":
        final_month = ""01""
    elif month_part == ""Feb"":
        final_month = ""02""
    elif month_part == ""Mar"":
        final_month = ""03""
    elif month_part == ""Apr"":
        final_month = ""04""
    elif month_part == ""May"":
        final_month = ""05""
    elif month_part == ""Jun"":
        final_month = ""06""
    elif month_part == ""Jul"":
        final_month = ""07""
    elif month_part == ""Aug"":
        final_month = ""08""
    elif month_part == ""Sep"":
        final_month = ""09""
    elif month_part == ""Oct"":
        final_month = ""10""
    elif month_part == ""Nov"":
        final_month = ""11""
    elif month_part == ""Dec"":
        final_month = ""12""

    final_year = year_part

    result = final_year + ""-"" + final_month + ""-"" + final_day
    return result"
"class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        trie=Trie()
        out=[]
        words=sentence.split("" "")
        for word in dictionary:
            trie.insert(word)
        for word in words:
            out.append(trie.transfer(word))
        return "" "".join(out)
        

class TrieNode(object):
        def __init__(self):
            self.children = {}
            self.isWord = False
class Trie:

    def __init__(self):
        self.root = TrieNode()
    def insert(self, word: str) -> None:
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.isWord = True
    def transfer(self, successor: str) -> bool:
        node = self.root
        out=""""
        for char in successor:
            if node.isWord:
                return out
            if char not in node.children:
                return successor
            out+=char
            node = node.children[char]
        return successor";"class Solution:
    def replaceWords(self, dictionary, sentence):
        words = sentence.split(' ')
        
        result_words = []
        
        for word in words:
            shortest_root = """"
            
            for root in dictionary:
                is_prefix = True
                if len(root) <= len(word):
                    for i in range(len(root)):
                        if root[i] != word[i]:
                            is_prefix = False
                            break
                else:
                    is_prefix = False

                if is_prefix:
                    if shortest_root == """" or len(root) < len(shortest_root):
                        shortest_root = root
            
            if shortest_root != """":
                result_words.append(shortest_root)
            else:
                result_words.append(word)

        new_sentence = """"
        for i in range(len(result_words)):
            if i > 0:
                new_sentence = new_sentence + "" ""
            new_sentence = new_sentence + result_words[i]
            
        return new_sentence"
"class Solution:
    def containVirus(self, mat: List[List[int]]) -> int:
        m,n = len(mat),len(mat[0])

        def dfs(i,j,visited,nextInfected):  # return no. of walls require to quarantined dfs area
            if 0<=i<m and 0<=j<n and (i,j) not in visited:
                if mat[i][j]==2: # Already quarantined cell
                    return 0
                if mat[i][j]==0:
                    nextInfected.add((i,j)) # add cell which will be infected next day
                    return 1   # require one wall to quarantined cell from one side
                    
                else:
                    visited.add((i,j))
                    return dfs(i-1,j,visited,nextInfected) + dfs(i+1,j,visited,nextInfected) + dfs(i,j-1,visited,nextInfected) + dfs(i,j+1,visited,nextInfected)  # traverse all four direction
            else:
                return 0
				
        ans = 0 
        while True:   # this loop running ""how many days we should installing the walls"" times
            # For every day check which area infect more cells
            visited = set()  # Using in dfs
            All_nextinfect  = set()
            stop , walls = set(),0   # here stop store the indices of maximum no. of cells in which we stop spreading of virus this day
            
            for i in range(m):
                for j in range(n):
                    if mat[i][j]==1 and (i,j) not in visited:
                        nextInfected = set()
                        a = dfs(i,j,visited,nextInfected)
                        
                        if len(stop)<len(nextInfected):
                            All_nextinfect  = All_nextinfect | stop # leave previous saved area from virus
                            stop = nextInfected  # pick new area which we want to save
                            walls = a  # require walls
                            p,q = i,j  # starting position(indices) of this area
                        else:
                            All_nextinfect  = All_nextinfect | nextInfected   
                            
            if not stop : # if our job is done i.e. No cell will be infect Later
                break
            ans += walls  # add new walls installed this day
            
            # change each cell value to 2 which will be covered by quarantined area
            def fun(p,q):
                if 0<=p<m and 0<=q<n and mat[p][q]==1:
                    mat[p][q]=2
                    fun(p+1,q)
                    fun(p-1,q)
                    fun(p,q-1)
                    fun(p,q+1)
            fun(p,q) # start dfs from start point of quarantined area
            
            for a,b in All_nextinfect: # set new infected cell value = 1 for iterating next day
                mat[a][b] = 1

        return ans   # Final answer";"class Solution:
    def containVirus(self, isInfected: list[list[int]]) -> int:
        m = len(isInfected)
        n = len(isInfected[0])
        total_walls = 0

        while True:
            regions = []
            visited = []
            for i in range(m):
                row = []
                for j in range(n):
                    row.append(False)
                visited.append(row)

            for r in range(m):
                for c in range(n):
                    if isInfected[r][c] == 1 and not visited[r][c]:
                        
                        current_region_cells = []
                        threatened_neighbors = []
                        walls_needed = 0
                        
                        q = []
                        q.append((r, c))
                        visited[r][c] = True
                        
                        head = 0
                        while head < len(q):
                            curr_r, curr_c = q[head]
                            head = head + 1
                            
                            current_region_cells.append((curr_r, curr_c))
                            
                            directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
                            for dr, dc in directions:
                                nr, nc = curr_r + dr, curr_c + dc
                                
                                if 0 <= nr < m and 0 <= nc < n:
                                    if isInfected[nr][nc] == 0:
                                        walls_needed = walls_needed + 1
                                        is_new_threat = True
                                        for tn_r, tn_c in threatened_neighbors:
                                            if tn_r == nr and tn_c == nc:
                                                is_new_threat = False
                                                break
                                        if is_new_threat:
                                            threatened_neighbors.append((nr, nc))
                                    elif isInfected[nr][nc] == 1 and not visited[nr][nc]:
                                        visited[nr][nc] = True
                                        q.append((nr, nc))
                        
                        if len(threatened_neighbors) > 0:
                            region_data = {}
                            region_data['cells'] = current_region_cells
                            region_data['threatened'] = threatened_neighbors
                            region_data['walls'] = walls_needed
                            regions.append(region_data)

            if not regions:
                break

            max_threat_count = -1
            quarantine_index = -1
            
            i = 0
            while i < len(regions):
                threat_count = 0
                for cell in regions[i]['threatened']:
                    threat_count = threat_count + 1

                if threat_count > max_threat_count:
                    max_threat_count = threat_count
                    quarantine_index = i
                i = i + 1
            
            if quarantine_index == -1:
                break
            
            region_to_quarantine = regions[quarantine_index]
            total_walls = total_walls + region_to_quarantine['walls']
            
            for cell_r, cell_c in region_to_quarantine['cells']:
                isInfected[cell_r][cell_c] = -1
            
            i = 0
            while i < len(regions):
                if i != quarantine_index:
                    region_to_spread = regions[i]
                    for threat_r, threat_c in region_to_spread['threatened']:
                        isInfected[threat_r][threat_c] = 1
                i = i + 1

        return total_walls"
"class Solution:
    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:
        #Let len(richer) = n and let len(quiet) = m!
        #Time: O(n + m + m + m*m + m +  m) -> O(m^2 + n)
        #Space: O(m*m + m + m + m*m + m) -> O(m^2)
        #step 1: build adjacency list representation and update indegrees of every node initially!
        adj = [[] for _ in range(len(quiet))]
        indegrees = [0] * len(quiet)
        #we want edges to go from richer to poorer so that ancestors of every node are all people
        #who have more money than the node person!
        for rel in richer:
            richer, poorer = rel[0], rel[1]
            adj[richer].append(poorer)
            indegrees[poorer] += 1
        
        queue = deque()
        ancestors = []
        for i in range(len(quiet)):
            new = set()
            new.add(i)
            ancestors.append(new)
        #step 2: fill in the queue all nodes that have indegrees of 0!

        #step 3: proceeding with Kahn's algorithm and recording list of all ancestors to every node!
        while queue:
            cur = queue.pop()
            for neighbor in adj[cur]:
                ancestors[neighbor].add(cur)
                ancestors[neighbor].update(ancestors[cur])
                indegrees[neighbor] -= 1
                if(indegrees[neighbor] == 0):
                    queue.append(neighbor)
        
        ancestors = [list(s) for s in ancestors]
        output = []
        #step 4:for each person, find the least quiet person who also has more money than the current               #person we're iterating on!
        for a in range(len(ancestors)):
            cur_ancestors = ancestors[a]
            if(len(cur_ancestors) == 1):
                output.append(a)
                continue
            minimum = cur_ancestors[0]
            for ancestor in cur_ancestors:
                #check if current person with more money than person a has lower quiet level!
                if(quiet[ancestor] < quiet[minimum]):
                    minimum = ancestor
            output.append(minimum)
        return output";"def loudAndRich(richer, quiet):
    n = len(quiet)
    
    adj = []
    for i in range(n):
        adj.append([])
        
    in_degree = []
    for i in range(n):
        in_degree.append(0)

    for r in richer:
        richer_person = r[0]
        poorer_person = r[1]
        adj[richer_person].append(poorer_person)
        in_degree[poorer_person] = in_degree[poorer_person] + 1

    answer = []
    for i in range(n):
        answer.append(i)

    queue = []
    for i in range(n):
        if in_degree[i] == 0:
            queue.append(i)
    
    head = 0
    while head < len(queue):
        person = queue[head]
        head = head + 1
        
        for poorer_neighbor in adj[person]:
            # The person's answer is the quietest person they know of so far
            # which could be themselves or someone richer than them.
            # We check if this person's answer is better for their poorer neighbor.
            if quiet[answer[person]] < quiet[answer[poorer_neighbor]]:
                answer[poorer_neighbor] = answer[person]
            
            in_degree[poorer_neighbor] = in_degree[poorer_neighbor] - 1
            if in_degree[poorer_neighbor] == 0:
                queue.append(poorer_neighbor)
                
    return answer"
"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        
        # Using the ITERATIVE APPROACH with O(logn)
        
        '''
        Step-by-step Binary Search Algorithm: We basically ignore half of the elements just after one comparison.

        1. Compare x with the middle element.
        2. If x matches with the middle element, we return the mid index.
        3. Else If x is greater than the mid element, then x can only lie in the right half subarray after the mid element. So we recur for the right half.
        4. Else (x is smaller) recur for the left half.    
        
        '''
        
        # Two containers
        low_value  = 0              # Index of first element    
        high_value = len(nums) - 1  # Index of last element
        
        while low_value <= high_value:                  # check if the high_value is higher than the low_value
            middle_value = (low_value + high_value)//2  # middle index of our list which will be the floor of the average of high_value plus low_value
            
            if nums[middle_value] == target:    # check if the middle element and the target are equal 
                return middle_value             # If they are equal, the position of the item will be returned
            
            if target < nums[middle_value]:     # check if the middle element is less than the item to be searched
                
                high_value = middle_value - 1   # the new position will shift to the right once.
                
            else:                               # check if the value of the last index is greater than or equal to the value of the first index
                                                
                low_value = middle_value + 1    #  the new position will shift to the left once
                     
        return -1  # If the target is not in the list, it will return a statement";"def search(nums, target):
    izquierda = 0
    derecha = len(nums) - 1

    while izquierda <= derecha:
        medio = (izquierda + derecha) // 2
        
        valor_medio = nums[medio]

        if valor_medio == target:
            return medio
        
        if valor_medio < target:
            izquierda = medio + 1
        else:
            derecha = medio - 1
            
    return -1"
"class Solution:
    def stoneGameVII(self, stones: List[int]) -> int:
        dp = [[0 for _ in range(len(stones))] for _ in range(len(stones))]     # dp table n x n
        run_sum = [0]                            # running sum -> sum [i..j] = run_sum[j] - run_sum[i]
        s = 0
        
		## Calculation of running sum
        for i in stones:
            s += i
            run_sum.append(s)
		
        n = len(stones) 
        
        for k in range(1, n):               # no. of stones left
            for i in range(0, n - k):   # from each starting point
                remove_i_stone = (run_sum[i+k+1] - run_sum[i+1])    # score after removing i th stone
                remove_j_stone = (run_sum[i+k] - run_sum[i])             # score after removing j th stone
                
                if (n-(k+1))%2 == 0:        # alice's move 
                    dp[i][i+k] = max(remove_i_stone + dp[i+1][i+k],
                                    remove_j_stone + dp[i][i+k-1])
                else:                       # bob's move
                    dp[i][i+k] = min(-remove_i_stone + dp[i+1][i+k],
                                    - remove_j_stone + dp[i][i+k-1])
                    
        return dp[0][n - 1]";"class Solution:
    def stoneGameVII(self, stones: list[int]) -> int:
        n = 0
        for s in stones:
            n = n + 1

        prefix_sum = []
        prefix_sum.append(0)
        current_sum = 0
        for s in stones:
            current_sum = current_sum + s
            prefix_sum.append(current_sum)

        dp = []
        i = 0
        while i < n:
            row = []
            j = 0
            while j < n:
                row.append(0)
                j = j + 1
            dp.append(row)
            i = i + 1

        length = 2
        while length <= n:
            i = 0
            while i <= n - length:
                j = i + length - 1
                
                sum_if_left_removed = prefix_sum[j + 1] - prefix_sum[i + 1]
                choice1 = sum_if_left_removed - dp[i + 1][j]
                
                sum_if_right_removed = prefix_sum[j] - prefix_sum[i]
                choice2 = sum_if_right_removed - dp[i][j - 1]
                
                if choice1 > choice2:
                    dp[i][j] = choice1
                else:
                    dp[i][j] = choice2
                
                i = i + 1
            length = length + 1
            
        return dp[0][n - 1]"
"# Linked List Solution
class MyHashSet(object):
    
    def __init__(self):
        self.keyRange = 769
        self.bucketArray = [LinkedList() for i in range(self.keyRange)]
        
    def _hash(self, key):
        return key % self.keyRange
    
    def add(self, key):
        bucketIndex = self._hash(key)
        self.bucketArray[bucketIndex].append(key)
        
    def remove(self, key):
        bucketIndex = self._hash(key)
        self.bucketArray[bucketIndex].deleteNodeKeyAll(key)
        # while self.bucketArray[bucketIndex].search(key):
        #     self.bucketArray[bucketIndex].deleteNodeKeyOne(key)
        
    def contains(self, key):
        bucketIndex = self._hash(key)
        return self.bucketArray[bucketIndex].search(key)
    
# ---------------------------------------------------------
## Define a linked list

class Node:
    
    def __init__(self, val, next = None):
        self.val = val
        self.next = next
        
class LinkedList:
    
    def __init__(self):
        self.head = None

# ---------------------------------------------------------
## Insert a new node

### Insert the new node at the front of the linked list
    def push(self, new_val):
        new_node = Node(new_val)
        new_node.next = self.head
        self.head = new_node
        
### Insert the new node at the end of the linked list
    def append(self, new_val):
        new_node = Node(new_val)
        if self.head is None:
            self.head = new_node
            return
        # Traverse till the end of the linked list
        last = self.head
        while last.next:
            last = last.next
        last.next = new_node

### Insert the new node after a given node
    def insertAfter(self, new_val, prev_node):
        if prev_node is None:
            print(""Please enter the node which is the previous node of the inserted node."")
            return
        new_node = Node(new_val)
        new_node.next = prev_node.next
        prev_node.next = new_node
        
# ---------------------------------------------------------
## Delete a node

### Delete a node by value
# Iterative Method
    def deleteNodeKeyOne(self, key): # delete a single node
        temp = self.head
        if temp is None:
            return
        if temp.val == key:
            self.head = temp.next
            temp = None
            return
        while temp is not None:
            if temp.val == key:
                break
            prev = temp
            temp = temp.next
        if temp is None:
            return
        prev.next = temp.next
        temp = None
        
    def deleteNodeKeyAll(self, key): # delete all the nodes with value key
        temp = self.head
        if temp is None:
            return
        while temp.val == key:
            deletedNode = temp
            self.head = temp.next
            temp = self.head
            deletedNode = None
            if temp is None:
                return
        nxt = temp.next
        while nxt is not None:
            if nxt.val == key:
                deletedNode = nxt
                temp.next = nxt.next
                deletedNode = None
            temp = nxt
            nxt = nxt.next

### Delete a node by position and return the value of the deleted node
    def deleteNodePosition(self, position):
        if self.head is None:
            return
        if position == 0:
            temp = self.head
            self.head = self.head.next
            temp = None
            return
        idx = 0
        current = self.head
        prev = self.head
        nxt = self.head
        while current is not None:
            if idx == position:
                nxt = current.next
                break
            prev = current
            current = current.next
            idx += 1
        prev.next = nxt
        current = None
        
# ---------------------------------------------------------
# Print a linked list
    def printList(self):
        temp = self.head
        while temp:
            print ("" %d"" %(temp.val))
            temp = temp.next

# ---------------------------------------------------------
## Search an element in a linked list
    def search(self, x):
        current = self.head
        while current is not None:
            if current.val == x:
                return True
            current = current.next
        return False";"class MyHashSet:
    def __init__(self):
        self.size = 1000
        self.buckets = []
        i = 0
        while i < self.size:
            self.buckets.append([])
            i = i + 1

    def add(self, key):
        bucket_index = key % self.size
        bucket = self.buckets[bucket_index]
        
        already_exists = False
        for current_key in bucket:
            if current_key == key:
                already_exists = True
                break
        
        if not already_exists:
            bucket.append(key)

    def remove(self, key):
        bucket_index = key % self.size
        bucket = self.buckets[bucket_index]
        
        new_bucket = []
        for current_key in bucket:
            if current_key != key:
                new_bucket.append(current_key)
        
        self.buckets[bucket_index] = new_bucket

    def contains(self, key):
        bucket_index = key % self.size
        bucket = self.buckets[bucket_index]
        
        for current_key in bucket:
            if current_key == key:
                return True
        
        return False"
"class Solution:
    def reachNumber(self, target: int) -> int:
        def gaussSum(n):
            return n*(n+1)//2
        
        def binaryFind(lower, upper):
            t = abs(target)
            sums, n = -1, -1
            while lower <= upper:
                mid = (lower+upper)//2
                if gaussSum(mid) >= t:
                    sums, n = gaussSum(mid), mid
                    upper = mid-1
                else:
                    lower = mid+1
            return sums, n
        
                    
        lower, upper = 0, 10**5
        # find min n s.t. 1+2+...+n>=abs(target)
        sums, n = binaryFind(lower, upper)
        while sums%2 != abs(target)%2:
            sums += n+1
            n += 1
        return n";"class Solution:
    def reachNumber(self, target: int) -> int:
        if target < 0:
            target = -target

        num_moves = 0
        position_sum = 0
        
        while position_sum < target:
            num_moves = num_moves + 1
            position_sum = position_sum + num_moves
        
        while (position_sum - target) % 2 != 0:
            num_moves = num_moves + 1
            position_sum = position_sum + num_moves
            
        return num_moves"
"class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        sortedList = sorted(nums)
        n = len(nums)
        if n%2==0:
            small = sortedList[:((n//2))][::-1]
            large = (sortedList[(n//2):])[::-1]
            for i in range(1,n,2):
                nums[i] = large[i//2]
            for i in range(0,n,2):
                nums[i] = small[i//2]
        else:
            small = sortedList[:1+((n//2))][::-1]
            large = (sortedList[1+(n//2):])[::-1]
            for i in range(1,n,2):
                nums[i] = large[i//2]
            for i in range(0,n,2):
                nums[i] = small[i//2]";"nums.sort()
i = 1
while i < len(nums) - 1:
    temp = nums[i]
    nums[i] = nums[i+1]
    nums[i+1] = temp
    i = i + 2"
"class Solution:
    def rotatedDigits(self, N: int) -> int:
        smallSet = {0,1,8}
        bigSet = {2,5,6,9}
        smallNum = [0,0,1,1,1,2,3,3,3,4][N % 10]
        bigNum = [1,2,3,3,3,4,5,5,6,7][N % 10]
        N = N // 10
        smInc, bgInc = 4, 7
        while N:
            x = N % 10
            N = N // 10
            sm, bg = 0, 0
            for i in range(x):
                if i in smallSet:
                    sm += smInc
                    bg += bgInc
                elif i in bigSet:
                    sm += bgInc
                    bg += bgInc
            if x in smallSet:
                smallNum += sm
                bigNum += bg
            elif x in bigSet:
                smallNum = bigNum + sm
                bigNum += bg
            else:
                smallNum = sm
                bigNum = bg
            smInc, bgInc = 4*bgInc + 3*smInc, bgInc * 7
        return smallNum";"class Solution:
    def rotatedDigits(self, n: int) -> int:
        count = 0
        for num in range(1, n + 1):
            num_as_string = str(num)
            
            is_valid = True
            is_different = False
            
            for digit in num_as_string:
                if digit == '3' or digit == '4' or digit == '7':
                    is_valid = False
                    break
                
                if digit == '2' or digit == '5' or digit == '6' or digit == '9':
                    is_different = True
            
            if is_valid == True and is_different == True:
                count = count + 1
        
        return count"
"class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:

		""Edge Case checking""
        
        if endWord not in wordList:
            return []
        
        size = len(beginWord)
        
        
        ""create llokup got all the possible wordpatters""
        
        lookup = defaultdict(list)                                  
        
        for word in wordList:                                     
            for i in range(size):
                lookup[word[:i] + ""*"" + word[i+1:]].append(word)    
        
        cur_len = 9999
        
        ans = []      
        
        ""enter the first element in the queue""
        
        queue =  collections.deque([[beginWord, 1,[beginWord]]])
        
        visited = {beginWord: True}
        
        while(queue):
            
            currWord, pathLength,words_till_now = queue.popleft()
            
            """"""
            instead of marking an elemnt vistied , when we insert it in the queue,
            we mark it as visited only when we pop and element
            this way , same word can be used by other curWords
            <ex :>
            ""red""
            ""tax""
            [""ted"",""tex"",""red"",""tax"",""tad"",""den"",""rex"",""pee""]                        
            and we make sure that element can not be used again           
            """"""
            visited[currWord] = True
            
            """"""
            run a for loop for all values for all the possible patterns for the popped word
            """"""
            
            for i in range(size):
                
                possibleWordPattern = currWord[:i] + ""*"" + currWord[i+1:]
                
                for word in lookup[possibleWordPattern]:            
                    
                    if(currWord == word):
                        continue
                    
                    """"""
                    if the word for the possibleWordPattern key matches with the end word we add it to the 
                    ans list
                    """"""
                        
                    if(word == endWord):                                                    
                        
                        if cur_len == pathLength + 1:
                                                    
                            ans.append(words_till_now+[word])
                        elif cur_len > pathLength + 1:
                            
                            ans = [words_till_now+[word]]
                            
                            cur_len = pathLength + 1
                    
                    if(word not in visited):                        
                        queue.append([word, pathLength + 1,words_till_now+[word]])
        
        return ans";"class Solution:
    def findLadders(self, beginWord, endWord, wordList):
        word_set = set(wordList)
        if endWord not in word_set:
            return []

        distances = {}
        distances[beginWord] = 0
        parents = {}
        
        queue = []
        queue.append(beginWord)
        
        found = False
        
        while len(queue) > 0:
            level_size = len(queue)
            for i in range(level_size):
                word = queue.pop(0)
                current_dist = distances[word]
                
                if word == endWord:
                    found = True
                
                alphabet = ""abcdefghijklmnopqrstuvwxyz""
                for char_index in range(len(word)):
                    original_char = word[char_index]
                    temp_list = list(word)
                    
                    for c in alphabet:
                        if c == original_char:
                            continue

                        temp_list[char_index] = c
                        next_word = """".join(temp_list)

                        if next_word in word_set:
                            if next_word not in distances:
                                distances[next_word] = current_dist + 1
                                if next_word not in parents:
                                    parents[next_word] = []
                                parents[next_word].append(word)
                                queue.append(next_word)
                            elif distances[next_word] == current_dist + 1:
                                if next_word not in parents:
                                    parents[next_word] = []
                                parents[next_word].append(word)
                    
                    temp_list[char_index] = original_char

            if found:
                break
        
        results = []
        if endWord in distances:
            path_stack = []
            initial_path = [endWord]
            path_stack.append(initial_path)
            
            while len(path_stack) > 0:
                current_path = path_stack.pop()
                last_word_in_path = current_path[-1]
                
                if last_word_in_path == beginWord:
                    final_path = []
                    index = len(current_path) - 1
                    while index >= 0:
                        final_path.append(current_path[index])
                        index = index - 1
                    results.append(final_path)
                else:
                    if last_word_in_path in parents:
                        for parent_word in parents[last_word_in_path]:
                            new_path = list(current_path)
                            new_path.append(parent_word)
                            path_stack.append(new_path)

        return results"
"class Solution:
    def numDecodings(self, s: str) -> int:
        non_zero = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
        first_incl, second_incl = 1, 0
        first_excl, second_excl = 0, 0
        
        if s[0] in non_zero:
            second_incl = 1
        if s[0] == '*':
            second_incl = 9
            
        for i in range(1, len(s)):
            new_incl, new_excl = 0, 0
            if s[i] == '*':
                new_incl = 9 * (second_incl + second_excl)
                
                if s[i-1] == '1':
                    # number is of type (1, *)
                    new_excl = 9 * (first_incl + first_excl)
                    
                elif s[i-1] == '2':
                    # number is of type (2, *)
                    new_excl = 6 * (first_incl + first_excl)
                    
                elif s[i-1] == '*':
                    # number is of type (*, *)
                    new_excl = 15 * (first_incl + first_excl)
            else:
                if s[i] in non_zero:
                    new_incl = second_incl + second_excl
                        
                if s[i-1] == '*':
                    # number is of type (*,digit)
                    if int(s[i]) <= 6:
                        new_excl = 2 * (first_excl + first_incl)
                    else:
                        new_excl = first_incl + first_excl
                        
                else:
                    # number is of type (digit,digit)
                    val = int(s[i-1:i+1])
                    if 10 <= val <= 26:
                        new_excl = first_incl + first_excl
                    else:
                        new_excl = 0
            first_incl, first_excl = second_incl, second_excl
            second_incl, second_excl = new_incl, new_excl
        return (second_incl + second_excl) % (10**9 + 7)";"class Solution:
    def numDecodings(self, s: str) -> int:
        MOD = 1000000007
        n = len(s)

        if n == 0:
            return 1
            
        dp_prev_prev = 1

        if s[0] == '0':
            dp_prev = 0
        elif s[0] == '*':
            dp_prev = 9
        else:
            dp_prev = 1
        
        if n == 1:
            return dp_prev

        i = 1
        while i < n:
            dp_current = 0
            
            # First, handle one-digit decoding for s[i]
            if s[i] == '*':
                # If s[i] is '*', it can be 1-9, so 9 ways.
                # Total ways = 9 * (ways to decode up to s[i-1])
                dp_current = (9 * dp_prev) % MOD
            elif s[i] > '0':
                # If s[i] is a non-zero digit, it's 1 way.
                # Total ways = 1 * (ways to decode up to s[i-1])
                dp_current = dp_prev
            # If s[i] is '0', it cannot form a one-digit code, so ways are 0.
            # dp_current remains 0 for this part.

            # Second, handle two-digit decoding for s[i-1]s[i]
            prev_char = s[i-1]
            curr_char = s[i]

            if prev_char == '1':
                if curr_char == '*':
                    # ""1*"" can be ""11"" through ""19"" (9 ways)
                    # Add 9 * (ways to decode up to s[i-2])
                    ways_from_two_digits = 9 * dp_prev_prev
                    dp_current = (dp_current + ways_from_two_digits) % MOD
                else:
                    # ""1"" followed by any digit is valid (""10""-""19"")
                    # Add 1 * (ways to decode up to s[i-2])
                    ways_from_two_digits = dp_prev_prev
                    dp_current = (dp_current + ways_from_two_digits) % MOD
            elif prev_char == '2':
                if curr_char == '*':
                    # ""2*"" can be ""21"" through ""26"" (6 ways)
                    # Add 6 * (ways to decode up to s[i-2])
                    ways_from_two_digits = 6 * dp_prev_prev
                    dp_current = (dp_current + ways_from_two_digits) % MOD
                elif curr_char >= '0' and curr_char <= '6':
                    # ""2"" followed by ""0""-""6"" is valid (""20""-""26"")
                    # Add 1 * (ways to decode up to s[i-2])
                    ways_from_two_digits = dp_prev_prev
                    dp_current = (dp_current + ways_from_two_digits) % MOD
            elif prev_char == '*':
                if curr_char == '*':
                    # ""**"" can be ""11""-""19"" (9 ways) or ""21""-""26"" (6 ways) -> 15 ways
                    # Add 15 * (ways to decode up to s[i-2])
                    ways_from_two_digits = 15 * dp_prev_prev
                    dp_current = (dp_current + ways_from_two_digits) % MOD
                elif curr_char >= '0' and curr_char <= '6':
                    # ""*d"" (d<=6) can be ""1d"" or ""2d"" -> 2 ways
                    # Add 2 * (ways to decode up to s[i-2])
                    ways_from_two_digits = 2 * dp_prev_prev
                    dp_current = (dp_current + ways_from_two_digits) % MOD
                else:
                    # ""*d"" (d>6) can only be ""1d"" -> 1 way
                    # Add 1 * (ways to decode up to s[i-2])
                    ways_from_two_digits = dp_prev_prev
                    dp_current = (dp_current + ways_from_two_digits) % MOD

            dp_prev_prev = dp_prev
            dp_prev = dp_current
            
            i = i + 1

        return dp_prev"
"class Solution:
    def isThree(self, n):
        
        answers =  [4, 9, 25, 49, 121, 169, 289, 361, 529, 841, 961, 1369, 1681, 1849, 2209, 2809, 3481, 3721, 4489, 5041, 5329, 6241, 6889, 7921, 9409]
        
        while True:
            size = len(answers)
            if size == 1:
                return answers[0] == n
            elif size == 0:
                return False
            mp = size // 2
            
            if answers[mp] == n:
                return True
            elif answers[mp] > n:
                answers = answers[:mp]
            else:
                answers = answers[mp + 1:]";"class Solution:
    def isThree(self, n: int) -> bool:
        divisors_count = 0
        i = 1
        while i <= n:
            if n % i == 0:
                divisors_count = divisors_count + 1
            i = i + 1
        
        if divisors_count == 3:
            return True
        else:
            return False"
"class Solution:
    def nthUglyNumber(self, n: int) -> int:
        lst=[1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45, 48, 50, 54, 60, 64, 72, 75, 80, 81, 90, 96, 100, 108, 120, 125, 128, 135, 144, 150, 160, 162, 180, 192, 200, 216, 225, 240, 243, 250, 256, 270, 288, 300, 320, 324, 360, 375, 384, 400, 405, 432, 450, 480, 486, 500, 512, 540, 576, 600, 625, 640, 648, 675, 720, 729, 750, 768, 800, 810, 864, 900, 960, 972, 1000, 1024, 1080, 1125, 1152, 1200, 1215, 1250, 1280, 1296, 1350, 1440, 1458, 1500, 1536, 1600, 1620, 1728, 1800, 1875, 1920, 1944, 2000, 2025, 2048, 2160, 2187, 2250, 2304, 2400, 2430, 2500, 2560, 2592, 2700, 2880, 2916, 3000, 3072, 3125, 3200, 3240, 3375, 3456, 3600, 3645, 3750, 3840, 3888, 4000, 4050, 4096, 4320, 4374, 4500, 4608, 4800, 4860, 5000, 5120, 5184, 5400, 5625, 5760, 5832, 6000, 6075, 6144, 6250, 6400, 6480, 6561, 6750, 6912, 7200, 7290, 7500, 7680, 7776, 8000, 8100, 8192, 8640, 8748, 9000, 9216, 9375, 9600, 9720, 10000, 10125, 10240, 10368, 10800, 10935, 11250, 11520, 11664, 12000, 12150, 12288, 12500, 12800, 12960, 13122, 13500, 13824, 14400, 14580, 15000, 15360, 15552, 15625, 16000, 16200, 16384, 16875, 17280, 17496, 18000, 18225, 18432, 18750, 19200, 19440, 19683, 20000, 20250, 20480, 20736, 21600, 21870, 22500, 23040, 23328, 24000, 24300, 24576, 25000, 25600, 25920, 26244, 27000, 27648, 28125, 28800, 29160, 30000, 30375, 30720, 31104, 31250, 32000, 32400, 32768, 32805, 33750, 34560, 34992, 36000, 36450, 36864, 37500, 38400, 38880, 39366, 40000, 40500, 40960, 41472, 43200, 43740, 45000, 46080, 46656, 46875, 48000, 48600, 49152, 50000, 50625, 51200, 51840, 52488, 54000, 54675, 55296, 56250, 57600, 58320, 59049, 60000, 60750, 61440, 62208, 62500, 64000, 64800, 65536, 65610, 67500, 69120, 69984, 72000, 72900, 73728, 75000, 76800, 77760, 78125, 78732, 80000, 81000, 81920, 82944, 84375, 86400, 87480, 90000, 91125, 92160, 93312, 93750, 96000, 97200, 98304, 98415, 100000, 101250, 102400, 103680, 104976, 108000, 109350, 110592, 112500, 115200, 116640, 118098, 120000, 121500, 122880, 124416, 125000, 128000, 129600, 131072, 131220, 135000, 138240, 139968, 140625, 144000, 145800, 147456, 150000, 151875, 153600, 155520, 156250, 157464, 160000, 162000, 163840, 164025, 165888, 168750, 172800, 174960, 177147, 180000, 182250, 184320, 186624, 187500, 192000, 194400, 196608, 196830, 200000, 202500, 204800, 207360, 209952, 216000, 218700, 221184, 225000, 230400, 233280, 234375, 236196, 240000, 243000, 245760, 248832, 250000, 253125, 256000, 259200, 262144, 262440, 270000, 273375, 276480, 279936, 281250, 288000, 291600, 294912, 295245, 300000, 303750, 307200, 311040, 312500, 314928, 320000, 324000, 327680, 328050, 331776, 337500, 345600, 349920, 354294, 360000, 364500, 368640, 373248, 375000, 384000, 388800, 390625, 393216, 393660, 400000, 405000, 409600, 414720, 419904, 421875, 432000, 437400, 442368, 450000, 455625, 460800, 466560, 468750, 472392, 480000, 486000, 491520, 492075, 497664, 500000, 506250, 512000, 518400, 524288, 524880, 531441, 540000, 546750, 552960, 559872, 562500, 576000, 583200, 589824, 590490, 600000, 607500, 614400, 622080, 625000, 629856, 640000, 648000, 655360, 656100, 663552, 675000, 691200, 699840, 703125, 708588, 720000, 729000, 737280, 746496, 750000, 759375, 768000, 777600, 781250, 786432, 787320, 800000, 810000, 819200, 820125, 829440, 839808, 843750, 864000, 874800, 884736, 885735, 900000, 911250, 921600, 933120, 937500, 944784, 960000, 972000, 983040, 984150, 995328, 1000000, 1012500, 1024000, 1036800, 1048576, 1049760, 1062882, 1080000, 1093500, 1105920, 1119744, 1125000, 1152000, 1166400, 1171875, 1179648, 1180980, 1200000, 1215000, 1228800, 1244160, 1250000, 1259712, 1265625, 1280000, 1296000, 1310720, 1312200, 1327104, 1350000, 1366875, 1382400, 1399680, 1406250, 1417176, 1440000, 1458000, 1474560, 1476225, 1492992, 1500000, 1518750, 1536000, 1555200, 1562500, 1572864, 1574640, 1594323, 1600000, 1620000, 1638400, 1640250, 1658880, 1679616, 1687500, 1728000, 1749600, 1769472, 1771470, 1800000, 1822500, 1843200, 1866240, 1875000, 1889568, 1920000, 1944000, 1953125, 1966080, 1968300, 1990656, 2000000, 2025000, 2048000, 2073600, 2097152, 2099520, 2109375, 2125764, 2160000, 2187000, 2211840, 2239488, 2250000, 2278125, 2304000, 2332800, 2343750, 2359296, 2361960, 2400000, 2430000, 2457600, 2460375, 2488320, 2500000, 2519424, 2531250, 2560000, 2592000, 2621440, 2624400, 2654208, 2657205, 2700000, 2733750, 2764800, 2799360, 2812500, 2834352, 2880000, 2916000, 2949120, 2952450, 2985984, 3000000, 3037500, 3072000, 3110400, 3125000, 3145728, 3149280, 3188646, 3200000, 3240000, 3276800, 3280500, 3317760, 3359232, 3375000, 3456000, 3499200, 3515625, 3538944, 3542940, 3600000, 3645000, 3686400, 3732480, 3750000, 3779136, 3796875, 3840000, 3888000, 3906250, 3932160, 3936600, 3981312, 4000000, 4050000, 4096000, 4100625, 4147200, 4194304, 4199040, 4218750, 4251528, 4320000, 4374000, 4423680, 4428675, 4478976, 4500000, 4556250, 4608000, 4665600, 4687500, 4718592, 4723920, 4782969, 4800000, 4860000, 4915200, 4920750, 4976640, 5000000, 5038848, 5062500, 5120000, 5184000, 5242880, 5248800, 5308416, 5314410, 5400000, 5467500, 5529600, 5598720, 5625000, 5668704, 5760000, 5832000, 5859375, 5898240, 5904900, 5971968, 6000000, 6075000, 6144000, 6220800, 6250000, 6291456, 6298560, 6328125, 6377292, 6400000, 6480000, 6553600, 6561000, 6635520, 6718464, 6750000, 6834375, 6912000, 6998400, 7031250, 7077888, 7085880, 7200000, 7290000, 7372800, 7381125, 7464960, 7500000, 7558272, 7593750, 7680000, 7776000, 7812500, 7864320, 7873200, 7962624, 7971615, 8000000, 8100000, 8192000, 8201250, 8294400, 8388608, 8398080, 8437500, 8503056, 8640000, 8748000, 8847360, 8857350, 8957952, 9000000, 9112500, 9216000, 9331200, 9375000, 9437184, 9447840, 9565938, 9600000, 9720000, 9765625, 9830400, 9841500, 9953280, 10000000, 10077696, 10125000, 10240000, 10368000, 10485760, 10497600, 10546875, 10616832, 10628820, 10800000, 10935000, 11059200, 11197440, 11250000, 11337408, 11390625, 11520000, 11664000, 11718750, 11796480, 11809800, 11943936, 12000000, 12150000, 12288000, 12301875, 12441600, 12500000, 12582912, 12597120, 12656250, 12754584, 12800000, 12960000, 13107200, 13122000, 13271040, 13286025, 13436928, 13500000, 13668750, 13824000, 13996800, 14062500, 14155776, 14171760, 14348907, 14400000, 14580000, 14745600, 14762250, 14929920, 15000000, 15116544, 15187500, 15360000, 15552000, 15625000, 15728640, 15746400, 15925248, 15943230, 16000000, 16200000, 16384000, 16402500, 16588800, 16777216, 16796160, 16875000, 17006112, 17280000, 17496000, 17578125, 17694720, 17714700, 17915904, 18000000, 18225000, 18432000, 18662400, 18750000, 18874368, 18895680, 18984375, 19131876, 19200000, 19440000, 19531250, 19660800, 19683000, 19906560, 20000000, 20155392, 20250000, 20480000, 20503125, 20736000, 20971520, 20995200, 21093750, 21233664, 21257640, 21600000, 21870000, 22118400, 22143375, 22394880, 22500000, 22674816, 22781250, 23040000, 23328000, 23437500, 23592960, 23619600, 23887872, 23914845, 24000000, 24300000, 24576000, 24603750, 24883200, 25000000, 25165824, 25194240, 25312500, 25509168, 25600000, 25920000, 26214400, 26244000, 26542080, 26572050, 26873856, 27000000, 27337500, 27648000, 27993600, 28125000, 28311552, 28343520, 28697814, 28800000, 29160000, 29296875, 29491200, 29524500, 29859840, 30000000, 30233088, 30375000, 30720000, 31104000, 31250000, 31457280, 31492800, 31640625, 31850496, 31886460, 32000000, 32400000, 32768000, 32805000, 33177600, 33554432, 33592320, 33750000, 34012224, 34171875, 34560000, 34992000, 35156250, 35389440, 35429400, 35831808, 36000000, 36450000, 36864000, 36905625, 37324800, 37500000, 37748736, 37791360, 37968750, 38263752, 38400000, 38880000, 39062500, 39321600, 39366000, 39813120, 39858075, 40000000, 40310784, 40500000, 40960000, 41006250, 41472000, 41943040, 41990400, 42187500, 42467328, 42515280, 43046721, 43200000, 43740000, 44236800, 44286750, 44789760, 45000000, 45349632, 45562500, 46080000, 46656000, 46875000, 47185920, 47239200, 47775744, 47829690, 48000000, 48600000, 48828125, 49152000, 49207500, 49766400, 50000000, 50331648, 50388480, 50625000, 51018336, 51200000, 51840000, 52428800, 52488000, 52734375, 53084160, 53144100, 53747712, 54000000, 54675000, 55296000, 55987200, 56250000, 56623104, 56687040, 56953125, 57395628, 57600000, 58320000, 58593750, 58982400, 59049000, 59719680, 60000000, 60466176, 60750000, 61440000, 61509375, 62208000, 62500000, 62914560, 62985600, 63281250, 63700992, 63772920, 64000000, 64800000, 65536000, 65610000, 66355200, 66430125, 67108864, 67184640, 67500000, 68024448, 68343750, 69120000, 69984000, 70312500, 70778880, 70858800, 71663616, 71744535, 72000000, 72900000, 73728000, 73811250, 74649600, 75000000, 75497472, 75582720, 75937500, 76527504, 76800000, 77760000, 78125000, 78643200, 78732000, 79626240, 79716150, 80000000, 80621568, 81000000, 81920000, 82012500, 82944000, 83886080, 83980800, 84375000, 84934656, 85030560, 86093442, 86400000, 87480000, 87890625, 88473600, 88573500, 89579520, 90000000, 90699264, 91125000, 92160000, 93312000, 93750000, 94371840, 94478400, 94921875, 95551488, 95659380, 96000000, 97200000, 97656250, 98304000, 98415000, 99532800, 100000000, 100663296, 100776960, 101250000, 102036672, 102400000, 102515625, 103680000, 104857600, 104976000, 105468750, 106168320, 106288200, 107495424, 108000000, 109350000, 110592000, 110716875, 111974400, 112500000, 113246208, 113374080, 113906250, 114791256, 115200000, 116640000, 117187500, 117964800, 118098000, 119439360, 119574225, 120000000, 120932352, 121500000, 122880000, 123018750, 124416000, 125000000, 125829120, 125971200, 126562500, 127401984, 127545840, 128000000, 129140163, 129600000, 131072000, 131220000, 132710400, 132860250, 134217728, 134369280, 135000000, 136048896, 136687500, 138240000, 139968000, 140625000, 141557760, 141717600, 143327232, 143489070, 144000000, 145800000, 146484375, 147456000, 147622500, 149299200, 150000000, 150994944, 151165440, 151875000, 153055008, 153600000, 155520000, 156250000, 157286400, 157464000, 158203125, 159252480, 159432300, 160000000, 161243136, 162000000, 163840000, 164025000, 165888000, 167772160, 167961600, 168750000, 169869312, 170061120, 170859375, 172186884, 172800000, 174960000, 175781250, 176947200, 177147000, 179159040, 180000000, 181398528, 182250000, 184320000, 184528125, 186624000, 187500000, 188743680, 188956800, 189843750, 191102976, 191318760, 192000000, 194400000, 195312500, 196608000, 196830000, 199065600, 199290375, 200000000, 201326592, 201553920, 202500000, 204073344, 204800000, 205031250, 207360000, 209715200, 209952000, 210937500, 212336640, 212576400, 214990848, 215233605, 216000000, 218700000, 221184000, 221433750, 223948800, 225000000, 226492416, 226748160, 227812500, 229582512, 230400000, 233280000, 234375000, 235929600, 236196000, 238878720, 239148450, 240000000, 241864704, 243000000, 244140625, 245760000, 246037500, 248832000, 250000000, 251658240, 251942400, 253125000, 254803968, 255091680, 256000000, 258280326, 259200000, 262144000, 262440000, 263671875, 265420800, 265720500, 268435456, 268738560, 270000000, 272097792, 273375000, 276480000, 279936000, 281250000, 283115520, 283435200, 284765625, 286654464, 286978140, 288000000, 291600000, 292968750, 294912000, 295245000, 298598400, 300000000, 301989888, 302330880, 303750000, 306110016, 307200000, 307546875, 311040000, 312500000, 314572800, 314928000, 316406250, 318504960, 318864600, 320000000, 322486272, 324000000, 327680000, 328050000, 331776000, 332150625, 335544320, 335923200, 337500000, 339738624, 340122240, 341718750, 344373768, 345600000, 349920000, 351562500, 353894400, 354294000, 358318080, 358722675, 360000000, 362797056, 364500000, 368640000, 369056250, 373248000, 375000000, 377487360, 377913600, 379687500, 382205952, 382637520, 384000000, 387420489, 388800000, 390625000, 393216000, 393660000, 398131200, 398580750, 400000000, 402653184, 403107840, 405000000, 408146688, 409600000, 410062500, 414720000, 419430400, 419904000, 421875000, 424673280, 425152800, 429981696, 430467210, 432000000, 437400000, 439453125, 442368000, 442867500, 447897600, 450000000, 452984832, 453496320, 455625000, 459165024, 460800000, 466560000, 468750000, 471859200, 472392000, 474609375, 477757440, 478296900, 480000000, 483729408, 486000000, 488281250, 491520000, 492075000, 497664000, 500000000, 503316480, 503884800, 506250000, 509607936, 510183360, 512000000, 512578125, 516560652, 518400000, 524288000, 524880000, 527343750, 530841600, 531441000, 536870912, 537477120, 540000000, 544195584, 546750000, 552960000, 553584375, 559872000, 562500000, 566231040, 566870400, 569531250, 573308928, 573956280, 576000000, 583200000, 585937500, 589824000, 590490000, 597196800, 597871125, 600000000, 603979776, 604661760, 607500000, 612220032, 614400000, 615093750, 622080000, 625000000, 629145600, 629856000, 632812500, 637009920, 637729200, 640000000, 644972544, 645700815, 648000000, 655360000, 656100000, 663552000, 664301250, 671088640, 671846400, 675000000, 679477248, 680244480, 683437500, 688747536, 691200000, 699840000, 703125000, 707788800, 708588000, 716636160, 717445350, 720000000, 725594112, 729000000, 732421875, 737280000, 738112500, 746496000, 750000000, 754974720, 755827200, 759375000, 764411904, 765275040, 768000000, 774840978, 777600000, 781250000, 786432000, 787320000, 791015625, 796262400, 797161500, 800000000, 805306368, 806215680, 810000000, 816293376, 819200000, 820125000, 829440000, 838860800, 839808000, 843750000, 849346560, 850305600, 854296875, 859963392, 860934420, 864000000, 874800000, 878906250, 884736000, 885735000, 895795200, 900000000, 905969664, 906992640, 911250000, 918330048, 921600000, 922640625, 933120000, 937500000, 943718400, 944784000, 949218750, 955514880, 956593800, 960000000, 967458816, 972000000, 976562500, 983040000, 984150000, 995328000, 996451875, 1000000000, 1006632960, 1007769600, 1012500000, 1019215872, 1020366720, 1024000000, 1025156250, 1033121304, 1036800000, 1048576000, 1049760000, 1054687500, 1061683200, 1062882000, 1073741824, 1074954240, 1076168025, 1080000000, 1088391168, 1093500000, 1105920000, 1107168750, 1119744000, 1125000000, 1132462080, 1133740800, 1139062500, 1146617856, 1147912560, 1152000000, 1162261467, 1166400000, 1171875000, 1179648000, 1180980000, 1194393600, 1195742250, 1200000000, 1207959552, 1209323520, 1215000000, 1220703125, 1224440064, 1228800000, 1230187500, 1244160000, 1250000000, 1258291200, 1259712000, 1265625000, 1274019840, 1275458400, 1280000000, 1289945088, 1291401630, 1296000000, 1310720000, 1312200000, 1318359375, 1327104000, 1328602500, 1342177280, 1343692800, 1350000000, 1358954496, 1360488960, 1366875000, 1377495072, 1382400000, 1399680000, 1406250000, 1415577600, 1417176000, 1423828125, 1433272320, 1434890700, 1440000000, 1451188224, 1458000000, 1464843750, 1474560000, 1476225000, 1492992000, 1500000000, 1509949440, 1511654400, 1518750000, 1528823808, 1530550080, 1536000000, 1537734375, 1549681956, 1555200000, 1562500000, 1572864000, 1574640000, 1582031250, 1592524800, 1594323000, 1600000000, 1610612736, 1612431360, 1620000000, 1632586752, 1638400000, 1640250000, 1658880000, 1660753125, 1677721600, 1679616000, 1687500000, 1698693120, 1700611200, 1708593750, 1719926784, 1721868840, 1728000000, 1749600000, 1757812500, 1769472000, 1771470000, 1791590400, 1793613375, 1800000000, 1811939328, 1813985280, 1822500000, 1836660096, 1843200000, 1845281250, 1866240000, 1875000000, 1887436800, 1889568000, 1898437500, 1911029760, 1913187600, 1920000000, 1934917632, 1937102445, 1944000000, 1953125000, 1966080000, 1968300000, 1990656000, 1992903750, 2000000000, 2013265920, 2015539200, 2025000000, 2038431744, 2040733440, 2048000000, 2050312500, 2066242608, 2073600000, 2097152000, 2099520000, 2109375000, 2123366400]
        return lst[n-1]";"def obtener_numero_feo(n):
    if n <= 0:
        return 0

    numeros_feos = [0] * n
    numeros_feos[0] = 1

    puntero2 = 0
    puntero3 = 0
    puntero5 = 0
    
    contador = 1
    while contador < n:
        siguiente_feo_por_2 = numeros_feos[puntero2] * 2
        siguiente_feo_por_3 = numeros_feos[puntero3] * 3
        siguiente_feo_por_5 = numeros_feos[puntero5] * 5

        siguiente_feo = siguiente_feo_por_2
        if siguiente_feo_por_3 < siguiente_feo:
            siguiente_feo = siguiente_feo_por_3
        if siguiente_feo_por_5 < siguiente_feo:
            siguiente_feo = siguiente_feo_por_5

        numeros_feos[contador] = siguiente_feo

        if siguiente_feo == siguiente_feo_por_2:
            puntero2 = puntero2 + 1
        
        if siguiente_feo == siguiente_feo_por_3:
            puntero3 = puntero3 + 1
            
        if siguiente_feo == siguiente_feo_por_5:
            puntero5 = puntero5 + 1
            
        contador = contador + 1

    resultado = numeros_feos[n - 1]
    return resultado"
"class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        def isSameCase(l, r, word, isUpper):
            while l <= r:
                if word[l].isupper() != isUpper or word[r].isupper() != isUpper:
                    return False
                l += 1
                r -= 1
            return True
        
        if len(word) == 1: # Base Case
            return True
        
        if word[0].isupper() and word[1].isupper(): #Case 1 ""USA""
            return isSameCase(1, len(word) - 1, word, True)
        elif word[0].islower() and word[1].islower(): #Case 2 ""leetcode""
            return isSameCase(1, len(word) - 1, word, False)
        elif word[0].isupper() and word[1].islower(): # Case 3 ""Google""
            return isSameCase(1, len(word) - 1, word, False)
        else:
            return False";"class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        capital_letters = 0
        i = 0
        while i < len(word):
            letter = word[i]
            if letter >= 'A' and letter <= 'Z':
                capital_letters = capital_letters + 1
            i = i + 1

        if capital_letters == len(word):
            return True
        
        if capital_letters == 0:
            return True
        
        if capital_letters == 1:
            first_letter = word[0]
            if first_letter >= 'A' and first_letter <= 'Z':
                return True

        return False"
"class Solution:
    
    def reversePairs(self, arr: List[int]) -> int:
        count = 0
        if len(arr) > 1:
            mid = len(arr)//2
            L = arr[:mid]
            R = arr[mid:]
            count = self.reversePairs(L) 
            count += self.reversePairs(R)
            count += self.merge(L,R,arr)
        return count
    
    def merge(self,L,R,arr):
		#finding count for the condition
        count = 0
        i,j = 0,0
        while i < len(L):
            while j < len(R):
                if L[i] > 2*R[j]:
                    j += 1
                else:
                    break
            
            if j > 0:
                count += j
            i += 1

		#merging the sorted arrays
        i,j,k = 0,0,0        
        while i < len(L) and j < len(R):    
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1   
            else:
                arr[k] = R[j]
                j += 1
            k += 1

        while i < len(L):
            arr[k] = L[i]
            k += 1
            i += 1   
        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1
                
        return count";"class Solution:
    def reversePairs(self, nums):
        count = 0
        n = 0
        
        for num in nums:
            n = n + 1
            
        i = 0
        while i < n:
            j = i + 1
            while j < n:
                if nums[i] > 2 * nums[j]:
                    count = count + 1
                j = j + 1
            i = i + 1
            
        return count"
"class Solution:
    def stoneGameIX(self, stones: List[int]) -> bool:
        stones = [v % 3 for v in stones]
        
        d = defaultdict(int)
        for v in stones:
            d[v] += 1
        
        while d[1] >= 2 and d[2] >= 2:
            d[2] -= 1
            d[1] -= 1
        
        if d[0] % 2 == 0: # number of 0s will not influent the result
            if (d[1] == 1 and d[2] >= 1) or (d[2] == 1 and d[1] >= 1):
                return True
        else:
            if (d[1] == 0 and d[2] >= 3) or (d[2] == 0 and d[1] >= 3):
                return True
            if (d[1] == 1 and d[2] >= 4) or (d[2] == 1 and d[1] >= 4):
                return True

        return False";"class Solution:
    def stoneGameIX(self, stones: list[int]) -> bool:
        count0 = 0
        count1 = 0
        count2 = 0
        
        for stone in stones:
            rem = stone % 3
            if rem == 0:
                count0 += 1
            elif rem == 1:
                count1 += 1
            else:
                count2 += 1
        
        if count1 == 0 and count2 == 0:
            return False
        
        if count1 == 0:
            if count2 < 3:
                return False
            if count0 % 2 == 0:
                return False
            else:
                return True
        
        if count2 == 0:
            if count1 < 3:
                return False
            if count0 % 2 == 0:
                return False
            else:
                return True

        if abs(count1 - count2) > 2:
            return True
        else:
            if count0 % 2 == 0:
                return False
            else:
                return True"
"class Solution:
    def rotateString(self, s: str, goal: str) -> bool:
        if len(s) != len(goal):
            return False
        
        txt = s + s
        n, m = len(txt), len(goal) 

        lps = self.build_lps(goal)
       
        i, j = 0, 0

        while i < n:
            if txt[i] == goal[j] :
                i, j = i + 1, j + 1
                
                if j == m:
                    return True
            else: 
                if j == 0:
                   i += 1 
                else:
                    j = lps[j-1]
                    
                    
        return False

    
    def build_lps(self, pattern):
        lps = [0] * len(pattern) 
        prev_lps, i = 0, 1

        while i < len(pattern):
            if pattern[i] == pattern[prev_lps]:
                lps[i] = prev_lps + 1
                prev_lps, i = prev_lps + 1, i + 1
            else:
                if prev_lps == 0:
                    lps[i] = 0
                    i += 1
                else:
                    prev_lps = lps[prev_lps - 1]

        return lps";"class Solution:
    def rotateString(self, s: str, goal: str) -> bool:
        if len(s) != len(goal):
            return False

        if s == goal:
            return True

        i = 0
        while i < len(s):
            first_character = s[0]
            remaining_string = s[1:]
            s = remaining_string + first_character

            if s == goal:
                return True
            
            i = i + 1
        
        return False"
"class Solution:
    def wordBreak(self, s: str, wordDict):
        output = []
        def backtracking(restString, candidate):
            # When the restString is empty, it means all substring/prefix of s are found in dictionary.
            # Add candidate to output answer.
            if restString == """":
                output.append(candidate)
                return
            
            # Process demonstration of the following for loop:
            # candidate = """"  <= 'cat'sanddog
            # candidate = ""cat""  <= 'sand'dog
            # candidate = ""cat sand""  <= dog
            # candidate = ""cat sand dog""  <= ''

            # candidate = """"  <= 'cats'anddog
            # candidate = ""cats""  <= 'and'dog
            # candidate = ""cats and""  <= dog
            # candidate = ""cats and dog""  <= ''

            # In the for loop range needs to add one, otherwise you will miss one char when you use restString[:i].
            # This for loop will keep checking if any prefix of restString was in dictionary.
            for i in range(len(restString)+1):
                if restString[:i] in wordDict:
                    # This if block can avoid the extra space in the from of candidate answer.
                    if candidate == """":
                        backtracking(restString[i:], restString[:i])
                    else:
                        backtracking(restString[i:], candidate+"" ""+restString[:i])
                    
        backtracking(s, """")
        return output

""""""
Input: s = ""catsanddog"", wordDict = [""cat"",""cats"",""and"",""sand"",""dog""]
Output: [""cats and dog"",""cat sand dog""]
""""""

if __name__ == ""__main__"":
    s = ""catsanddog"" 
    wordDict = [""cat"",""cats"",""and"",""sand"",""dog""]
    solution = Solution()
    print(f""s = {s}"")
    print(f""wordDict = {wordDict}"")
    print(f""wordBreak = {solution.wordBreak(s, wordDict)}"")";"class Solution:
    def wordBreak(self, s: str, wordDict: list[str]) -> list[str]:
        word_set = set(wordDict)
        n = len(s)
        
        dp = []
        i = 0
        while i <= n:
            dp.append([])
            i = i + 1
        
        dp[0] = [""""]
        
        i = 1
        while i <= n:
            j = 0
            while j < i:
                word = s[j:i]
                if word in word_set:
                    if len(dp[j]) > 0:
                        for sentence_prefix in dp[j]:
                            if sentence_prefix == """":
                                new_sentence = word
                            else:
                                new_sentence = sentence_prefix + "" "" + word
                            dp[i].append(new_sentence)
                j = j + 1
            i = i + 1
            
        return dp[n]"
"class Solution:
    def bagOfTokensScore(self, tokens: List[int], power: int) -> int:
        # Establish score to return
        score = 0
        
        # Why use Collections.deque instead of the list 
        # as-is? One word - optimization! Deque has been 
        # written in such a way where popping items off
        # the front of the list using popleft occurs in O(1)
        # time, while running tokens.pop(0) runs in O(n) time.
        # Since we care a lot about runtime, deque's
        # the way to go here
        d = deque(sorted(tokens))
        while d:
            # Since we've sorted the list in ascending 
            # order, we don't need to compare the power to 
            # all values - if it's smaller than the smallest, 
            # it'll be smaller than everything
            if power < d[0]:
                # Pop the tail of the list (play token face-down)
                if score > 0 and len(d) > 1:
                    power += d.pop()
                    score -= 1
                # It's possible power will be smaller than 
                # all scores but either our score's too low
                # to play anything face-down OR there's only
                # one piece left, making the play redundnat.
                # In either of these cases, we're done
                else:
                    return score
            else:
                #Pop the head (play token face-up)
                power -= d.popleft()
                score += 1
        # Game over - time to return our score!
        return score";"class Solution:
    def bagOfTokensScore(self, tokens, power):
        tokens.sort()
        
        score = 0
        max_score = 0
        
        left = 0
        right = len(tokens) - 1
        
        while left <= right:
            if power >= tokens[left]:
                power = power - tokens[left]
                score = score + 1
                left = left + 1
                if score > max_score:
                    max_score = score
            elif score > 0:
                power = power + tokens[right]
                score = score - 1
                right = right - 1
            else:
                break
                
        return max_score"
"class Solution:
    def buddyStrings(self, s: str, goal: str) -> bool:
        n1=len(s)
        n2=len(goal)
        if n1!=n2: #if length is not equal we cannot make them the same with interchange
            return False
        d=defaultdict(list)
        mx =0 #max count of individual
        cnt=defaultdict(int)
        for i in range(n1):
            cnt[s[i]]+=1
            if cnt[s[i]]>mx:
                mx=cnt[s[i]] # maximum times acharacter occurs in s 
            
            d[i]=[s[i],goal[i]] #store value of both strings at an index
        count=0
        dif=[]
       
        for k in d:
            
            
            a=d[k][0] #letter at index k of s
            b=d[k][1] #letter at index k of s
            if a!=b:
                count+=1 
                dif.append(k)
            if count>2: # only one interchange is allowed 
                return False 
        
        if count==1:
            return False #one index at has unmatched value , can never be interchanged
        if count==0:
            if mx >=2: #s='aa' goal='aa'
                
                return True
            return False #s='ab' goal='ab'
        
        if d[dif[0]][0]==d[dif[1]][1] and d[dif[1]][0]==d[dif[0]][1]: #if 2 values are at wrong index check if there interchange would make the strings same 
            return True 
        return False";"class Solution:
    def buddyStrings(self, s: str, goal: str) -> bool:
        if len(s) != len(goal):
            return False

        if s == goal:
            seen_characters = []
            for char in s:
                if char in seen_characters:
                    return True
                seen_characters.append(char)
            return False

        diff_indices = []
        for i in range(len(s)):
            if s[i] != goal[i]:
                diff_indices.append(i)
        
        if len(diff_indices) == 2:
            first_index = diff_indices[0]
            second_index = diff_indices[1]
            
            if s[first_index] == goal[second_index] and s[second_index] == goal[first_index]:
                return True

        return False"
"class Solution:
    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:
        """"""LeetCode 835

        Not hard in terms of figuring out a method, but very complicated in
        implementation. First turn both images into bitmaps. Then brute force
        it by traversing all possible overlap states. At each state, compute
        the number of overlapped positions.

        The difficulty lies in accurately finding out the correct bitmap from
        both images at each overlapped state to perform the AND operation.

        O(N^4), 645 ms, faster than 81.87%
        """"""
        n = len(img1)
        bitmap1 = [sum(v << (n - i - 1) for i, v in enumerate(row)) for row in img1]
        bitmap2 = [sum(v << (n - i - 1) for i, v in enumerate(row)) for row in img2]
        res = 0
        for i in range(2 * n - 1):
            for j in range(2 * n - 1):
                cur = 0
                if i <= n - 1:
                    if j <= n - 1:
                        for ii in range(n - i - 1, n):
                            ol = ((bitmap1[ii] &amp, ((1 << (j + 1)) - 1)) << (n - j - 1)) &amp, (bitmap2[ii - (n - i - 1)])
                            cur += bin(ol).count('1')
                    else:
                        for ii in range(n - i - 1, n):
                            ol = (bitmap1[ii] >> (j - n + 1)) &amp, (bitmap2[ii - (n - i - 1)])
                            cur += bin(ol).count('1')
                else:
                    if j <= n - 1:
                        for ii in range(2 * n - i - 1):
                            ol = ((bitmap1[ii] &amp, ((1 << (j + 1)) - 1)) << (n - j - 1)) &amp, (bitmap2[ii + i - n + 1])
                            cur += bin(ol).count('1')
                    else:
                        for ii in range(2 * n - i - 1):
                            ol = (bitmap1[ii] >> (j - n + 1)) &amp, (bitmap2[ii + i - n + 1])
                            cur += bin(ol).count('1')
                res = max(res, cur)
        return res";"class Solution:
    def largestOverlap(self, img1, img2):
        n = 0
        if img1:
            n = len(img1)

        max_so_far = 0

        y_shift = -n + 1
        while y_shift < n:
            x_shift = -n + 1
            while x_shift < n:
                
                current_overlap = 0
                row = 0
                while row < n:
                    col = 0
                    while col < n:
                        
                        shifted_row = row + y_shift
                        shifted_col = col + x_shift

                        is_in_bounds = False
                        if shifted_row >= 0 and shifted_row < n and shifted_col >= 0 and shifted_col < n:
                            is_in_bounds = True

                        if is_in_bounds:
                            pixel1 = img1[row][col]
                            pixel2 = img2[shifted_row][shifted_col]
                            if pixel1 == 1 and pixel2 == 1:
                                current_overlap = current_overlap + 1
                        
                        col = col + 1
                    row = row + 1

                if current_overlap > max_so_far:
                    max_so_far = current_overlap

                x_shift = x_shift + 1
            y_shift = y_shift + 1
            
        return max_so_far"
"class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
	
        def helper(full, empty, drank):
		    # Base case, make sure we can continue (we have enough to cash in)
            if full + empty < numExchange:
                return drank+full
			# If we have any full bottles we'll make them empty
            if full:
                empty += full
            # Exchange empties for fulls
            new = empty // numExchange
			# Don't forget there might be remainders!
            remaining_empt = empty - (new*numExchange)
            return helper(new, remaining_empt, drank + full)
            
        return helper(numBottles, 0, 0)";"class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
        bottles_drank = 0
        empty_bottles = 0

        bottles_drank = bottles_drank + numBottles
        empty_bottles = empty_bottles + numBottles

        while empty_bottles >= numExchange:
            new_full_bottles = empty_bottles // numExchange
            
            empty_bottles_used = new_full_bottles * numExchange
            
            empty_bottles = empty_bottles - empty_bottles_used
            
            bottles_drank = bottles_drank + new_full_bottles
            
            empty_bottles = empty_bottles + new_full_bottles

        return bottles_drank"
"class Solution:
    def bulbSwitch(self, n: int) -> int:
        bulb_on = 0
        v = 2
        while n >= 1:
            bulb_on += 1
            n -= v + 1
            v += 2
        return bulb_on";"class Solution:
    def bulbSwitch(self, n: int) -> int:
        bulbs_on = 0
        i = 1
        while i * i <= n:
            bulbs_on = bulbs_on + 1
            i = i + 1
        return bulbs_on"
"class Solution:
    def orderlyQueue(self, s: str, k: int) -> str:
        # case1 : ? s ??????????? return ??? s ??
        if len(set(s)) == 1: return s
        # case2 : ? k ?? 1???? return ?????????(????????????)
        if k != 1: return """".join(sorted(s))
        # case3 : ? k ? 1????????????????
        Len = len(s)
        Min = ""{""
        Min_idxs = dict() # ???????? index ????key = index, val = smallest char
        for i in range(Len):
            if Min > s[i]: # ??????????????? {index:char}??????? == 1
                Min = s[i]
                Min_idxs = {i:s[i]}
            elif Min == s[i]: # ????????????? index:char??????? > 1
                Min_idxs[i] = s[i]
                
        step = 1 # ????? index ?????????????
        # ??????? 1 (????????????????????)?????????????????
        while len(Min_idxs) != 1 and step < Len:

            Min = ""{""
            for idx in Min_idxs:
                comp_idx = (idx+step)%Len # ? index ?? s ????? s[0] ?????
                if Min > s[comp_idx]: # ???? index ? step ????????
                    Min = s[comp_idx]
                Min_idxs[idx] = s[comp_idx] # ??? k,v ?? value ????? step ???
            
            # ? value ???????? key ????
            del_list = [k for k, v in Min_idxs.items() if v != Min]
            # ?? value ???????? k,v ?
            for idx in del_list:
                Min_idxs.pop(idx)
            # ????? step ???
            step += 1

        split_idx = list(Min_idxs.keys())[0] # ??????

        return s[split_idx:] + s[:split_idx] # ????? return";"def orderlyQueue(s, k):
    if k > 1:
        char_list = []
        for char in s:
            char_list.append(char)

        n = len(char_list)
        for i in range(n):
            for j in range(0, n - i - 1):
                if char_list[j] > char_list[j + 1]:
                    temp = char_list[j]
                    char_list[j] = char_list[j + 1]
                    char_list[j + 1] = temp
        
        final_string = """"
        for char in char_list:
            final_string = final_string + char
        return final_string
    else:
        smallest_s = s
        current_s = s
        for i in range(len(s)):
            first_char = current_s[0]
            other_chars = current_s[1:]
            current_s = other_chars + first_char
            if current_s < smallest_s:
                smallest_s = current_s
        return smallest_s"
"class Solution:
    def leastBricks(self, wall: List[List[int]]) -> int:
        
        """"""
        
        Line can be drawn at one unit distance.
        
        Idea here is to create map of points where each row would like to have line
        Such that no brick is cut.
        
        Post this, check max row fine with particualr point.
        
        Ex For this row, [1,2,2,1]
        
        we can draw line without cutting any brick 
        at 1 or 1+2, or 1+2+2
        
        
        
        """"""
        
        
        lenMap  = collections.defaultdict(int)
        
        for w in wall:
            s = 0 
            for i in w[:-1]:
                s = s + i
                lenMap[s] = lenMap[s] + 1
        
        
        fine = 0
        if lenMap.values():
            fine = max(lenMap.values())
        
        return (len(wall) - fine)";"class Solution:
    def leastBricks(self, wall: list[list[int]]) -> int:
        edge_counts = {}
        
        for row in wall:
            position = 0
            num_bricks_in_row = len(row)
            
            # We only care about internal edges, not the final edge of the wall
            if num_bricks_in_row > 1:
                for i in range(num_bricks_in_row - 1):
                    brick_width = row[i]
                    position = position + brick_width
                    
                    if position in edge_counts:
                        edge_counts[position] = edge_counts[position] + 1
                    else:
                        edge_counts[position] = 1

        max_edges = 0
        
        # Find the position with the most edges passing through it
        if edge_counts:
            for position in edge_counts:
                count = edge_counts[position]
                if count > max_edges:
                    max_edges = count
        
        num_rows = len(wall)
        min_bricks_crossed = num_rows - max_edges
        
        return min_bricks_crossed"
"class Solution:
    # O(logn) time,
    # O(1) space,
    # Approach: binary search,
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        
        def findLowerBoundIndexToNum(lo, hi, num):
            while True:
                mid = (lo+hi)//2
                curr = citations[mid]
                
                if curr == num and (mid == 0 or citations[mid-1] < num):
                    return mid
                elif curr == num:
                    hi = mid-1
                elif curr > num:
                    if mid == 0 or citations[mid-1] < num:
                        return mid
                    hi = mid-1
                else:
                    if lo >= hi:
                        if citations[hi] >= num:
                            return hi
                        else:
                            return n
                    lo = mid+1
        
        def valid(hindex):
            index = findLowerBoundIndexToNum(0, n-1, hindex)
            citation_num = n - index
            return citation_num >= hindex
        
        
        def findMaxHindex(lo, hi):
            while True:
                mid = (lo+hi)//2
                validCitation = valid(mid)
                
                if validCitation and (mid == n or not valid(mid+1)):
                    return mid
                elif not validCitation:
                    hi = mid-1
                else:
                    if lo >= hi:
                        return hi
                    lo = mid+1
                
        return findMaxHindex(0, n)";"class Solution:
    def hIndex(self, citations: list[int]) -> int:
        n = len(citations)
        low = 0
        high = n - 1
        h_index = 0
        
        while low <= high:
            mid = (low + high) // 2
            
            papers = n - mid
            
            if citations[mid] >= papers:
                h_index = papers
                high = mid - 1
            else:
                low = mid + 1
                
        return h_index"
"class Solution:
    def addDigits(self, num: int) -> int:

        num = [int(i) for i in str(num)]

        if len(num) == 1:
          return num[0]

        while(len(num) != 1): 
          sum = 0
          for i in range(len(num)):
            sum += num[i]
          num = sum
          num = [int(i) for i in str(num)]
        return num[0]";"class Solution:
    def addDigits(self, num: int) -> int:
        while num >= 10:
            suma_temporal = 0
            numero_como_cadena = str(num)
            for caracter_digito in numero_como_cadena:
                suma_temporal = suma_temporal + int(caracter_digito)
            num = suma_temporal
        return num"
"class Solution:

    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        # Step 0: Special case of an empty route
        if source == target: return 0

        # Step 1: Create a dict of [stop -> busses stopping at this stop]
        stop2bus = dict()
        for i in range(len(routes)):
            for stop in routes[i]:
                if stop not in stop2bus: stop2bus[stop] = set()
                stop2bus[stop].add(i)

        # Step 2: BFS over the bus stops
        bfs_queue = [(source,0)] # Tuple of (bus stop, number of busses taken to get to the stop)
        visited = {source} # Set of visited bus stops to avoid cycles
        
        while len(bfs_queue) > 0: # BFS
            stop, numBusses = bfs_queue.pop(0)
            if stop==target: return numBusses # If we arrived at the target, stop here!
            if stop in stop2bus:
                for bus in stop2bus[stop]: # Check all busses at this stop
                    for neighbour in routes[bus]: # Check all stops of each bus
                        if neighbour not in visited:
                            # Add all new stops to the neighbours
                            bfs_queue.append((neighbour,numBusses+1))
                            visited.add(neighbour)
                    routes[bus]=[]
            
        return -1 # If we finished the BFS and did not reach the target, it is unreachable";"class Solution:
    def numBusesToDestination(self, routes, source, target):
        if source == target:
            return 0

        stop_to_routes_map = {}
        for i in range(len(routes)):
            route = routes[i]
            for stop in route:
                if stop not in stop_to_routes_map:
                    stop_to_routes_map[stop] = []
                stop_to_routes_map[stop].append(i)

        queue = []
        visited_routes = set()

        if source in stop_to_routes_map:
            for route_index in stop_to_routes_map[source]:
                queue.append(route_index)
                visited_routes.add(route_index)

        buses_count = 1
        
        while len(queue) > 0:
            level_size = len(queue)
            for _ in range(level_size):
                current_route_index = queue.pop(0)

                for stop in routes[current_route_index]:
                    if stop == target:
                        return buses_count

                    if stop in stop_to_routes_map:
                        for next_route_index in stop_to_routes_map[stop]:
                            if next_route_index not in visited_routes:
                                visited_routes.add(next_route_index)
                                queue.append(next_route_index)

            buses_count = buses_count + 1

        return -1"
"class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        n = len(piles)
        memo = [[0] * n for i in range(n)]
        
        def dp(i, j):
            if (i > j): return 0
            if (memo[i][j] != 0):
                return memo[i][j]
            
            player_turn = (n - (j - i)) % 2
            if (player_turn == 1):
                # increasing player1's score when player1 picks a max pile
                memo[i][j] = max(piles[i] + dp(i+1, j), piles[j] + dp(i, j-1))
            else:
                # decreasing player1's score when player2 picks a pile and player2 is assumed to pick the larger pile leading to a min score for player1
                memo[i][j] = min(-piles[i] + dp(i+1, j), -piles[j] + dp(i, j-1))
            return memo[i][j]
                
        return dp(0, n-1) > 0";"class Solution:
    def stoneGame(self, piles: list[int]) -> bool:
        n = len(piles)
        
        if n > 0:
            return True
        else:
            return False"
"class Solution:
    #Time-Complexity: O(rows*cols)
    #Space-Complexity: O(rows*cols + rows*cols) -> O(rows*cols)
    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:
        #this is a standard bfs problem!
        #we will add to queue pixels that share same color as the starting pixel point 
        #that have not already been visited!
        #For each element we dequeue from queue, we will overwrite that entry with the new
        #color!
        #our answer will return image parameter that is modified in-place!
        rows, cols = len(image), len(image[0])
        visited = set()
        q = collections.deque()
        orig_color = image[sr][sc]
        q.append([sr, sc])
        visited.add((sr, sc))
        four_directions = [[1,0],[-1,0], [0,1], [0,-1]]
        #initiate bfs!
        while q:
            cr, cc = q.popleft()
            image[cr][cc] = color
            #iterate through each of four directional neighbors!
            for direction in four_directions:
                r_change, c_change = direction
                if(cr + r_change in range(rows) and
                   cc + c_change in range(cols) and 
                   image[cr+r_change][cc+c_change] == orig_color and
                   (cr+r_change, cc+c_change) not in visited):
                    q.append([cr+r_change, cc+c_change])
                    visited.add((cr+r_change, cc+c_change))
        #once bfs ends, return grid changed in place!
        return image";"def floodFill(image, sr, sc, color):
    rows = len(image)
    cols = len(image[0])
    original_color = image[sr][sc]

    if original_color == color:
        return image

    q = []
    q.append((sr, sc))
    image[sr][sc] = color

    while len(q) > 0:
        r, c = q.pop(0)

        # Up
        if r - 1 >= 0 and image[r - 1][c] == original_color:
            image[r - 1][c] = color
            q.append((r - 1, c))

        # Down
        if r + 1 < rows and image[r + 1][c] == original_color:
            image[r + 1][c] = color
            q.append((r + 1, c))

        # Left
        if c - 1 >= 0 and image[r][c - 1] == original_color:
            image[r][c - 1] = color
            q.append((r, c - 1))

        # Right
        if c + 1 < cols and image[r][c + 1] == original_color:
            image[r][c + 1] = color
            q.append((r, c + 1))

    return image"
"class Solution:
    def toGoatLatin(self, sentence: str) -> str:
        new = sentence.split() # Breaks up the input into individual sentences
        count = 1 # Starting at 1 since we only have one ""a"" to begin with.
        
        for x in range(len(new)):
            if new[x][0].casefold() in 'aeiou': # Checks if the first value of x is a vowel. The casefold, can be replaced with lower, lowers the case. Can also just be removed and have ""in 'aeiouAEIOU'
                new[x] = new[x] + 'ma' + 'a'*count # Brings it together with the count multiplying number of ""a""'s as needed.
                count += 1
            elif new[x].casefold() not in 'aeiou': # Same comment as above.
                new[x] = new[x][1:] + new[x][0] + 'ma' + 'a'*count # Just moves the first value to the end then does the a.
                count += 1
        
        return "" "".join(x for x in new) # Converts the list back into a string.";"class Solution:
    def toGoatLatin(self, sentence: str) -> str:
        words = sentence.split(' ')
        vowels = ""aeiouAEIOU""
        new_words_list = []
        
        index = 1
        for word in words:
            first_char = word[0]
            
            is_vowel = False
            for v in vowels:
                if v == first_char:
                    is_vowel = True
                    break
            
            if is_vowel:
                new_word = word + ""ma""
            else:
                rest_of_word = word[1:]
                new_word = rest_of_word + first_char + ""ma""

            a_to_add = """"
            for i in range(index):
                a_to_add = a_to_add + ""a""

            new_word = new_word + a_to_add
            new_words_list.append(new_word)
            
            index = index + 1
            
        result_sentence = """"
        for i in range(len(new_words_list)):
            word = new_words_list[i]
            result_sentence = result_sentence + word
            if i < len(new_words_list) - 1:
                result_sentence = result_sentence + "" ""
                
        return result_sentence"
"class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        # Break words into pieces
        # Empty word can be found in the dictionary
        # can the whole s be also represented in the dictionary?
        
        # BUILDING THE INTUITION HERE
        """"""
        1. can I generate all substrings and check if the strings in the 
        dictionary are present in the substring.
        2. This will not work, why? Because strings in the mother set 
        may have been used already to create another string
        
        SOLUTION
        --------------------------
        1. Go through the dictionary of words and find the string which is the 
        potential begining of the string
        2. segment the length of that string from the string.
        3. Check if the remaining string can also be segmented in words from 
        the dictionary.
        4. if there are no more strings to segment then we can return True.
        5. This is a recurrence problem and can be solved with the recurrence 
        solution.
        
        6. The recurrence function should go through the word dictionary 
        and the one which qualifies will now segment the rest of the string 
        and check for the rest of the segment of the string.
        
        FOR THE RECURRENCE RELATION
        
        1. With every word in the dictionary, get the length of the word.
        2. Check if a segment of the string is equal to that word.
        3. if True, call the function of the rest of the segment of the string.
        
        Base Case:
        1. If all strings are segmented, which means we have the empty ("""") string
        so we can then return True
        
        2. Else we return False
        
        """"""
        """""" RECURRENCE SOLUTION """"""
        def sectionBreak(string):
            if len(string) == 0:
                return True

            for word in wordDict:
                prefix = string[:len(word)]

                if prefix == word and sectionBreak(string[len(word):]):
                    return True
            return False
        
        return sectionBreak(s)
        
        """"""
        MOMOIZATION
        """"""
        def sectionBreak(string, memo):
            if len(string) == 0:
                return True
            elif string in memo:
                return memo[string]

            for word in wordDict:
                prefix = string[:len(word)]

                if prefix == word and sectionBreak(string[len(word):], memo):
                    memo[string] = True
                    return True
            memo[string] = False
            return False
        
        return sectionBreak(s, {})

        """"""
        The dynammic programming approach 
        1. The empty substring can be segmented to any of the words in the dictionary.
        2. Let the index of the words represents the sufix of words in the dictionary.
        3. If suffix of a word is in the dictionary then and the suffix of the previous 
        word is also in the dictionary, then it stands to prove that, the substring of 
        the string up to the current suffix can also be segmented
        """"""
    
        # Initialize a dp table with the length of the string + 1
        # Plus 1 is to compensate for the empty string
        # You can either iterate from the back if you want to use the prefix instead of suffix pointers.
        
        wordSet = set(wordDict) # put words in a hashSet to optimize lookup to O(1)
        dp = [False for _ in range(len(s)+1)]
        dp[0] = True
        
        for i in range(1, len(s)+1):
            for j in range(i-1, -1, -1):
                if dp[j] and s[j:i] in wordSet:
                    dp[i] = True
                    break  # break from the loop if a segment is found
        return dp[-1]";"class Solution:
    def wordBreak(self, s, wordDict):
        n = len(s)
        dp = []
        i = 0
        while i < n + 1:
            dp.append(False)
            i = i + 1

        dp[0] = True

        i = 1
        while i < n + 1:
            j = 0
            while j < i:
                if dp[j] == True:
                    substring = s[j:i]
                    is_in_dictionary = False
                    for word in wordDict:
                        if word == substring:
                            is_in_dictionary = True
                            break
                    
                    if is_in_dictionary == True:
                        dp[i] = True
                        break
                j = j + 1
            i = i + 1
        
        return dp[n]"
"class Solution:
    def binaryGap(self, n: int) -> int:
        
        #Bit mask
        mask = 1,
        
        #Max streak and streak default to zero
        maxStreak = 0,
        streak = 0,
        
        #Burn through all of the rightmost zeroes
        #Keep bitshifting n to the right
        #As long as the rightmost bit is not 1 ( which means its even)
        while n > 0 and n % 2 != 1:
            n = n >> 1,
        
        #Then we can begin finding our distances
        while n > 0:
            #Each iteration, we see if the rightmost bit is 1
            isOne = ( mask &amp, n ) == 1,
            
            #If it is, we update our max
            if isOne:
                maxStreak = max( maxStreak, streak ),
                
                #And then increment the streak
                streak = 1,
                
            #If it is a zero, we increment the streak
            else:  
                streak += 1,
                
            #Each time, we bitshift right
            n = n >> 1,
        
        #Note, we will always end at a valid 1 as leading zeros are not
        #processed and we stop when n == 0
        return maxStreak,";"class Solution:
    def binaryGap(self, n: int) -> int:
        binary_string = bin(n)[2:]
        
        max_distance = 0
        last_one_index = -1
        current_index = 0
        
        for bit in binary_string:
            if bit == '1':
                if last_one_index != -1:
                    distance = current_index - last_one_index
                    if distance > max_distance:
                        max_distance = distance
                
                last_one_index = current_index
            
            current_index = current_index + 1
            
        return max_distance"
"class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        
        """"""
        Let suppose we can divide the array in to two subsets S1 and S2.
        Such that, the difference of those subset is target value.
        sum(S1) + sum(S2) = total     --- (1)
        sum(S1) - sum(S2) = target    --- (2)
        _____________________________________
        2*sum(S1) = total + target    --- (1) + (2)
        
        Hence, sum(S1) = total + target // 2
        """"""
        
        # Total of array
        total = sum(nums)
        
        # Base Case:
        # If total is less than target it is not possible to find any subsets
        # If total + target is odd, no subset exists
        if (total < target) or ((total + target) % 2):
            return 0
        
        # Get the value of sum of subset S1
        sum_s1 = (total + target) // 2
        
        # Recurrsion with memoization
        def countSubsetSum(n: int, w : int, t: Dict):
            if n == 0:
                t[(n,w)] = (0 if w else 1)
            else:
                if (n,w) not in t:
                    if nums[n-1] <= w:
                        t[(n,w)] = countSubsetSum(n-1, w-nums[n-1], t) + countSubsetSum(n-1, w, t) 
                    else:
                        t[(n,w)] = countSubsetSum(n-1, w, t)
            return t[(n,w)]
            
        return countSubsetSum(len(nums), sum_s1, dict())";"class Solution:
    def findTargetSumWays(self, nums, target):
        count = 0
        stack = []
        stack.append((0, 0))

        while len(stack) > 0:
            index, current_sum = stack.pop()

            if index == len(nums):
                if current_sum == target:
                    count = count + 1
            else:
                num = nums[index]
                
                # Add the number
                stack.append((index + 1, current_sum + num))
                
                # Subtract the number
                stack.append((index + 1, current_sum - num))
        
        return count"
"class Solution:
    #Time-Complexity: O(16rows*cols), in worst case our bfs algorithm needs to         process, and each iteration of while loop in worst case will run for loop
    #2 times, with each going through each of eight directions for total of 16!
    #-> O(rows*cols)
    #Space-Complexity: O(2rows*cols)->O(rows*cols)
    #each and every entry of grid that could be updated!
    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:
        #click is going to be start position of our bfs!
        
        #first thing we got to check is if click position clicks a unrevealed mine directly -> Immediate
        #Game Over!
        rows, cols = len(board), len(board[0])
        sr, sc = click
        if(board[sr][sc] == 'M'):
            board[sr][sc] = 'X'
            return board
        
        #otherwise, we need to inititate bfs starting from click position using a queue data structure!
        q = collections.deque()
        #need a visited hashset so we don't revisit empty cell again! Since we may need to bfs
        #continuously from a cell with no adjacent mines in terms of its neighbors!
        visited = set()
        q.append(click)
        visited.add((sr, sc))
        eight_directions = [[1, 0], [-1, 0], [0, 1], [0,-1], [-1, -1], [-1, 1], [1, -1], [1, 1]]
        # as long as queue is non-empty initiate bfs!
        while q:
            #cr = current row, cc = current column!
            cr, cc = q.popleft()
            #for each new empty cell we are processing, the number of adjacent mines starts as 0!
            number_of_mines = 0
            #we have to loop through each of the 8 directional neighbors and check how many of them
            #are in-bounds, unrevealed mine cell!
            for direction in eight_directions:
                r_change, c_change = direction
                if(cr + r_change in range(rows) and 
                   cc + c_change in range(cols) and 
                   board[cr+r_change][cc+c_change] == 'M'):
                    number_of_mines += 1
            #once we iterated through all possible eight neighbors, check if current empty cell
            #has no adjacent mines or even at least 1!
            if(number_of_mines == 0):
                #then, check each of eight directional neighbors: in-bounds, unrevealed empty cell, and
                #and it's not already visited!
                for direction2 in eight_directions:
                    r_change2, c_change2 = direction2
                    if(cr + r_change2 in range(rows) and
                       cc + c_change2 in range(cols) and
                       board[cr+r_change2][cc+c_change2] == 'E' and
                       (cr+r_change2, cc+c_change2) not in visited):
                        q.append([cr+r_change2, cc+c_change2])
                        visited.add((cr+r_change2, cc+c_change2))
                #current empty cell 
                board[cr][cc] = 'B'
            else:
                #otherwise, we need to stop bfs from current cell and label current cell
                #by number of adjacent land mines! digits 1-8 at most!
                board[cr][cc] = str(number_of_mines)
        #once bfs is done, our game board is updated! Simply return it!
        return board";"class Solution:
    def updateBoard(self, board, click):
        rows = len(board)
        cols = len(board[0])
        r = click[0]
        c = click[1]

        if board[r][c] == 'M':
            board[r][c] = 'X'
            return board
        
        queue = []
        queue.append((r, c))
        
        if board[r][c] == 'E':
            board[r][c] = 'B'
        
        head = 0
        while head < len(queue):
            curr_r, curr_c = queue[head]
            head = head + 1

            mine_count = 0
            for i in range(-1, 2):
                for j in range(-1, 2):
                    if i == 0 and j == 0:
                        continue
                    
                    nr = curr_r + i
                    nc = curr_c + j

                    if 0 <= nr < rows and 0 <= nc < cols:
                        if board[nr][nc] == 'M':
                            mine_count = mine_count + 1
            
            if mine_count > 0:
                board[curr_r][curr_c] = str(mine_count)
            else:
                board[curr_r][curr_c] = 'B'
                for i in range(-1, 2):
                    for j in range(-1, 2):
                        if i == 0 and j == 0:
                            continue
                        
                        nr = curr_r + i
                        nc = curr_c + j

                        if 0 <= nr < rows and 0 <= nc < cols:
                            if board[nr][nc] == 'E':
                                board[nr][nc] = 'B'
                                queue.append((nr, nc))
        
        return board"
"class Solution:
    def isUgly(self, n):
        # Base Cases: 
        # For a number to be ""Ugly"" the first
        # prerequisite is that it is positive
        if n <= 0: return False
        if n == 1: return True

        # Initializing desired set for O(1) lookups later
        # Not a huge improvement, but it's non-zero improvement
        desired = {2,3,5}
        primes = (i for i in [2,3,5,7])

        current_prime = next(primes)
        while True:
            # As soon as our current prime exceeds 2,3,5 we know our n
            # has prime factors not included in the ""Ugly"" grouping
            if current_prime not in desired: return False
            
            # We want to divide n by said prime as many times as we can
            # If the prime doesn't divide evenly into n then we go to the
            # next prime. We would only do this shift 3 times, and once 
            # we have, we've gone into the realm of non-Ugly numbers
            while n % current_prime == 0:
                div= n/current_prime
                if div == 1: return True
                n = div
            current_prime = next(primes)";"class Solution:
    def isUgly(self, n: int) -> bool:
        if n <= 0:
            return False

        while n % 2 == 0:
            n = n / 2

        while n % 3 == 0:
            n = n / 3

        while n % 5 == 0:
            n = n / 5

        if n == 1:
            return True
        else:
            return False"
"class Solution:
    def deserialize(self, s: str) -> NestedInteger:
        stack = []
        integerStr = ''
        
        for c in s:
            if c == '[':
                stack.append(NestedInteger())
            elif c == ']':
                if len(integerStr)>0:
                    stack[-1].add(NestedInteger(int(integerStr)))
                integerStr = ''
                poppedList = stack.pop()
                if len(stack)==0:
                    return poppedList
                stack[-1].add(poppedList)
            elif c == ',':
                if len(integerStr)>0:
                    stack[-1].add(NestedInteger(int(integerStr)))
                integerStr = ''
            else:
                integerStr += c
                
        return NestedInteger(int(s))";"class Solution(object):
    def deserialize(self, s):
        if s[0] != '[':
            value = int(s)
            return NestedInteger(value)

        if s == '[]':
            return NestedInteger()

        stack = []
        root = NestedInteger()
        stack.append(root)

        i = 1
        length = len(s)

        while i < length:
            char = s[i]

            if char == '[':
                new_list = NestedInteger()
                current_list = stack[-1]
                current_list.add(new_list)
                stack.append(new_list)
                i = i + 1
            elif char == ']':
                stack.pop()
                i = i + 1
            elif char == ',':
                i = i + 1
            else:
                start_of_num = i
                j = i
                if s[j] == '-':
                    j = j + 1
                while j < length and s[j].isdigit():
                    j = j + 1
                
                num_string = s[start_of_num:j]
                value = int(num_string)
                num_ni = NestedInteger(value)
                
                current_list = stack[-1]
                current_list.add(num_ni)
                
                i = j
                
        return root"
"class Solution:
    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:
        prev_key, prev_ts = ('',0) ## this tuple will contain the previous key press and when that was released (prev_ts)
        slowest_key, max_duration = ('',0) ## this tuple will contain the slowest key and for how long it was pressed for
        for key,release_ts in zip(keysPressed,releaseTimes): ## convert keyPressed and releaseTimes into tuples and example the tuple one-by-one
            cur_duration = release_ts - prev_ts ## get the duration for which the key was pressed
            if prev_ts == 0: ## initial case, first key press
                prev_ts = release_ts
                max_duration=release_ts
            if cur_duration > max_duration: ## subsequent keys, check if current duration is more than max we have seen so far
                slowest_key, max_duration = key, cur_duration ## assign the max tuple with the new max and corresponding key
            elif cur_duration == max_duration: ## if current key press duration and max are the same, 
                if key > slowest_key: ## check which one is higher lexically, if current key is higher then update the slowest key to current key
                    slowest_key = key
            prev_key, prev_ts = key, release_ts ## set current key and release_ts to prev for next iteration
        return slowest_key";"class Solution:
    def slowestKey(self, releaseTimes: list[int], keysPressed: str) -> str:
        max_duration = releaseTimes[0]
        result_key = keysPressed[0]
        
        i = 1
        while i < len(keysPressed):
            duration = releaseTimes[i] - releaseTimes[i - 1]
            
            if duration > max_duration:
                max_duration = duration
                result_key = keysPressed[i]
            elif duration == max_duration:
                if keysPressed[i] > result_key:
                    result_key = keysPressed[i]
            
            i = i + 1
            
        return result_key"
"class Solution:
    # O(n * m^2) time, n --> len(wordList), m --> len(wordList[i])
    # O(n*m) space,
    # Approach: BFS, hashtable, string
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        
        vstd = set()
        pattern_map = {}
        
        def buildPattern() -> None:
            addWordPattern(beginWord)
            for word in wordList:
                addWordPattern(word)
                
        
        def addWordPattern(word: str) -> None:
            patterns = getPatterns(word)
            
            for pattern in patterns:
                if pattern not in pattern_map.keys():
                    pattern_map[pattern] = []
                pattern_map[pattern].append(word)
        
        
        def getPatterns(word: str) -> List[str]:
            patterns = []
            for i in range(len(word)):
                pattern = word[:i] + '#' + word[i+1:]
                patterns.append(pattern)
                
            return patterns
        
        
        def getNeighbours(root_word: str) -> List[str]:
            neighbours = []
            patterns = getPatterns(root_word)
            
            for pattern in patterns:
                words = pattern_map[pattern]
                for word in words:
                    if word != root_word:
                        neighbours.append(word)
                
            return neighbours
        
        
        def bfs(root_word:str) -> int:
            qu = deque()
            qu.append(root_word)
            depth = 0
            
            while qu:
                n = len(qu)
                depth +=1
                for i in range(n):
                    root_word = qu.popleft()
                    if root_word in vstd:   continue
                    
                    if root_word == endWord:
                        return depth
                    
                    vstd.add(root_word)
                    neighbours = getNeighbours(root_word)
                    for nb in neighbours:
                        qu.append(nb)
                    
            return 0
            
        buildPattern()
        ans = bfs(beginWord)
        return ans";"def ladderLength(beginWord, endWord, wordList):
    word_set = set()
    for word in wordList:
        word_set.add(word)

    if endWord not in word_set:
        return 0

    queue = []
    queue.append((beginWord, 1))
    
    visited = set()
    visited.add(beginWord)

    while len(queue) > 0:
        current_word, length = queue.pop(0)

        if current_word == endWord:
            return length

        word_as_list = list(current_word)
        for i in range(len(word_as_list)):
            original_char = word_as_list[i]
            
            alphabet = ""abcdefghijklmnopqrstuvwxyz""
            for char in alphabet:
                if char == original_char:
                    continue

                word_as_list[i] = char
                next_word = """".join(word_as_list)

                if next_word in word_set:
                    if next_word not in visited:
                        visited.add(next_word)
                        queue.append((next_word, length + 1))
            
            word_as_list[i] = original_char

    return 0"
"class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        drop = {}   # passengers drop location list        
        nxt = trips[0][2]   # next/earliest drop point
        
        # swap-> numPassengersi and fromi in the trips, then
        # sort(asc) trips as per pickup location
        for p in trips:
            p[0], p[1]  = p[1], p[0]
        heapq.heapify(trips)
        
			seats = capacity    #available seats
        while trips:
            # current stop, num of passenger, dest/to
            (curr, psg, dest) = heapq.heappop(trips)
            # drop passengers
            while nxt <= curr:
                if drop:
                    seats += drop[nxt]
                    del drop[nxt]
                    if drop:
                        nxt = min(drop)                
                    else:
                        nxt = dest                            
            # pick passengers/psg        
            seats -= psg            
            if seats < 0:                
                return False
            #number of passengers to drop at location dest
            if dest in drop:
                drop[dest] += psg
            else:                
                drop[dest] = psg
            nxt = min(nxt, dest)            
            
        return True";"class Solution:
    def carPooling(self, trips: list[list[int]], capacity: int) -> bool:
        max_location = 0
        for trip in trips:
            if trip[2] > max_location:
                max_location = trip[2]

        timeline = []
        for i in range(max_location + 1):
            timeline.append(0)

        for trip in trips:
            passengers = trip[0]
            start = trip[1]
            end = trip[2]
            timeline[start] = timeline[start] + passengers
            timeline[end] = timeline[end] - passengers

        current_passengers = 0
        for i in range(max_location + 1):
            current_passengers = current_passengers + timeline[i]
            if current_passengers > capacity:
                return False
        
        return True"
"class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        
        dict_1 = from_str_to_dict(ransomNote)
        dict_2 = from_str_to_dict(magazine)
        
        return check_compatibility(dict_1, dict_2)
    
# Define helper method that checks if to dictionaries have keys in common, and 
# if the ransomNote needs more letters then what the magazine can provide.

def check_compatibility(dict_1, dict_2):
    
    # Check for common keys.
    for key in list(dict_1.keys()):
        
        if not key in dict_2:
            
            return False
        
        # Check for valid quantity.
        if dict_1[key] > dict_2[key]:
            
            return False
        
    return True

# Convert a string into a dictionary.

def from_str_to_dict(string: str):
    
    dic = {}
    
    for i in string:
        
        if i in dic:
            
            dic[i] += 1
            
        else:
            
            dic[i] = 1
            
    return dic        

# Runtime: 134 ms, faster than 24.02% of Python3 online submissions for Ransom Note.
# Memory Usage: 14.1 MB, less than 93.55% of Python3 online submissions for Ransom Note.

# If you like my work and found it helpful, then I'll appreciate a like. Thanks!";"class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        magazine_letras = list(magazine)
        
        for letra in ransomNote:
            if letra in magazine_letras:
                magazine_letras.remove(letra)
            else:
                return False
        
        return True"
"class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        self.targetSum, self.ans = targetSum, []            # variable initialization
        self.get_path_sum(root, 0, [])                      # calling function get path sum
        return self.ans                                     # return answer
        
    def get_path_sum(self, root, psum, path):
        if not root: return None                            # if not root return None
        if not root.left and not root.right:                # if curr node is leaf
            if root.val + psum == self.targetSum:           # if path sum from root to leaf = target sum
                path.append(root.val)                       # append node value to path
                self.ans.append([e for e in path])          # add path to ans list
                path.pop(-1)                                # remove node value from path
                return,                                     # return
        path.append(root.val)                               # append node value to path
        self.get_path_sum(root.left, psum + root.val, path) # left traversal
        self.get_path_sum(root.right, psum + root.val, path)# right traversal
        path.pop(-1)                                        # remove node value from path";"class Solution:
    def pathSum(self, root, targetSum):
        if root is None:
            return []

        all_paths = []
        stack = []
        # Each item in the stack will be a tuple: (node, current_sum, path_list)
        stack.append((root, root.val, [root.val]))

        while len(stack) > 0:
            current_node, current_sum, path = stack.pop()

            is_leaf = current_node.left is None and current_node.right is None
            if is_leaf:
                if current_sum == targetSum:
                    all_paths.append(path)

            if current_node.right is not None:
                right_child = current_node.right
                
                new_path_for_right = []
                for node_val in path:
                    new_path_for_right.append(node_val)
                new_path_for_right.append(right_child.val)
                
                new_sum_for_right = current_sum + right_child.val
                
                stack.append((right_child, new_sum_for_right, new_path_for_right))

            if current_node.left is not None:
                left_child = current_node.left
                
                new_path_for_left = []
                for node_val in path:
                    new_path_for_left.append(node_val)
                new_path_for_left.append(left_child.val)
                
                new_sum_for_left = current_sum + left_child.val
                
                stack.append((left_child, new_sum_for_left, new_path_for_left))

        return all_paths"
"class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        # To adhere to the problem's constraints, we should probably hardcode this!
        tables_of_addition = {str(x): {str(i): str(x+i) for i in range(10)} for x in range(0, 10)}
        # Corner case
        for i in range(10, 20): tables_of_addition[""1""][str(i)] = str(1+i)
        
        # Ensuring that the 2 numbers are the same size.
        num1 = num1.zfill(max(len(num1), len(num2)))
        num2 = num2.zfill(max(len(num1), len(num2)))

        p = len(num1)-1
        
        carry, results = ""0"", """"
        while p > -1:
            curr_res = tables_of_addition[num1[p]][num2[p]]
            
            # Carry is a bit tricky since current result can be in the range 0, 18 (inclusive)
            curr_res_with_carry = tables_of_addition[str(carry)][curr_res] if str(carry) == ""1"" else curr_res
            carry = ""0""
            
            # We know that the maximum addition (between 9 &amp, 9) is 2 digits and will equal 18
            if len(curr_res_with_carry) > 1:
                carry = curr_res_with_carry[0]
                results = curr_res_with_carry[1]+results
            else:
                results = curr_res_with_carry[0]+results
            p-=1
        
        return results if carry == ""0"" else carry + results";"class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        resultado = """"
        acarreo = 0
        
        puntero1 = len(num1) - 1
        puntero2 = len(num2) - 1

        while puntero1 >= 0 or puntero2 >= 0 or acarreo > 0:
            digito1 = 0
            if puntero1 >= 0:
                digito1 = ord(num1[puntero1]) - ord('0')
            
            digito2 = 0
            if puntero2 >= 0:
                digito2 = ord(num2[puntero2]) - ord('0')
            
            suma = digito1 + digito2 + acarreo
            
            digito_actual = suma % 10
            acarreo = suma // 10
            
            resultado = str(digito_actual) + resultado
            
            puntero1 = puntero1 - 1
            puntero2 = puntero2 - 1
            
        return resultado"
"class Solution:
    def maxJumps(self, nums: List[int], d: int) -> int:
        N = len(nums)
        seen = set() # seen for lookup, to memoize
        dp = [1]*N   # stores the values of jump we can make from Ith index in DP.                                    #  minimum being 1 jump (i.e its self)
        
        def recursion(indx):
            # if we have indx in seen return its value  dp[indx].
            if indx in seen:
                return dp[indx]
            # base case if indx is out of range we cant jump. return 0
            if indx<0 or indx >= N:
                return 0
            
        # tempR : all the jumps we can make to the right side of indx
        # tempL : all the jumps we can make to the left side of indx
            tempR,tempL= 0,0
            curr = nums[indx] # height of current indx so we only jump allowed jump 
                    # i.e nums[i] < curr <- allowed  if curr =< nums[i] break(jump not allowed)
            
            #max jump we can make to the right Side are stored in tempR, 
            for i in range(indx+1, min(indx+d+1,N) ):
                if nums[i] < curr:
                    tempR = max(tempR, recursion(i)) # store max jumps in right
                else:
                    break
            for i in range(indx-1, max(-1,indx-d-1) , -1): 
                if nums[i] < curr:
                    tempL = max(tempL, recursion(i)) # store max jumps in  left
                else:
                    break
            # update dp[indx] by (1 + maxjumps( right, left))   ( 1 becoz it can jump on itself)
            dp[indx] = max(tempR,tempL) + 1 
            seen.add(indx) # as Indx calculated, can use its value next time, so added to seen
            return dp[indx]
        
        
        # for all indices we check how many jumps we can make
        for i in range(N): 
            if i not in seen: # if ith index is not in seen then we have comupted its jumps.
                recursion(i)
        return max(dp)  # returns the max jumps";"class Solution:
    def maxJumps(self, arr, d):
        n = len(arr)
        dp = [1] * n
        
        memo = {}

        for i in range(n):
            if i not in memo:
                
                stack = [i]
                visited_in_path = {i}
                
                while stack:
                    curr_i = stack[-1]
                    
                    if curr_i in memo:
                        stack.pop()
                        continue

                    has_unresolved_dependency = False
                    
                    # Check right jumps
                    for x in range(1, d + 1):
                        next_i = curr_i + x
                        if next_i >= n or arr[next_i] >= arr[curr_i]:
                            break
                        if next_i not in memo and next_i not in visited_in_path:
                            stack.append(next_i)
                            visited_in_path.add(next_i)
                            has_unresolved_dependency = True
                    
                    if has_unresolved_dependency:
                        continue

                    # Check left jumps
                    for x in range(1, d + 1):
                        next_i = curr_i - x
                        if next_i < 0 or arr[next_i] >= arr[curr_i]:
                            break
                        if next_i not in memo and next_i not in visited_in_path:
                            stack.append(next_i)
                            visited_in_path.add(next_i)
                            has_unresolved_dependency = True

                    if has_unresolved_dependency:
                        continue
                    
                    # All dependencies are resolved, calculate dp[curr_i]
                    stack.pop()
                    visited_in_path.remove(curr_i)
                    
                    max_path = 1
                    # Right jumps
                    for x in range(1, d + 1):
                        next_i = curr_i + x
                        if next_i >= n or arr[next_i] >= arr[curr_i]:
                            break
                        path_len = 1 + memo[next_i]
                        if path_len > max_path:
                            max_path = path_len
                            
                    # Left jumps
                    for x in range(1, d + 1):
                        next_i = curr_i - x
                        if next_i < 0 or arr[next_i] >= arr[curr_i]:
                            break
                        path_len = 1 + memo[next_i]
                        if path_len > max_path:
                            max_path = path_len
                            
                    memo[curr_i] = max_path
        
        max_overall = 0
        if not arr:
            return 0
            
        for i in range(n):
            if memo[i] > max_overall:
                max_overall = memo[i]
                
        return max_overall"
"class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if node is None: return None #if we have an empty graph
        visited = [] #will store all visited nodes
        cloneNodes = {} #will store cloned nodes. In each k:v pair k is the val attribute of 
                        #the old node and v is the corresponding cloned node
        adj = {} #the adjacency list for the graph. In each k:v pair k is the val attribute
                 #of a node and v is a list of the val attributes of its neighbors.
        stack = [node] #stack of nodes to be visited. Each time we visit a node, we will add
                       #its neighbors in the stack.
        while stack != []:
            curr = stack.pop() #take a node out of the stack
            if curr.val not in visited: #if node was already visited we do nothing
                visited.append(curr.val)
                cloneNodes[curr.val] = Node(curr.val) #create new node with the same val and 
                                                      #no neighbors
                adj[curr.val] = []
                for nd in curr.neighbors:
                    stack.append(nd) #add neighbors in the stack
                    adj[curr.val].append(nd.val) #save neighbors in adjacency dictionary
        for k, v in adj.items():
            #update neighbors of cloned nodes to match the neighbors of old ones
            cloneNodes[k].neighbors = [cloneNodes[i] for i in v]
        return cloneNodes[node.val] #return clone of initial node";"class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return None

        old_to_new = {}
        queue = []
        
        queue.append(node)
        cloned_start_node = Node(node.val, [])
        old_to_new[node] = cloned_start_node

        while len(queue) > 0:
            current_original_node = queue.pop(0)

            for original_neighbor in current_original_node.neighbors:
                if original_neighbor not in old_to_new:
                    new_cloned_neighbor = Node(original_neighbor.val, [])
                    old_to_new[original_neighbor] = new_cloned_neighbor
                    queue.append(original_neighbor)
                
                cloned_current_node = old_to_new[current_original_node]
                cloned_neighbor_node = old_to_new[original_neighbor]
                cloned_current_node.neighbors.append(cloned_neighbor_node)

        return cloned_start_node"
"class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        n=len(nums)
        
        # Brute Force: O(n^3) --> TLE
		# for i in range(n):
        #     for j in range(i+1, n):
        #         for k in range(j+1, n):
        #             if nums[i]<nums[k] and nums[k]<nums[j]:
        #                 return True
        
        # Optimised using BS: O(nlogn) --> TLE 
        # for i in range(n):
        #     j=i+1
        #     k=n-1
        #     while j<k:
        #         if nums[i]<nums[j] and nums[i]<nums[k]:
        #             if nums[j]<nums[k]:
        #                 k-=1
        #             elif nums[k]==nums[j]:
        #                 j+=1
        #             else:
        #                 return True
        #         elif nums[i]<nums[j]:
        #             k-=1
        #         else:
        #             j+=1
        
        # Optimised using Monotonic stack: O(n)
        st=[]
        mini=nums[0]
        for num in nums:
            while st and st[-1][0]<=num:
                st.pop()
            if st and st[-1][1]<num:
                return True
            st.append([num, mini])
            mini=min(mini, num)
        return False";"class Solution:
    def find132pattern(self, nums: list[int]) -> bool:
        n = len(nums)
        if n < 3:
            return False

        i_val = 0
        j_val = 0
        k_val = 0

        i = 0
        while i < n:
            j = i + 1
            while j < n:
                k = j + 1
                while k < n:
                    i_val = nums[i]
                    j_val = nums[j]
                    k_val = nums[k]

                    if i_val < k_val and k_val < j_val:
                        return True
                    k = k + 1
                j = j + 1
            i = i + 1
            
        return False"
"class Solution:
    def new21Game(self, n: int, k: int, maxPts: int) -> float:
        if n >= k - 1 + maxPts: return 1 #the last possible stop-point is k-1, if we roll a maxPts and it will end within n, that means anyway it will end within n with prob 1, there is no need to continue
        dp = [0] * (n + 1) #dp[i] is the probability we reach point i. As we care what's the probability within n, at most we need dp to calculate from 1 to n
        dp[0], curSum = 1, 0 #dp[0] is the probability we reach 0. As we start with 0, we have a probability of 1 reaching 0
        for i in range(1, n + 1):
            if i - 1 < k: # when the previous point hasn't reached k, that means we can still continue to roll, and we'll add that point. Otherwise, when i - 1 already reaches k, then the game stops and we cannot reach status i from  i - 1 (we cannot pick any more number)
                curSum += dp[i - 1]
            if i - 1 >= maxPts: # we can only reach point i from point i - 1, i - 2, ..., i - maxPts. and hence when we calculate point i, we need to make sure the previous points outside of the range drops out
                curSum -= dp[i - 1 - maxPts]
            dp[i] = curSum / maxPts
        return sum(dp[k:]) # we calculate all the probabilities that we land in point k, point k + 1, until point n";"class Solution:
    def new21Game(self, n: int, k: int, maxPts: int) -> float:
        if k == 0:
            return 1.0
        
        if n >= k - 1 + maxPts:
            return 1.0

        dp = []
        i = 0
        while i <= n:
            dp.append(0.0)
            i = i + 1

        dp[0] = 1.0
        
        window_sum = 1.0

        i = 1
        while i <= n:
            dp[i] = window_sum / float(maxPts)

            if i < k:
                window_sum = window_sum + dp[i]
            
            if i >= maxPts:
                if i - maxPts < k:
                    window_sum = window_sum - dp[i - maxPts]
            
            i = i + 1

        total_probability = 0.0
        i = k
        while i <= n:
            total_probability = total_probability + dp[i]
            i = i + 1
            
        return total_probability"
"class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        return self.moveZerosOptimal(nums)
		return self.moveZerosOptimalTwo(nums)
        # return self.moveZeroesByPopAndAppend(nums)

#     O(n) || O(1)
# runtime: 291ms 32.26%
    def moveZerosOptimal(self, nums):
        if not nums:return nums

        nextPtr = 0

        for num in nums:
            if num != 0:
                nums[nextPtr] = num
                nextPtr += 1
        
        for i in range(nextPtr, len(nums)):
            nums[i] = 0

        return nums
    
	# O(n) || O(1)
	def moveZerosOptimalTwo(self, nums):
		if not nums:
			return nums
			
		left = 0
		for right in range(len(nums)):
			if nums[right]:
				nums[left], nums[right] = nums[right], nums[left]
				left += 1
		return nums
    
# O(n) || O(1) space: but its a bad practice,
# appending a element is an O(1) operation but when you pop(O(1)) 
# all the elements to its right move to fill the space. O(n)
# runtime: 1698ms 5.69%
    def moveZeroesByPopAndAppend(self, nums):
        if not nums:
            return nums

        for i in nums:
            if i == 0:
                nums.remove(i)
                nums.append(i)

        return nums";"class Solution:
    def moveZeroes(self, nums):
        pos = 0
        
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[pos] = nums[i]
                pos = pos + 1
        
        while pos < len(nums):
            nums[pos] = 0
            pos = pos + 1"
"class Solution:
        #greedy algorithm
        def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
                #if the gas at all stations is less than the cost at all stations then gas will not be sufficient to travel the circuit once
                if sum(gas) < sum(cost):
                        #so return - 1
                        return - 1
                #if the gas is sufficient 
                #we have to find from which index we should start
                total = 0 
                #res is a variable which is created to store the index from which we are going to start
                res = 0 
                #iterate of the indexes of gas
                for i in range(len(gas)):
                        #add the difference of gas and cost at each station
                        total += (gas[i]  - cost[i])
                        #if the difference is less than 0 
                        if total < 0:
                                #then we have to check the positive difference
                                #so reset total to 0 
                                total = 0
                                #increse the res value to next index
                                res = i + 1
                #after finishing the for-loop 
                #we the return the index where first positive difference is occured
                return res";"class Solution:
    def canCompleteCircuit(self, gas: list[int], cost: list[int]) -> int:
        total_tank = 0
        current_tank = 0
        starting_station = 0
        n = len(gas)

        for i in range(n):
            net_gas = gas[i] - cost[i]
            
            total_tank = total_tank + net_gas
            current_tank = current_tank + net_gas

            if current_tank < 0:
                starting_station = i + 1
                current_tank = 0
        
        if total_tank < 0:
            return -1
        else:
            return starting_station"
"class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        
        # Init
        m = len(matrix)
        n = len(matrix[0])
        max_len = 0
        
        # Convert matrix value of string to int
        for row in range(m):
            for col in range(n):
                matrix[row][col] = int(matrix[row][col])
        
        # Scan first row
        for col in range(n):
            max_len = max(max_len, matrix[0][col])
            
        # Scan first column
        for row in range(m):
            max_len = max(max_len, matrix[row][0])
        
        # For each row starting from second row
        for i in range(1,m):
            
            # For each col starting from second column
            for j in range(1,n):
                
                # If the current element is non-zero
                if matrix[i][j]:
                    
                    # If all three of it's adjacent elements are non-zero
                    # Three elements are:
                    # a) element in the previous row ""[i-1][j]""
                    # b) element in the previous column ""[i][j-1]""
                    # c) element in previous diagonal ""[i-1][j-1]""
                    if matrix[i-1][j] and matrix[i][j-1] and matrix[i-1][j-1]:
                        
                        # Get the minimum of all three adjacent elements and add one to it
                        # This updates length of the element w.r.t how many adjacent ones
                        # are available in the original matrix
                        matrix[i][j] = min(matrix[i-1][j], matrix[i][j-1], matrix[i-1][j-1]) + 1
                    
                    # Calc max len w.r.t the updated length of the current element
                    max_len = max(max_len, matrix[i][j])
                        
                    
        return max_len**2 # Area of a square of length ""l"" is l*l = l^2";"class Solution:
    def maximalSquare(self, matrix):
        if not matrix:
            return 0

        rows = len(matrix)
        cols = len(matrix[0])
        
        dp_table = []
        i = 0
        while i < rows:
            row_list = []
            j = 0
            while j < cols:
                row_list.append(0)
                j = j + 1
            dp_table.append(row_list)
            i = i + 1
            
        max_side_length = 0
        
        i = 0
        while i < rows:
            j = 0
            while j < cols:
                if matrix[i][j] == '1':
                    if i == 0 or j == 0:
                        dp_table[i][j] = 1
                    else:
                        val_top = dp_table[i-1][j]
                        val_left = dp_table[i][j-1]
                        val_top_left = dp_table[i-1][j-1]
                        
                        min_val = val_top
                        if val_left < min_val:
                            min_val = val_left
                        if val_top_left < min_val:
                            min_val = val_top_left
                        
                        dp_table[i][j] = 1 + min_val
                else:
                    dp_table[i][j] = 0

                if dp_table[i][j] > max_side_length:
                    max_side_length = dp_table[i][j]
                
                j = j + 1
            i = i + 1
            
        result_area = max_side_length * max_side_length
        return result_area"
"class Solution2:
    def _get_all_divisors(self, num: int):
        for divisor in range(1, int(num ** 0.5) + 1):
            if num % divisor == 0:
                yield divisor
                other_divisor = num // divisor
                if divisor != other_divisor:
                    yield other_divisor

    def checkPerfectNumber(self, num: int) -> bool:
        sum_of_divisors = sum(self._get_all_divisors(num)) - num
        return sum_of_divisors == num";"class Solution:
    def checkPerfectNumber(self, num: int) -> bool:
        if num <= 1:
            return False

        sum_of_divisors = 0
        i = 1
        while i < num:
            if num % i == 0:
                sum_of_divisors = sum_of_divisors + i
            i = i + 1

        if sum_of_divisors == num:
            return True
        else:
            return False"
"class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        words_out = []
        for w_x in words:
            inx_words = []
            inx_count = []
            for xx in range(len(w_x)):
                inx_words.append(self.index_all(board, w_x[xx]))
                inx_count.append(len(inx_words[xx]))
            if inx_count.count(0) > 0:
                pass
            else:
                board_2 = []
                for x in range(len(board)):
                    for y in range(len(board[0])):
                        try:
                            b2 = [f'{board[x][y]}{board[x][y + 1]}']
                        except IndexError:
                            b2 = [0]
                        try:
                            b2 += [f'{board[x][y]}{board[x + 1][y]}']
                        except IndexError:
                            b2 += [0]
                        b2 += [f'{board[x][y]}{board[x][y - 1]}', f'{board[x][y]}{board[x - 1][y]}']
                        if x == 0 and y == 0:
                            board_2 += b2[:2]
                        elif x == 0 and y != 0:
                            board_2 += b2[:3]
                        elif x != 0 and y == 0:
                            board_2 += [b2[0], b2[1], b2[3]]
                        else:
                            board_2 += b2

                break_c = False
                for x in range(len(w_x) - 1):
                    words_2 = w_x[x] + w_x[x + 1]
                    if board_2.count(words_2) == 0:
                        break_c = True
                        break

                if break_c:
                    continue

                w_x0 = w_x[:]
                if inx_count[-1] <= inx_count[0]:
                    w_x = w_x[::-1]
                    inx_words = inx_words[::-1]

                inx = [0 for i in range(len(w_x))]
                while inx[0] < len(inx_words[0]):
                    inx_s1 = inx_words[0][inx[0]]
                    i = 1
                    path = [inx_s1]
                    inx_words0 = [aa[:] for aa in inx_words]
                    while i < len(w_x):
                        try:
                            for ix in range(i, len(w_x)):
                                if inx_words0[ix].count(inx_s1) > 0:
                                    inx_words0[ix].remove(inx_s1)
                            inx_s2 = inx_words0[i][inx[i]]
                            inx_s12 = [[inx_s1[0] + 1, inx_s1[1]], [inx_s1[0] - 1, inx_s1[1]],
                                       [inx_s1[0], inx_s1[1] + 1], [inx_s1[0], inx_s1[1] - 1]]

                            if inx_s12.count(inx_s2) == 0:
                                inx[i] += 1
                                break
                            inx_s1 = inx_s2
                            path.append(inx_s1)
                            i += 1
                        except IndexError:
                            inx[i - 1] += 1
                            inx[i:] = [0] * (len(w_x) - i)
                            break

                    if i == len(w_x):
                        inx[i - 1] += 1
                        if len(w_x) == len(set(map(tuple, path))):
                            words_out.append(w_x0)
                            break
        return words_out

    def index_all(self, my_list, v):
        inx_s = []
        for i, x in enumerate(my_list):
            inx_c = [i for i, m in enumerate(x) if m == v]
            for xx in inx_c:
                inx_s.append([i, xx])
        return inx_s";"def findWords(board, words):
    trie = {}
    for word in words:
        node = trie
        for char in word:
            if char not in node:
                node[char] = {}
            node = node[char]
        node['#'] = word

    rows = len(board)
    cols = len(board[0])
    result_set = set()

    for r in range(rows):
        for c in range(cols):
            char = board[r][c]
            if char in trie:
                stack = []
                visited_path = set()
                visited_path.add((r, c))
                stack.append((r, c, trie[char], visited_path))

                while len(stack) > 0:
                    current_r, current_c, current_node, visited = stack.pop()

                    if '#' in current_node:
                        result_set.add(current_node['#'])
                        del current_node['#']

                    # Up
                    next_r, next_c = current_r - 1, current_c
                    if next_r >= 0:
                        if (next_r, next_c) not in visited:
                            next_char = board[next_r][next_c]
                            if next_char in current_node:
                                new_visited = set(visited)
                                new_visited.add((next_r, next_c))
                                stack.append((next_r, next_c, current_node[next_char], new_visited))

                    # Down
                    next_r, next_c = current_r + 1, current_c
                    if next_r < rows:
                        if (next_r, next_c) not in visited:
                            next_char = board[next_r][next_c]
                            if next_char in current_node:
                                new_visited = set(visited)
                                new_visited.add((next_r, next_c))
                                stack.append((next_r, next_c, current_node[next_char], new_visited))

                    # Left
                    next_r, next_c = current_r, current_c - 1
                    if next_c >= 0:
                        if (next_r, next_c) not in visited:
                            next_char = board[next_r][next_c]
                            if next_char in current_node:
                                new_visited = set(visited)
                                new_visited.add((next_r, next_c))
                                stack.append((next_r, next_c, current_node[next_char], new_visited))

                    # Right
                    next_r, next_c = current_r, current_c + 1
                    if next_c < cols:
                        if (next_r, next_c) not in visited:
                            next_char = board[next_r][next_c]
                            if next_char in current_node:
                                new_visited = set(visited)
                                new_visited.add((next_r, next_c))
                                stack.append((next_r, next_c, current_node[next_char], new_visited))

    final_result = []
    for word in result_set:
        final_result.append(word)

    return final_result"
"class Solution:
    def minimumBoxes(self, m: int) -> int:
        def cbrt(x):
            return x**(1. / 3)

        # Find the first tetrahedral number greater than
        # or equal to m.
        x = cbrt(sqrt(3)*sqrt(243*(m**2) - 1) + 27*m)
        n = ceil(x/cbrt(9) + 1/(cbrt(3)*x) - 1)
        
        # If m is the nth tetrahedral number, return the
        # nth triangular number (the base).
        t_n =n*(n+1)*(n+2) // 6 
        if m == t_n:
            return n*(n+1)//2

        # Otherwise, we must adjust the answer.
        ans = n*(n+1)//2
        j = t_n + 1
        while m < j:
            j -= n
            ans -= 1
            n -= 1

        return ans + 1";"class Solution:
    def minimumBoxes(self, n: int) -> int:
        floor_count = 0
        total_count = 0
        layer_size = 0

        while total_count < n:
            layer_size = layer_size + 1
            floor_count = floor_count + layer_size
            total_count = total_count + floor_count

        if total_count == n:
            return floor_count

        total_count = total_count - floor_count
        floor_count = floor_count - layer_size
        remaining_boxes = n - total_count

        extra_on_floor = 0
        while remaining_boxes > 0:
            extra_on_floor = extra_on_floor + 1
            remaining_boxes = remaining_boxes - extra_on_floor
            
        return floor_count + extra_on_floor"
"class Solution:
    def magicalString(self, n: int) -> int:
        ref = ""122112""
        actual = """"
        start = 0
        one = True
        
        while(len(ref) < n):
            for i in range(start, len(ref)):
                if(one):
                    actual += int(ref[i]) * ""1""
                    one = False
                else:
                    actual += int(ref[i]) * ""2""
                    one = True
                    
            if(len(actual) > len(ref)):
                start = len(ref)
                ref = actual
        
        return ref[:n].count(""1"")";"class Solution:
    def magicalString(self, n: int) -> int:
        if n == 0:
            return 0
        if n <= 3:
            return 1

        s = [1, 2, 2]
        
        read_pointer = 2
        write_pointer = 3
        current_num = 1
        
        while write_pointer < n:
            count = s[read_pointer]
            num_to_add = current_num
            
            i = 0
            while i < count:
                s.append(num_to_add)
                write_pointer = write_pointer + 1
                i = i + 1
            
            read_pointer = read_pointer + 1
            
            if current_num == 1:
                current_num = 2
            else:
                current_num = 1

        count_ones = 0
        i = 0
        while i < n:
            if s[i] == 1:
                count_ones = count_ones + 1
            i = i + 1
            
        return count_ones"
"class Solution:
    def reverseString(self, s: List[str]) -> None:
        """"""
        Do not return anything, modify s in-place instead.
        """"""
        return self.reverseStringOptimal(s)
    
#     O(n) || O(1)
# runtime: 342 19.09%
    def reverseStringOptimal(self, string):
        if not string: return string
        left, right = 0, len(string) - 1

        while left < right:
            string[left], string[right] = string[right], string[left]
            left += 1
            right -= 1

        return string
    
    
#     O(n) || O(n)
# brute force
    def reverseStringWithNewList(self, string):
        if not string:
            return string

        newList = [0] * len(string)

        j = 0
        for i in reversed(range(len(string))):
            newList[i] = string[j]
            j += 1

        return newList

# below are just 'some' python built in
    def reverseStringWithListCompression(self, string):
        if not string: return string
        return [string[i] for i in reversed(range(len(string)))]

    
    def reversedStringWithReverse(self, string):
        string.reverse() 
        return string or string[::-1]";"def reverseString(s):
    left_pointer = 0
    right_pointer = len(s) - 1

    while left_pointer < right_pointer:
        temp_char = s[left_pointer]
        s[left_pointer] = s[right_pointer]
        s[right_pointer] = temp_char
        
        left_pointer = left_pointer + 1
        right_pointer = right_pointer - 1"
"class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        freq = [0] * 26
        for task in tasks: freq[ord(task) - ord('A')] += 1
        
        # highest freq, how many letters have it
        highest_freq, no_high_tasks = self.highest_freq1(freq, len(tasks))
        
        parts = highest_freq - 1
        empty_slots = (n - no_high_tasks + 1) * parts
        idle = max(0, empty_slots - ( len(tasks) - no_high_tasks * highest_freq))
        
        return len(tasks) + idle


    def highest_freq1(self, freq, total_tasks):
        '''
        sort in O(Nlog(N)) using heap, find the max frequency and 
        the no. of tasks that have it
        '''
        heapq.heapify(freq)
        max_so_far, high_tasks = -math.inf, 0
        
        while freq:
            occ = heapq.heappop(freq)
            if max_so_far < occ:
                max_so_far = occ
                high_tasks = 0
            if occ == max_so_far: high_tasks += 1
        
        return max_so_far, high_tasks
    
    
    def highest_freq2(self, freq, total_tasks):
        '''
        Sort in O(Nlog(N)) using Timsort and find the no. of tasks with max freq
        '''
        freq = sorted(freq, reverse=True)
        highest_freq, no_high_tasks = freq[0], 0
        
        for f in freq:
            if f == highest_freq: no_high_tasks += 1
        
        return highest_freq, no_high_tasks
    
    
    def highest_freq3(self, freq, total_tasks):
        '''
        Sort in O(N) using bucket sort and return the highest non-empty bucket
        and the number of elements in it
        '''
        buckets = [[] for _ in range(total_tasks + 1)]
        
        for i in range(len(freq)):
            f = freq[i]
            buckets[f].append(i)
        
        highest_freq = -1
        for i in range(len(buckets) - 1, 0, -1):
            if buckets[i]:
                highest_freq = i
                break
        
        return highest_freq, len(buckets[highest_freq])";"class Solution:
    def leastInterval(self, tasks: list[str], n: int) -> int:
        frequencies = [0] * 26
        for task in tasks:
            index = ord(task) - ord('A')
            frequencies[index] = frequencies[index] + 1

        max_freq = 0
        for freq in frequencies:
            if freq > max_freq:
                max_freq = freq

        if max_freq == 0:
            return 0

        num_max_freq_tasks = 0
        for freq in frequencies:
            if freq == max_freq:
                num_max_freq_tasks = num_max_freq_tasks + 1

        time_based_on_idle = (max_freq - 1) * (n + 1) + num_max_freq_tasks
        
        total_tasks = 0
        for task in tasks:
            total_tasks = total_tasks + 1
        
        result = 0
        if time_based_on_idle > total_tasks:
            result = time_based_on_idle
        else:
            result = total_tasks
            
        return result"
"class Solution:
    def countPoints(self, rings: str) -> int:
        r = []
        g = []
        b = []
        ring_nums = set()
        count = 0
        for i in range(0, len(rings)):
            if rings[i] == 'R':
                r.append(int(rings[i+1]))
                if rings[i+1] not in ring_nums:
                    ring_nums.add(int(rings[i+1]))
            elif rings[i] == 'G':
                g.append(int(rings[i+1]))
                if rings[i+1] not in ring_nums:
                    ring_nums.add(int(rings[i+1]))
            elif rings[i] == 'B':
                b.append(int(rings[i+1]))
                if rings[i+1] not in ring_nums:
                    ring_nums.add(int(rings[i+1]))
        for i in ring_nums:
            if i in r and i in g and i in b:
                count += 1
        return count";"class Solution:
    def countPoints(self, rings: str) -> int:
        rods = [
            [], [], [], [], [], [], [], [], [], []
        ]

        i = 0
        while i < len(rings):
            color = rings[i]
            rod_character = rings[i+1]
            rod_index = int(rod_character)

            color_is_present = False
            for c in rods[rod_index]:
                if c == color:
                    color_is_present = True
                    break
            
            if color_is_present == False:
                rods[rod_index].append(color)

            i = i + 2
        
        count = 0
        for rod_colors in rods:
            if len(rod_colors) == 3:
                count = count + 1
        
        return count"
"class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        
        """"""
        Input: Array of integers
        constraints:
        1. Infinite number of each coin
        output: integer
        
        1. Do I have duplicate integers in the array
        2. Choose a single coin and add it up till it hits the targetj
        or greater than the target.
        
        Input variables are going to be the target, and the coins
        Base Case:
        if target hits zero, then return 1
        elif target is less than zero return 0
        Can we have a target less than zero
        Can the target be zero itself
        """"""
        if amount <= 0 and not coins:
            return 0
        if not coins:
            return 0
        memo = {}
        def dfs(target, n, memo):
            if (target, n) in memo:
                return memo[(target, n)]
            if target == 0:
                return 1
            if target < 0 or n == 0:
                return 0
            
            if (coins[n-1] <= target):
                res = dfs(target-coins[n-1], n, memo) + dfs(target, n-1, memo)
                memo[(target, n)] = res
                return res
            else:
                res = dfs(target, n-1, memo)
                memo[(target, n)] = res
                return res
        res = dfs(amount, len(coins), {})
        return res
    
        """"""
        2D DYNAMIC PROGRAMMING
        """"""
        dp = [[0]*(amount+1) for _ in range(len(coins)+1)]
        dp[0][0] = 1

        for i in range(1, len(coins)+1):
            for j in range(amount+1):
                if (coins[i-1]<=j):
                    dp[i][j] = dp[i][j-coins[i-1]] + dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j]
        return dp[len(coins)][amount]
    
        """"""
        1D DYNAMIC PROGRAMMING
        """"""
        dp = [0 for _ in range(amount+1)]
        dp[0] = 1
        for x in coins:
            for j in range(amount+1):
                if x <= j:
                    dp[j] += dp[j-x]
        return dp[amount]";"class Solution(object):
    def change(self, amount, coins):
        dp = []
        i = 0
        while i <= amount:
            dp.append(0)
            i = i + 1
        
        dp[0] = 1
        
        for coin in coins:
            j = coin
            while j <= amount:
                dp[j] = dp[j] + dp[j - coin]
                j = j + 1
                
        return dp[amount]"
"class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:
        def get_coordinates(x1,x2,y1,y2):
            return {0:[x1,y1],1:[x2,y1],2:[x2,y2],3:[x1,y2]}
        
        first = get_coordinates(ax1,ax2,ay1,ay2)
        second = get_coordinates(bx1,bx2,by1,by2)
        
        def left_overlap(a,b):
            if b[0][0]>=a[0][0] and b[0][0]<a[1][0] and b[1][0]>=a[1][0]:
                return abs(b[0][0]-a[1][0])
            if a[0][0]>=b[0][0] and a[0][0]<b[1][0] and a[1][0]>=b[1][0]:
                return abs(a[0][0]-b[1][0])
            if b[0][0]>=a[0][0] and b[0][0]<a[1][0] and b[1][0]<a[1][0]:
                return abs(b[1][0]-b[0][0])
            if a[0][0]>=b[0][0] and a[0][0]<b[1][0] and a[1][0]<b[1][0]:
                return abs(a[1][0]-a[0][0])
        
        def top_overlap(a,b):
            if b[0][1]>=a[0][1] and b[0][1]<a[2][1] and b[2][1]>=a[2][1]:
                return abs(b[0][1]-a[2][1])
            if a[0][1]>=b[0][1] and a[0][1]<b[2][1] and a[2][1]>=b[2][1]:
                return abs(a[0][1]-b[2][1])
            if b[0][1]>=a[0][1] and b[0][1]<a[2][1] and b[2][1]<a[2][1]:
                return abs(b[2][1]-b[0][1])
            if a[0][1]>=b[0][1] and a[0][1]<b[2][1] and a[2][1]<b[2][1]:
                return abs(a[2][1]-a[0][1])
        
        l=left_overlap(first,second)
        t=top_overlap(first, second)
        
        total_area = (first[1][0]-first[0][0])*(first[2][1]-first[0][1])
        total_area+=(second[1][0]-second[0][0])*(second[2][1]-second[0][1])
        if l is not None and t is not None:
            total_area -=l*t
        return total_area";"class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:
        
        area_del_rectangulo_a = (ax2 - ax1) * (ay2 - ay1)
        
        area_del_rectangulo_b = (bx2 - bx1) * (by2 - by1)
        
        solapamiento_izquierda = 0
        if ax1 > bx1:
            solapamiento_izquierda = ax1
        else:
            solapamiento_izquierda = bx1

        solapamiento_abajo = 0
        if ay1 > by1:
            solapamiento_abajo = ay1
        else:
            solapamiento_abajo = by1

        solapamiento_derecha = 0
        if ax2 < bx2:
            solapamiento_derecha = ax2
        else:
            solapamiento_derecha = bx2
            
        solapamiento_arriba = 0
        if ay2 < by2:
            solapamiento_arriba = ay2
        else:
            solapamiento_arriba = by2
            
        ancho_solapamiento = solapamiento_derecha - solapamiento_izquierda
        alto_solapamiento = solapamiento_arriba - solapamiento_abajo
        
        area_de_solapamiento = 0
        if ancho_solapamiento > 0 and alto_solapamiento > 0:
            area_de_solapamiento = ancho_solapamiento * alto_solapamiento
            
        area_total = area_del_rectangulo_a + area_del_rectangulo_b - area_de_solapamiento
        
        return area_total"
